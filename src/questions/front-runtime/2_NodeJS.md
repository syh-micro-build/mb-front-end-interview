# Node

## 1. Nodejs适用于哪些场景？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- T后端开发，Nodejs的异步I/O天生适合做Web高并发。

- BFF开发，比如SSR中间层或者GraphQL中间层。

- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。

## 2. Nodejs的事件循环和浏览器有什么区别？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：

- timers阶段：处理setTimeout()和setInterval()等定时器事件。

- I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。

- idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。

- poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。

- check阶段：执行setImmediate()的回调函数。

- close callbacks阶段：执行关闭事件的回调函数，例如socket.on('close')。

## 3. Nodejs的内存泄漏排查方法有哪些？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js的内存泄漏排查方法有以下几种：

- 使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。

- 使用第三方内存分析工具，如Chrome DevTools、VisualVM等。

- 使用内存泄漏检测工具，如`leak`、`memwatch`等。

- 使用代码审查和静态分析工具，如ESLint、JSHint等。

- 使用单元测试和集成测试，确保代码的正确性和稳定性。

## 4. Nodejs的进程管理有哪些方法？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js的进程管理有以下几种方法：

- 使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。

- 使用`cluster`模块创建集群，利用多核CPU资源。

- 使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。

- 使用`forever`等第三方工具，如自动重启、日志管理等功能。

- 使用`node-mac`等第三方工具，如自动重启、日志管理等功能。

## 5. Nodejs的模块化有哪些方法？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js的模块化有以下几种方法：

- CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。

- ES6模块化：使用`import`和`export`进行模块导入和导出。

- AMD模块化：使用`define`和`require`进行模块导入和导出。

- UMD模块化：兼容CommonJS和AMD模块化。

- 全局变量：将变量挂载到`global`对象上，方便全局访问。

- 命名空间：将变量挂载到命名空间对象上，避免全局变量污染。

- 模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。

## 6. 讲一下常见的Nodejs框架？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。

- Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。

- Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。

- Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。

## 7. Nodejs的异步编程有哪些方法？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js的异步编程有以下几种方法：

- 回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。

- Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。

- async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。

- Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。

- 流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。

- 事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。

## 8. Nodejs的文件系统有哪些方法？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

Node.js的文件系统有以下几种方法：

- `fs.readFile`：读取文件内容。

- `fs.writeFile`：写入文件内容。

- `fs.appendFile`：追加文件内容。

- `fs.unlink`：删除文件。

- `fs.rename`：重命名文件。

- `fs.stat`：获取文件信息。

- `fs.readdir`：读取目录内容。

- `fs.mkdir`：创建目录。

- `fs.rmdir`：删除目录。

- `fs.watch`：监听文件或目录的变化。

## 9. 什么是Stream流，有哪些应用场景？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。

- 比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。

## 10. 什么是BFF？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（1 分）

- BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。

- 最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。

## 11. 什么是ORM？Nodejs的ORM框架有哪些？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。

- 这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。

- Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。

## 12. 什么是微服务？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（1 分）

- 微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。

- 微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。

## 13. 请介绍一下require的模块加载机制？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- 先计算模块路径

- 如果模块在缓存里面，取出缓存

- 如果是内置模块，取出内置模块

- 加载模块

- 输出模块的exports属性即可

## 14. Node.js的优点是什么？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- 异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。

- 单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。

- 开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。

- 跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。

- 高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。

- 数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。

## 15. Node.js采用哪种编程模式？它的优势是什么？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。

- 此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。

- 总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。

## 16. 解释一下Event Loop的工作原理？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。

- 当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。

- 当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。

## 17. node.js的同步和异步编程是什么意思？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（2 分）

- 同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。

- 而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。

- Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。

## 18. 解释一下Node.js的Express框架及其主要组件?

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：

- Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。

- Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。

- View engine：视图引擎，用于渲染HTML模板。

- Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。

- Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。

- Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。

- Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。

## 19.你如何在Node.js中使用中间件来组织代码？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- 在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：

- 定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。

- 使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。

- 使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。

- 在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。

## 20.你如何在Node.js中处理HTTP请求和响应？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- 创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.

- 监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。

- 处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。

- 发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。

- 通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。
需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。

## 21.请解释一下Node.js的集群化工作模式？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。
在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。

- 此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。

- 总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。

## 22.讲一下EventEmitter？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。

- 使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。

- 举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。

- 这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：

```js
const fs = require('fs');

fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error(`Failed to read file: ${err}`);
  } else {
    console.log(`File content: ${data}`);
  }
});
```

- 这是使用EventEmitter的文件读取：

```js
const fs = require('fs');

const stream = fs.createReadStream('file.txt');

stream.on('data', (chunk) => {
  console.log(`Received ${chunk.length} bytes of data.`);
});

stream.on('end', () => {
  console.log('Finished reading file.');
});
```

- 很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。

## 23.Buffer怎么理解，有什么应用？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。

- 可以将其看作是一个字节数组，用来存储和操作二进制数据。

- 应用场景：

- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：

```js
const net = require('net');

const client = net.createConnection({ port: 8080 }, () => {
  // 将字符串转换为二进制数据
  const data = Buffer.from('Hello, world!', 'utf8');

  // 发送数据
  client.write(data);
});

```

- 文件操作，用Buffer来存储文件数据：

```js
const fs = require('fs');

// 读取文件，并将数据存储到 Buffer 对象中
const data = fs.readFileSync('/path/to/file');

// 处理数据
// ...
```

- 加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：

```js

const crypto = require('crypto');

// 创建加密解密算法需要的二进制数据
const key = Buffer.from('mysecretkey', 'utf8');
const iv = Buffer.alloc(16);

// 创建加密解密算法对象
const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

// 加密数据
const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
```

- 图像处理：

```js

const fs = require('fs');
const sharp = require('sharp');

// 读取图片文件，并将数据存储到 Buffer 对象中
const data = fs.readFileSync('/path/to/image');

// 处理图片
sharp(data)
  .resize(200, 200)
  .toFile('/path/to/resized-image', (err, info) => {
    // ...
  });

```

## 24. 什么是I/O？

#### 类型：`基础`

#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`

#### 解答（3 分）

- 概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。

- 异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。

- 而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。

- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：

- 异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。

- 听起来异步I/O很好，那为什么同步I/O依然会存在？

- 传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。

- 对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性

- 对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。

- CPU密集和I/O密集：

- CPU密集任务指的是纯计算任务。

- I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。
