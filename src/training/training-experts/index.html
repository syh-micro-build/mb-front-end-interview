<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.BugVFdDY.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.DjS0JqvM.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.Dn8fXuHs.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.Yf3z8opX.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-experts_index.md.q9-YtNN3.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-experts_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 在 Vue2.x 中如何检测数组的变化？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. TypeScript中的装饰器是什么？如何使用？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>
</li>
<li><p><strong>4：</strong> 常见的装饰器类型：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 类装饰器</span>
<span class="hljs-keyword">function</span> classDecorator&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>:any[]):{}}&gt;(<span class="hljs-attr">constructor</span>:T) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> constructor {
        newProperty = <span class="hljs-string">&quot;new property&quot;</span>;
        hello = <span class="hljs-string">&quot;override&quot;</span>;
    }
}

<span class="hljs-comment">// 方法装饰器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">methodDecorator</span>(<span class="hljs-params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) {
    <span class="hljs-comment">// 保存原始方法</span>
    <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;
    
    <span class="hljs-comment">// 修改方法的行为</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: any[]</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before method execution&#x27;</span>);
        <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After method execution&#x27;</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-comment">// 使用装饰器</span>
@classDecorator
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {
    @methodDecorator
    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);
    }
}

<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();
e.<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// Before method execution</span>
<span class="hljs-comment">// Hello!</span>
<span class="hljs-comment">// After method execution</span>
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. React 中的单向数据流是什么意思？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。</p>
</li>
<li><p>数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。</p>
</li>
<li><p>易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。</p>
</li>
<li><p>可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>当一个元素的 <strong>visibility</strong> 属性被设置成 <strong>collapse</strong> 值后，对于一般的元素，它的表现跟 <strong>hidden</strong> 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 <strong>display: none</strong> 一样，也就是说，它们占用的空间也会释放。</p>
<p>在谷歌浏览器里，使用 <strong>collapse</strong> 值和使用 <strong>hidden</strong> 值没有什么区别。</p>
<p>在火狐浏览器、Opera和IE11里，使用 <strong>collapse</strong> 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">虚拟化（Virtualization）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. CSS 有哪些选择器？权重是如何计算的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong><ul>
<li>基本选择器：ID 选择器 &gt; 类选择器/伪类选择器/属性选择器 &gt; 元素选择器/伪元素选择器 &gt; 通配符选择器</li>
<li>关系选择器：后代选择器、父子选择器、兄弟选择器</li>
</ul>
</li>
<li><strong>1：</strong> ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">XSS 攻击</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】</li>
<li><strong>:2</strong> 防御：</li>
</ul>
<blockquote>
<p>1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。<br>2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 如何在组件中批量使用Vuex的getter属性</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>如何在组件中批量使用Vuex的getter属性</p>
<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {mapGetters} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">computed</span>:{
        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])
    }
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. React.createClass和extends Component的区别有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>语法区别</p>
<ul>
<li><p>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</p>
</li>
<li><p>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
</li>
</ul>
<p>propType 和 getDefaultProps</p>
<ul>
<li><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>
</li>
<li><p>React.Component：通过设置两个属性propTypes和defaultProps</p>
</li>
</ul>
<p>状态的区别</p>
<ul>
<li><p>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</p>
</li>
<li><p>React.Component：通过constructor构造函数设置初始状态</p>
</li>
</ul>
<p>this.state</p>
<ul>
<li><p>React.createClass：需要显示的调用this.setState()方法</p>
</li>
<li><p>React.Component：不需要调用，直接this.state获取</p>
</li>
</ul>
<p>Mixins</p>
<ul>
<li><p>React.createClass：通过mixins属性混合进来</p>
</li>
<li><p>React.Component：通过引入React Mixin</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP与UDP区别是什么</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Component, Element, Instance 之间有什么区别和联系？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p>
</li>
<li><p>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p>
</li>
<li><p>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
</li>
</ul>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. react事件绑定方式有哪些</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>render方法中使用bind</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>render方法中使用箭头函数</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(e)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>constructor中bind</p>
<pre><code class="hljs language-html">
<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre><p>定义阶段使用箭头函数绑定</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. 什么是状态管理器？你使用或了解哪些状态管理器？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。
状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。
除了 React Context，Redux 或 MobX 也常用作状态管理库。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. React中有使用过getDefaultProps吗？它有什么作用？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> <span class="hljs-title class_">ShowTitle</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">getDefaultProps</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span>{
      title : <span class="hljs-string">&quot;React&quot;</span>
    }
  },
  render : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> &lt;h1&gt;{this.props.title}&lt;/h1&gt;
  }
});
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 对 React-Intl 的理解，它的工作原理？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>
<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>
<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. 什么是React调和？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。
调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. webpack的Plugin和Loader的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>
<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. 说说如何借助webpack来优化前端性能?</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>3：</strong></li>
</ul>
<blockquote>
<p>JS代码压缩<br>CSS代码压缩<br>Html文件代码压缩<br>文件大小压缩<br>图片压缩<br>Tree Shaking<br>代码分离<br>内联 chunk</p>
</blockquote>
<ul>
<li><p>raw-loader：加载文件原始内容（utf-8）</p>
</li>
<li><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</p>
</li>
<li><p>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</p>
</li>
<li><p>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</p>
</li>
<li><p>image-loader：加载并且压缩图片文件</p>
</li>
<li><p>babel-loader：把 ES6 转换成 ES5</p>
</li>
<li><p>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</p>
</li>
<li><p>html-webpack-plugin：简化 html 文件的创建，可以指定模板和输出文件</p>
</li>
<li><p>mini-css-extract-plugin：分离 css 文件</p>
</li>
<li><p>clean-webpack-plugin：清理文件夹</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积</p>
</li>
<li><p>terser-webpack-plugin：压缩 js 文件</p>
</li>
<li><p>optimize-css-assets-webpack-plugin：压缩 css 文件</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积</p>
</li>
<li><p>webpack-dashboard：可以更友好的展示相关打包信息。</p>
</li>
<li><p>webpack-merge：提取公共配置，减少重复配置代码</p>
</li>
<li><p>speed-measure-webpack-plugin：可以得知每个 loader 和 plugin 的执行耗时</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积，方便找出问题所在</p>
</li>
<li><p>HotModuleReplacementPlugin：模块热替换</p>
</li>
</ul>
<p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p>
<p>map文件只要不打开开发者工具，浏览器是不会加载的。</p>
<p>线上环境一般有三种处理方案：</p>
<ul>
<li>hidden-source-map：借助第三方错误监控平台 Sentry 使用</li>
<li>nosources-source-map：只会显示具体行数和错误，不会显示具体源码</li>
<li>inline-source-map：通过 dataURL 形式内联在打包文件中</li>
</ul>
<p>注意：避免在生产中使用 eval-source-map 和 cheap-module-eval-source-map，因为这两个配置会导致代码缓存失效，从而降低应用性能。</p>
<p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p>
<p>在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<p>Webpack开启监听模式，有两种方式：</p>
<ul>
<li><p>启动 webpack 命令时，带上 --watch 参数</p>
</li>
<li><p>在配置 webpack.config.js 中设置 watch:true</p>
</li>
</ul>
<p>缺点：每次需要手动刷新浏览器</p>
<p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。</p>
<p>VSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。
bundlesize 工具包可以进行自动化资源体积监控。</p>
<p>文件指纹是打包后输出的文件名的后缀。</p>
<ul>
<li><p>Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</p>
</li>
<li><p>Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值</p>
</li>
<li><p>Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</p>
</li>
</ul>
<p>文件指纹是打包后输出的文件名的后缀。</p>
<p>设置 output 的 filename，用 chunkhash。</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: {        
    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        
    <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    
    },    
    <span class="hljs-attr">output</span>: {        
      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        
      <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    
}}
</code></pre><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: {        
    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        
    <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    },   
    <span class="hljs-attr">output</span>: {        
      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        
      <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    
    },    
    <span class="hljs-attr">plugins</span>:[        
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({            
        <span class="hljs-attr">filename</span>: <span class="hljs-string">`[name][contenthash:8].css`</span>        
      })    
  ]}


</code></pre><p>设置file-loader的name，使用hash。</p>
<ul>
<li><p>ext 资源后缀名</p>
</li>
<li><p>name 资源名称</p>
</li>
<li><p>path 资源所在路径</p>
</li>
<li><p>folder 资源所在文件夹</p>
</li>
<li><p>base 资源相对于上下文路径</p>
</li>
<li><p>hash 文件内容的 hash 值</p>
</li>
<li><p>digest 文件内容的 digest 值</p>
</li>
<li><p>content 文件内容的 base64 编码</p>
</li>
<li><p>query url查询参数</p>
</li>
<li><p>emoji 一个随机的指代文件内容的emoj</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    
  <span class="hljs-attr">output</span>: {        
    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,        
    <span class="hljs-attr">path</span>:path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)    
    },    
    <span class="hljs-attr">module</span>:{        
      <span class="hljs-attr">rules</span>:[{            
        <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,            
        <span class="hljs-attr">use</span>:[{                
          <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span>,                
          <span class="hljs-attr">options</span>:{                    
            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>                
        }            
      }]        
    }]    
  }}
</code></pre><p>可以使用 enforce 强制执行 loader 的作用顺序，pre 代表在所有正常 loader 之前执行，post 是所有 loader 之后执行。(inline 官方不推荐使用)</p>
<p>代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</p>
<p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p>
<p>打包成唯一脚本：虽然减少http请求，但是体积大，导致体积过大，影响首屏加载性能。</p>
<p>代码分割的意义：将代码分割成多份进行按需加载，减少单个文件体积，降低首屏加载时间，提升性能。</p>
<p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p>
<ul>
<li><p>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</p>
</li>
<li><p>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</p>
</li>
<li><p>尽可能的异步化 Loader，如果计算量很小，同步也可以</p>
</li>
<li><p>Loader 是无状态的，我们不应该在 Loader 中保留状态</p>
</li>
<li><p>使用 loader-utils 和 schema-utils 为我们提供的实用工具</p>
</li>
<li><p>加载本地 Loader 方法</p>
</li>
</ul>
<p>Npm link</p>
<p>ResolveLoader</p>
<p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p>
<ul>
<li><p>compiler 暴露了和 Webpack 整个生命周期相关的钩子</p>
</li>
<li><p>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</p>
</li>
<li><p>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</p>
</li>
<li><p>传给每个插件的 compiler 和 - compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</p>
</li>
<li><p>找出合适的事件点去完成想要的功能</p>
</li>
</ul>
<p>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</p>
<p>watch-run 当依赖的文件发生变化时会触发</p>
<ul>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li>
</ul>
<p>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p>
<ul>
<li><p>解析：将代码转换成 AST</p>
<p>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</p>
<p>语法分析：分析token流(上面生成的数组)并生成 AST</p>
</li>
<li><p>转换：处理 AST，进行添加、更新或移除等操作</p>
<p>Taro就是利用 babel 完成的小程序语法转换</p>
</li>
<li><p>生成：将处理后的 AST 转换成代码</p>
</li>
</ul>
<p>Babel 是一个编译器，它主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p>Babel 的配置文件通常是一个名为 babel.config.js 的 JavaScript 文件，它位于项目的根目录中。在这个文件中，你可以使用 Babel 的配置选项来指定如何转换你的代码。</p>
<p>要配置 Babel 以支持最新的 ECMAScript 语法，你可以使用 @babel/preset-env 预设。这个预设会根据你的目标环境自动选择需要的 Babel 插件和 polyfills，以支持最新的 ECMAScript 语法。</p>
<p>以下是一个基本的 babel.config.js 文件的示例，它使用 @babel/preset-env 预设来支持最新的 ECMAScript 语法：</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [
    [
      <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,
      {
        <span class="hljs-attr">targets</span>: {
          <span class="hljs-attr">node</span>: <span class="hljs-string">&#x27;current&#x27;</span>,
        },
      },
    ],
  ],
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 简述webpack的构建流程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>
<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统
<img src="/public/images/image2.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何处理 CSS 模块？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly (Wasm) 的核心特点有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。</li>
<li><strong>1：</strong>  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。</li>
<li><strong>1：</strong>  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。</li>
<li><strong>1：</strong>  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。</li>
<li><strong>1：</strong>  小体积：Wasm 格式文件较小，传输高效，加载速度快。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">V8 引擎如何进行代码优化？</h4><div class="head-re"><span class="head-score">12 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：<ul>
<li>解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化</li>
<li>热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。</li>
<li>优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率</li>
<li>逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配</li>
<li>内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问</li>
<li>代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly 的工作原理是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>
<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>
<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>
<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. webpack的Plugin是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. webpack 的热更新是什么?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Hot Module Replacement 简称 HRM</li>
<li><strong>1：</strong> 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. webpack proxy是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. webpack 中提供服务器的工具是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-23T07:13:33.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"B0kI6ZAn\",\"ing.md\":\"D1nWfXw6\",\"readme.md\":\"V-2xb-2G\",\"src_guide_getting-started.md\":\"BQLWWlLl\",\"src_guide_why.md\":\"OU7461E3\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BLPjwUje\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"DR1Y899G\",\"src_questions_computer-base_1_计算机硬件.md\":\"CNJX_Gmh\",\"src_questions_computer-base_2_计算机软件.md\":\"3AHM_dFp\",\"src_questions_computer-base_3_计算机网络.md\":\"Cz3_phQD\",\"src_questions_computer-base_4_计算机编程.md\":\"iz2hcs7Z\",\"src_questions_computer-base_5_计算机科学.md\":\"Dduwy4Fn\",\"src_questions_computer-base_6_软件工程.md\":\"BgskRMZQ\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"Bw7y5gdE\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"Duz1RZHm\",\"src_questions_data-structures-algorithms_1_算法.md\":\"B4RUqUcP\",\"src_questions_front-architect_1_前端架构.md\":\"DBCmoyXJ\",\"src_questions_front-base_1_html.md\":\"CY8M36wG\",\"src_questions_front-base_2_css.md\":\"CdCz3wtD\",\"src_questions_front-base_3_javascript.md\":\"DCO6-lRG\",\"src_questions_front-base_4_typescript.md\":\"sb_DU04C\",\"src_questions_front-component_1_ui组件库.md\":\"BkHcZQOo\",\"src_questions_front-component_2_业务组件库.md\":\"BXDe725T\",\"src_questions_front-engineering_1_前端标准化.md\":\"DK5EbIOS\",\"src_questions_front-engineering_2_前端自动化.md\":\"DmGicU7r\",\"src_questions_front-engineering_3_webpack.md\":\"DK1-MjFB\",\"src_questions_front-engineering_4_vite.md\":\"C8tjvJlu\",\"src_questions_front-engineering_5_rollup.md\":\"DQgOmzHl\",\"src_questions_front-frame_1_react.md\":\"7ggdYYic\",\"src_questions_front-frame_2_vue.md\":\"BnMYsCpX\",\"src_questions_front-frame_3_next.md\":\"DPpVj7o7\",\"src_questions_front-frame_4_nuxt.md\":\"Cz6Sjgu6\",\"src_questions_front-frame_5_qiankun.md\":\"BRXOg93l\",\"src_questions_front-newest_1_前端最前沿.md\":\"DGQCpAd6\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DTbYUNGk\",\"src_questions_front-runtime_1_浏览器.md\":\"CJZzU5_Q\",\"src_questions_front-runtime_2_nodejs.md\":\"CJTviEm7\",\"src_questions_front-safety_1_前端安全.md\":\"B5qgd_Zy\",\"src_questions_server_1_nest.md\":\"CpWxXPyz\",\"src_questions_server_2_mongodb.md\":\"DmHp7BE2\",\"src_questions_server_3_mysql.md\":\"BNbkwvdx\",\"src_questions_server_4_nginx.md\":\"CxL3C3Ah\",\"src_questions_server_5_docker.md\":\"BAENpARb\",\"src_questions_server_6_kubernets.md\":\"Dr1NgPRO\",\"src_questions_server_7_nacos.md\":\"CRIXxMHr\",\"src_questions_server_8_redis.md\":\"qwm-KtdX\",\"src_training_training-architecture_index.md\":\"5JIvloGv\",\"src_training_training-experts_index.md\":\"q9-YtNN3\",\"src_training_training-intermediate_index.md\":\"ScbRqrwV\",\"src_training_training-primary_index.md\":\"JG7NU-vm\",\"src_training_training-senior_index.md\":\"CV2bcnFQ\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>