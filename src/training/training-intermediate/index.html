<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.Dqb6yj2l.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DjnnLVgv.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.dJbyYXqx.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-intermediate_index.md.Dh43bU4g.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-intermediate_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 在 HTML 中，如何创建一个无序列表和有序列表？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  创建无序列表使用<code>&lt;ul&gt;</code>标签，列表项使用<code>&lt;li&gt;</code>标签。</li>
<li><strong>1：</strong>  创建有序列表使用<code>&lt;ol&gt;</code>标签，同样列表项使用<code>&lt;li&gt;</code>标签。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. DNS 协议是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 为什么this.xx可以访问data中的数据?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue在initData时，做了数据代理</p>
<ul>
<li><p>判断传入的data，函数就执行，对象不做处理</p>
</li>
<li><p>data 赋值给 vm._data</p>
</li>
<li><p>然后变量 vm._data对象，把可枚举属性的get代理到 vm上</p>
</li>
<li><p>访问vm.xxx 就相当于 vm._data.xx === vm.data.xx</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. 作用域和执行上下文的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；</p>
</li>
<li><p>函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSRF 攻击</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>
<li><strong>:4</strong> 防御：</li>
</ul>
<blockquote>
<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>
<blockquote>
<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>
</blockquote>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. CSS 居中</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：定位居中</strong></li>
</ul>
<p>①已知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            width:100px;
            height:100px;
            background-color: aqua;
            position:fixed;
            left:50%;
            top:50%;
            margin-left:-50px;
            margin-top:-50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>②未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            position:fixed;
            left:0;
            top:0;
            right:0;
            bottom:0;
            margin:auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ul>
<li><strong>1：子元素在父元素中居中</strong></li>
</ul>
<p>①已知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">    父元素{
        <span class="hljs-comment">/* 相对定位 */</span>
        <span class="hljs-attr">position</span>: relative;
    }
    子元素{
        <span class="hljs-attr">width</span>:100px;
        <span class="hljs-attr">height</span>:100px;
        <span class="hljs-comment">/* 绝对定位 */</span>
        <span class="hljs-attr">position</span>:absolute;
        <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
        <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
        margin-<span class="hljs-attr">left</span>:-50px;
        margin-<span class="hljs-attr">top</span>:-50px;
    }
</code></pre><p>②未知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-comment">/* 相对定位 */</span>
      <span class="hljs-attr">position</span>: relative;
  }
  子元素{
      <span class="hljs-comment">/* 绝对定位 */</span>
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">top</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">right</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">bottom</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">margin</span>:auto;
  }
</code></pre><ul>
<li><strong>1：使用弹性布局</strong></li>
</ul>
<p>① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  html,body{
      <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>%;
  }
  <span class="hljs-comment">/* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */</span>
  body{
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
</code></pre><p>② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**</p>
<pre><code class="hljs language-css">  父元素 {
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
    
</code></pre><ul>
<li><strong>1：使用css3变形来实现</strong></li>
</ul>
<p>① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  元素{
      <span class="hljs-attr">position</span>:fixed;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(-<span class="hljs-number">50</span>%) <span class="hljs-title function_">translateY</span>(-<span class="hljs-number">50</span>%);
  }
</code></pre><p>② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-attr">position</span>:relative;
  }
  子元素{
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translate</span>(-<span class="hljs-number">50</span>%,-<span class="hljs-number">50</span>%);
  }
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释一下什么是处理器架构（CPU Architecture）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23.Buffer怎么理解，有什么应用？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。</p>
</li>
<li><p>可以将其看作是一个字节数组，用来存储和操作二进制数据。</p>
</li>
<li><p>应用场景：</p>
</li>
<li><p>网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);

<span class="hljs-keyword">const</span> client = net.<span class="hljs-title function_">createConnection</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> }, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 将字符串转换为二进制数据</span>
  <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);

  <span class="hljs-comment">// 发送数据</span>
  client.<span class="hljs-title function_">write</span>(data);
});
</code></pre><ul>
<li>文件操作，用Buffer来存储文件数据：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-comment">// 读取文件，并将数据存储到 Buffer 对象中</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;/path/to/file&#x27;</span>);

<span class="hljs-comment">// 处理数据</span>
<span class="hljs-comment">// ...</span>
</code></pre><ul>
<li>加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);

<span class="hljs-comment">// 创建加密解密算法需要的二进制数据</span>
<span class="hljs-keyword">const</span> key = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;mysecretkey&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);
<span class="hljs-keyword">const</span> iv = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">16</span>);

<span class="hljs-comment">// 创建加密解密算法对象</span>
<span class="hljs-keyword">const</span> cipher = crypto.<span class="hljs-title function_">createCipheriv</span>(<span class="hljs-string">&#x27;aes-256-cbc&#x27;</span>, key, iv);

<span class="hljs-comment">// 加密数据</span>
<span class="hljs-keyword">const</span> encrypted = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([cipher.<span class="hljs-title function_">update</span>(data), cipher.<span class="hljs-title function_">final</span>()]);
</code></pre><ul>
<li>图像处理：</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> sharp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;sharp&#x27;</span>);

<span class="hljs-comment">// 读取图片文件，并将数据存储到 Buffer 对象中</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;/path/to/image&#x27;</span>);

<span class="hljs-comment">// 处理图片</span>
<span class="hljs-title function_">sharp</span>(data)
  .<span class="hljs-title function_">resize</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>)
  .<span class="hljs-title function_">toFile</span>(<span class="hljs-string">&#x27;/path/to/resized-image&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, info</span>) =&gt;</span> {
    <span class="hljs-comment">// ...</span>
  });
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 行内元素和块级元素的区别是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;</code>等；行内元素不会独占一行，在一行内可以多个行
内元素并排显示，如<code>&lt;span&gt;、&lt;a&gt;、&lt;img&gt;</code>等。</li>
<li><strong>1：</strong>  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般
不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。</li>
<li><strong>1：</strong>  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含
块级元素，不过<code>&lt;a&gt;</code>标签比较特殊，理论上可以包含大部分元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. document.write() 和 innerHTML 的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；</p>
</li>
<li><p>innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；</p>
</li>
<li><p>innerHTML将内容写入到某个DOM节点，不会导致页面重绘；</p>
</li>
<li><p>innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Unicode、UTF-8、UTF-16、UTF-32的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。</p>
</li>
<li><p>UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。</p>
</li>
<li><p>UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>
</li>
<li><p>UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>
</li>
<li><p>UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. Set、Map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
</li>
<li><p>Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。</p>
</li>
<li><p>Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. CSS 中的 BEM 命名规范是什么？为什么要使用它？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> BEM 命名规范：<ul>
<li>Block（块）：独立的组件，如 <code>.button</code></li>
<li>Element（元素）：属于块的一部分，用 <code>__</code> 连接，如 <code>.button__text</code></li>
<li>Modifier（修饰符）：改变块或元素的外观或行为，用 <code>--</code> 连接，如 <code>.button--large</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css"><span class="hljs-comment">/* Block */</span>
.<span class="hljs-property">card</span> {
    <span class="hljs-attr">padding</span>: 20px;
}

<span class="hljs-comment">/* Element */</span>
.<span class="hljs-property">card__title</span> {
    font-<span class="hljs-attr">size</span>: 18px;
}

<span class="hljs-comment">/* Element */</span>
.<span class="hljs-property">card__content</span> {
    margin-<span class="hljs-attr">top</span>: 10px;
}

<span class="hljs-comment">/* Modifier */</span>
.<span class="hljs-property">card</span>--featured {
    <span class="hljs-attr">background</span>: #f0f0f0;
}
</code></pre><ul>
<li><strong>2：</strong> 使用BEM的好处：<ul>
<li>提高代码的可读性和可维护性</li>
<li>避免CSS选择器嵌套过深</li>
<li>减少命名冲突</li>
<li>明确表达组件结构和关系</li>
<li>方便团队协作和代码复用</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 深浅拷贝的区别？如何实现一个深拷贝？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>深浅拷贝通常只针对引用类型</p>
</li>
<li><p>浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针</p>
</li>
<li><p>深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
          newObj[key]=obj[key]
        }
      }
      <span class="hljs-keyword">return</span>  newObj
} 
<span class="hljs-comment">// 咱们会浅拷贝当然还要深拷贝呀  开始</span>
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
        <span class="hljs-keyword">if</span>  ( <span class="hljs-title function_">typeof</span>(obj[key])!==obj||obj[key]===<span class="hljs-literal">null</span>){
           newObj[key]=obj[key]
        }<span class="hljs-keyword">else</span>{
           newObj[key]=<span class="hljs-title function_">shallowCopy</span>(obj[key])
        }  
        }
      }
      <span class="hljs-keyword">return</span>  newObj
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. label 的作用是什么？如何使用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<pre><code class="hljs language-html">
&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;mobile&quot;</span>&gt;<span class="hljs-title class_">Number</span>:&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 宏任务有哪些？微任务有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。</p>
</li>
<li><p>常见的宏任务有：</p>
</li>
<li><p>setTimeout 和 setInterval 的回调函数</p>
</li>
<li><p>DOM 事件</p>
</li>
<li><p>XMLHttpRequest 中的readystatechange事件</p>
</li>
<li><p>requestAnimationFrame 中的回调函数</p>
</li>
<li><p>I/O 操作和网络请求的回调函数</p>
</li>
<li><p>Node.js 中的文件读写操作的回调函数</p>
</li>
<li><p>Node.js 中的进程事件</p>
</li>
<li><p>常见的微任务有：</p>
</li>
<li><p>Promise.then 和 Promise.catch 的回调函数</p>
</li>
<li><p>MutationObserver 的回调函数</p>
</li>
<li><p>process.nextTick 函数</p>
</li>
<li><p>Object.observe 的回调函数</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>行内元素有：a b span img input select strong；</p>
<p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；</p>
<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>
<p>常见的有：br hr img input link meta</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. 什么是I/O？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。</p>
</li>
<li><p>异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。</p>
</li>
<li><p>而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。</p>
</li>
<li><p>网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：</p>
</li>
<li><p>异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。</p>
</li>
<li><p>听起来异步I/O很好，那为什么同步I/O依然会存在？</p>
</li>
<li><p>传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。</p>
</li>
<li><p>对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性</p>
</li>
<li><p>对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。</p>
</li>
<li><p>CPU密集和I/O密集：</p>
</li>
<li><p>CPU密集任务指的是纯计算任务。</p>
</li>
<li><p>I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 父组件如何监听子组件生命周期？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>vue2 使用 @hook:mounted</p>
<p>vue3 使用 @vue:mounted</p>
<p>自定义事件，在子组件生命周期中去执行 下面是vue3的写法</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;h1 @click=&quot;send&quot;&gt;Home 页面&lt;/h1&gt;
  &lt;Text @vue:mounted=&quot;fn&quot; /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { onMounted, ref } from &#x27;vue&#x27;
import Text from &#x27;../components/Text.vue&#x27;
const fn = () =&gt; {
  console.log(&#x27;Text mounted&#x27;)
}
&lt;/script&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. react无状态组件和class类组件的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>直观区别，函数组件代码量较少，相比类组件更加简洁</p>
</li>
<li><p>函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑</p>
</li>
<li><p>因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 使用Hooks要遵守哪些原则？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>
</li>
<li><p>只在 React 函数中调用 Hook</p>
</li>
</ul>
<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li><p>在 React 的函数组件中调用 Hook</p>
</li>
<li><p>在自定义 Hook 中调用其他 Hook</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 使用 Mobx 的特点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. React如何判断什么时候重新渲染组件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。</p>
<p>当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行</p>
<p>componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。</p>
<p>componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。</p>
<p>访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：</p>
<p>使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>. <span class="hljs-title function_">assign</span> ( { }， state, {
<span class="hljs-attr">type</span>:action .<span class="hljs-property">type</span>,
shouldNotPaint : <span class="hljs-literal">true</span>
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. Redux 有哪些优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>
</li>
<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>
</li>
<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>
</li>
<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>
</li>
<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>
</li>
<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. 什么是 Redux Thunk？它解决了什么问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。</p>
<p>解决问题：</p>
<p>异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。</p>
<p>复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data });
};

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));

store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. React中setState的第二个参数作用是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">key1</span>: newState1,
    <span class="hljs-attr">key2</span>: newState2,
    ...
}, callback) <span class="hljs-comment">// 第二个参数是 state 更新完成后的回调函数</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. React diff 原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>把树形结构按照层级分解，只比较同级元素。</p>
</li>
<li><p>列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
</li>
<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
</li>
<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
</li>
<li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">71. 类组件的setState和函数组件的useState异同</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>相同点</p>
<p>都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。</p>
<p>不同点</p>
<p>setState只要调用了就会执行更新；useState会浅比较2次state是否相同</p>
<p>setState有专门监听变化的回调函数；useState只能通过useEffect</p>
<p>setState底层处理上主要是和老的state合并；useState则重新赋值</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Redux 实现了哪种模式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. 解释 React 中 render() 的目的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. React如何做路由监听</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-react">
<span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">router</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>)=&gt;</span>{ <span class="hljs-keyword">if</span>(route.<span class="hljs-property">pathname</span>===<span class="hljs-string">&#x27;/xxx&#x27;</span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); } }); } 
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">75. shouldComponentUpdate有什么用？为什么它很重要？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。</p>
<p>和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. 如何在 Redux Thunk 中处理异步操作？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">addUser</span> = (<span class="hljs-params">{ firstName, lastName }</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserStart</span>());
  }

  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>, {
    firstName,
    lastName,
    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserSuccess</span>(res.<span class="hljs-property">data</span>));
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserError</span>(error.<span class="hljs-property">message</span>));
  })
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. React如何进行代码拆分？拆分的原则是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>
</li>
<li><p>在我们的react项目中：</p>
</li>
<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>
</li>
<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>
</li>
<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>
</li>
<li><p>静态类型的资源单独放置</p>
</li>
<li><p>公共组件、高阶组件、插件单独放置</p>
</li>
<li><p>工具类文件单独放置</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. 说说React的Context API及其使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>
</li>
<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>
</li>
<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. TCP与UDP区别是什么</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 为什么React并不推荐优先考虑使用Context？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</p>
<p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</p>
<p>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</p>
<p>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是PWA？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-14T06:27:01.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DR-CRcVW\",\"ing.md\":\"5u8N9YHE\",\"readme.md\":\"BO7L1nGd\",\"src_guide_getting-started.md\":\"BL_q6Ue2\",\"src_guide_why.md\":\"D9J8LAG8\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DcQeWWsV\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"DwhFqmEd\",\"src_questions_computer-base_1_计算机硬件.md\":\"BEuR0vGs\",\"src_questions_computer-base_2_计算机软件.md\":\"BjIdeU2K\",\"src_questions_computer-base_3_计算机网络.md\":\"D0cgmLEE\",\"src_questions_computer-base_4_计算机编程.md\":\"CMYadLtf\",\"src_questions_computer-base_5_计算机科学.md\":\"B4axBKUR\",\"src_questions_computer-base_6_软件工程.md\":\"Draq3Zd6\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"DJqPu91Q\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"glBfufB5\",\"src_questions_data-structures-algorithms_1_算法.md\":\"B3MBj-pW\",\"src_questions_front-architect_1_前端架构.md\":\"DEiliwZN\",\"src_questions_front-base_1_html.md\":\"7eQWgNwI\",\"src_questions_front-base_2_css.md\":\"B9SAoPEq\",\"src_questions_front-base_3_javascript.md\":\"DGSj343P\",\"src_questions_front-base_4_typescript.md\":\"CFBsX3A4\",\"src_questions_front-component_1_ui组件库.md\":\"DV463euX\",\"src_questions_front-component_2_业务组件库.md\":\"In8RE9n3\",\"src_questions_front-engineering_1_前端标准化.md\":\"HOR6L34l\",\"src_questions_front-engineering_2_前端自动化.md\":\"4eN3C8u2\",\"src_questions_front-engineering_3_webpack.md\":\"C5tOso6L\",\"src_questions_front-engineering_4_vite.md\":\"Bop_fEoV\",\"src_questions_front-engineering_5_rollup.md\":\"zPKOYs4K\",\"src_questions_front-frame_1_react.md\":\"BUAn8I8g\",\"src_questions_front-frame_2_vue.md\":\"CQ4vRVvZ\",\"src_questions_front-frame_3_next.md\":\"C1mviGo9\",\"src_questions_front-frame_4_nuxt.md\":\"Bmm06HKq\",\"src_questions_front-frame_5_qiankun.md\":\"a35X8AbZ\",\"src_questions_front-newest_1_前端最前沿.md\":\"Bs3MACdv\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DuqkDZEw\",\"src_questions_front-runtime_1_浏览器.md\":\"B_ikF5EJ\",\"src_questions_front-runtime_2_nodejs.md\":\"Cy_garHb\",\"src_questions_front-safety_1_前端安全.md\":\"BDsXyF_-\",\"src_questions_server_1_nest.md\":\"Bs698SMq\",\"src_questions_server_2_mongodb.md\":\"CeTKWpP9\",\"src_questions_server_3_mysql.md\":\"DQMVdoJZ\",\"src_questions_server_4_nginx.md\":\"Du-5ryhs\",\"src_questions_server_5_docker.md\":\"Im4aj6DF\",\"src_questions_server_6_kubernets.md\":\"Bwso7S1m\",\"src_questions_server_7_nacos.md\":\"BJsq7EXT\",\"src_questions_server_8_redis.md\":\"DDhlAmtA\",\"src_training_training-architecture_index.md\":\"BOePXhi9\",\"src_training_training-experts_index.md\":\"B53GKTpD\",\"src_training_training-intermediate_index.md\":\"Dh43bU4g\",\"src_training_training-primary_index.md\":\"C3Wt8LlC\",\"src_training_training-senior_index.md\":\"dVTv3L9z\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>