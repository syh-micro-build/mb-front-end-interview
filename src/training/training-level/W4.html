<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.NeqWCXrc.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.B_6UHZUb.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.CjzyDsWZ.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W4.md.YzHCFx_Q.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W4" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何在 Webpack 中使用 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 首先安装 <code>ts-loader</code> 和 <code>typescript</code>。</li>
<li><strong>1：</strong> 然后在 Webpack 配置文件中配置：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>] <span class="hljs-comment">// 解析文件扩展名</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>
      }
    ]
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly (Wasm) 的核心特点有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。</li>
<li><strong>1：</strong>  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。</li>
<li><strong>1：</strong>  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。</li>
<li><strong>1：</strong>  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。</li>
<li><strong>1：</strong>  小体积：Wasm 格式文件较小，传输高效，加载速度快。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">是否写过Plugin？简单描述一下编写Plugin的思路？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `w3`,`W4`、`W5`、`W6`</div><details class="inner-content"><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p>
<ul>
<li><p>compiler 暴露了和 Webpack 整个生命周期相关的钩子</p>
</li>
<li><p>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</p>
</li>
<li><p>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</p>
</li>
<li><p>传给每个插件的 compiler 和 - compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</p>
</li>
<li><p>找出合适的事件点去完成想要的功能</p>
</li>
</ul>
<p>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</p>
<p>watch-run 当依赖的文件发生变化时会触发</p>
<ul>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Webpack 中的 Tree Shaking 是什么，如何开启？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 是什么  </p>
<ul>
<li><strong>Tree Shaking</strong> 是通过<strong>静态分析 ES Module 导入导出语句</strong>，移除未被使用代码的优化（类似“摇树去枯叶”）。  </li>
<li><strong>核心依赖</strong>：ES Module 静态结构（<code>import/export</code> 编译时确定），无法用于 CommonJS。</li>
</ul>
</li>
<li><p><strong>1：</strong> 核心作用  </p>
<ul>
<li><strong>减体积</strong>：剔除死代码（如未调用的函数、未使用的变量），典型场景：lodash 按需引入体积减少 90%+。  </li>
<li><strong>提性能</strong>：减少浏览器下载/执行的代码量，提升首屏加载速度。</li>
</ul>
</li>
<li><p><strong>1：</strong> 配置与说明  </p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>配置代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>前提</strong></td>
<td>使用 ES Module（<code>import/export</code>）</td>
<td>CommonJS 动态语法（<code>require</code>）不支持 Tree Shaking</td>
</tr>
<tr>
<td><strong>生产模式默认</strong></td>
<td><code>mode: &#39;production&#39;</code></td>
<td>自动启用 Tree Shaking + Terser 压缩（无需额外配置）</td>
</tr>
<tr>
<td><strong>显式配置</strong></td>
<td><code>javascript&lt;br&gt;optimization: {&lt;br&gt;  treeShaking: true&lt;br&gt;}&lt;br&gt;</code></td>
<td>开发模式如需开启（不推荐，影响构建速度）</td>
</tr>
<tr>
<td><strong>标记副作用</strong></td>
<td><code>package.json</code> 声明：<br><code>&quot;sideEffects&quot;: false</code></td>
<td>全局无副作用（适用于纯 ESM 库），或精细保留：<code>[&quot;*.css&quot;, &quot;./src/utils/side-effect.js&quot;]</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>1：</strong> 完整示例（生产模式）</p>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 关键：自动开启 Tree Shaking</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  <span class="hljs-attr">output</span>: { <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.[contenthash].js&#x27;</span> }
};

<span class="hljs-comment">// src/math.js（ES Module）</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b; <span class="hljs-comment">// 被引用，保留</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = (<span class="hljs-params">a, b</span>) =&gt; a - b; <span class="hljs-comment">// 未引用，被摇树移除</span>

<span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> { add } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>; <span class="hljs-comment">// 仅引入 add</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
</code></pre><ul>
<li><strong>1：</strong> 注意事项  <ul>
<li><strong>必查项</strong>：打包后代码搜索未引用的函数名（如 <code>subtract</code>），确认是否被删除。  </li>
<li><strong>样式文件</strong>：CSS 需在 <code>sideEffects</code> 中声明（否则可能被误删）。  </li>
<li><strong>动态导入</strong>：<code>import(&#39;./module.js&#39;)</code> 单独打包，不影响主包 Tree Shaking。  </li>
<li><strong>开发模式</strong>：无需开启（<code>mode: &#39;development&#39;</code> 下默认关闭，因压缩会拖慢构建）。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack proxy是什么？怎么配置？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>
<li><strong>1：</strong> 配置如下：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),
    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&quot;/api&quot;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-comment">// </span>
      },
    },
    <span class="hljs-comment">// ...</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 与传统的 Webpack 打包工具有何不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly 的工作原理是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>
<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>
<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>
<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">图片的文件指纹设置</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `w3`,`W4`、`W5`、`W6`</div><details class="inner-content"><p>设置file-loader的name，使用hash。</p>
<ul>
<li><p>ext 资源后缀名</p>
</li>
<li><p>name 资源名称</p>
</li>
<li><p>path 资源所在路径</p>
</li>
<li><p>folder 资源所在文件夹</p>
</li>
<li><p>base 资源相对于上下文路径</p>
</li>
<li><p>hash 文件内容的 hash 值</p>
</li>
<li><p>digest 文件内容的 digest 值</p>
</li>
<li><p>content 文件内容的 base64 编码</p>
</li>
<li><p>query url查询参数</p>
</li>
<li><p>emoji 一个随机的指代文件内容的emoj</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    
  <span class="hljs-attr">output</span>: {        
    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,        
    <span class="hljs-attr">path</span>:path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)    
    },    
    <span class="hljs-attr">module</span>:{        
      <span class="hljs-attr">rules</span>:[{            
        <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,            
        <span class="hljs-attr">use</span>:[{                
          <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span>,                
          <span class="hljs-attr">options</span>:{                    
            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>                
        }            
      }]        
    }]    
  }}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 WebAssembly？其主要用途是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>
<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>
<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>
<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Webpack 中的 DllPlugin 和 DllReferencePlugin 有什么作用，如何使用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>DllPlugin</code> 用于创建动态链接库（DLL），将一些不经常变化的模块（如第三方库）打包成一个单独的文件，减少每次构建的时间。<code>DllReferencePlugin</code> 用于在主构建中引用这些 DLL 文件。</li>
<li><strong>1：</strong> 使用步骤：<ul>
<li>配置 <code>DllPlugin</code> 创建 DLL 文件：</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// webpack.dll.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">vendors</span>: [<span class="hljs-string">&#x27;react&#x27;</span>, <span class="hljs-string">&#x27;react-dom&#x27;</span>]
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,
    <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;[name]_[hash]&#x27;</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[name]_[hash]&#x27;</span>,
      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>)
    })
  ]
};
</code></pre><ul>
<li>配置 <code>DllReferencePlugin</code> 引用 DLL 文件：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// 其他配置...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>({
      <span class="hljs-attr">manifest</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;vendors-manifest.json&#x27;</span>)
    })
  ]
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">说说如何借助webpack来优化前端性能?</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `w3`,`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>3：</strong><ul>
<li>JS代码压缩  </li>
<li>CSS代码压缩  </li>
<li>Html文件代码压缩  </li>
<li>文件大小压缩  </li>
<li>图片压缩  </li>
<li>Tree Shaking  </li>
<li>代码分离  </li>
<li>内联 chunk</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Webpack 是如何处理模块打包的？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> <strong>模块解析</strong></p>
<ul>
<li>Webpack 从配置的入口文件开始，通过静态分析代码中的导入语句（如 <code>import</code>、<code>require</code>）来识别模块之间的依赖关系。例如，当遇到 <code>import &#39;./module.js&#39;</code> 时，Webpack 会将 <code>module.js</code> 标记为当前模块的依赖。</li>
<li>对于不同类型的模块，Webpack 会根据配置的 <code>resolve</code> 规则来确定模块的查找路径和文件扩展名。比如，设置 <code>extensions: [&#39;.js&#39;, &#39;.json&#39;]</code> 后，在查找模块时会自动尝试添加这些扩展名。</li>
</ul>
</li>
<li><p><strong>1：</strong> <strong>Loader 处理</strong></p>
<ul>
<li>在解析模块的过程中，Webpack 会根据 <code>module.rules</code> 配置的规则，使用相应的 loader 对模块进行处理。例如，对于 CSS 文件，会使用 <code>css-loader</code> 解析其中的 <code>@import</code> 和 <code>url()</code> 语句，再使用 <code>style-loader</code> 将 CSS 注入到 DOM 中。</li>
<li>loader 是按照从右到左（或从下到上）的顺序依次执行的。例如 <code>use: [&#39;style-loader&#39;, &#39;css-loader&#39;]</code>，会先执行 <code>css-loader</code>，再执行 <code>style-loader</code>。</li>
</ul>
</li>
<li><p><strong>1：</strong> <strong>依赖图构建</strong></p>
<ul>
<li>Webpack 通过递归地解析所有模块及其依赖，构建出一个完整的依赖图（Dependency Graph）。这个图记录了所有模块之间的依赖关系和顺序。</li>
<li>依赖图中的每个节点代表一个模块，边代表模块之间的依赖关系。Webpack 会根据这个图来确定模块的打包顺序和方式。</li>
</ul>
</li>
<li><p><strong>1：</strong> <strong>代码生成与打包</strong></p>
<ul>
<li>Webpack 根据依赖图将所有模块的代码合并和打包成一个或多个文件。在这个过程中，Webpack 会对代码进行优化，如去除未使用的代码（Tree Shaking）、压缩代码等。</li>
<li>对于不同的入口文件，Webpack 会生成对应的打包文件。例如，配置了多个入口 <code>entry: { app: &#39;./src/app.js&#39;, admin: &#39;./src/admin.js&#39; }</code>，会生成 <code>app.bundle.js</code> 和 <code>admin.bundle.js</code> 等文件。</li>
</ul>
</li>
<li><p><strong>1：</strong> <strong>插件机制</strong></p>
<ul>
<li>Webpack 在整个打包过程中提供了丰富的钩子（Hook），插件可以在这些钩子上注册自己的逻辑，从而在不同的阶段执行特定的任务。</li>
<li>例如，<code>HtmlWebpackPlugin</code> 会在打包完成后生成 HTML 文件，并将打包后的 JavaScript 和 CSS 文件插入到 HTML 中；<code>MiniCssExtractPlugin</code> 会在打包过程中提取 CSS 到单独的文件中。</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">是否写过Loader？简单描述一下编写loader的思路？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `w3`,`W4`、`W5`、`W6`</div><details class="inner-content"><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p>
<ul>
<li><p>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</p>
</li>
<li><p>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</p>
</li>
<li><p>尽可能的异步化 Loader，如果计算量很小，同步也可以</p>
</li>
<li><p>Loader 是无状态的，我们不应该在 Loader 中保留状态</p>
</li>
<li><p>使用 loader-utils 和 schema-utils 为我们提供的实用工具</p>
</li>
<li><p>加载本地 Loader 方法</p>
</li>
</ul>
<p>Npm link</p>
<p>ResolveLoader</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Webpack 常用配置有哪些</h4><div class="head-re"><span class="head-score">12 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> <strong>入口与出口</strong></p>
<ul>
<li><strong>入口</strong>：单入口 <code>entry: &#39;./src/index.js&#39;</code>；多入口 <code>entry: { main: &#39;./src/main.js&#39;, vendor: &#39;./src/vendor.js&#39; }</code>。</li>
<li><strong>出口</strong>：<code>output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].[hash].js&#39; }</code>。</li>
</ul>
</li>
<li><p><strong>4：</strong> <strong>Loader 及功能与示例</strong></p>
<ul>
<li>用于处理不同类型文件的转换器。它可以将非 JavaScript 文件（如 CSS、图片、TS 等）转换为 Webpack 能够处理的模块。</li>
<li><code>style-loader</code>：将 CSS 以 <code>&lt;style&gt;</code> 标签形式插入到 HTML 的 <code>&lt;head&gt;</code> 中。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-comment">// 先使用 css-loader 解析，再用 style-loader 插入</span>
        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] 
      }
    ]
  }
};
</code></pre><ul>
<li><code>css-loader</code>：解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code> 等语句，处理 CSS 模块之间的依赖关系。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-comment">// 解析 CSS 文件</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span> 
      }
    ]
  }
};
</code></pre><ul>
<li><code>sass-loader</code>：将 Sass 或 SCSS 文件编译为 CSS 文件，需配合 <code>node-sass</code> 或 <code>dart-sass</code> 使用。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>,
        <span class="hljs-comment">// 按顺序依次使用 sass-loader、css-loader、style-loader 处理</span>
        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>] 
      }
    ]
  }
};
</code></pre><ul>
<li><code>less-loader</code>：把 Less 文件转换为普通的 CSS 文件。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,
        <span class="hljs-comment">// 处理 Less 文件</span>
        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>] 
      }
    ]
  }
};
</code></pre><ul>
<li><code>postcss-loader</code>：使用 PostCSS 对 CSS 进行转换和优化，例如添加浏览器前缀、压缩 CSS 等。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-string">&#x27;style-loader&#x27;</span>,
          <span class="hljs-string">&#x27;css-loader&#x27;</span>,
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">postcssOptions</span>: {
                <span class="hljs-attr">plugins</span>: [
                  <span class="hljs-comment">// 添加浏览器前缀</span>
                  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>) 
                ]
              }
            }
          }
        ]
      }
    ]
  }
};
</code></pre><ul>
<li><code>file-loader</code>：处理文件资源，将文件复制到输出目录，并返回文件的公共 URL，适用于图片、字体等。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/i</span>,
        <span class="hljs-comment">// 处理图片文件</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span> 
      }
    ]
  }
};
</code></pre><ul>
<li><code>url-loader</code>：功能与 <code>file-loader</code> 类似，但当文件大小小于指定阈值时，会将文件转换为 Data URL 嵌入到代码中，减少 HTTP 请求。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/i</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-comment">// 小于 8192 字节转换为 Data URL</span>
            <span class="hljs-attr">limit</span>: <span class="hljs-number">8192</span> 
          }
        }
      }
    ]
  }
};
</code></pre><ul>
<li><code>svg-url-loader</code>：专门处理 SVG 文件，可将 SVG 转换为 Data URL 或使用 <code>file-loader</code> 处理。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.svg$/</span>,
        <span class="hljs-comment">// 处理 SVG 文件</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;svg-url-loader&#x27;</span> 
      }
    ]
  }
};
</code></pre><ul>
<li><code>babel-loader</code>：结合 Babel 将 ES6+ 代码转换为向后兼容的 JavaScript 代码，确保在旧浏览器中正常运行。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,
          <span class="hljs-attr">options</span>: {
            <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]
          }
        }
      }
    ]
  }
};
</code></pre><ul>
<li><code>ts-loader</code>：将 TypeScript 文件编译为 JavaScript 文件，配合 TypeScript 项目使用。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,
        <span class="hljs-comment">// 处理 TypeScript 文件</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;ts-loader&#x27;</span> 
      }
    ]
  }
};
</code></pre><ul>
<li><code>markdown-loader</code>：将 Markdown 文件转换为 HTML 字符串，方便在项目中使用 Markdown 内容。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,
        <span class="hljs-comment">// 处理 Markdown 文件</span>
        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;markdown-loader&#x27;</span> 
      }
    ]
  }
};
</code></pre></li>
<li><p><strong>4：</strong> <strong>插件及功能与示例</strong></p>
<ul>
<li>用于在 Webpack 构建过程的优化和扩展，如代码压缩、生成 HTML 文件、分割代码等。</li>
<li><code>HtmlWebpackPlugin</code>：自动生成 HTML 文件，并将打包后的 JavaScript 和 CSS 文件自动插入到 HTML 中，可使用模板文件。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
      <span class="hljs-comment">// 指定 HTML 模板文件</span>
      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> 
    })
  ]
};
</code></pre><ul>
<li><code>MiniCssExtractPlugin</code>：将 CSS 提取到单独的文件中，避免将 CSS 内联到 JavaScript 中，提高页面加载性能。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-comment">// 提取 CSS 到单独文件</span>
          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, 
          <span class="hljs-string">&#x27;css-loader&#x27;</span>
        ]
      }
    ]
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({
      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].css&#x27;</span>
    })
  ]
};
</code></pre><ul>
<li><code>OptimizeCssAssetsPlugin</code>：压缩和优化 CSS 文件，去除多余的空格、注释等。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCssAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 压缩优化 CSS</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCssAssetsPlugin</span>() 
  ]
};
</code></pre><ul>
<li><code>TerserPlugin</code>：在生产模式下默认使用，用于压缩 JavaScript 代码，减小文件体积。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-comment">// 压缩 JavaScript 代码</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>() 
    ]
  }
};
</code></pre><ul>
<li><code>SplitChunksPlugin</code>（Webpack 4 及以后）：提取公共模块，实现代码分割，减少重复打包。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre><ul>
<li><code>HardSourceWebpackPlugin</code>：为模块提供中间缓存，加快二次构建速度。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;hard-source-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 启用模块缓存</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardSourceWebpackPlugin</span>() 
  ]
};
</code></pre><ul>
<li><code>DefinePlugin</code>：定义全局常量，可在代码中使用，常用于区分开发和生产环境。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>({
      <span class="hljs-comment">// 定义全局常量</span>
      <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;production&#x27;</span>) 
    })
  ]
};
</code></pre><ul>
<li><code>HotModuleReplacementPlugin</code>：开启热更新功能，在开发过程中修改代码后只更新修改的模块，无需重新加载整个页面。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 开启热更新</span>
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>() 
  ]
};
</code></pre><ul>
<li><code>CleanWebpackPlugin</code>：在每次构建前清理输出目录，避免旧文件残留。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">CleanWebpackPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 清理输出目录</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>() 
  ]
};
</code></pre><ul>
<li><code>WebpackBundleAnalyzerPlugin</code>：生成打包文件的可视化报告，帮助分析各个模块的大小和依赖关系，便于优化打包结果。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// 生成打包分析报告</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>() 
  ]
};
</code></pre></li>
<li><p><strong>1：</strong> <strong>模式</strong></p>
<ul>
<li><code>development</code>：开启调试特性，如生成 Source Map、不进行代码压缩等，方便开发调试。</li>
<li><code>production</code>：自动开启代码压缩、Tree Shaking 等优化，减小打包文件体积，提高生产环境性能。</li>
</ul>
</li>
<li><p><strong>2：</strong> <strong>开发服务器</strong></p>
<ul>
<li><strong>热更新</strong>：<code>devServer: { hot: true }</code>，结合 <code>webpack.HotModuleReplacementPlugin</code> 实现模块热替换。</li>
<li><strong>代理</strong>：<code>devServer: { proxy: { &#39;/api&#39;: { target: &#39;http://backend.example.com&#39; } } }</code>，解决开发环境中的跨域问题。</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是BFF？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。</p>
</li>
<li><p>最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 在v-if 和 v-for 的优先级哪个高？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 说一下 watch 与 computed 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>都是观察数据变化的（相同）</p>
</li>
<li><p>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化</p>
</li>
<li><p>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</p>
</li>
<li><p>watch 支持异步，computed 不支持；</p>
</li>
<li><p>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</p>
</li>
<li><p>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</p>
</li>
<li><p>omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件
的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。</li>
<li><strong>1：</strong> 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，
让这些组件都通过这个 HOC 来获得权限验证功能。</li>
<li><strong>1：</strong> 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专
注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. watch怎么停止监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何使用 calc() 函数？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算，注意运算符前后一定要有空格，否则不生效。例如：</li>
</ul>
<pre><code class="hljs language-css">  <span class="hljs-attr">width</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% - 20px);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 为什么React并不推荐优先考虑使用Context？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</p>
<p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</p>
<p>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</p>
<p>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">66. 说说React Hooks是如何解决类组件中一些常见问题的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。</p>
</li>
<li><p>这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。</p>
</li>
<li><p>通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。</p>
</li>
<li><p>此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. React.createClass和extends Component的区别有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>语法区别</p>
<ul>
<li><p>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</p>
</li>
<li><p>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
</li>
</ul>
<p>propType 和 getDefaultProps</p>
<ul>
<li><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>
</li>
<li><p>React.Component：通过设置两个属性propTypes和defaultProps</p>
</li>
</ul>
<p>状态的区别</p>
<ul>
<li><p>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</p>
</li>
<li><p>React.Component：通过constructor构造函数设置初始状态</p>
</li>
</ul>
<p>this.state</p>
<ul>
<li><p>React.createClass：需要显示的调用this.setState()方法</p>
</li>
<li><p>React.Component：不需要调用，直接this.state获取</p>
</li>
</ul>
<p>Mixins</p>
<ul>
<li><p>React.createClass：通过mixins属性混合进来</p>
</li>
<li><p>React.Component：通过引入React Mixin</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSS中 transition和animation的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，
而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. 什么是 useEffect？它如何工作？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。</p>
</li>
<li><p>工作原理：</p>
</li>
<li><p>执行副作用：在组件挂载和更新时执行副作用操作。</p>
</li>
<li><p>清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。</p>
</li>
</ul>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">DataFetcher</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
      <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
      <span class="hljs-title function_">setData</span>(json);
    };

    <span class="hljs-title function_">fetchData</span>();

    <span class="hljs-comment">// 清理函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Cleanup&#x27;</span>);
    };
  }, []); <span class="hljs-comment">// 依赖数组为空，表示仅在组件挂载时执行</span>

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}
    &lt;/div&gt;
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetcher</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">谈谈你对 Web 标准以及 W3C 的理解和认识</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。</li>
<li><strong>1：</strong> 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器是怎样解析CSS选择器的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 从右向左解析。如： <code>.nav &gt; li a</code> 先匹配 a，再向上查找 li 和 .nav；</li>
<li><strong>1：</strong> 减少回溯开销</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 什么是 React Context API？它解决了什么问题？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React Context API：</p>
</li>
<li><p>Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。</p>
</li>
<li><p>创建 Context：使用 React.createContext 创建一个 Context 对象。</p>
</li>
<li><p>提供 Context：使用 Context.Provider 组件将数据传递给子组件。</p>
</li>
<li><p>消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">画一条0.5px的线</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2:</strong> 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：</li>
</ul>
<pre><code class="hljs language-css"><span class="hljs-attr">transform</span>: <span class="hljs-title function_">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);
</code></pre><ul>
<li><strong>2:</strong> 采用meta viewport的方式</li>
</ul>
<pre><code class="hljs language-html">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;</span>/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. Composition API 和 Options API 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">常见的浏览器内核有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>
<li><strong>1：</strong>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
<li><strong>1：</strong>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>
<li><strong>1：</strong>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>
</ul>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-04-07T02:13:36.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W3</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W5</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"9IsXlCxp\",\"ing.md\":\"DEx_Hc6S\",\"readme.md\":\"DDRa-sHs\",\"src_guide_getting-started.md\":\"CL71JWFM\",\"src_guide_why.md\":\"BvHIQ29d\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BokmUTWX\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"3Wwru424\",\"src_questions_computer-base_1_计算机硬件.md\":\"D9ntIop5\",\"src_questions_computer-base_2_计算机软件.md\":\"1EFyKC9f\",\"src_questions_computer-base_3_计算机网络.md\":\"C8RS2Mqz\",\"src_questions_computer-base_4_计算机编程.md\":\"Dir3CXmc\",\"src_questions_computer-base_5_计算机科学.md\":\"BTCW5YUI\",\"src_questions_computer-base_6_软件工程.md\":\"cmH5FSmz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"hIOQG21W\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CDM0yZEJ\",\"src_questions_data-structures-algorithms_1_算法.md\":\"ezcy1UHw\",\"src_questions_front-architect_1_前端架构.md\":\"BlTcSsq5\",\"src_questions_front-base_1_html.md\":\"DKu7GdHT\",\"src_questions_front-base_2_css.md\":\"BZ5_kkJW\",\"src_questions_front-base_3_javascript.md\":\"DhTsJI1R\",\"src_questions_front-base_4_typescript.md\":\"BYuwObrq\",\"src_questions_front-component_1_ui组件库.md\":\"kKacFWzv\",\"src_questions_front-component_2_业务组件库.md\":\"C9DBaQ9p\",\"src_questions_front-engineering_1_前端标准化.md\":\"CylB49a0\",\"src_questions_front-engineering_2_前端自动化.md\":\"CTgFekrK\",\"src_questions_front-engineering_3_webpack.md\":\"Cq0JY9i3\",\"src_questions_front-engineering_4_vite.md\":\"3Y3SC4KR\",\"src_questions_front-engineering_5_rollup.md\":\"Dc4coaJV\",\"src_questions_front-frame_1_react.md\":\"Nlj0kn5y\",\"src_questions_front-frame_2_vue.md\":\"C5o5nKbw\",\"src_questions_front-frame_3_next.md\":\"BSu_8BbM\",\"src_questions_front-frame_4_nuxt.md\":\"Dt8qSTaJ\",\"src_questions_front-frame_5_qiankun.md\":\"DaqtgiFk\",\"src_questions_front-newest_1_前端最前沿.md\":\"DFCokeFy\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"C2PRlOez\",\"src_questions_front-runtime_1_浏览器.md\":\"vFrDFvMb\",\"src_questions_front-runtime_2_nodejs.md\":\"BQYPG2Jf\",\"src_questions_front-safety_1_前端安全.md\":\"C8KfU3-Q\",\"src_questions_server_1_nest.md\":\"DCR3vJNi\",\"src_questions_server_2_mongodb.md\":\"C4f3evNV\",\"src_questions_server_3_mysql.md\":\"DS5uALSZ\",\"src_questions_server_4_nginx.md\":\"DGiMpf1Z\",\"src_questions_server_5_docker.md\":\"BBvUP3x7\",\"src_questions_server_6_kubernets.md\":\"iLBW23Fb\",\"src_questions_server_7_nacos.md\":\"sZY9vX9E\",\"src_questions_server_8_redis.md\":\"BlcQCjeU\",\"src_training_training-level_w1.md\":\"B1JchKhY\",\"src_training_training-level_w2.md\":\"BKzf8iR1\",\"src_training_training-level_w3.md\":\"bT9tGkXO\",\"src_training_training-level_w4.md\":\"YzHCFx_Q\",\"src_training_training-level_w5.md\":\"CpFeBIr-\",\"src_training_training-level_w6.md\":\"Ds_07UrR\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>