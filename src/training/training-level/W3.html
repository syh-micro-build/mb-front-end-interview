<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.D_tXsTg_.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.B7mL2hbk.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.B_xZcBep.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W3.md.d5s5SNvX.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W3" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. react如何做到和vue中keep-alive的缓存效果</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. 如何在 Redux Thunk 中处理异步操作？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">addUser</span> = (<span class="hljs-params">{ firstName, lastName }</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserStart</span>());
  }

  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>, {
    firstName,
    lastName,
    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserSuccess</span>(res.<span class="hljs-property">data</span>));
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserError</span>(error.<span class="hljs-property">message</span>));
  })
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 对 React-Intl 的理解，它的工作原理？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>
<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>
<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 为什么说React中的props是只读的？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 说说对高阶组件（HOC）的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p>
</li>
<li><p>接受一个或多个函数作为输入</p>
</li>
<li><p>输出一个函数</p>
</li>
<li><p>在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. 如何用 React构建（ build）生产模式？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. React18中引入的并发模式是什么，它带来了哪些改进</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。</p>
</li>
<li><p>通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。</p>
</li>
<li><p>此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 使用Hooks要遵守哪些原则？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>
</li>
<li><p>只在 React 函数中调用 Hook</p>
</li>
</ul>
<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li><p>在 React 的函数组件中调用 Hook</p>
</li>
<li><p>在自定义 Hook 中调用其他 Hook</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. 在React中组件的this.state和setState有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Vuex和单纯的全局对象有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">从输入URL到看到页面发生的全过程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>1.用户首先在浏览器地址栏中输入想要访问的网站的URL。</li>
<li>2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。</li>
<li>3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。</li>
<li>4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。</li>
<li>5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。</li>
<li>6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。</li>
<li>7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器中常见的存储方式有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。</li>
<li><strong>1：</strong> LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。</li>
<li><strong>1：</strong> SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。</li>
<li><strong>1：</strong> IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. Vue-Router 的懒加载如何实现</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>加载渲染过程：</p>
<p>方案一(常用)：使用箭头函数+import动态加载</p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/list.vue&#x27;</span>)
  <span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
    <span class="hljs-attr">routes</span>: [
      { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> }
    ]
  })
</code></pre><p>方案二：使用箭头函数+require动态加载</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>({
  <span class="hljs-attr">routes</span>: [
   {
     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,
     <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;@/components/list&#x27;</span>], resolve)
   }
  ]
})
</code></pre><p>方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// r就是resolve</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">List</span> = r =&gt; <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([], <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">r</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);
<span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>({
  <span class="hljs-attr">routes</span>: [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;list&#x27;</span>
  }
 ]
}))
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. webpack 的热更新原理?</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，</li>
<li><strong>1：</strong> 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。</li>
<li><strong>1：</strong> 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识</li>
<li><strong>1：</strong> 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。
<img src="/public/images/image.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. Webpack 的核心概念有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 入口（Entry）：指示 Webpack 从哪个模块开始打包，可配置单个或多个入口。</li>
<li><strong>1：</strong> 输出（Output）：告诉 Webpack 打包后的文件存放在哪里，以及如何命名。</li>
<li><strong>1：</strong> loader：用于处理不同类型的文件，将它们转换为 Webpack 能够处理的模块。例如，<code>css-loader</code> 用于处理 CSS 文件，<code>babel-loader</code> 用于将 ES6+ 代码转
换为向后兼容的 JavaScript 代码。</li>
<li><strong>1：</strong> 插件（Plugin）：用于执行更广泛的任务，如代码压缩、分割代码、生成 HTML 文件等。常见的插件有 HtmlWebpackPlugin、MiniCssExtractPlugin 等。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>无样式内容闪烁，因 CSS 加载延迟。解决方案：将 CSS 放在 <code>&lt;head&gt;</code> 中，避免使用 @import。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSS 中的 BEM 命名规范是什么？为什么要使用它？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> BEM 命名规范：</p>
<ul>
<li>Block（块）：独立的组件，如 <code>.button</code></li>
<li>Element（元素）：属于块的一部分，用 <code>__</code> 连接，如 <code>.button__text</code></li>
<li>Modifier（修饰符）：改变块或元素的外观或行为，用 <code>--</code> 连接，如 <code>.button--large</code></li>
</ul>
</li>
<li><p><strong>2：</strong> 使用BEM的好处：</p>
<ul>
<li>提高代码的可读性和可维护性</li>
<li>避免CSS选择器嵌套过深</li>
<li>减少命名冲突</li>
<li>明确表达组件结构和关系</li>
<li>方便团队协作和代码复用</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释 Nuxt3 中 nitro 的作用及关键配置项</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配</li>
<li><strong>1：</strong> 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">preset</span>: <span class="hljs-string">&#x27;node-server&#x27;</span>
  }
}
<span class="hljs-comment">//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，</span>
<span class="hljs-comment">// 例如 preset: &#x27;serverless&#x27;，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。</span>
</code></pre><ul>
<li><strong>2：</strong> routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">routeRules</span>: {
      <span class="hljs-string">&#x27;/&#x27;</span>: {
        <span class="hljs-attr">cache</span>: {
          <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> * <span class="hljs-number">10</span> <span class="hljs-comment">// 为首页设置缓存时间，这里是 10 分钟</span>
        }
      },
      <span class="hljs-string">&#x27;/about&#x27;</span>: {
        <span class="hljs-attr">redirect</span>: {
          <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-comment">// 将访问 /about 页面重定向到首页</span>
          <span class="hljs-attr">statusCode</span>: <span class="hljs-number">302</span>
        }
      },
      <span class="hljs-string">&#x27;/api/data&#x27;</span>: {
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment">// 为 /api/data 路由设置响应头，允许跨域访问</span>
        }
      }
    }
  }
}
<span class="hljs-comment">//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减</span>
<span class="hljs-comment">// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。</span>
</code></pre><ul>
<li><strong>1：</strong> devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地
开发环境下顺畅地协同工作。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">devProxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>, <span class="hljs-comment">// 后端 API 服务器的实际地址</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
      }
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的
要求，精准地定制构建结果的呈现形式。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-comment">// 设置构建输出目录为 dist</span>
      <span class="hljs-attr">publicDir</span>: <span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-comment">// 设定公共资源目录为 public</span>
      <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;esm&#x27;</span> <span class="hljs-comment">// 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式</span>
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部
系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;./server/plugins/myPlugin.ts&#x27;</span>]
  }
}
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 对 SPA 单页面的理解，它的优缺点分别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 如何动态绑定 class 和 style？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：</p>
<pre><code class="hljs language-html">&lt;div :<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;{ active: isActive, &#x27;text-danger&#x27;: hasError }&quot;</span>&gt;&lt;/div&gt;
&lt;div :class=&quot;[isActive ? &#x27;active&#x27; : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + &#x27;px&#x27; }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSS 动画和过渡的区别是什么？如何使用它们？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> 过渡（Transition）：<ul>
<li>从一个状态到另一个状态的平滑过渡</li>
<li>需要触发条件（如hover）</li>
<li>只能定义开始和结束状态</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">.<span class="hljs-property">element</span> {
    <span class="hljs-attr">width</span>: 100px;
    <span class="hljs-attr">transition</span>: width <span class="hljs-number">0.</span>3s ease;
}

.<span class="hljs-property">element</span>:hover {
    <span class="hljs-attr">width</span>: 200px;
}
</code></pre><ul>
<li><strong>2：</strong> 动画（Animation）：<ul>
<li>可以定义多个状态的变化</li>
<li>可以循环播放</li>
<li>可以自动播放，无需触发条件</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">@keyframes slide {
    <span class="hljs-number">0</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-number">50</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(100px);
    }
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
}

.<span class="hljs-property">element</span> {
    <span class="hljs-attr">animation</span>: slide 2s ease infinite;
}
</code></pre><ul>
<li><strong>2：</strong> 主要区别：<ul>
<li>触发方式：过渡需要触发条件，动画可以自动播放</li>
<li>状态数量：过渡只有开始和结束两个状态，动画可以有多个状态</li>
<li>循环播放：动画可以循环播放，过渡不能</li>
<li>控制能力：动画的控制能力更强，可以精确控制中间状态</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. Vue中怎么异步加载组件</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-js">&lt;template&gt; 
    &lt;MyComponent /&gt; 
&lt;/template&gt;
&lt;script setup&gt;
import { defineAsyncComponent } from &#x27;vue&#x27;

const MyComponent = defineAsyncComponent(() =&gt;
  import(&#x27;./components/MyComponent.vue&#x27;)
)
&lt;/script&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. React如何进行代码拆分？拆分的原则是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>
</li>
<li><p>在我们的react项目中：</p>
</li>
<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>
</li>
<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>
</li>
<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>
</li>
<li><p>静态类型的资源单独放置</p>
</li>
<li><p>公共组件、高阶组件、插件单独放置</p>
</li>
<li><p>工具类文件单独放置</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）哪些方法会触发 react 重新渲染?</p>
<ul>
<li>setState（）方法被调用</li>
</ul>
<p>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</p>
<ul>
<li>父组件重新渲染</li>
</ul>
<p>只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。</p>
<p>（2）重新渲染 render 会做些什么?</p>
<ul>
<li><p>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</p>
</li>
<li><p>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</p>
</li>
<li><p>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. 什么是React调和？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。
调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTML、XML、XHTML 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；</p>
</li>
<li><p>XML：可扩展标记语言，是语法较为严格、严格的标记语言；</p>
</li>
<li><p>XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. Vue 3 中的 Teleport 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Teleport 用于将组件渲染到指定 DOM 节点。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &lt;div&gt;Modal&lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. TCP的可靠传输机制</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。</p>
<p>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。</p>
<p>当发送方收到接收方的三个冗余的确认应答后，这是一种指示，说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">谈谈你对唤醒函数的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础`、`编程</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> 基本概念
唤醒函数通常用于控制程序的执行流程，特别是在异步编程或并发编程场景中。其核心作用是在特定条件满足时，将处于等待或阻塞状态的代码重新激活继续执行。它就像是一个“开关”，在合适的时机触发，让程序从暂停状态恢复运行，有助于实现程序的有序执行和资源的合理利用。</p>
</li>
<li><p><strong>2：</strong> 实现方式及示例</p>
<ul>
<li><strong>基于定时器的唤醒</strong>：通过 <code>setTimeout</code> 或 <code>setInterval</code> 来设置一个延迟时间，当时间到达时触发唤醒操作。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">wakeAfterDelay</span>(<span class="hljs-params">delay</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;唤醒啦&#x27;</span>);
        }, delay);
    });
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始等待&#x27;</span>);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">wakeAfterDelay</span>(<span class="hljs-number">2000</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行&#x27;</span>);
}

<span class="hljs-title function_">main</span>();
</code></pre><ul>
<li><strong>基于事件的唤醒</strong>：监听某个特定事件，当事件发生时进行唤醒。在前端开发中，常见的如按钮点击、网络请求完成等事件。</li>
</ul>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;button id=&quot;wakeBtn&quot;&gt;点击唤醒&lt;/button&gt;
    &lt;script&gt;
        function wakeOnClick() {
            return new Promise((resolve) =&gt; {
                const btn = document.getElementById(&#x27;wakeBtn&#x27;);
                btn.addEventListener(&#x27;click&#x27;, () =&gt; {
                    resolve(&#x27;按钮点击，唤醒啦&#x27;);
                });
            });
        }

        async function main() {
            console.log(&#x27;等待点击&#x27;);
            const result = await wakeOnClick();
            console.log(result);
            console.log(&#x27;继续执行&#x27;);
        }

        main();
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre></li>
<li><p><strong>2：</strong> 应用场景</p>
<ul>
<li><strong>电商系统中的限时抢购</strong>：在电商的限时抢购活动中，服务器需要在活动开始的瞬间处理大量用户的请求。可以使用唤醒函数结合定时器来实现。服务器在活动开始前处于等待状态，通过 <code>setTimeout</code> 设定活动开始时间，当时间到达，唤醒函数被触发，服务器开始接收和处理用户的抢购请求。例如：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2024-12-31 00:00:00&#x27;</span>).<span class="hljs-title function_">getTime</span>();
<span class="hljs-keyword">const</span> currentTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
<span class="hljs-keyword">const</span> delay = startTime - currentTime;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">startFlashSale</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;限时抢购活动开始，开始处理请求&#x27;</span>);
    <span class="hljs-comment">// 处理抢购请求的逻辑</span>
}

<span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">setTimeout</span>(startFlashSale, delay);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">startFlashSale</span>();
}
</code></pre><ul>
<li><strong>视频会议系统中的发言控制</strong>：在视频会议系统中，为了避免多人同时发言造成混乱，通常会有一个主持人控制发言顺序。当主持人允许某个参会者发言时，相当于触发了一个唤醒事件。可以使用基于事件的唤醒函数来实现。例如，参会者的客户端代码如下：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">waitForPermission</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
        <span class="hljs-comment">// 监听主持人允许发言的事件</span>
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;host-permission&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;你可以发言了&#x27;</span>);
        });
    });
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">participant</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;等待主持人允许发言&#x27;</span>);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitForPermission</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    <span class="hljs-comment">// 开始发言的逻辑</span>
}

<span class="hljs-title function_">participant</span>();
</code></pre><ul>
<li><strong>物流系统中的任务调度</strong>：在物流系统中，当一个包裹到达某个中转站时，需要等待特定的条件满足（如车辆装满、到达规定的发车时间等）才会继续运输。可以使用唤醒函数来控制任务的执行。例如，使用定时器在规定的发车时间唤醒运输任务，或者监听车辆装满的事件来触发唤醒。</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">JS 如何实现函数缓存</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础`、`架构`、`编程`、`算法</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> 基本原理
函数缓存是指将函数的输入参数和对应的输出结果存储起来，当再次使用相同的参数调用该函数时，直接从缓存中获取结果，而不是重新执行函数，从而提高函数的执行效率，尤其是对于一些计算密集型或耗时的函数。</p>
</li>
<li><p><strong>2：</strong> 实现方式</p>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 定义 memoize 高阶函数，用于将普通函数转换为具有缓存功能的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">func</span>) {
    <span class="hljs-comment">// 使用 Map 对象来存储缓存，键为参数，值为函数执行结果</span>
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
        <span class="hljs-comment">// 将参数转换为字符串作为缓存的键</span>
        <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);
        <span class="hljs-comment">// 检查缓存中是否已存在该键对应的结果</span>
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-comment">// 若存在，直接从缓存中获取结果并返回</span>
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);
        }
        <span class="hljs-comment">// 若缓存中不存在，调用原函数并传入参数</span>
        <span class="hljs-keyword">const</span> result = func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        <span class="hljs-comment">// 将参数和对应的结果存入缓存</span>
        cache.<span class="hljs-title function_">set</span>(key, result);
        <span class="hljs-comment">// 返回函数执行结果</span>
        <span class="hljs-keyword">return</span> result;
    };
}

<span class="hljs-comment">// 模拟一个计算密集型的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">expensiveCalculation</span>(<span class="hljs-params">num</span>) {
    <span class="hljs-comment">// 打印提示信息，表示正在进行耗时计算</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Performing expensive calculation...&#x27;</span>);
    <span class="hljs-comment">// 返回输入参数乘以 2 的结果</span>
    <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;
}

<span class="hljs-comment">// 使用 memoize 函数将 expensiveCalculation 转换为具有缓存功能的函数</span>
<span class="hljs-keyword">const</span> memoizedCalculation = <span class="hljs-title function_">memoize</span>(expensiveCalculation);

<span class="hljs-comment">// 第一次调用，由于缓存中没有结果，会执行计算并将结果存入缓存</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedCalculation</span>(<span class="hljs-number">5</span>)); 
<span class="hljs-comment">// 第二次调用，由于参数相同，直接从缓存中获取结果，不再执行计算</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedCalculation</span>(<span class="hljs-number">5</span>)); 
</code></pre><ul>
<li><strong>2：</strong> 注意事项<ul>
<li><strong>参数类型限制</strong>：在使用 <code>JSON.stringify</code> 将参数转换为键时，存在一些类型限制。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 定义一个接收函数作为参数的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcWithFuncParam</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">// 执行传入的回调函数并返回结果</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>();
}
<span class="hljs-comment">// 将 funcWithFuncParam 转换为具有缓存功能的函数</span>
<span class="hljs-keyword">const</span> memoizedFunc = <span class="hljs-title function_">memoize</span>(funcWithFuncParam);
<span class="hljs-comment">// 定义一个回调函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">10</span>;
<span class="hljs-comment">// 将包含回调函数的参数数组转换为字符串作为键</span>
<span class="hljs-keyword">const</span> key1 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([callback]); 
<span class="hljs-comment">// 输出结果为 [null]，说明 JSON.stringify 忽略了函数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key1); 
<span class="hljs-comment">// 定义一个 Symbol 类型的参数</span>
<span class="hljs-keyword">const</span> symbolParam = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>);
<span class="hljs-comment">// 将包含 Symbol 类型参数的数组转换为字符串作为键</span>
<span class="hljs-keyword">const</span> key2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([symbolParam]); 
<span class="hljs-comment">// 输出结果为 [null]，说明 JSON.stringify 忽略了 Symbol</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key2); 
</code></pre><p>对于包含函数、<code>Symbol</code> 等特殊类型的复杂对象参数，需要自定义生成唯一键的方式，比如使用 <code>WeakMap</code> 结合其他逻辑来处理函数，或者为 <code>Symbol</code> 类型参数添加额外的标识信息。</p>
<ul>
<li><strong>缓存大小控制</strong>：如果缓存不断增长，可能会导致内存占用过高。可以考虑实现缓存淘汰策略，如最近最少使用（LRU）算法。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 定义 LRUCache 类，实现最近最少使用的缓存策略</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {
    <span class="hljs-comment">// 构造函数，接收缓存容量作为参数</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">capacity</span>) {
        <span class="hljs-comment">// 存储缓存容量</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;
        <span class="hljs-comment">// 使用 Map 对象来存储缓存</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    }

    <span class="hljs-comment">// 获取缓存中指定键的值</span>
    <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
        <span class="hljs-comment">// 检查缓存中是否存在该键</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-comment">// 若存在，获取该键对应的值</span>
            <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);
            <span class="hljs-comment">// 先删除该键值对</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);
            <span class="hljs-comment">// 再重新插入该键值对，以更新其访问顺序</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);
            <span class="hljs-comment">// 返回该键对应的值</span>
            <span class="hljs-keyword">return</span> value;
        }
        <span class="hljs-comment">// 若不存在，返回 -1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// 向缓存中插入或更新键值对</span>
    <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) {
        <span class="hljs-comment">// 若缓存中已存在该键，先删除该键值对</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);
        } 
        <span class="hljs-comment">// 若缓存已满</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) {
            <span class="hljs-comment">// 删除最早访问的键值对</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);
        }
        <span class="hljs-comment">// 插入或更新键值对</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, value);
    }
}
</code></pre><p>在实现函数缓存时，可以将 <code>Map</code> 替换为 <code>LRUCache</code> 实例，以控制缓存的大小。</p>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">为什么要初始化 CSS 样式</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>消除浏览器默认样式差异（如 margin、padding），便于布局。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Rollup 支持哪些输出格式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Rollup 支持多种输出格式，包括amd（用于 AMD 模块系统）、cjs（CommonJS，用于 Node.js）、es（ES6 模块）、iife（立即执行函数表达式，用于浏览器）、umd（通用模块定义，可在多种环境使用）</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTML5 中的WebSocket是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>基于TCP的全双工通信协议</li>
<li>服务器可以主动推送数据</li>
<li>建立在HTTP协议之上</li>
<li>使用ws://或wss://作为协议前缀</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>持久连接</li>
<li>全双工通信</li>
<li>数据格式轻量</li>
<li>更好的实时性</li>
</ul>
</li>
<li><p><strong>1：</strong> 与HTTP的区别：</p>
<ul>
<li>不需要频繁建立连接</li>
<li>服务器可以主动推送</li>
<li>更低的通信开销</li>
<li>无同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 应用场景：</p>
<ul>
<li>实时聊天</li>
<li>游戏通信</li>
<li>实时数据展示</li>
<li>协同编辑</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">png、jpg、gif、webp这些图片格式的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标和存在透明背景的图</p>
<p>jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片</p>
<p>gif：一般是做动图</p>
<p>webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好</p>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-11T10:06:57.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W2</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W4</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CTDjqzeX\",\"ing.md\":\"CH0HdY0B\",\"readme.md\":\"DnZL1-VP\",\"src_guide_getting-started.md\":\"CJ0J_CtP\",\"src_guide_why.md\":\"CbRX8aDm\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DgcZUKDE\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"C-6y2qIx\",\"src_questions_computer-base_1_计算机硬件.md\":\"DlDomtZl\",\"src_questions_computer-base_2_计算机软件.md\":\"BLqZyJ7K\",\"src_questions_computer-base_3_计算机网络.md\":\"BRWkc7dO\",\"src_questions_computer-base_4_计算机编程.md\":\"CE0AEDMb\",\"src_questions_computer-base_5_计算机科学.md\":\"BIPGThwM\",\"src_questions_computer-base_6_软件工程.md\":\"LfItVMhz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"CfCMI_51\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CT5dgkcF\",\"src_questions_data-structures-algorithms_1_算法.md\":\"C5OQ6B1C\",\"src_questions_front-architect_1_前端架构.md\":\"nlJ-6Zmq\",\"src_questions_front-base_1_html.md\":\"lN9bZGUZ\",\"src_questions_front-base_2_css.md\":\"BkAEUReq\",\"src_questions_front-base_3_javascript.md\":\"ORAxtGxP\",\"src_questions_front-base_4_typescript.md\":\"DUcY6JJd\",\"src_questions_front-component_1_ui组件库.md\":\"Cw6Ub8xE\",\"src_questions_front-component_2_业务组件库.md\":\"CPFt5D9o\",\"src_questions_front-engineering_1_前端标准化.md\":\"_IjVLQDC\",\"src_questions_front-engineering_2_前端自动化.md\":\"CCkdHCll\",\"src_questions_front-engineering_3_webpack.md\":\"DxYcK11n\",\"src_questions_front-engineering_4_vite.md\":\"C3jG4P_f\",\"src_questions_front-engineering_5_rollup.md\":\"aqF6ocmE\",\"src_questions_front-frame_1_react.md\":\"CgoS3dDk\",\"src_questions_front-frame_2_vue.md\":\"CMsYTgMa\",\"src_questions_front-frame_3_next.md\":\"B-QiY-J7\",\"src_questions_front-frame_4_nuxt.md\":\"rwjDYcf7\",\"src_questions_front-frame_5_qiankun.md\":\"CjSY80ey\",\"src_questions_front-newest_1_前端最前沿.md\":\"Be5yzuEA\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"CNZTYAVc\",\"src_questions_front-runtime_1_浏览器.md\":\"CV_H3dXA\",\"src_questions_front-runtime_2_nodejs.md\":\"y4RBr4Hw\",\"src_questions_front-safety_1_前端安全.md\":\"DRc-ceK8\",\"src_questions_server_1_nest.md\":\"DMoVbT6x\",\"src_questions_server_2_mongodb.md\":\"BONv2NLt\",\"src_questions_server_3_mysql.md\":\"D5_KVqET\",\"src_questions_server_4_nginx.md\":\"rmjcinpv\",\"src_questions_server_5_docker.md\":\"DbBYBc0a\",\"src_questions_server_6_kubernets.md\":\"B_ZSjKij\",\"src_questions_server_7_nacos.md\":\"CHU7ic1v\",\"src_questions_server_8_redis.md\":\"CQEQv895\",\"src_training_training-level_w1.md\":\"CTGYARiY\",\"src_training_training-level_w2.md\":\"5zoripVU\",\"src_training_training-level_w3.md\":\"d5s5SNvX\",\"src_training_training-level_w4.md\":\"D4PoiEyU\",\"src_training_training-level_w5.md\":\"yBawm4Yy\",\"src_training_training-level_w6.md\":\"oM5ZqnVr\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>