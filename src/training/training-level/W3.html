<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.aWa-iuwY.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.H9aklZEq.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.DbFOcVcq.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W3.md.yOkoU3sC.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W3" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 如何访问DOM元素？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// Accessing the DOM element</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={myRef} /&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 对componentWillReceiveProps 的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>
<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>
<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">二分查找</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>
<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>
<li><strong>1：</strong> 时间复杂度： O(log n)。</li>
<li><strong>1：</strong> 思路：<ul>
<li>每次取中间元素与目标值比较。</li>
<li>若中间值大于目标值，目标值一定在左半部分。</li>
<li>若中间值小于目标值，目标值一定在右半部分。</li>
<li>重复上述步骤直到找到目标值或数组为空。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. 如何不使用脚手架创建一个项目</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ol>
<li><p>yarn init 初始化package.json文件</p>
</li>
<li><p>安装react和react-dom</p>
</li>
<li><p>配置webpack</p>
</li>
<li><p>安装router</p>
</li>
<li><p>安装redux</p>
</li>
</ol>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. 什么是状态管理器？你使用或了解哪些状态管理器？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。
状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。
除了 React Context，Redux 或 MobX 也常用作状态管理库。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. 如何用 React构建（ build）生产模式？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. React为什么要校验Prop？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。</p>
<p>数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。</p>
<p>组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。</p>
<p>提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。</p>
<p>调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Component, Element, Instance 之间有什么区别和联系？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p>
</li>
<li><p>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p>
</li>
<li><p>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
</li>
</ul>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. Vue 3 中的 toRef 和 toRefs 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>toRef：将对象的某个属性转换为 ref。</p>
<p>toRefs：将整个响应式对象的所有属性转换为 ref。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { reactive, toRef, toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> });
    <span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 单个属性</span>
    <span class="hljs-keyword">const</span> stateRefs = <span class="hljs-title function_">toRefs</span>(state); <span class="hljs-comment">// 所有属性</span>

    <span class="hljs-keyword">return</span> { nameRef, stateRefs };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是二叉搜索树（BST）</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查
找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>
<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. Vue 3 中的 provide 和 inject 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>provide 和 inject 用于跨层级组件通信。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { provide, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>);
    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;message&#x27;</span>, message); <span class="hljs-comment">// 提供数据</span>
  }
};

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;message&#x27;</span>); <span class="hljs-comment">// 注入数据</span>
    <span class="hljs-keyword">return</span> { message };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">iframe 风险</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 说一下 Vue 的 computed 的实现原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。</p>
<p>它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。</p>
<p>收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty</p>
<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>
<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。</p>
<p>如果 dirty 为 false，则直接返回 watcher 的 value</p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher</p>
<p>当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算</p>
<p>而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 中的 define 配置项有什么作用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> define 配置项用于在编译时定义全局常量。它可以让你在代码中使用这些常量，并且在打包时会将这些常量替换为实际的值。这在处理一些环境特定的配置或常量时非常有用。
例如，在 vite.config.js 中：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">define</span>: {
    <span class="hljs-attr">__APP_VERSION__</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;1.0.0&#x27;</span>),
    <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;development&#x27;</span>)
  }
});

<span class="hljs-comment">//在代码中就可以使用这些定义的常量：</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__APP_VERSION__);
<span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前是开发环境&#x27;</span>);
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Webpack 如何实现代码分割？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<p>在 Webpack 中，实现代码分割有以下几种方式：</p>
<ul>
<li><strong>1：</strong> 多入口配置：在 entry 中配置多个入口，Webpack 会为每个入口生成一个独立的打包文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;./src/about.js&#x27;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  }
};
</code></pre><ul>
<li><strong>1：</strong> 动态导入（Dynamic Import）：使用 ES6 的动态导入语法（import()）实现按需加载。Webpack 会自动将动态导入的模块分割成单独的文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 在代码中使用动态导入</span>
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
});
</code></pre><ul>
<li><strong>1：</strong> SplitChunksPlugin：Webpack 内置的插件，用于分割公共代码和第三方库，减少重复打包。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. 如何判断一个元素是否在可视区域内？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：用途</strong></li>
</ul>
<p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p>
<p><img src="/public/images/3_JavaScript_20241230001543.png" alt=""></p>
<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p>
<blockquote>
<ul>
<li>图片的懒加载</li>
<li>列表的无限滚动</li>
<li>计算广告元素的曝光情况</li>
<li>可点击链接的预加载</li>
</ul>
</blockquote>
<ul>
<li><strong>实现方式: 3</strong></li>
</ul>
<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p>
<p><img src="/public/images/3_JavaScript_20241230001827.png" alt=""></p>
<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>
<ul>
<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li>
<li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li>
</ul>
<p>这里可以看到<code>client</code>元素都不包括外边距</p>
<p>最后，关于<code>scroll</code>系列的属性如下：</p>
<ul>
<li><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p>
</li>
<li><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p>
</li>
<li><p>垂直滚动 <code>scrollTop &gt; 0</code></p>
</li>
<li><p>水平滚动 <code>scrollLeft &gt; 0</code></p>
</li>
<li><p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p>
</li>
<li><p>上述属性都是只读的，每次访问都要重新开始</p>
</li>
</ul>
<p>下面再看看如何实现判断：</p>
<p>公式如下：</p>
<pre><code class="hljs language-js">el.<span class="hljs-property">offsetTop</span> - <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> &lt;= viewPortHeight
</code></pre><p>代码实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPortOfOne</span> (<span class="hljs-params">el</span>) {
    <span class="hljs-comment">// viewPortHeight 兼容所有浏览器写法</span>
    <span class="hljs-keyword">const</span> viewPortHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span> 
    <span class="hljs-keyword">const</span> offsetTop = el.<span class="hljs-property">offsetTop</span>
    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>
    <span class="hljs-keyword">const</span> top = offsetTop - scrollTop
    <span class="hljs-keyword">return</span> top &lt;= viewPortHeight
}
</code></pre><p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.target&#x27;</span>);
<span class="hljs-keyword">const</span> clientRect = target.<span class="hljs-title function_">getBoundingClientRect</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clientRect);

<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   bottom: 556.21875,</span>
<span class="hljs-comment">//   height: 393.59375,</span>
<span class="hljs-comment">//   left: 333,</span>
<span class="hljs-comment">//   right: 1017,</span>
<span class="hljs-comment">//   top: 162.625,</span>
<span class="hljs-comment">//   width: 684</span>
<span class="hljs-comment">// }</span>
</code></pre><p>属性对应的关系图如下所示：</p>
<p><img src="/public/images/3_JavaScript_20241230002050.png" alt=""></p>
<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>
<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>
<ul>
<li>top 大于等于 0</li>
<li>left 大于等于 0</li>
<li>bottom 小于等于视窗高度</li>
<li>right 小于等于视窗宽度</li>
</ul>
<p>实现代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;
  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;
  <span class="hljs-keyword">const</span> {
    top,
    right,
    bottom,
    left,
  } = element.<span class="hljs-title function_">getBoundingClientRect</span>();

  <span class="hljs-keyword">return</span> (
    top &gt;= <span class="hljs-number">0</span> &amp;&amp;
    left &gt;= <span class="hljs-number">0</span> &amp;&amp;
    right &lt;= viewWidth &amp;&amp;
    bottom &lt;= viewHeight
  );
}
</code></pre><p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 <code>getBoundingClientRect</code> 会好很多</p>
<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> options = {
  <span class="hljs-comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span>
  <span class="hljs-comment">// 1 表示完全被包含</span>
  <span class="hljs-attr">threshold</span>: <span class="hljs-number">1.0</span>, 
  <span class="hljs-attr">root</span>:<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#scrollArea&#x27;</span>) <span class="hljs-comment">// 必须是目标元素的父级元素</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">entries, observer</span>) =&gt; { ....}

<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, options);
</code></pre><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>
<p>关于<code>callback</code>回调函数常用属性如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 上段代码中被省略的 callback</span>
<span class="hljs-keyword">const</span> callback = <span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) { 
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
        entry.<span class="hljs-property">time</span>;               <span class="hljs-comment">// 触发的时间</span>
        entry.<span class="hljs-property">rootBounds</span>;         <span class="hljs-comment">// 根元素的位置矩形，这种情况下为视窗位置</span>
        entry.<span class="hljs-property">boundingClientRect</span>; <span class="hljs-comment">// 被观察者的位置举行</span>
        entry.<span class="hljs-property">intersectionRect</span>;   <span class="hljs-comment">// 重叠区域的位置矩形</span>
        entry.<span class="hljs-property">intersectionRatio</span>;  <span class="hljs-comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span>
        entry.<span class="hljs-property">target</span>;             <span class="hljs-comment">// 被观察者</span>
    });
};
</code></pre><p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.target&#x27;</span>);
observer.<span class="hljs-title function_">observe</span>(target);
</code></pre><p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>
<p><code>Html</code>结构如下：</p>
<pre><code class="hljs language-js">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/div&gt;
</code></pre><p><code>css</code>样式如下：</p>
<pre><code class="hljs language-css">.<span class="hljs-property">container</span> {
    <span class="hljs-attr">display</span>: flex;
    flex-<span class="hljs-attr">wrap</span>: wrap;
}
.<span class="hljs-property">target</span> {
    <span class="hljs-attr">margin</span>: 5px;
    <span class="hljs-attr">width</span>: 20px;
    <span class="hljs-attr">height</span>: 20px;
    <span class="hljs-attr">background</span>: red;
}
</code></pre><p>往<code>container</code>插入1000个元素</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> $container = $(<span class="hljs-string">&quot;.container&quot;</span>);

<span class="hljs-comment">// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createTargets</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> htmlString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)
    .<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;</span>)
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);
  $container.<span class="hljs-title function_">html</span>(htmlString);
}
</code></pre><p>这里，首先使用 <code>getBoundingClientRect</code> 方法进行判断元素是否在可视区域</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) {
    <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;
    <span class="hljs-keyword">const</span> viewHeight =
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;
    <span class="hljs-keyword">const</span> { top, right, bottom, left } = element.<span class="hljs-title function_">getBoundingClientRect</span>();

    <span class="hljs-keyword">return</span> top &gt;= <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;
}
</code></pre><p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>
<pre><code class="hljs language-js">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scroll !&quot;</span>);
    $targets.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, element</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInViewPort</span>(element)) {
            $(element).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>);
        }
    });
});
</code></pre><p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>
<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>
<p>首先创建一个观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(getYellow, { <span class="hljs-attr">threshold</span>: <span class="hljs-number">1.0</span> });
</code></pre><p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getYellow</span>(<span class="hljs-params">entries, observer</span>) {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
        $(entry.<span class="hljs-property">target</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>);
    });
}
</code></pre><p>最后传入观察者，即<code>.target</code>元素</p>
<pre><code class="hljs language-js">$targets.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, element</span>) =&gt;</span> {
    observer.<span class="hljs-title function_">observe</span>(element);
});
</code></pre><p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何处理子应用之间的公共依赖？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配
置 props 等方式将主应用中的公共依赖传递给子应用使用。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTML5 中的WebSocket是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>基于TCP的全双工通信协议</li>
<li>服务器可以主动推送数据</li>
<li>建立在HTTP协议之上</li>
<li>使用ws://或wss://作为协议前缀</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>持久连接</li>
<li>全双工通信</li>
<li>数据格式轻量</li>
<li>更好的实时性</li>
</ul>
</li>
<li><p><strong>1：</strong> 与HTTP的区别：</p>
<ul>
<li>不需要频繁建立连接</li>
<li>服务器可以主动推送</li>
<li>更低的通信开销</li>
<li>无同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 应用场景：</p>
<ul>
<li>实时聊天</li>
<li>游戏通信</li>
<li>实时数据展示</li>
<li>协同编辑</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">基础配置</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<pre><code class="hljs language-conf"># <span class="hljs-title class_">Nginx</span> 启动时创建的 worker 进程的数量
worker_processes  <span class="hljs-number">1</span>;

# 配置 <span class="hljs-title class_">Nginx</span> 主进程的 <span class="hljs-variable constant_">PID</span> 文件路径
#pid        logs/nginx.<span class="hljs-property">pid</span>;

events {
    # 指定每个 worker 进程可以同时处理的最大连接数
    worker_connections  <span class="hljs-number">1024</span>;
}

http {
    include       mime.<span class="hljs-property">types</span>;
    default_type  application/octet-stream;

    # 提高文件传输的效率，特别是对于大文件来说
    sendfile        on;
    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率
    tcp_nopush     on;

    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间
    # 在这里，连接在 <span class="hljs-number">65</span> 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度
    keepalive_timeout  <span class="hljs-number">65</span>;

    # 启用 <span class="hljs-variable constant_">HTTP</span> 响应的压缩功能，以减少传输的数据量，提高网络传输效率
    gzip  on;

    server {
        # 端口
        listen       <span class="hljs-number">8099</span>;
        server_name  localhost;
        
        location / {
            root html-vue;
            # hash 路由的重定向
            try_files $uri $uri/ /index.<span class="hljs-property">html</span>;
            index index.<span class="hljs-property">html</span>;
            # 跨域
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;
            # 允许跨域请求的方法包括 <span class="hljs-variable constant_">GET</span>、<span class="hljs-variable constant_">POST</span> 和 <span class="hljs-variable constant_">OPTIONS</span>
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;
            # 允许跨域请求携带的自定义请求头
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;
            
            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过
            <span class="hljs-keyword">if</span> ($request_filename ~* ^.*?.(html|htm|js)$) {
              add_header <span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span> no-cache;
            }
        }

        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理 - 作用是不在 vue 项目中写死 ip
        # 这样配置后，再也不用给前端里面写固定的 ip
        location /data {
            # 删除 url 中的 /data 但是目前貌似不生效
            # rewrite ^<span class="hljs-regexp">/data/</span>(.*)$ /$1 <span class="hljs-keyword">break</span>;
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }

    # 基础访问
    server {
        listen       <span class="hljs-number">80</span>;
        server_name  localhost;

        location / {
            root   html;
            index  index.<span class="hljs-property">html</span> index.<span class="hljs-property">htm</span>;
        }
        # 错误页面
        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理
        location /data {
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }
}
</code></pre></details></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 使用 Mobx 的特点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">指令集（Instruction Set）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. TCP的重传机制</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。</p>
<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. 解释 React 中 render() 的目的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. React 中的 Hook 是什么？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: W1</div><details class="inner-content"><ul>
<li><strong>1：</strong> useState()：用于在函数组件中添加状态。</li>
<li><strong>1：</strong> useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。</li>
<li><strong>1：</strong> useContext()：用于在函数组件中访问上下文（Context）。</li>
<li><strong>1：</strong> useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。</li>
<li><strong>1：</strong> useRef()：用于访问组件中的 DOM 节点或保存可变的值。</li>
<li><strong>1：</strong> useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. ref与reactive的区别？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li>
<li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li>
<li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li>
<li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li>
<li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li>
<li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 深浅拷贝的区别？如何实现一个深拷贝？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>深浅拷贝通常只针对引用类型</p>
</li>
<li><p>浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针</p>
</li>
<li><p>深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
          newObj[key]=obj[key]
        }
      }
      <span class="hljs-keyword">return</span>  newObj
} 
<span class="hljs-comment">// 咱们会浅拷贝当然还要深拷贝呀  开始</span>
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
        <span class="hljs-keyword">if</span>  ( <span class="hljs-title function_">typeof</span>(obj[key])!==obj||obj[key]===<span class="hljs-literal">null</span>){
           newObj[key]=obj[key]
        }<span class="hljs-keyword">else</span>{
           newObj[key]=<span class="hljs-title function_">shallowCopy</span>(obj[key])
        }  
        }
      }
      <span class="hljs-keyword">return</span>  newObj
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. js 中const真的不能修改吗？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 作用域链的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。</p>
<details>

<ul>
<li><strong>1：</strong> 数据类型</li>
</ul>
<pre><code class="hljs language-mermaid">graph <span class="hljs-variable constant_">TD</span>;

    A[作用域链] --&gt; B[作用域];
    A --&gt; C[词法作用域];
    A --&gt; D[作用域链];
</code></pre><ul>
<li><strong>1：</strong> 作用域</li>
</ul>
<p>作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。
例如：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-title function_">greet</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<span class="hljs-comment">// Uncaught ReferenceError: greeting is not defined</span>
</code></pre><ul>
<li><strong>1：</strong> 全局作用域</li>
</ul>
<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 全局变量</span>
<span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
</code></pre><ul>
<li><strong>1：</strong> 函数作用域</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 块级作用域</li>
</ul>
<p>ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</p>
<pre><code class="hljs language-js">{
  <span class="hljs-comment">// 块级作用域中的变量</span>
  <span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-keyword">var</span> lang = <span class="hljs-string">&#x27;English&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// Prints &#x27;Hello World!&#x27;</span>
}
<span class="hljs-comment">// 变量 &#x27;English&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lang);
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 词法作用域</li>
</ul>
<p>词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">foo</span>();
}
<span class="hljs-title function_">bar</span>();
</code></pre><ul>
<li><strong>1：</strong> 作用域链</li>
</ul>
<p>在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>
<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> sex = <span class="hljs-string">&#x27;男&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">student</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 张三</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sex); <span class="hljs-comment">// 男</span>
    }
    <span class="hljs-title function_">student</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span>
}
<span class="hljs-title function_">person</span>();

<span class="hljs-comment">/*
student 函数内部：
当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。
当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。

person 函数内部：
当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。

*/</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 为什么说React中的props是只读的？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. HTTP 常用的状态码及使用场景？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>1xx：表示目前是协议的中间状态，还需要后续请求</p>
</li>
<li><p>2xx：表示请求成功</p>
</li>
<li><p>3xx：表示重定向状态，需要重新请求</p>
</li>
<li><p>4xx：表示请求报文错误</p>
</li>
<li><p>5xx：服务器端错误</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. Vue 3 的主要新特性是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Composition API：提供更灵活的代码组织方式。</p>
<p>性能优化：使用 Proxy 实现响应式，性能更好。</p>
<p>Tree-shaking：支持按需引入，减小打包体积。</p>
<p>TypeScript 支持：对 TypeScript 的支持更好。</p>
<p>Fragment、Teleport、Suspense：新增内置组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">进程和线程的区别?</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>. 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p>. 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。</p>
</li>
<li><p>进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。</p>
</li>
<li><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是重绘和回流及怎么减少重绘和回流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。</p>
</li>
<li><p>回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是PWA？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>
</ul>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-05T11:30:20.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W2</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W4</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CL7-4TFT\",\"ing.md\":\"DQZRn9c2\",\"readme.md\":\"qmLYs93R\",\"src_guide_getting-started.md\":\"Yh0nrujY\",\"src_guide_why.md\":\"DpfsseqL\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DzEnUFHR\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"88MPxhXX\",\"src_questions_computer-base_1_计算机硬件.md\":\"7ccW9q5h\",\"src_questions_computer-base_2_计算机软件.md\":\"kqoHHdIR\",\"src_questions_computer-base_3_计算机网络.md\":\"CZHghAhn\",\"src_questions_computer-base_4_计算机编程.md\":\"clZTLBk4\",\"src_questions_computer-base_5_计算机科学.md\":\"CVPq3rrh\",\"src_questions_computer-base_6_软件工程.md\":\"Bvrd6ZRz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BL_pxDB_\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CrkFqMQn\",\"src_questions_data-structures-algorithms_1_算法.md\":\"VZa60Ttb\",\"src_questions_front-architect_1_前端架构.md\":\"CHk6hNKq\",\"src_questions_front-base_1_html.md\":\"LhOHQo-Z\",\"src_questions_front-base_2_css.md\":\"RC4KrvHY\",\"src_questions_front-base_3_javascript.md\":\"D03C_TSG\",\"src_questions_front-base_4_typescript.md\":\"B8uxclxS\",\"src_questions_front-component_1_ui组件库.md\":\"lt0ACG8O\",\"src_questions_front-component_2_业务组件库.md\":\"Bs3mq_bU\",\"src_questions_front-engineering_1_前端标准化.md\":\"qitpZqFe\",\"src_questions_front-engineering_2_前端自动化.md\":\"BGsi-r5X\",\"src_questions_front-engineering_3_webpack.md\":\"Ch83H4YJ\",\"src_questions_front-engineering_4_vite.md\":\"BJ3BkeEu\",\"src_questions_front-engineering_5_rollup.md\":\"B8wxVUs0\",\"src_questions_front-frame_1_react.md\":\"1EkQ7uYB\",\"src_questions_front-frame_2_vue.md\":\"BNfv15bK\",\"src_questions_front-frame_3_next.md\":\"BzUWEHzp\",\"src_questions_front-frame_4_nuxt.md\":\"C_8jdgao\",\"src_questions_front-frame_5_qiankun.md\":\"DUPovSFq\",\"src_questions_front-newest_1_前端最前沿.md\":\"C2JP8MIB\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"CXC-w0X2\",\"src_questions_front-runtime_1_浏览器.md\":\"DUf_llrY\",\"src_questions_front-runtime_2_nodejs.md\":\"BXrQZH4z\",\"src_questions_front-safety_1_前端安全.md\":\"DOUx70sC\",\"src_questions_server_1_nest.md\":\"CuyN3kZX\",\"src_questions_server_2_mongodb.md\":\"RqRu2CFC\",\"src_questions_server_3_mysql.md\":\"C7acOSCu\",\"src_questions_server_4_nginx.md\":\"Bkv5YNp-\",\"src_questions_server_5_docker.md\":\"Bl-g4oOg\",\"src_questions_server_6_kubernets.md\":\"Ddc4cHor\",\"src_questions_server_7_nacos.md\":\"i_lK1_82\",\"src_questions_server_8_redis.md\":\"BL4MhzUk\",\"src_training_training-level_w1.md\":\"C0rZslr-\",\"src_training_training-level_w2.md\":\"DT56PF_X\",\"src_training_training-level_w3.md\":\"yOkoU3sC\",\"src_training_training-level_w4.md\":\"jMqQTVrp\",\"src_training_training-level_w5.md\":\"DjEgqvTt\",\"src_training_training-level_w6.md\":\"W-tO-1if\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>