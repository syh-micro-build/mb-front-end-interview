<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.D1YhdFhH.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DGuxiWsN.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.CwYRharI.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W3.md.DPAKgxx6.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W3" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">PWA有那些优点？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>
<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>
<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>
<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>
<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>
<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>
<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>
<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>
<li><strong>1：</strong> 绕过应用商店</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 创建自定义钩子的规则是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>钩子名称以 &quot;use &quot;开头。</p>
</li>
<li><p>钩子只能从其他钩子或 React 元素中调用。</p>
</li>
<li><p>不要有条件地调用钩子。</p>
</li>
<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>
</li>
<li><p>自定义钩子必须是纯函数。</p>
</li>
<li><p>自定义钩子可以返回值或其他钩子。</p>
</li>
<li><p>以描述性的方式命名自定义钩子。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. 如何不使用脚手架创建一个项目</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ol>
<li><p>yarn init 初始化package.json文件</p>
</li>
<li><p>安装react和react-dom</p>
</li>
<li><p>配置webpack</p>
</li>
<li><p>安装router</p>
</li>
<li><p>安装redux</p>
</li>
</ol>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. React的Suspense组件和lazy函数是如何支持代码拆分的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>
</li>
<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>
</li>
<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>
</li>
<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. React.Component 和 React.PureComponent 的区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>区别：</p>
<p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：</p>
<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>
<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>
<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 解释 keyof typeof 的组合用法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> typeof 用于获取一个值的类型，keyof 用于获取一个类型的所有键组成的联合类型。keyof typeof 通常用于获取一个对象值的所有属性名组成的联合类型。示例：</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> colors = {
    <span class="hljs-attr">red</span>: <span class="hljs-string">&#x27;#FF0000&#x27;</span>,
    <span class="hljs-attr">green</span>: <span class="hljs-string">&#x27;#00FF00&#x27;</span>,
    <span class="hljs-attr">blue</span>: <span class="hljs-string">&#x27;#0000FF&#x27;</span>
};
type <span class="hljs-title class_">ColorKeys</span> = keyof <span class="hljs-keyword">typeof</span> colors; 
<span class="hljs-comment">// ColorKeys 类型为 &#x27;red&#x27; | &#x27;green&#x27; | &#x27;blue&#x27;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. DNS同时使用TCP和UDP协议？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>DNS占用53号端口，同时使用TCP和UDP协议</p>
<ul>
<li>在区域传输的时候使用TCP协议</li>
</ul>
<p>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p>
<p>TCP是一种可靠连接，保证了数据的准确性。</p>
<ul>
<li>在域名解析的时候使用UDP协议</li>
</ul>
<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. 什么是 mixin？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">GET和POST有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>
<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>
<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>
<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>
<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>
<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Webpack 如何实现代码分割？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<p>在 Webpack 中，实现代码分割有以下几种方式：</p>
<ul>
<li><strong>1：</strong> 多入口配置：在 entry 中配置多个入口，Webpack 会为每个入口生成一个独立的打包文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;./src/about.js&#x27;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  }
};
</code></pre><ul>
<li><strong>1：</strong> 动态导入（Dynamic Import）：使用 ES6 的动态导入语法（import()）实现按需加载。Webpack 会自动将动态导入的模块分割成单独的文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 在代码中使用动态导入</span>
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
});
</code></pre><ul>
<li><strong>1：</strong> SplitChunksPlugin：Webpack 内置的插件，用于分割公共代码和第三方库，减少重复打包。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何处理 CSS 模块？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. webpack代理怎么配置？proxy中常用的属性是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 配置如下：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),
    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&quot;/api&quot;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-comment">// </span>
      },
    },
    <span class="hljs-comment">// ...</span>
  },
};
</code></pre><ul>
<li><strong>2：</strong> 常用属性：</li>
</ul>
<blockquote>
<p>target：表示的是代理到的目标地址<br>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite<br>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false<br>changeOrigin：它表示是否更新代理后请求的 headers 中host地址  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。</p>
<p>区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：</p>
<ul>
<li><p>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border</p>
</li>
<li><p>设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效</p>
</li>
<li><p>用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效</p>
</li>
<li><p>设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. 什么是 useEffect？它如何工作？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。</p>
</li>
<li><p>工作原理：</p>
</li>
<li><p>执行副作用：在组件挂载和更新时执行副作用操作。</p>
</li>
<li><p>清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。</p>
</li>
</ul>
<pre><code class="hljs language-JSX"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">DataFetcher</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
      <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
      <span class="hljs-title function_">setData</span>(json);
    };

    <span class="hljs-title function_">fetchData</span>();

    <span class="hljs-comment">// 清理函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Cleanup&#x27;</span>);
    };
  }, []); <span class="hljs-comment">// 依赖数组为空，表示仅在组件挂载时执行</span>

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}
    &lt;/div&gt;
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetcher</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">画一条0.5px的线</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2:</strong> 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：</li>
</ul>
<pre><code class="hljs language-css"><span class="hljs-attr">transform</span>: <span class="hljs-title function_">scale</span>(<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>);
</code></pre><ul>
<li><strong>2:</strong> 采用meta viewport的方式</li>
</ul>
<pre><code class="hljs language-html">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;</span>/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何实现样式隔离？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Shadow DOM：Qiankun 内部可以利用 Shadow DOM 的特性，将子应用的 DOM 结构和样式封装在一个独立的作用域中，使其样式不会影响到外部主应用和其他子应用。</li>
<li><strong>1：</strong> CSS 前缀：给子应用的所有 CSS 类名添加特定的前缀，避免类名冲突，从而实现样式隔离。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何实现子应用的加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加
载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Ajax Fetch Axios的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise</p>
</li>
<li><p>Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现</p>
</li>
<li><p>Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释数据库事务的 ACID 特性</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>
<li><strong>1：</strong> 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改
时，事务要确保这个一致性始终成立。</li>
<li><strong>1：</strong> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之
间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。</li>
<li><strong>1：</strong> 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订
单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. React中有使用过getDefaultProps吗？它有什么作用？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> <span class="hljs-title class_">ShowTitle</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">getDefaultProps</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span>{
      title : <span class="hljs-string">&quot;React&quot;</span>
    }
  },
  render : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> &lt;h1&gt;{this.props.title}&lt;/h1&gt;
  }
});
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 定义一个泛型函数 `add&lt;T&gt;(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add&lt;number&gt;(1, 2)`返回值类型是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">回流重绘</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 中级</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 回流：浏览器渲染页面之前需要对结构进行布局计算</p>
</li>
<li><p><strong>1：</strong> 重绘：将已经计算好布局的容器绘制出来</p>
</li>
<li><p><strong>1：</strong> 触发回流：页面上有容器的几何属性发生变更</p>
</li>
<li><p><strong>1：</strong> 触发重绘：容器非几何属性变更 （字体，颜色）</p>
</li>
<li><p><strong>1：</strong> 回流必定重绘，重绘不一定回流</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. react无状态组件和class类组件的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>直观区别，函数组件代码量较少，相比类组件更加简洁</p>
</li>
<li><p>函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑</p>
</li>
<li><p>因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Rollup 中，如何实现对 TypeScript 代码的打包？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 可以使用rollup-plugin-typescript2插件。首先确保项目安装了typescript和rollup-plugin-typescript2，然后在 Rollup 配置文件中配置：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> typescript <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rollup-plugin-typescript2&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;input.ts&#x27;</span>,
    <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">file</span>: <span class="hljs-string">&#x27;output.js&#x27;</span>,
        <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;iife&#x27;</span>
    },
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-title function_">typescript</span>()
    ]
};
<span class="hljs-comment">//该插件会将 TypeScript 代码编译为 JavaScript 代码，并进行打包。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong><ul>
<li>flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：</li>
<li>display: flex：将容器设置为弹性容器。</li>
<li>flex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。</li>
<li>justify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。</li>
<li>align-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何进行前端资源加载优化</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 中级</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 延迟加载非关键资源，如图片、视频等，提高页面加载速度。</li>
<li><strong>1：</strong> 使用懒加载技术，按需加载页面内容，减少首次加载时间。</li>
<li><strong>1：</strong> 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。</li>
<li><strong>1：</strong> 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. 如何在组件中重复使用Vuex的mutation</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>使用mapMutations辅助函数,在组件中这么使用</p>
<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { mapMutations } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>
<span class="hljs-attr">methods</span>:{
    ...<span class="hljs-title function_">mapMutations</span>({
        <span class="hljs-attr">setNumber</span>:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,
    })
}
</code></pre><p>然后调用this.setNumber(10)相当调用this.$store.commit(&#39;SET_NUMBER&#39;,10)</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19.你如何在Node.js中使用中间件来组织代码？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：</p>
</li>
<li><p>定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。</p>
</li>
<li><p>使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。</p>
</li>
<li><p>使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。</p>
</li>
<li><p>在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. Vue 3 中的 Teleport 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Teleport 用于将组件渲染到指定 DOM 节点。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &lt;div&gt;Modal&lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是静态网页？什么是动态网页？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTTP2相对于HTTP1.x有什么优势和特点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。</li>
<li>HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。</li>
<li>HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。</li>
<li>HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。</li>
<li>HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。</li>
</ul>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-03T10:18:53.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W2</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W4</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"IoeEMIuF\",\"ing.md\":\"DTrBR9yg\",\"readme.md\":\"D5n-KkNJ\",\"src_guide_getting-started.md\":\"ChtL3Mtx\",\"src_guide_why.md\":\"DZl37MYP\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"Ba3sY47u\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Dar2eeCi\",\"src_questions_computer-base_1_计算机硬件.md\":\"yWllFOGD\",\"src_questions_computer-base_2_计算机软件.md\":\"DD__xmtU\",\"src_questions_computer-base_3_计算机网络.md\":\"BEwQL-kq\",\"src_questions_computer-base_4_计算机编程.md\":\"B9LXSO_W\",\"src_questions_computer-base_5_计算机科学.md\":\"DV8OyJcU\",\"src_questions_computer-base_6_软件工程.md\":\"Dq38go82\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"VZbBUPTc\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"2WqTLKdf\",\"src_questions_data-structures-algorithms_1_算法.md\":\"C2cLfWsV\",\"src_questions_front-architect_1_前端架构.md\":\"BXhL-Puj\",\"src_questions_front-base_1_html.md\":\"BkJU9mox\",\"src_questions_front-base_2_css.md\":\"jTva325d\",\"src_questions_front-base_3_javascript.md\":\"Dbt06Hfe\",\"src_questions_front-base_4_typescript.md\":\"CFgEQYHZ\",\"src_questions_front-component_1_ui组件库.md\":\"BzBvi87z\",\"src_questions_front-component_2_业务组件库.md\":\"CgK5NWa1\",\"src_questions_front-engineering_1_前端标准化.md\":\"C5ZOSvmA\",\"src_questions_front-engineering_2_前端自动化.md\":\"HhmKP52V\",\"src_questions_front-engineering_3_webpack.md\":\"C3VoK4yQ\",\"src_questions_front-engineering_4_vite.md\":\"DnAlxCUt\",\"src_questions_front-engineering_5_rollup.md\":\"DCp1Pxrt\",\"src_questions_front-frame_1_react.md\":\"C13aIPJH\",\"src_questions_front-frame_2_vue.md\":\"CKXCSiZK\",\"src_questions_front-frame_3_next.md\":\"CNtIvVdT\",\"src_questions_front-frame_4_nuxt.md\":\"BYOTYEZq\",\"src_questions_front-frame_5_qiankun.md\":\"DC2_5_sx\",\"src_questions_front-newest_1_前端最前沿.md\":\"DydqOcE1\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DP1tcX-H\",\"src_questions_front-runtime_1_浏览器.md\":\"Iba9Dq5f\",\"src_questions_front-runtime_2_nodejs.md\":\"DKfb3aqy\",\"src_questions_front-safety_1_前端安全.md\":\"CkJgBd3y\",\"src_questions_server_1_nest.md\":\"C7Bpf_Nf\",\"src_questions_server_2_mongodb.md\":\"sjUsLbyN\",\"src_questions_server_3_mysql.md\":\"wp1a_B3f\",\"src_questions_server_4_nginx.md\":\"GlyPL6yP\",\"src_questions_server_5_docker.md\":\"6sFKIAhZ\",\"src_questions_server_6_kubernets.md\":\"BGqfcaaX\",\"src_questions_server_7_nacos.md\":\"BGmbNKcQ\",\"src_questions_server_8_redis.md\":\"Bj5LGfky\",\"src_training_training-level_w1.md\":\"Ct9B19gt\",\"src_training_training-level_w2.md\":\"Dctj8HX-\",\"src_training_training-level_w3.md\":\"DPAKgxx6\",\"src_training_training-level_w4.md\":\"BhmFk_3u\",\"src_training_training-level_w5.md\":\"Dxy_ldFk\",\"src_training_training-level_w6.md\":\"BNvC3aYq\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>