<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.Bm9z-6Qm.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.C0xOGa6x.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.8HCKRZmN.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W2.md.D78WBe6q.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W2" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. React的Suspense组件和lazy函数是如何支持代码拆分的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>
</li>
<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>
</li>
<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>
</li>
<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. react事件绑定方式有哪些</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>render方法中使用bind</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>render方法中使用箭头函数</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(e)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>constructor中bind</p>
<pre><code class="hljs language-html">
<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre><p>定义阶段使用箭头函数绑定</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. React如何做路由监听</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-react">
<span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">router</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>)=&gt;</span>{ <span class="hljs-keyword">if</span>(route.<span class="hljs-property">pathname</span>===<span class="hljs-string">&#x27;/xxx&#x27;</span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); } }); } 
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 为什么React并不推荐优先考虑使用Context？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</p>
<p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</p>
<p>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</p>
<p>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">75. shouldComponentUpdate有什么用？为什么它很重要？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。</p>
<p>和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">PWA有那些优点？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>
<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>
<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>
<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>
<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>
<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>
<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>
<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>
<li><strong>1：</strong> 绕过应用商店</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. React中setState的第二个参数作用是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">key1</span>: newState1,
    <span class="hljs-attr">key2</span>: newState2,
    ...
}, callback) <span class="hljs-comment">// 第二个参数是 state 更新完成后的回调函数</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Component, Element, Instance 之间有什么区别和联系？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p>
</li>
<li><p>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p>
</li>
<li><p>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
</li>
</ul>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）哪些方法会触发 react 重新渲染?</p>
<ul>
<li>setState（）方法被调用</li>
</ul>
<p>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</p>
<ul>
<li>父组件重新渲染</li>
</ul>
<p>只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。</p>
<p>（2）重新渲染 render 会做些什么?</p>
<ul>
<li><p>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</p>
</li>
<li><p>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</p>
</li>
<li><p>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. 什么是 Redux Thunk？它解决了什么问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。</p>
<p>解决问题：</p>
<p>异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。</p>
<p>复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data });
};

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));

store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. Redux和Mobx有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。</p>
</li>
<li><p>Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. React为什么要校验Prop？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。</p>
<p>数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。</p>
<p>组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。</p>
<p>提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。</p>
<p>调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 说说对高阶组件（HOC）的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p>
</li>
<li><p>接受一个或多个函数作为输入</p>
</li>
<li><p>输出一个函数</p>
</li>
<li><p>在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 如何访问DOM元素？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// Accessing the DOM element</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={myRef} /&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 使用Hooks要遵守哪些原则？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>
</li>
<li><p>只在 React 函数中调用 Hook</p>
</li>
</ul>
<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li><p>在 React 的函数组件中调用 Hook</p>
</li>
<li><p>在自定义 Hook 中调用其他 Hook</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是PWA？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Redux 实现了哪种模式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. React中有使用过getDefaultProps吗？它有什么作用？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> <span class="hljs-title class_">ShowTitle</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
  <span class="hljs-attr">getDefaultProps</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span>{
      title : <span class="hljs-string">&quot;React&quot;</span>
    }
  },
  render : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> &lt;h1&gt;{this.props.title}&lt;/h1&gt;
  }
});
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 什么是TypeScript？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 说一下 Vue SSR 的实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>
</li>
<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 HTML 中，如何创建一个无序列表和有序列表？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>创建无序列表使用<code>&lt;ul&gt;</code>标签，列表项使用<code>&lt;li&gt;</code>标签。</li>
<li>创建有序列表使用<code>&lt;ol&gt;</code>标签，同样列表项使用<code>&lt;li&gt;</code>标签。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 为什么this.xx可以访问data中的数据?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Vue在initData时，做了数据代理</p>
<ul>
<li><p>判断传入的data，函数就执行，对象不做处理</p>
</li>
<li><p>data 赋值给 vm._data</p>
</li>
<li><p>然后变量 vm._data对象，把可枚举属性的get代理到 vm上</p>
</li>
<li><p>访问vm.xxx 就相当于 vm._data.xx === vm.data.xx</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. Vue中怎么做全局错误监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>
<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Vue 3 中的 Suspense 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Suspense 用于处理异步组件的加载状态。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;AsyncComponent /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. React 中的单向数据流是什么意思？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。</p>
</li>
<li><p>数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。</p>
</li>
<li><p>易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。</p>
</li>
<li><p>可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 如何动态更新对象或数组的值？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. 什么是执行上下文和执行栈？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。</p>
</li>
<li><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是虚拟 DOM？它是如何工作的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>
</li>
<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>
</li>
<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>
</li>
<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是二叉搜索树（BST）</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查
找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 与传统的 Webpack 打包工具有何不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Webpack 如何实现代码分割？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<p>在 Webpack 中，实现代码分割有以下几种方式：</p>
<ul>
<li><strong>1：</strong> 多入口配置：在 entry 中配置多个入口，Webpack 会为每个入口生成一个独立的打包文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;./src/about.js&#x27;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  }
};
</code></pre><ul>
<li><strong>1：</strong> 动态导入（Dynamic Import）：使用 ES6 的动态导入语法（import()）实现按需加载。Webpack 会自动将动态导入的模块分割成单独的文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 在代码中使用动态导入</span>
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
});
</code></pre><ul>
<li><strong>1：</strong> SplitChunksPlugin：Webpack 内置的插件，用于分割公共代码和第三方库，减少重复打包。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 常用工具类型？</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> Partial：满足部分属性(一个都没满足也可)即可</li>
<li><strong>1：</strong> Required：所有属性都需要</li>
<li><strong>1：</strong> Readonly: 包装后的所有属性只读</li>
<li><strong>1：</strong> Pick: 选取部分属性</li>
<li><strong>1：</strong> Omit: 去除部分属性</li>
<li><strong>1：</strong> Extract: 交集</li>
<li><strong>1：</strong> Exclude: 差集</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件</li>
<li><strong>1：</strong> getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. Vue 3 中的 onRenderTracked 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>onRenderTracked 是调试钩子，用于跟踪渲染依赖。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { onRenderTracked } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">onRenderTracked</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跟踪到依赖:&#x27;</span>, event);
    });
  }
};

</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">谈谈你对盒模型的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 标准盒模型：<code>box-sizing: content-box;</code>，实际占用宽度 = width + padding + border</li>
<li><strong>1：</strong> 怪异盒模型：<code>box-sizing: border-box;</code>，实际占用宽度 = width（不会额外增加 padding 和 border）</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何实现子应用的加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加
载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">基础配置</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<pre><code class="hljs language-conf"># <span class="hljs-title class_">Nginx</span> 启动时创建的 worker 进程的数量
worker_processes  <span class="hljs-number">1</span>;

# 配置 <span class="hljs-title class_">Nginx</span> 主进程的 <span class="hljs-variable constant_">PID</span> 文件路径
#pid        logs/nginx.<span class="hljs-property">pid</span>;

events {
    # 指定每个 worker 进程可以同时处理的最大连接数
    worker_connections  <span class="hljs-number">1024</span>;
}

http {
    include       mime.<span class="hljs-property">types</span>;
    default_type  application/octet-stream;

    # 提高文件传输的效率，特别是对于大文件来说
    sendfile        on;
    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率
    tcp_nopush     on;

    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间
    # 在这里，连接在 <span class="hljs-number">65</span> 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度
    keepalive_timeout  <span class="hljs-number">65</span>;

    # 启用 <span class="hljs-variable constant_">HTTP</span> 响应的压缩功能，以减少传输的数据量，提高网络传输效率
    gzip  on;

    server {
        # 端口
        listen       <span class="hljs-number">8099</span>;
        server_name  localhost;
        
        location / {
            root html-vue;
            # hash 路由的重定向
            try_files $uri $uri/ /index.<span class="hljs-property">html</span>;
            index index.<span class="hljs-property">html</span>;
            # 跨域
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;
            # 允许跨域请求的方法包括 <span class="hljs-variable constant_">GET</span>、<span class="hljs-variable constant_">POST</span> 和 <span class="hljs-variable constant_">OPTIONS</span>
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;
            # 允许跨域请求携带的自定义请求头
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;
            
            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过
            <span class="hljs-keyword">if</span> ($request_filename ~* ^.*?.(html|htm|js)$) {
              add_header <span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span> no-cache;
            }
        }

        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理 - 作用是不在 vue 项目中写死 ip
        # 这样配置后，再也不用给前端里面写固定的 ip
        location /data {
            # 删除 url 中的 /data 但是目前貌似不生效
            # rewrite ^<span class="hljs-regexp">/data/</span>(.*)$ /$1 <span class="hljs-keyword">break</span>;
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }

    # 基础访问
    server {
        listen       <span class="hljs-number">80</span>;
        server_name  localhost;

        location / {
            root   html;
            index  index.<span class="hljs-property">html</span> index.<span class="hljs-property">htm</span>;
        }
        # 错误页面
        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理
        location /data {
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }
}
</code></pre></details></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. mixin和mixis区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。</p>
<p>mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。</p>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-06T06:13:52.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W1</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W3</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"G5wtZjGP\",\"ing.md\":\"B5hGbqnn\",\"readme.md\":\"OK8SeUiF\",\"src_guide_getting-started.md\":\"CrVxb2FN\",\"src_guide_why.md\":\"BqyA-_WT\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"Dxf_CA8-\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"BOs8wFDk\",\"src_questions_computer-base_1_计算机硬件.md\":\"CF-BemLA\",\"src_questions_computer-base_2_计算机软件.md\":\"8e3-OlWV\",\"src_questions_computer-base_3_计算机网络.md\":\"CSJI3vzR\",\"src_questions_computer-base_4_计算机编程.md\":\"DkbD8O4G\",\"src_questions_computer-base_5_计算机科学.md\":\"B-mYJqCC\",\"src_questions_computer-base_6_软件工程.md\":\"CYJQM_BM\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"H7WVaLvn\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CohAraP5\",\"src_questions_data-structures-algorithms_1_算法.md\":\"SmLu_pVS\",\"src_questions_front-architect_1_前端架构.md\":\"CgvhXTS4\",\"src_questions_front-base_1_html.md\":\"DLQeSpaL\",\"src_questions_front-base_2_css.md\":\"DD7YutH3\",\"src_questions_front-base_3_javascript.md\":\"-7z0y-W-\",\"src_questions_front-base_4_typescript.md\":\"DQxRuoSO\",\"src_questions_front-component_1_ui组件库.md\":\"Dpe9Oq-k\",\"src_questions_front-component_2_业务组件库.md\":\"mPsNLmjk\",\"src_questions_front-engineering_1_前端标准化.md\":\"BtiumeWi\",\"src_questions_front-engineering_2_前端自动化.md\":\"_PdM3ytE\",\"src_questions_front-engineering_3_webpack.md\":\"DZdNNnn0\",\"src_questions_front-engineering_4_vite.md\":\"DJ4vvreZ\",\"src_questions_front-engineering_5_rollup.md\":\"PsYo7ka2\",\"src_questions_front-frame_1_react.md\":\"DMNZZ54C\",\"src_questions_front-frame_2_vue.md\":\"CKVK2eHZ\",\"src_questions_front-frame_3_next.md\":\"B6pMi4bQ\",\"src_questions_front-frame_4_nuxt.md\":\"C1fdluE8\",\"src_questions_front-frame_5_qiankun.md\":\"C-MPv6hg\",\"src_questions_front-newest_1_前端最前沿.md\":\"BEbyrQK_\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"BmovbcFg\",\"src_questions_front-runtime_1_浏览器.md\":\"v63DWQzL\",\"src_questions_front-runtime_2_nodejs.md\":\"cQd0aA4S\",\"src_questions_front-safety_1_前端安全.md\":\"C2foxxlD\",\"src_questions_server_1_nest.md\":\"Dw6Vx__v\",\"src_questions_server_2_mongodb.md\":\"CUnmOlwP\",\"src_questions_server_3_mysql.md\":\"CZ5_GJRs\",\"src_questions_server_4_nginx.md\":\"C-vETNlG\",\"src_questions_server_5_docker.md\":\"DO_jQRO-\",\"src_questions_server_6_kubernets.md\":\"Dmu4qIRm\",\"src_questions_server_7_nacos.md\":\"DxALnRYb\",\"src_questions_server_8_redis.md\":\"By4aU7d7\",\"src_training_training-level_w1.md\":\"DpPAJWUp\",\"src_training_training-level_w2.md\":\"D78WBe6q\",\"src_training_training-level_w3.md\":\"DsdMV1ge\",\"src_training_training-level_w4.md\":\"CDRPV8nD\",\"src_training_training-level_w5.md\":\"DwvkBsPw\",\"src_training_training-level_w6.md\":\"CJCI4BcG\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>