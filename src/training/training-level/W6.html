<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.HtZR29kT.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DoTvM9Y0.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.DEinPzlH.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W6.md.B-EIGGUo.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W6" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. webpack proxy是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 简述webpack的构建流程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>
<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统
<img src="/public/images/image2.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. webpack 的热更新是什么?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Hot Module Replacement 简称 HRM</li>
<li><strong>1：</strong> 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">当 Vite 热更新失效时，可能的原因有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 配置问题：检查 vite.config.js 中是否有影响热更新的配置，如 server.hmr 配置错误。</li>
<li><strong>1：</strong> 代码问题：某些代码结构或语法可能导致热更新失效，例如在模块顶层使用 const 定义的对象或函数被修改，可能无法触发热更新。</li>
<li><strong>1：</strong> 插件冲突：使用的某些插件可能与 Vite 的热更新机制冲突，尝试禁用部分插件排查问题。</li>
<li><strong>1：</strong> 浏览器缓存：浏览器缓存可能会影响热更新，尝试清空浏览器缓存或使用无痕模式。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Webpack 如何实现代码分割？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<p>在 Webpack 中，实现代码分割有以下几种方式：</p>
<ul>
<li><strong>1：</strong> 多入口配置：在 entry 中配置多个入口，Webpack 会为每个入口生成一个独立的打包文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;./src/about.js&#x27;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  }
};
</code></pre><ul>
<li><strong>1：</strong> 动态导入（Dynamic Import）：使用 ES6 的动态导入语法（import()）实现按需加载。Webpack 会自动将动态导入的模块分割成单独的文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 在代码中使用动态导入</span>
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
});
</code></pre><ul>
<li><strong>1：</strong> SplitChunksPlugin：Webpack 内置的插件，用于分割公共代码和第三方库，减少重复打包。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. webpack中的Plugin如何编写？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>5：</strong> 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务<br>webpack 编译会创建两个核心对象:</li>
<li>compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子</li>
<li>compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation<br>将被创建如果自己要实现 plugin ，也需要遵循一定的规范:</li>
<li>插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.</li>
<li>传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> {
  <span class="hljs-comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span>
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    <span class="hljs-comment">//找到合适的事件钩子，实现自己的插件功能</span>
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&quot;MyPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> {
      <span class="hljs-comment">// compilation: 当前打包构建流程的上下文</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(compilation);
      <span class="hljs-comment">// do something...</span>
    });
  }
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. webpack的Plugin和Loader的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>
<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. 如何实现一个上拉加载，下拉刷新？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> 上拉加载</li>
</ul>
<p>首先可以看一张图</p>
<p><img src="/public/images/3_JavaScript_20241230002614.png" alt=""></p>
<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>
<p>判断页面触底我们需要先了解一下下面几个属性</p>
<ul>
<li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p>
</li>
<li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p>
</li>
<li><p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</p>
</li>
</ul>
<p>综上我们得出一个触底公式：</p>
<pre><code class="hljs language-js">scrollTop + clientHeight &gt;= scrollHeight
</code></pre><p>简单实现</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> clientHeight  = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">//浏览器高度</span>
<span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollHeight</span>;
<span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;
 
<span class="hljs-keyword">let</span> distance = <span class="hljs-number">50</span>;  <span class="hljs-comment">//距离视窗还用50的时候，开始触发；</span>

<span class="hljs-keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始加载数据&quot;</span>);
}
</code></pre><ul>
<li><strong>2：</strong> 下拉刷新</li>
</ul>
<p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>
<p>关于下拉刷新的原生实现，主要分成三步：</p>
<ul>
<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>
<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>
</ul>
<p>举个例子：</p>
<p><code>Html</code>结构如下：</p>
<pre><code class="hljs language-js">&lt;main&gt;
    &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt;
    &lt;ul id=&quot;refreshContainer&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;333&lt;/li&gt;
        &lt;li&gt;444&lt;/li&gt;
        &lt;li&gt;555&lt;/li&gt;
        ...
    &lt;/ul&gt;
&lt;/main&gt;
</code></pre><p>监听<code>touchstart</code>事件，记录初始的值</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> _element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;refreshContainer&#x27;</span>),
    _refreshText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.refreshText&#x27;</span>),
    _startPos = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 初始的值</span>
    _transitionHeight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 移动的距离</span>

_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    _startPos = e.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">pageY</span>; <span class="hljs-comment">// 记录初始位置</span>
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;relative&#x27;</span>;
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;transform 0s&#x27;</span>;
}, <span class="hljs-literal">false</span>);
</code></pre><p>监听<code>touchmove</code>移动事件，记录滑动差值</p>
<pre><code class="hljs language-js">_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// e.touches[0].pageY 当前位置</span>
    _transitionHeight = e.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">pageY</span> - _startPos; <span class="hljs-comment">// 记录差值</span>

    <span class="hljs-keyword">if</span> (_transitionHeight &gt; <span class="hljs-number">0</span> &amp;&amp; _transitionHeight &lt; <span class="hljs-number">60</span>) { 
        _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;下拉刷新&#x27;</span>; 
        _element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="hljs-string">&#x27;px)&#x27;</span>;

        <span class="hljs-keyword">if</span> (_transitionHeight &gt; <span class="hljs-number">55</span>) {
            _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;释放更新&#x27;</span>;
        }
    }                
}, <span class="hljs-literal">false</span>);
</code></pre><p>最后，就是监听<code>touchend</code>离开的事件</p>
<pre><code class="hljs language-js">_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;transform 0.5s ease 1s&#x27;</span>;
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateY(0px)&#x27;</span>;
    _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;更新中...&#x27;</span>;
    <span class="hljs-comment">// todo...</span>

}, <span class="hljs-literal">false</span>);
</code></pre><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>
<ul>
<li><p>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</p>
</li>
<li><p>下拉到一定值时，显示松手释放后的操作提示</p>
</li>
<li><p>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</p>
</li>
<li><p><strong>2：</strong> 案例</p>
</li>
</ul>
<p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>
<p>HTML结构</p>
<pre><code class="hljs language-js">&lt;div id=<span class="hljs-string">&quot;position-wrapper&quot;</span>&gt;
    &lt;div&gt;
        &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt;
        &lt;div class=&quot;position-list&quot;&gt;
   &lt;!--列表内容--&gt;
        &lt;/div&gt;
        &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BScroll</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@better-scroll/core&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">PullDown</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@better-scroll/pull-down&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">PullUp</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@better-scroll/pull-up&#x27;</span>;
<span class="hljs-title class_">BScroll</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">PullDown</span>);
<span class="hljs-title class_">BScroll</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">PullUp</span>);
</code></pre><p>实例化<code>BetterScroll</code>，并传入相关的参数</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> pageNo = <span class="hljs-number">1</span>,pageSize = <span class="hljs-number">10</span>,dataList = [],isMore = <span class="hljs-literal">true</span>;  
<span class="hljs-keyword">var</span> scroll= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BScroll</span>(<span class="hljs-string">&quot;#position-wrapper&quot;</span>,{
    <span class="hljs-attr">scrollY</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//垂直方向滚动</span>
    <span class="hljs-attr">click</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true</span>
    <span class="hljs-attr">pullUpLoad</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//上拉加载更多</span>
    <span class="hljs-attr">pullDownRefresh</span>:{
        <span class="hljs-attr">threshold</span>:<span class="hljs-number">50</span>,<span class="hljs-comment">//触发pullingDown事件的位置</span>
        <span class="hljs-attr">stop</span>:<span class="hljs-number">0</span><span class="hljs-comment">//下拉回弹后停留的位置</span>
    }
});
<span class="hljs-comment">//监听下拉刷新</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;pullingDown&quot;</span>,pullingDownHandler);
<span class="hljs-comment">//监测实时滚动</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;scroll&quot;</span>,scrollHandler);
<span class="hljs-comment">//上拉加载更多</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;pullingUp&quot;</span>,pullingUpHandler);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pullingDownHandler</span>(<span class="hljs-params"></span>){
    dataList=[];
    pageNo=<span class="hljs-number">1</span>;
    isMore=<span class="hljs-literal">true</span>;
    $(<span class="hljs-string">&quot;.more&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;查看更多&quot;</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">getlist</span>();<span class="hljs-comment">//请求数据</span>
    scroll.<span class="hljs-title function_">finishPullDown</span>();<span class="hljs-comment">//每次下拉结束后，需要执行这个操作</span>
    scroll.<span class="hljs-title function_">refresh</span>();<span class="hljs-comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span>
}
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pullingUpHandler</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">if</span>(!isMore){
        $(<span class="hljs-string">&quot;.more&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;没有更多数据了&quot;</span>);
        scroll.<span class="hljs-title function_">finishPullUp</span>();<span class="hljs-comment">//每次上拉结束后，需要执行这个操作</span>
        <span class="hljs-keyword">return</span>;
    }
    pageNo++;
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getlist</span>();<span class="hljs-comment">//请求数据</span>
    scroll.<span class="hljs-title function_">finishPullUp</span>();<span class="hljs-comment">//每次上拉结束后，需要执行这个操作</span>
    scroll.<span class="hljs-title function_">refresh</span>();<span class="hljs-comment">//当滚动区域的dom结构有变化时，需要执行这个操作    </span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">scrollHandler</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>&gt;<span class="hljs-number">50</span>) $(<span class="hljs-string">&#x27;.refresh&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;松手开始加载&quot;</span>);
    <span class="hljs-keyword">else</span> $(<span class="hljs-string">&#x27;.refresh&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;下拉刷新&quot;</span>);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getlist</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">//返回的数据</span>
    <span class="hljs-keyword">let</span> result=....;
    dataList=dataList.<span class="hljs-title function_">concat</span>(result);
    <span class="hljs-comment">//判断是否已加载完</span>
    <span class="hljs-keyword">if</span>(result.<span class="hljs-property">length</span>&lt;pageSize) isMore=<span class="hljs-literal">false</span>;
    <span class="hljs-comment">//将dataList渲染到html内容中</span>
}    
</code></pre><p>注意点：</p>
<p>使用 <code>better-scroll</code> 实现下拉刷新、上拉加载时要注意以下几点：</p>
<ul>
<li><code>wrapper</code> 里必须只有一个子元素</li>
<li>子元素的高度要比 <code>wrapper</code> 要高</li>
<li>使用的时候，要确定 <code>DOM</code> 元素是否已经生成，必须要等到 <code>DOM</code> 渲染完成后，再 <code>new BScroll()</code></li>
<li>滚动区域的 <code>DOM</code> 元素结构有变化后，需要执行刷新 <code>refresh()</code></li>
<li>上拉或者下拉，结束后，需要执行 <code>finishPullUp()</code> 或者 <code>finishPullDown()</code>，否则将不会执行下次操作</li>
<li><code>better-scroll</code>，默认会阻止浏览器的原生 <code>click</code> 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 <code>click:true</code></li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请简要介绍一下 Qiankun 及其主要应用场景</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Qiankun 是一个基于 single-spa 的微前端实现库，由蚂蚁金服开源。它提供了简单、强大的微前端解决方案，用于将多个独立的前端应用整合到一个大的应用中。其主要应用场景包括：</p>
<ul>
<li><strong>1：</strong> 大型项目拆分：将复杂的大型前端项目拆分成多个小型、独立的子应用，每个子应用可以由不同的团队独立开发、测试和部署。</li>
<li><strong>1：</strong> 旧系统升级：在不影响现有业务的前提下，逐步对旧系统进行升级改造，将新功能以子应用的形式集成到旧系统中。</li>
<li><strong>1：</strong> 多技术栈融合：允许在同一个项目中使用不同的前端技术栈（如 Vue、React、Angular 等），充分发挥各技术栈的优势。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTML5 中的Web Worker是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>运行在后台的JavaScript</li>
<li>独立于主线程</li>
<li>不会阻塞页面渲染</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>多线程执行</li>
<li>消息通信机制</li>
<li>独立的运行环境</li>
</ul>
</li>
<li><p><strong>1：</strong> 使用限制：</p>
<ul>
<li>无法访问DOM</li>
<li>无法访问window对象</li>
<li>无法访问document对象</li>
<li>有同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 适用场景：</p>
<ul>
<li>复杂数据处理</li>
<li>大量计算</li>
<li>图像处理</li>
<li>数据加密</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。</p>
<p>区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：</p>
<ul>
<li><p>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border</p>
</li>
<li><p>设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效</p>
</li>
<li><p>用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效</p>
</li>
<li><p>设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释 Nuxt3 中 nitro 的作用及关键配置项</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配</li>
<li><strong>1：</strong> 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">preset</span>: <span class="hljs-string">&#x27;node-server&#x27;</span>
  }
}
<span class="hljs-comment">//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，</span>
<span class="hljs-comment">// 例如 preset: &#x27;serverless&#x27;，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。</span>
</code></pre><ul>
<li><strong>2：</strong> routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">routeRules</span>: {
      <span class="hljs-string">&#x27;/&#x27;</span>: {
        <span class="hljs-attr">cache</span>: {
          <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> * <span class="hljs-number">10</span> <span class="hljs-comment">// 为首页设置缓存时间，这里是 10 分钟</span>
        }
      },
      <span class="hljs-string">&#x27;/about&#x27;</span>: {
        <span class="hljs-attr">redirect</span>: {
          <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-comment">// 将访问 /about 页面重定向到首页</span>
          <span class="hljs-attr">statusCode</span>: <span class="hljs-number">302</span>
        }
      },
      <span class="hljs-string">&#x27;/api/data&#x27;</span>: {
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment">// 为 /api/data 路由设置响应头，允许跨域访问</span>
        }
      }
    }
  }
}
<span class="hljs-comment">//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减</span>
<span class="hljs-comment">// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。</span>
</code></pre><ul>
<li><strong>1：</strong> devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地
开发环境下顺畅地协同工作。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">devProxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>, <span class="hljs-comment">// 后端 API 服务器的实际地址</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
      }
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的
要求，精准地定制构建结果的呈现形式。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-comment">// 设置构建输出目录为 dist</span>
      <span class="hljs-attr">publicDir</span>: <span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-comment">// 设定公共资源目录为 public</span>
      <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;esm&#x27;</span> <span class="hljs-comment">// 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式</span>
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部
系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;./server/plugins/myPlugin.ts&#x27;</span>]
  }
}
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. Vue 3 中的 Teleport 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Teleport 用于将组件渲染到指定 DOM 节点。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &lt;div&gt;Modal&lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. Vue的路由实现, hash路由和history路由实现原理说一下？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p>
<p>history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染
后 useEffect 都会执行，可能导致不必要的副作用反复运行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. 什么是 mixin？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 如何动态更新对象或数组的值？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">从输入URL到看到页面发生的全过程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>1.用户首先在浏览器地址栏中输入想要访问的网站的URL。</li>
<li>2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。</li>
<li>3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。</li>
<li>4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。</li>
<li>5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。</li>
<li>6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。</li>
<li>7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 对componentWillReceiveProps 的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>
<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>
<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. React 中 keys 的作用是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
</li>
<li><p>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：</p>
</li>
</ul>
<pre><code class="hljs language-react">
  &lt;ul&gt;
  {todos.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span>
    &lt;li key={todo.id}&gt;
      {todo.text}
    &lt;/li&gt;
  )};
  &lt;/ul&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. React的事件和普通的HTML事件有什么不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li><p>兼容所有浏览器，更好的跨平台；</p>
</li>
<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>
</li>
<li><p>方便 react 统一管理和事务机制。</p>
</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. React的Suspense组件和lazy函数是如何支持代码拆分的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>
</li>
<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>
</li>
<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>
</li>
<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. vue-router怎么动态添加、删除路由？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>添加路由</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title function_">addRoute</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> newRoute = {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HelloWorld.vue&#x27;</span>), <span class="hljs-comment">// 动态加载组件</span>
  };
  router.<span class="hljs-title function_">addRoute</span>(newRoute);
};
</code></pre><p>添加路由</p>
<pre><code class="hljs language-js">
router.<span class="hljs-title function_">removeRoute</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">谈谈你对CSS属性继承的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 可继承属性</p>
<ul>
<li>字体相关：font、font-family、font-size、font-style、font-variant、font-weight</li>
<li>文本相关：color、letter-spacing、line-height、visibility、cursor、direction</li>
</ul>
</li>
<li><p><strong>1：</strong> 不可继承属性</p>
<ul>
<li>盒模型：width、height、margin、padding、border</li>
<li>定位 &amp; 布局：display、position、top、left、right、bottom、z-index、overflow</li>
<li>背景 &amp; 其他：background、box-shadow、visibility</li>
</ul>
</li>
<li><p><strong>1：</strong> 强制继承或不继承</p>
<ul>
<li><p>强制继承：inherit，<code>background-color: inherit;</code></p>
</li>
<li><p>阻止继承：initial，<code>color: initial;</code></p>
</li>
<li><p>恢复原继承模式：unset，多用于样式重置</p>
<pre><code class="hljs language-css">.<span class="hljs-property">reset</span> {
  <span class="hljs-attr">color</span>: unset;  <span class="hljs-comment">/*对于 color，相当于 inherit */</span>
  <span class="hljs-attr">border</span>: unset; <span class="hljs-comment">/* 对于 border，相当于 initial，变为默认无边框*/</span>
  <span class="hljs-comment">/*或*/</span>
  <span class="hljs-attr">all</span>: unset;
}
</code></pre></li>
</ul>
</li>
<li><p><strong>1:</strong> 作用</p>
<ul>
<li>减少重复定义，降低代码量</li>
<li>特定情境禁止继承，保证元素独立性</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. webpack常见的提升构建速度的方法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 常见的有一下几种：</li>
</ul>
<blockquote>
<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">iframe 风险</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. React18中引入的并发模式是什么，它带来了哪些改进</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。</p>
</li>
<li><p>通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。</p>
</li>
<li><p>此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. 为什么udp不会粘包？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</p>
</li>
<li><p>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. typeof NaN 的结果是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">img的srcset属性的作⽤？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>
<pre><code class="hljs language-html">&lt;img src=<span class="hljs-string">&quot;default.png&quot;</span> srcset=<span class="hljs-string">&quot;low-res.jpg 1x, high-res.jpg 2x&quot;</span> /&gt;
</code></pre></details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-06T10:31:10.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W5</span><!--]--></a></div><div class="pager" data-v-1bcd8184><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DRSQzDDw\",\"ing.md\":\"CSU-FsBG\",\"readme.md\":\"cqdrLr7w\",\"src_guide_getting-started.md\":\"BHPmUDVJ\",\"src_guide_why.md\":\"wOg8p7Ad\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BnMYHb8m\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Cu9S-QlQ\",\"src_questions_computer-base_1_计算机硬件.md\":\"al8R9D-E\",\"src_questions_computer-base_2_计算机软件.md\":\"D_jU7b6G\",\"src_questions_computer-base_3_计算机网络.md\":\"Xd7T8CeT\",\"src_questions_computer-base_4_计算机编程.md\":\"DWan4sSl\",\"src_questions_computer-base_5_计算机科学.md\":\"CSoNdlp3\",\"src_questions_computer-base_6_软件工程.md\":\"BjKCkvJf\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"sSV9NAFe\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"X9R89Kjf\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CGUqRD7T\",\"src_questions_front-architect_1_前端架构.md\":\"B_fi0PMQ\",\"src_questions_front-base_1_html.md\":\"puIZAD8P\",\"src_questions_front-base_2_css.md\":\"El69VmB3\",\"src_questions_front-base_3_javascript.md\":\"BxZgvmfX\",\"src_questions_front-base_4_typescript.md\":\"CVOl4kiK\",\"src_questions_front-component_1_ui组件库.md\":\"Dt2PAPQH\",\"src_questions_front-component_2_业务组件库.md\":\"54yhkCjm\",\"src_questions_front-engineering_1_前端标准化.md\":\"PT6s3MxK\",\"src_questions_front-engineering_2_前端自动化.md\":\"K3JpjrZ8\",\"src_questions_front-engineering_3_webpack.md\":\"DYVMsHtI\",\"src_questions_front-engineering_4_vite.md\":\"D7lsS2qi\",\"src_questions_front-engineering_5_rollup.md\":\"CzKX1OrJ\",\"src_questions_front-frame_1_react.md\":\"D94c7Fr7\",\"src_questions_front-frame_2_vue.md\":\"ClzRw8cI\",\"src_questions_front-frame_3_next.md\":\"_X_2bvGV\",\"src_questions_front-frame_4_nuxt.md\":\"B_zxOWRv\",\"src_questions_front-frame_5_qiankun.md\":\"CR7z0igt\",\"src_questions_front-newest_1_前端最前沿.md\":\"D7UgmFKS\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"CQy2C9gp\",\"src_questions_front-runtime_1_浏览器.md\":\"MusgKYKR\",\"src_questions_front-runtime_2_nodejs.md\":\"BJcD5Fiu\",\"src_questions_front-safety_1_前端安全.md\":\"AcrAACg3\",\"src_questions_server_1_nest.md\":\"C4RWwIxj\",\"src_questions_server_2_mongodb.md\":\"BfbvC669\",\"src_questions_server_3_mysql.md\":\"CllnAFdP\",\"src_questions_server_4_nginx.md\":\"D4l6Bj16\",\"src_questions_server_5_docker.md\":\"B9mC1-10\",\"src_questions_server_6_kubernets.md\":\"C3-n22Hy\",\"src_questions_server_7_nacos.md\":\"B5joPxVq\",\"src_questions_server_8_redis.md\":\"DvwV_kkZ\",\"src_training_training-level_w1.md\":\"Dqg3jRL6\",\"src_training_training-level_w2.md\":\"BUkKvwUZ\",\"src_training_training-level_w3.md\":\"DYLpRINC\",\"src_training_training-level_w4.md\":\"DCnhXtU7\",\"src_training_training-level_w5.md\":\"Bj6cij9d\",\"src_training_training-level_w6.md\":\"B-EIGGUo\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>