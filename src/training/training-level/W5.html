<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfHBCVxN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.sGCIefLx.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DTgmue_e.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.M3zWpYJA.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-level_W5.md.CCVc827f.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-level/w1.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>面试级别</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W1.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W1</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W2.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W2</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W3.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W3</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W4</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W5.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W5</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>W6</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-level_W5" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. 说说如何借助webpack来优化前端性能?</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `w3`,`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>3：</strong></li>
</ul>
<blockquote>
<p>JS代码压缩<br>CSS代码压缩<br>Html文件代码压缩<br>文件大小压缩<br>图片压缩<br>Tree Shaking<br>代码分离<br>内联 chunk</p>
</blockquote>
<ul>
<li><p>raw-loader：加载文件原始内容（utf-8）</p>
</li>
<li><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</p>
</li>
<li><p>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</p>
</li>
<li><p>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</p>
</li>
<li><p>image-loader：加载并且压缩图片文件</p>
</li>
<li><p>babel-loader：把 ES6 转换成 ES5</p>
</li>
<li><p>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</p>
</li>
<li><p>html-webpack-plugin：简化 html 文件的创建，可以指定模板和输出文件</p>
</li>
<li><p>mini-css-extract-plugin：分离 css 文件</p>
</li>
<li><p>clean-webpack-plugin：清理文件夹</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积</p>
</li>
<li><p>terser-webpack-plugin：压缩 js 文件</p>
</li>
<li><p>optimize-css-assets-webpack-plugin：压缩 css 文件</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积</p>
</li>
<li><p>webpack-dashboard：可以更友好的展示相关打包信息。</p>
</li>
<li><p>webpack-merge：提取公共配置，减少重复配置代码</p>
</li>
<li><p>speed-measure-webpack-plugin：可以得知每个 loader 和 plugin 的执行耗时</p>
</li>
<li><p>webpack-bundle-analyzer：可视化 webpack 输出文件的体积，方便找出问题所在</p>
</li>
<li><p>HotModuleReplacementPlugin：模块热替换</p>
</li>
</ul>
<p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p>
<p>map文件只要不打开开发者工具，浏览器是不会加载的。</p>
<p>线上环境一般有三种处理方案：</p>
<ul>
<li>hidden-source-map：借助第三方错误监控平台 Sentry 使用</li>
<li>nosources-source-map：只会显示具体行数和错误，不会显示具体源码</li>
<li>inline-source-map：通过 dataURL 形式内联在打包文件中</li>
</ul>
<p>注意：避免在生产中使用 eval-source-map 和 cheap-module-eval-source-map，因为这两个配置会导致代码缓存失效，从而降低应用性能。</p>
<p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p>
<p>在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<p>Webpack开启监听模式，有两种方式：</p>
<ul>
<li><p>启动 webpack 命令时，带上 --watch 参数</p>
</li>
<li><p>在配置 webpack.config.js 中设置 watch:true</p>
</li>
</ul>
<p>缺点：每次需要手动刷新浏览器</p>
<p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。</p>
<p>VSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。
bundlesize 工具包可以进行自动化资源体积监控。</p>
<p>文件指纹是打包后输出的文件名的后缀。</p>
<ul>
<li><p>Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</p>
</li>
<li><p>Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生成不同的 chunkhash 值</p>
</li>
<li><p>Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</p>
</li>
</ul>
<p>文件指纹是打包后输出的文件名的后缀。</p>
<p>设置 output 的 filename，用 chunkhash。</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: {        
    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        
    <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    
    },    
    <span class="hljs-attr">output</span>: {        
      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        
      <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    
}}
</code></pre><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: {        
    <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        
    <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    },   
    <span class="hljs-attr">output</span>: {        
      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        
      <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    
    },    
    <span class="hljs-attr">plugins</span>:[        
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({            
        <span class="hljs-attr">filename</span>: <span class="hljs-string">`[name][contenthash:8].css`</span>        
      })    
  ]}


</code></pre><p>设置file-loader的name，使用hash。</p>
<ul>
<li><p>ext 资源后缀名</p>
</li>
<li><p>name 资源名称</p>
</li>
<li><p>path 资源所在路径</p>
</li>
<li><p>folder 资源所在文件夹</p>
</li>
<li><p>base 资源相对于上下文路径</p>
</li>
<li><p>hash 文件内容的 hash 值</p>
</li>
<li><p>digest 文件内容的 digest 值</p>
</li>
<li><p>content 文件内容的 base64 编码</p>
</li>
<li><p>query url查询参数</p>
</li>
<li><p>emoji 一个随机的指代文件内容的emoj</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {    
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    
  <span class="hljs-attr">output</span>: {        
    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,        
    <span class="hljs-attr">path</span>:path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)    
    },    
    <span class="hljs-attr">module</span>:{        
      <span class="hljs-attr">rules</span>:[{            
        <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,            
        <span class="hljs-attr">use</span>:[{                
          <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span>,                
          <span class="hljs-attr">options</span>:{                    
            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>                
        }            
      }]        
    }]    
  }}
</code></pre><p>可以使用 enforce 强制执行 loader 的作用顺序，pre 代表在所有正常 loader 之前执行，post 是所有 loader 之后执行。(inline 官方不推荐使用)</p>
<p>代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。</p>
<p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p>
<p>打包成唯一脚本：虽然减少http请求，但是体积大，导致体积过大，影响首屏加载性能。</p>
<p>代码分割的意义：将代码分割成多份进行按需加载，减少单个文件体积，降低首屏加载时间，提升性能。</p>
<p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p>
<ul>
<li><p>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</p>
</li>
<li><p>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据</p>
</li>
<li><p>尽可能的异步化 Loader，如果计算量很小，同步也可以</p>
</li>
<li><p>Loader 是无状态的，我们不应该在 Loader 中保留状态</p>
</li>
<li><p>使用 loader-utils 和 schema-utils 为我们提供的实用工具</p>
</li>
<li><p>加载本地 Loader 方法</p>
</li>
</ul>
<p>Npm link</p>
<p>ResolveLoader</p>
<p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p>
<ul>
<li><p>compiler 暴露了和 Webpack 整个生命周期相关的钩子</p>
</li>
<li><p>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</p>
</li>
<li><p>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</p>
</li>
<li><p>传给每个插件的 compiler 和 - compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</p>
</li>
<li><p>找出合适的事件点去完成想要的功能</p>
</li>
</ul>
<p>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</p>
<p>watch-run 当依赖的文件发生变化时会触发</p>
<ul>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li>
</ul>
<p>大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p>
<ul>
<li><p>解析：将代码转换成 AST</p>
<p>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</p>
<p>语法分析：分析token流(上面生成的数组)并生成 AST</p>
</li>
<li><p>转换：处理 AST，进行添加、更新或移除等操作</p>
<p>Taro就是利用 babel 完成的小程序语法转换</p>
</li>
<li><p>生成：将处理后的 AST 转换成代码</p>
</li>
</ul>
<p>Babel 是一个编译器，它主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p>Babel 的配置文件通常是一个名为 babel.config.js 的 JavaScript 文件，它位于项目的根目录中。在这个文件中，你可以使用 Babel 的配置选项来指定如何转换你的代码。</p>
<p>要配置 Babel 以支持最新的 ECMAScript 语法，你可以使用 @babel/preset-env 预设。这个预设会根据你的目标环境自动选择需要的 Babel 插件和 polyfills，以支持最新的 ECMAScript 语法。</p>
<p>以下是一个基本的 babel.config.js 文件的示例，它使用 @babel/preset-env 预设来支持最新的 ECMAScript 语法：</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [
    [
      <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,
      {
        <span class="hljs-attr">targets</span>: {
          <span class="hljs-attr">node</span>: <span class="hljs-string">&#x27;current&#x27;</span>,
        },
      },
    ],
  ],
};
</code></pre><p>没用 webpack 之前有什么问题：</p>
<p>全局变量污染： 传统的 JavaScript 开发中，所有变量和函数默认都是全局的；</p>
<p>手动管理依赖顺序麻烦： 在script里引入外部 JS 难度随着项目体量越来越难；</p>
<p>手动进行性能优化繁琐： 如文件合并、压缩、减少 HTTP 请求，繁琐且易出错；</p>
<p>要确保代码在不同浏览器中的兼容性： 需要手动编写或引入 polyfills、babel 等第三方工具；</p>
<p>对于小型项目来说，这些问题不太明显。但随之项目规模逐渐增大，再去解决这些问题就很吃力，这个时候我们就需要一种工具来帮我们把这些机械性问题，自动化的解决掉，让开发者更加专注在业务层面。</p>
<p>依赖图的构建过程</p>
<p>入口点：Webpack 从配置的入口点entry开始，从入口文件开始解析。</p>
<p>递归解析：递归解析每个模块的依赖，找到所有被引用的模块。</p>
<p>构建依赖图：根据模块之间的依赖关系构建一个依赖图。</p>
<p>确定顺序：根据依赖图确定模块的引用顺序，确保被依赖的模块先于依赖它们的模块打包。</p>
<p>配置 devtool: &#39;source-map&#39;后，</p>
<p>在编译过程中，会生成一个 .map 文件，一般用于代码调试和错误监控。</p>
<ul>
<li><p>包含了源代码、编译后的代码、以及它们之间的映射关系。</p>
</li>
<li><p>编译后的文件通常会在文件末尾添加一个注释，指向 SourceMap文件的位置。</p>
</li>
<li><p>当在浏览器开发者工具调试时，浏览器会读取这行注释并加载对应的 SourceMap 文件</p>
</li>
</ul>
<p>报错时，点击跳转。即使运行的是编译后的代码，也能够追溯到原始源代码的具体位置，而不是处理经过转换或压缩后的代码，从而提高了调试效率。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Webpack 如何实现代码分割？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<p>在 Webpack 中，实现代码分割有以下几种方式：</p>
<ul>
<li><strong>1：</strong> 多入口配置：在 entry 中配置多个入口，Webpack 会为每个入口生成一个独立的打包文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;./src/about.js&#x27;</span>
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  }
};
</code></pre><ul>
<li><strong>1：</strong> 动态导入（Dynamic Import）：使用 ES6 的动态导入语法（import()）实现按需加载。Webpack 会自动将动态导入的模块分割成单独的文件。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 在代码中使用动态导入</span>
button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> { add } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./math.js&#x27;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
});
</code></pre><ul>
<li><strong>1：</strong> SplitChunksPlugin：Webpack 内置的插件，用于分割公共代码和第三方库，减少重复打包。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">optimization</span>: {
    <span class="hljs-attr">splitChunks</span>: {
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>
    }
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. webpack常见的提升构建速度的方法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 常见的有一下几种：</li>
</ul>
<blockquote>
<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何处理 CSS 模块？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. webpack的Plugin和Loader的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>
<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. proxy是工作原理？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>({<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
}));
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 生产构建的主要优化策略有哪些？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> 依赖预打包<br>
&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>
&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。</li>
<li><strong>1：</strong> 代码压缩与混淆:<br>
&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>
&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。</p>
<ul>
<li><p><strong>1：</strong> CSS 优化:</br>
&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>
&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。</p>
</li>
<li><p><strong>1：</strong> 静态资源处理:</br>
&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>
&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。</p>
</li>
<li><p><strong>2：</strong> Tree - Shaking（摇树优化）:</br>
&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>
&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。</p>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. 什么是纯组件？为什么要使用纯组件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>纯组件：</p>
</li>
<li><p>纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。</p>
</li>
<li><p>优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。</p>
</li>
<li><p>使用场景：</p>
</li>
<li><p>静态数据：组件的 props 和 state 不经常变化。</p>
</li>
<li><p>复杂组件：组件内部逻辑复杂，重新渲染开销大。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 DOCTYPE， 有何作用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>  Doctype是HTML5的文档声明。浏览器发展过程中，HTML出现很多版本，不同版本之间格式有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何处理子应用之间的公共依赖？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配
置 props 等方式将主应用中的公共依赖传递给子应用使用。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTML5 中的Web Worker是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>运行在后台的JavaScript</li>
<li>独立于主线程</li>
<li>不会阻塞页面渲染</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>多线程执行</li>
<li>消息通信机制</li>
<li>独立的运行环境</li>
</ul>
</li>
<li><p><strong>1：</strong> 使用限制：</p>
<ul>
<li>无法访问DOM</li>
<li>无法访问window对象</li>
<li>无法访问document对象</li>
<li>有同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 适用场景：</p>
<ul>
<li>复杂数据处理</li>
<li>大量计算</li>
<li>图像处理</li>
<li>数据加密</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 如何实现子应用的加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加
载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">ES6 和 CommonJS 的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 语法风格<ul>
<li>ES6 模块使用 <code>import</code> 和 <code>export</code> 关键字。支持多种导出和导入方式，如默认导出（<code>export default</code>）和命名导出（<code>export const</code> 等）。</li>
<li>CommonJS 模块使用 <code>require()</code> 和 <code>module.exports</code>。支持 exports 对象和 exports.foo 属性的方式导出。</li>
</ul>
</li>
<li><strong>1：</strong> 加载方式<ul>
<li>ES6 模块是静态加载，在编译时就确定模块的依赖关系和导入导出的内容。这使得 JavaScript 引擎可以进行静态分析，实现诸如 Tree - Shaking（消除未使用的代码）等优化。</li>
<li>CommonJS是动态加载，在运行时才会去查找和加载模块。每次 require 调用时都会执行模块代码，只有第一次加载时会缓存结果。</li>
</ul>
</li>
<li><strong>1：</strong> 模块加载机制<ul>
<li>ES6 模块主要用于浏览器环境和现代 Node.js 环境（Node.js 从 v13.2.0 开始默认支持 ES6 模块，文件扩展名使用 .mjs）。</li>
<li>CommonJS主要用于 Node.js 服务器端开发，因为它与 Node.js 的同步加载模型和文件系统操作配合良好。</li>
</ul>
</li>
<li><strong>1：</strong> 循环依赖处理<ul>
<li>ES6 模块可以处理循环依赖，因为它是静态分析的，在模块加载过程中会先创建模块的引用，在运行时再填充具体的值。</li>
<li>CommonJS处理循环依赖时可能会出现问题，因为它是动态加载的，如果在循环依赖的情况下，某个模块在未完全初始化时就被引用，可能会得到未完全初始化的对象。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Qiankun 有哪些优点？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。</li>
<li><strong>1：</strong> 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。</li>
<li><strong>1：</strong> 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。</li>
<li><strong>1：</strong> 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在网页中应该使用奇数还是偶数的字体？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>推荐偶数字体（如 14px、16px），避免点阵字体渲染问题。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">超链接有哪些常见的表现形式？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong><ul>
<li>跳转链接：页面跳转，<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></li>
<li>下载链接：下载资源，<code>&lt;a href=&quot;data.zip&quot;&gt;本地&lt;/a&gt;</code></li>
<li>锚点链接：锚点跳转，<code>&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;</code></li>
<li>邮箱链接：唤起邮箱，<code>&lt;a href=&quot;mailto:xxx@xxx.com&quot;&gt;xxx&lt;/a&gt;</code></li>
<li>空链接：返回页面顶部，<code>&lt;a href=&quot;&quot;&gt;​&lt;/a&gt;</code></li>
<li>代码块：执行代码，<code>&lt;a href=&quot;javascript:void(0);&quot;&gt;​&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">理解BFC吗？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>
BFC（Block Formatting Context，块级格式化上下文）是CSS 布局中的一种渲染机制，它决定了块级元素如何定位及相互影响。BFC 具有独立的布局规则，内部元素不会影响外部元素。</li>
<li><strong>2：</strong><ul>
<li>防止 margin 折叠，让相邻元素的 margin 不会合并</li>
<li>清除浮动，让父元素包裹浮动子元素，防止高度塌陷</li>
<li>隔离布局，避免浮动元素影响其他元素</li>
<li>适应性布局，让 float 元素与普通元素共存</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. ?.、??、!、!.、_、** 等符号的含义？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行</li>
<li><strong>1：</strong> ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</li>
<li><strong>1：</strong> ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined</li>
<li><strong>1：</strong> !. 在变量名后添加，可以断言排除undefined和null类型</li>
<li><strong>1：</strong> _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324</li>
<li><strong>1：</strong> ** 求幂</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63. 如何不使用脚手架创建一个项目</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ol>
<li><p>yarn init 初始化package.json文件</p>
</li>
<li><p>安装react和react-dom</p>
</li>
<li><p>配置webpack</p>
</li>
<li><p>安装router</p>
</li>
<li><p>安装redux</p>
</li>
</ol>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 创建自定义钩子的规则是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>钩子名称以 &quot;use &quot;开头。</p>
</li>
<li><p>钩子只能从其他钩子或 React 元素中调用。</p>
</li>
<li><p>不要有条件地调用钩子。</p>
</li>
<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>
</li>
<li><p>自定义钩子必须是纯函数。</p>
</li>
<li><p>自定义钩子可以返回值或其他钩子。</p>
</li>
<li><p>以描述性的方式命名自定义钩子。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. React的事件和普通的HTML事件有什么不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li><p>兼容所有浏览器，更好的跨平台；</p>
</li>
<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>
</li>
<li><p>方便 react 统一管理和事务机制。</p>
</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 对componentWillReceiveProps 的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>
<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>
<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. Nodejs的异步编程有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Node.js的异步编程有以下几种方法：</p>
<ul>
<li><p>回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。</p>
</li>
<li><p>Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。</p>
</li>
<li><p>async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。</p>
</li>
<li><p>Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。</p>
</li>
<li><p>流程控制库：如<code>async</code>、<code>bluebird</code>、<code>co</code>等库，提供了更方便的异步编程方式。</p>
</li>
<li><p>事件驱动：通过事件驱动的方式处理异步操作，如<code>EventEmitter</code>、<code>Stream</code>等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">相邻图片为什么会产生间隙？该如何处理？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1:</strong> 图片标签是行内块元素，浏览器会将相邻行内块之间的空白字符解析为空格，从而产生间隙。</li>
<li><strong>3:</strong> 处理方式<ul>
<li>使用<code>display: block</code>；</li>
<li>使用负 margin 值；</li>
<li>父容器<code>font-size: 0</code>；</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">== 和 === 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>==</code> 为宽松相等，会隐式转换类型后比较（例如 <code>&#39;5&#39; == 5</code> 返回 true）</li>
<li><strong>1：</strong> <code>===</code> 为严格相等，要求值和类型完全相同（例如 <code>&#39;5&#39; === 5</code> 返回 false）</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">点击劫持</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>:1</strong> 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。</li>
<li><strong>:2</strong> 通常的攻击步骤是这样的：</li>
</ul>
<blockquote>
<p>1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。<br>2、将我们的页面放入到 iframe 当中。<br>3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。<br>4、把 iframe 设置为100%透明度。<br>5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。</p>
</blockquote>
<ul>
<li><strong>:1</strong> 危害：</li>
</ul>
<blockquote>
<p>攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。</p>
</blockquote>
<ul>
<li><strong>:2</strong> 防御：</li>
</ul>
<blockquote>
<p>1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。
2、判断当前页面是否被嵌入到 iframe 中。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. TypeScript 如何设计 Class 的声明？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {
   <span class="hljs-attr">greeting</span>: string;
   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: string</span>) {
       <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;
   }
   <span class="hljs-title function_">greet</span>(): string{
       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;
   }
}
<span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-string">&quot;world&quot;</span>);
</code></pre><ul>
<li><strong>2：</strong> Result类型是 string | number 。因为NonNullable会排除null和undefined 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. webpack-dev-server是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. 什么是泛型,有什么作用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。</li>
</ul>
<details>

<pre><code class="hljs language-typescript">
interface <span class="hljs-title class_">IResponseData</span>&lt;T&gt;{
    <span class="hljs-attr">code</span>: number;
    message?: string;
    <span class="hljs-attr">data</span>: T;
}


interface <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">email</span>: string;
}

<span class="hljs-comment">// 使用时传入User类型</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">IResponseData</span>&lt;<span class="hljs-title class_">User</span>&gt; = {
  <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Success&quot;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,
    <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;xxx@qq.com&quot;</span>
  }
};
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器是怎样解析CSS选择器的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 从右向左解析。如： <code>.nav &gt; li a</code> 先匹配 a，再向上查找 li 和 .nav；</li>
<li><strong>1：</strong> 减少回溯开销</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. Vue 3 中的Teleport功能有什么作用，如何使用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 <code>&lt;teleport&gt;</code> 标签包裹需要瞬移的元素，并
指定to属性为目标 DOM 元素的选择器或id。例如:</li>
</ul>
<pre><code class="hljs language-js">&lt;teleport to=<span class="hljs-string">&quot;#app-root&quot;</span>&gt;...&lt;/teleport&gt;
<span class="hljs-comment">//会将包裹的元素移动到id为app-root的元素内部。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 网络协议是什么</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>
</ul>
</details></div><div class="content-scoring"><button class="export-excel customized">客制化</button><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-03-12T10:13:04.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-level/W4.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>W4</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-level/W6.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>W6</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DWcuxi6H\",\"ing.md\":\"bAJzL5wj\",\"readme.md\":\"CA3-_Jpn\",\"src_guide_getting-started.md\":\"Cx6SZiyU\",\"src_guide_why.md\":\"DOAyEZQX\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DYMvsHvf\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"5cllqO-d\",\"src_questions_computer-base_1_计算机硬件.md\":\"C6Yk0Hjf\",\"src_questions_computer-base_2_计算机软件.md\":\"Bde1qVO8\",\"src_questions_computer-base_3_计算机网络.md\":\"B7Q-m4sv\",\"src_questions_computer-base_4_计算机编程.md\":\"C_-W9mXB\",\"src_questions_computer-base_5_计算机科学.md\":\"Df2lE70w\",\"src_questions_computer-base_6_软件工程.md\":\"B9idcnXG\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"5YsGlX5R\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"DlGXEKXH\",\"src_questions_data-structures-algorithms_1_算法.md\":\"DbvUJo7b\",\"src_questions_front-architect_1_前端架构.md\":\"BlICIy_F\",\"src_questions_front-base_1_html.md\":\"BJeqUgMb\",\"src_questions_front-base_2_css.md\":\"DZdPrOQb\",\"src_questions_front-base_3_javascript.md\":\"DnGPf_A_\",\"src_questions_front-base_4_typescript.md\":\"8nXyTXBm\",\"src_questions_front-component_1_ui组件库.md\":\"ZFN6OVBm\",\"src_questions_front-component_2_业务组件库.md\":\"Ct9Ck5zx\",\"src_questions_front-engineering_1_前端标准化.md\":\"Bq5DHOSo\",\"src_questions_front-engineering_2_前端自动化.md\":\"BN9zjIbe\",\"src_questions_front-engineering_3_webpack.md\":\"8eaZzOtX\",\"src_questions_front-engineering_4_vite.md\":\"BDVqsyM8\",\"src_questions_front-engineering_5_rollup.md\":\"DBVnKIhM\",\"src_questions_front-frame_1_react.md\":\"CFt8ndJA\",\"src_questions_front-frame_2_vue.md\":\"xAno7ZUY\",\"src_questions_front-frame_3_next.md\":\"Bt1IQJQa\",\"src_questions_front-frame_4_nuxt.md\":\"CvGQdydm\",\"src_questions_front-frame_5_qiankun.md\":\"C_bJ3c_J\",\"src_questions_front-newest_1_前端最前沿.md\":\"BiXw8lU3\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"BlaAbkMD\",\"src_questions_front-runtime_1_浏览器.md\":\"C4a0GxYI\",\"src_questions_front-runtime_2_nodejs.md\":\"D3xgXW8p\",\"src_questions_front-safety_1_前端安全.md\":\"DIeJ5-8Q\",\"src_questions_server_1_nest.md\":\"lQ3Wk-iR\",\"src_questions_server_2_mongodb.md\":\"BWUALWl-\",\"src_questions_server_3_mysql.md\":\"CqqgeGXy\",\"src_questions_server_4_nginx.md\":\"Bk1OnI6d\",\"src_questions_server_5_docker.md\":\"Caf-bezx\",\"src_questions_server_6_kubernets.md\":\"DvrLAoVO\",\"src_questions_server_7_nacos.md\":\"Y-ai80mh\",\"src_questions_server_8_redis.md\":\"DpCDOXGu\",\"src_training_training-level_w1.md\":\"DawlxvwF\",\"src_training_training-level_w2.md\":\"DIoaad9Z\",\"src_training_training-level_w3.md\":\"DjAkh7u0\",\"src_training_training-level_w4.md\":\"BKKMRT-H\",\"src_training_training-level_w5.md\":\"CCVc827f\",\"src_training_training-level_w6.md\":\"BnCGiQqX\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-level/w1\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"面试级别\",\"collapsed\":false,\"items\":[{\"text\":\"W1\",\"link\":\"/src/training/training-level/W1.md\"},{\"text\":\"W2\",\"link\":\"/src/training/training-level/W2.md\"},{\"text\":\"W3\",\"link\":\"/src/training/training-level/W3.md\"},{\"text\":\"W4\",\"link\":\"/src/training/training-level/W4.md\"},{\"text\":\"W5\",\"link\":\"/src/training/training-level/W5.md\"},{\"text\":\"W6\",\"link\":\"/src/training/training-level/W6.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>