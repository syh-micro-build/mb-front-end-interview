<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.Bs1qLOmp.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.4a5KvWbr.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.CbqoL1Og.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-senior_index.md.CfdVGd5G.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-senior_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. CSS 居中</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：定位居中</strong></li>
</ul>
<p>①已知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            width:100px;
            height:100px;
            background-color: aqua;
            position:fixed;
            left:50%;
            top:50%;
            margin-left:-50px;
            margin-top:-50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>②未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            position:fixed;
            left:0;
            top:0;
            right:0;
            bottom:0;
            margin:auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ul>
<li><strong>1：子元素在父元素中居中</strong></li>
</ul>
<p>①已知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">    父元素{
        <span class="hljs-comment">/* 相对定位 */</span>
        <span class="hljs-attr">position</span>: relative;
    }
    子元素{
        <span class="hljs-attr">width</span>:100px;
        <span class="hljs-attr">height</span>:100px;
        <span class="hljs-comment">/* 绝对定位 */</span>
        <span class="hljs-attr">position</span>:absolute;
        <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
        <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
        margin-<span class="hljs-attr">left</span>:-50px;
        margin-<span class="hljs-attr">top</span>:-50px;
    }
</code></pre><p>②未知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-comment">/* 相对定位 */</span>
      <span class="hljs-attr">position</span>: relative;
  }
  子元素{
      <span class="hljs-comment">/* 绝对定位 */</span>
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">top</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">right</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">bottom</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">margin</span>:auto;
  }
</code></pre><ul>
<li><strong>1：使用弹性布局</strong></li>
</ul>
<p>① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  html,body{
      <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>%;
  }
  <span class="hljs-comment">/* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */</span>
  body{
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
</code></pre><p>② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**</p>
<pre><code class="hljs language-css">  父元素 {
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
    
</code></pre><ul>
<li><strong>1：使用css3变形来实现</strong></li>
</ul>
<p>① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  元素{
      <span class="hljs-attr">position</span>:fixed;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(-<span class="hljs-number">50</span>%) <span class="hljs-title function_">translateY</span>(-<span class="hljs-number">50</span>%);
  }
</code></pre><p>② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-attr">position</span>:relative;
  }
  子元素{
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translate</span>(-<span class="hljs-number">50</span>%,-<span class="hljs-number">50</span>%);
  }
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. Canvas 和 SVG 有何区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。</p>
<p>SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. Vue 3 的主要新特性是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Composition API：提供更灵活的代码组织方式。</p>
<p>性能优化：使用 Proxy 实现响应式，性能更好。</p>
<p>Tree-shaking：支持按需引入，减小打包体积。</p>
<p>TypeScript 支持：对 TypeScript 的支持更好。</p>
<p>Fragment、Teleport、Suspense：新增内置组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. Promise.all和Promise.race的区别的使用场景？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
</li>
<li><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>
</li>
<li><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
</li>
<li><p>Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 手写单例模式（创建模式）</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js">    <span class="hljs-keyword">let</span> <span class="hljs-title class_">CreateSingleton</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
       <span class="hljs-keyword">let</span> instance;
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) {
           <span class="hljs-keyword">if</span> (instance) {
               <span class="hljs-keyword">return</span> instance;
           }
           <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
           <span class="hljs-keyword">return</span> instance = <span class="hljs-variable language_">this</span>;
       }
    })();
    <span class="hljs-title class_">CreateSingleton</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    }

<span class="hljs-keyword">let</span> <span class="hljs-title class_">Winner</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateSingleton</span>(<span class="hljs-string">&#x27;Winner&#x27;</span>);
<span class="hljs-keyword">let</span> <span class="hljs-title class_">Looser</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateSingleton</span>(<span class="hljs-string">&#x27;Looser&#x27;</span>);
​
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Winner</span> === <span class="hljs-title class_">Looser</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Winner</span>.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// &#x27;Winner&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Looser</span>.<span class="hljs-title function_">getName</span>());  <span class="hljs-comment">// &#x27;Winner&#x27;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 如何清除浮动?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong>
.clearfix{
  clear:both;
  content:&#39;&#39;;
  display:block;
  width: 0;
  height: 0;
  visibility:hidden;
}</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. label 的作用是什么？如何使用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<pre><code class="hljs language-html">
&lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;mobile&quot;</span>&gt;<span class="hljs-title class_">Number</span>:&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. JS 什么是防抖和节流？它们的应用场景有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。</li>
<li><strong>2：</strong> 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. 解释 React 中 render() 的目的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 如何访问DOM元素？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// Accessing the DOM element</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={myRef} /&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 使用 Mobx 的特点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. React的事件和普通的HTML事件有什么不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li><p>兼容所有浏览器，更好的跨平台；</p>
</li>
<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>
</li>
<li><p>方便 react 统一管理和事务机制。</p>
</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 创建自定义钩子的规则是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>钩子名称以 &quot;use &quot;开头。</p>
</li>
<li><p>钩子只能从其他钩子或 React 元素中调用。</p>
</li>
<li><p>不要有条件地调用钩子。</p>
</li>
<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>
</li>
<li><p>自定义钩子必须是纯函数。</p>
</li>
<li><p>自定义钩子可以返回值或其他钩子。</p>
</li>
<li><p>以描述性的方式命名自定义钩子。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. react事件绑定方式有哪些</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>render方法中使用bind</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>render方法中使用箭头函数</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(e)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>constructor中bind</p>
<pre><code class="hljs language-html">
<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre><p>定义阶段使用箭头函数绑定</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. 说说React的Context API及其使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>
</li>
<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>
</li>
<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">二分查找</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>
<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>
<li><strong>1：</strong> 时间复杂度： O(log n)。</li>
<li><strong>1：</strong> 思路：<ul>
<li>每次取中间元素与目标值比较。</li>
<li>若中间值大于目标值，目标值一定在左半部分。</li>
<li>若中间值小于目标值，目标值一定在右半部分。</li>
<li>重复上述步骤直到找到目标值或数组为空。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. React.Component 和 React.PureComponent 的区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：</p>
<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>
<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>
<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. React 组件中怎么做事件代理？它的原理是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p>
<p>在React底层，主要对合成事件做了两件事：</p>
<ul>
<li><p>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</p>
</li>
<li><p>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. 什么是状态管理器？你使用或了解哪些状态管理器？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。
状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。
除了 React Context，Redux 或 MobX 也常用作状态管理库。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. 如何跟踪功能组件的卸载？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。
为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-title function_">setValue</span>(value);
  }
  <span class="hljs-title class_">SomeAPI</span>.<span class="hljs-title function_">doFunction</span>(id, handleChange);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">SomeAPI</span>.<span class="hljs-title function_">undoFunction</span>(id, handleChange);
  };
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. React中setState的第二个参数作用是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>
<pre><code class="hljs language-js">
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">key1</span>: newState1,
    <span class="hljs-attr">key2</span>: newState2,
    ...
}, callback) <span class="hljs-comment">// 第二个参数是 state 更新完成后的回调函数</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 对componentWillReceiveProps 的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>
<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>
<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. react如何做到和vue中keep-alive的缓存效果</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. react函数组件和类组件的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>编写形式：类组件的编写形式更加的冗余</p>
</li>
<li><p>状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态</p>
</li>
<li><p>生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果</p>
</li>
<li><p>调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法</p>
</li>
<li><p>获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 受控组件和非受控组件有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>
</li>
<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. Redux 有哪些优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>
</li>
<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>
</li>
<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>
</li>
<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>
</li>
<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>
</li>
<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. webpack常见的提升构建速度的方法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 常见的有一下几种：</li>
</ul>
<blockquote>
<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 WebAssembly？其主要用途是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>
<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>
<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>
<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">对Service Worker的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>
<li><strong>4：</strong><ul>
<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>
<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. webpack proxy 为什么能解决跨域？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，
代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">基础配置</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<pre><code class="hljs language-conf"># <span class="hljs-title class_">Nginx</span> 启动时创建的 worker 进程的数量
worker_processes  <span class="hljs-number">1</span>;

# 配置 <span class="hljs-title class_">Nginx</span> 主进程的 <span class="hljs-variable constant_">PID</span> 文件路径
#pid        logs/nginx.<span class="hljs-property">pid</span>;

events {
    # 指定每个 worker 进程可以同时处理的最大连接数
    worker_connections  <span class="hljs-number">1024</span>;
}

http {
    include       mime.<span class="hljs-property">types</span>;
    default_type  application/octet-stream;

    # 提高文件传输的效率，特别是对于大文件来说
    sendfile        on;
    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率
    tcp_nopush     on;

    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间
    # 在这里，连接在 <span class="hljs-number">65</span> 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度
    keepalive_timeout  <span class="hljs-number">65</span>;

    # 启用 <span class="hljs-variable constant_">HTTP</span> 响应的压缩功能，以减少传输的数据量，提高网络传输效率
    gzip  on;

    server {
        # 端口
        listen       <span class="hljs-number">8099</span>;
        server_name  localhost;
        
        location / {
            root html-vue;
            # hash 路由的重定向
            try_files $uri $uri/ /index.<span class="hljs-property">html</span>;
            index index.<span class="hljs-property">html</span>;
            # 跨域
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;
            # 允许跨域请求的方法包括 <span class="hljs-variable constant_">GET</span>、<span class="hljs-variable constant_">POST</span> 和 <span class="hljs-variable constant_">OPTIONS</span>
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;
            # 允许跨域请求携带的自定义请求头
            add_header <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;</span>;
            
            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过
            <span class="hljs-keyword">if</span> ($request_filename ~* ^.*?.(html|htm|js)$) {
              add_header <span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span> no-cache;
            }
        }

        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理 - 作用是不在 vue 项目中写死 ip
        # 这样配置后，再也不用给前端里面写固定的 ip
        location /data {
            # 删除 url 中的 /data 但是目前貌似不生效
            # rewrite ^<span class="hljs-regexp">/data/</span>(.*)$ /$1 <span class="hljs-keyword">break</span>;
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }

    # 基础访问
    server {
        listen       <span class="hljs-number">80</span>;
        server_name  localhost;

        location / {
            root   html;
            index  index.<span class="hljs-property">html</span> index.<span class="hljs-property">htm</span>;
        }
        # 错误页面
        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.<span class="hljs-property">html</span>;
        location = /50x.<span class="hljs-property">html</span> {
            root   html;
        }

        # 跨域代理
        location /data {
            proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//192.168.31.214:3000;</span>
        }
    }
}
</code></pre></details></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 谈谈你对 Web 标准以及 W3C 的理解和认识</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。</li>
<li><strong>1：</strong> 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-24T06:17:18.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"cUgFDYJ8\",\"ing.md\":\"C7K-JIv9\",\"readme.md\":\"FXViB3LL\",\"src_guide_getting-started.md\":\"DxCfpS6C\",\"src_guide_why.md\":\"CwM69Rm0\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"C7x41sBI\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"BebAqh4h\",\"src_questions_computer-base_1_计算机硬件.md\":\"pnpVTiz-\",\"src_questions_computer-base_2_计算机软件.md\":\"rlE1JiIp\",\"src_questions_computer-base_3_计算机网络.md\":\"DeVLkpqI\",\"src_questions_computer-base_4_计算机编程.md\":\"FA7cygv4\",\"src_questions_computer-base_5_计算机科学.md\":\"u93s6aX6\",\"src_questions_computer-base_6_软件工程.md\":\"BdPuCYVm\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BT7BuCDi\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"B86w_kaG\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CXfSrH-H\",\"src_questions_front-architect_1_前端架构.md\":\"DACSalpM\",\"src_questions_front-base_1_html.md\":\"BS15v9KI\",\"src_questions_front-base_2_css.md\":\"Ci-9A8T6\",\"src_questions_front-base_3_javascript.md\":\"DQJ3wN9Q\",\"src_questions_front-base_4_typescript.md\":\"BNYuClW1\",\"src_questions_front-component_1_ui组件库.md\":\"Cq8f9QIv\",\"src_questions_front-component_2_业务组件库.md\":\"H_htzyR1\",\"src_questions_front-engineering_1_前端标准化.md\":\"DkmG1g-r\",\"src_questions_front-engineering_2_前端自动化.md\":\"DXK0T28h\",\"src_questions_front-engineering_3_webpack.md\":\"CWH_Xgrv\",\"src_questions_front-engineering_4_vite.md\":\"Dfpf3Gr9\",\"src_questions_front-engineering_5_rollup.md\":\"DyYDu8wF\",\"src_questions_front-frame_1_react.md\":\"D5Yp02nh\",\"src_questions_front-frame_2_vue.md\":\"Dnu3-Opi\",\"src_questions_front-frame_3_next.md\":\"ByAawdEG\",\"src_questions_front-frame_4_nuxt.md\":\"C2J7eTS-\",\"src_questions_front-frame_5_qiankun.md\":\"CofEjfEy\",\"src_questions_front-newest_1_前端最前沿.md\":\"DKM0xvh5\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"_JfjBIsX\",\"src_questions_front-runtime_1_浏览器.md\":\"nr97r-3-\",\"src_questions_front-runtime_2_nodejs.md\":\"Dcrb6pY3\",\"src_questions_front-safety_1_前端安全.md\":\"CVSxxaGW\",\"src_questions_server_1_nest.md\":\"DhwC3DUs\",\"src_questions_server_2_mongodb.md\":\"ByGgHN0g\",\"src_questions_server_3_mysql.md\":\"5mf69SMB\",\"src_questions_server_4_nginx.md\":\"CmDbQjql\",\"src_questions_server_5_docker.md\":\"DSAPifO_\",\"src_questions_server_6_kubernets.md\":\"taWwC6jl\",\"src_questions_server_7_nacos.md\":\"CNZSchh2\",\"src_questions_server_8_redis.md\":\"DdjsyJlS\",\"src_training_training-architecture_index.md\":\"CSlA1hX4\",\"src_training_training-experts_index.md\":\"Duz6DXmi\",\"src_training_training-intermediate_index.md\":\"DfoPGPpy\",\"src_training_training-primary_index.md\":\"BYipliXv\",\"src_training_training-senior_index.md\":\"CfdVGd5G\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>