<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfdlugHt.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.UPCtyyuv.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CjDcszOu.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.5WXdMwYP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.DaqghNJ-.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-senior_index.md.Dl6B2VJu.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-senior_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. Vue 初始化页面闪动问题如何解决？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。</p>
<p>解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：</p>
<pre><code class="hljs language-html">[v-cloak] { <span class="hljs-attr">display</span>: none; }

&lt;div v-cloak&gt;
  {{ message }}
&lt;/div&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20.你如何在Node.js中处理HTTP请求和响应？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.</p>
</li>
<li><p>监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。</p>
</li>
<li><p>处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。</p>
</li>
<li><p>发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。</p>
</li>
<li><p>通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。
需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. head 标签有什么作用，其中什么标签必不可少？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：base, link 等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>shallowRef：只对 .value 进行响应式处理。</p>
<p>shallowReactive：只对对象的第一层属性进行响应式处理。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { shallowRef, shallowReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">shallowRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 基本类型</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">info</span>: { <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> } }); <span class="hljs-comment">// 对象类型</span>

    <span class="hljs-keyword">return</span> { count, state };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 说一下 web worker</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>如何创建 web worker：</p>
<p>检测浏览器对于 web worker 的支持性</p>
<p>创建 web worker 文件（js，回传函数等）</p>
<p>创建 web worker 对象</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 什么是TypeScript？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 什么是 优雅降级、渐进增强？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。</p>
<p>优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。</p>
<p>渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 描述cookie，localStorage，sessionStorage的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。</p>
</li>
<li><p>localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。</p>
</li>
<li><p>sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。</p>
</li>
<li><p>localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. Set、Map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
</li>
<li><p>Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。</p>
</li>
<li><p>Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. position:fixed; 在 android 下无效怎么处理 ？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-html">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. react如何做到和vue中keep-alive的缓存效果</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. 说说React的Context API及其使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>
</li>
<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>
</li>
<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. React中的setState批量更新的过程是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p>
<p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. React为什么要校验Prop？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。</p>
<p>数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。</p>
<p>组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。</p>
<p>提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。</p>
<p>调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>. <span class="hljs-title function_">assign</span> ( { }， state, {
<span class="hljs-attr">type</span>:action .<span class="hljs-property">type</span>,
shouldNotPaint : <span class="hljs-literal">true</span>
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. Redux和Mobx有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。</p>
</li>
<li><p>Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. React的Suspense组件和lazy函数是如何支持代码拆分的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>
</li>
<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>
</li>
<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>
</li>
<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. Component, Element, Instance 之间有什么区别和联系？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p>
</li>
<li><p>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p>
</li>
<li><p>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
</li>
</ul>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 如何访问DOM元素？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myRef.<span class="hljs-property">current</span>); <span class="hljs-comment">// Accessing the DOM element</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; ref={myRef} /&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. react函数组件和类组件的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>编写形式：类组件的编写形式更加的冗余</p>
</li>
<li><p>状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态</p>
</li>
<li><p>生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果</p>
</li>
<li><p>调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法</p>
</li>
<li><p>获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. 在React中组件的this.state和setState有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. 解释 React 中 render() 的目的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">PWA有那些优点？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>
<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>
<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>
<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>
<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>
<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>
<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>
<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>
<li><strong>1：</strong> 绕过应用商店</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">66. 说说React Hooks是如何解决类组件中一些常见问题的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。</p>
</li>
<li><p>这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。</p>
</li>
<li><p>通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。</p>
</li>
<li><p>此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Redux 实现了哪种模式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. react事件绑定方式有哪些</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>render方法中使用bind</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>render方法中使用箭头函数</p>
<pre><code class="hljs language-html">&lt;div onClick={<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleClick</span>(e)}&gt;test&lt;/div&gt;
</code></pre><p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>
<p>constructor中bind</p>
<pre><code class="hljs language-html">
<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
</code></pre><p>定义阶段使用箭头函数绑定</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. React如何进行代码拆分？拆分的原则是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>
</li>
<li><p>在我们的react项目中：</p>
</li>
<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>
</li>
<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>
</li>
<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>
</li>
<li><p>静态类型的资源单独放置</p>
</li>
<li><p>公共组件、高阶组件、插件单独放置</p>
</li>
<li><p>工具类文件单独放置</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. 如何跟踪功能组件中对象字段的变化？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Changed!&#x27;</span>)
}, [obj.<span class="hljs-property">someField</span>])
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">对Service Worker的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>
<li><strong>4：</strong><ul>
<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>
<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly 的工作原理是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>
<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>
<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>
<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack-dev-server是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack的Plugin是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack的Plugin和Loader的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>
<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack中的Loader如何编写？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>5：</strong> loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。
函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//导出一个函数，source为webpack传递给loader的文件源内容</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>){
 <span class="hljs-keyword">const</span> content = <span class="hljs-title function_">doSomeThing2JsString</span>(source);
<span class="hljs-comment">//如果 loader 配置了 options 对象，那么this.query将指向 options</span>
<span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-property">query</span>;
<span class="hljs-comment">// 可以用作解析其他模块路径的上下文</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this.context&#x27;</span>);
<span class="hljs-comment">/*
* this.callback 参数:
* error:Error |null，当 loader 出错时向外抛出一个 error
* content:String | Buffer，经过 loader 编译后需要导出的内容
* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程
*/</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>，content);<span class="hljs-comment">//异步</span>
<span class="hljs-keyword">return</span> content;<span class="hljs-comment">//同步</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">webpack proxy 为什么能解决跨域？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，
代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. 如何实现一个上拉加载，下拉刷新？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>2：</strong> 上拉加载</li>
</ul>
<p>首先可以看一张图</p>
<p><img src="/public/images/3_JavaScript_20241230002614.png" alt=""></p>
<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>
<p>判断页面触底我们需要先了解一下下面几个属性</p>
<ul>
<li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p>
</li>
<li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p>
</li>
<li><p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</p>
</li>
</ul>
<p>综上我们得出一个触底公式：</p>
<pre><code class="hljs language-js">scrollTop + clientHeight &gt;= scrollHeight
</code></pre><p>简单实现</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> clientHeight  = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">//浏览器高度</span>
<span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollHeight</span>;
<span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;
 
<span class="hljs-keyword">let</span> distance = <span class="hljs-number">50</span>;  <span class="hljs-comment">//距离视窗还用50的时候，开始触发；</span>

<span class="hljs-keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始加载数据&quot;</span>);
}
</code></pre><ul>
<li><strong>2：</strong> 下拉刷新</li>
</ul>
<p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>
<p>关于下拉刷新的原生实现，主要分成三步：</p>
<ul>
<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>
<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>
</ul>
<p>举个例子：</p>
<p><code>Html</code>结构如下：</p>
<pre><code class="hljs language-js">&lt;main&gt;
    &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt;
    &lt;ul id=&quot;refreshContainer&quot;&gt;
        &lt;li&gt;111&lt;/li&gt;
        &lt;li&gt;222&lt;/li&gt;
        &lt;li&gt;333&lt;/li&gt;
        &lt;li&gt;444&lt;/li&gt;
        &lt;li&gt;555&lt;/li&gt;
        ...
    &lt;/ul&gt;
&lt;/main&gt;
</code></pre><p>监听<code>touchstart</code>事件，记录初始的值</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> _element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;refreshContainer&#x27;</span>),
    _refreshText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.refreshText&#x27;</span>),
    _startPos = <span class="hljs-number">0</span>,  <span class="hljs-comment">// 初始的值</span>
    _transitionHeight = <span class="hljs-number">0</span>; <span class="hljs-comment">// 移动的距离</span>

_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    _startPos = e.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">pageY</span>; <span class="hljs-comment">// 记录初始位置</span>
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&#x27;relative&#x27;</span>;
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;transform 0s&#x27;</span>;
}, <span class="hljs-literal">false</span>);
</code></pre><p>监听<code>touchmove</code>移动事件，记录滑动差值</p>
<pre><code class="hljs language-js">_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// e.touches[0].pageY 当前位置</span>
    _transitionHeight = e.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">pageY</span> - _startPos; <span class="hljs-comment">// 记录差值</span>

    <span class="hljs-keyword">if</span> (_transitionHeight &gt; <span class="hljs-number">0</span> &amp;&amp; _transitionHeight &lt; <span class="hljs-number">60</span>) { 
        _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;下拉刷新&#x27;</span>; 
        _element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateY(&#x27;</span>+_transitionHeight+<span class="hljs-string">&#x27;px)&#x27;</span>;

        <span class="hljs-keyword">if</span> (_transitionHeight &gt; <span class="hljs-number">55</span>) {
            _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;释放更新&#x27;</span>;
        }
    }                
}, <span class="hljs-literal">false</span>);
</code></pre><p>最后，就是监听<code>touchend</code>离开的事件</p>
<pre><code class="hljs language-js">_element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transition</span> = <span class="hljs-string">&#x27;transform 0.5s ease 1s&#x27;</span>;
    _element.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">&#x27;translateY(0px)&#x27;</span>;
    _refreshText.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;更新中...&#x27;</span>;
    <span class="hljs-comment">// todo...</span>

}, <span class="hljs-literal">false</span>);
</code></pre><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>
<ul>
<li><p>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</p>
</li>
<li><p>下拉到一定值时，显示松手释放后的操作提示</p>
</li>
<li><p>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</p>
</li>
<li><p><strong>2：</strong> 案例</p>
</li>
</ul>
<p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>
<p>HTML结构</p>
<pre><code class="hljs language-js">&lt;div id=<span class="hljs-string">&quot;position-wrapper&quot;</span>&gt;
    &lt;div&gt;
        &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt;
        &lt;div class=&quot;position-list&quot;&gt;
   &lt;!--列表内容--&gt;
        &lt;/div&gt;
        &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BScroll</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@better-scroll/core&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">PullDown</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@better-scroll/pull-down&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">PullUp</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@better-scroll/pull-up&#x27;</span>;
<span class="hljs-title class_">BScroll</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">PullDown</span>);
<span class="hljs-title class_">BScroll</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">PullUp</span>);
</code></pre><p>实例化<code>BetterScroll</code>，并传入相关的参数</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> pageNo = <span class="hljs-number">1</span>,pageSize = <span class="hljs-number">10</span>,dataList = [],isMore = <span class="hljs-literal">true</span>;  
<span class="hljs-keyword">var</span> scroll= <span class="hljs-keyword">new</span> <span class="hljs-title class_">BScroll</span>(<span class="hljs-string">&quot;#position-wrapper&quot;</span>,{
    <span class="hljs-attr">scrollY</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//垂直方向滚动</span>
    <span class="hljs-attr">click</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true</span>
    <span class="hljs-attr">pullUpLoad</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//上拉加载更多</span>
    <span class="hljs-attr">pullDownRefresh</span>:{
        <span class="hljs-attr">threshold</span>:<span class="hljs-number">50</span>,<span class="hljs-comment">//触发pullingDown事件的位置</span>
        <span class="hljs-attr">stop</span>:<span class="hljs-number">0</span><span class="hljs-comment">//下拉回弹后停留的位置</span>
    }
});
<span class="hljs-comment">//监听下拉刷新</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;pullingDown&quot;</span>,pullingDownHandler);
<span class="hljs-comment">//监测实时滚动</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;scroll&quot;</span>,scrollHandler);
<span class="hljs-comment">//上拉加载更多</span>
scroll.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;pullingUp&quot;</span>,pullingUpHandler);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pullingDownHandler</span>(<span class="hljs-params"></span>){
    dataList=[];
    pageNo=<span class="hljs-number">1</span>;
    isMore=<span class="hljs-literal">true</span>;
    $(<span class="hljs-string">&quot;.more&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;查看更多&quot;</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">getlist</span>();<span class="hljs-comment">//请求数据</span>
    scroll.<span class="hljs-title function_">finishPullDown</span>();<span class="hljs-comment">//每次下拉结束后，需要执行这个操作</span>
    scroll.<span class="hljs-title function_">refresh</span>();<span class="hljs-comment">//当滚动区域的dom结构有变化时，需要执行这个操作</span>
}
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pullingUpHandler</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">if</span>(!isMore){
        $(<span class="hljs-string">&quot;.more&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;没有更多数据了&quot;</span>);
        scroll.<span class="hljs-title function_">finishPullUp</span>();<span class="hljs-comment">//每次上拉结束后，需要执行这个操作</span>
        <span class="hljs-keyword">return</span>;
    }
    pageNo++;
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getlist</span>();<span class="hljs-comment">//请求数据</span>
    scroll.<span class="hljs-title function_">finishPullUp</span>();<span class="hljs-comment">//每次上拉结束后，需要执行这个操作</span>
    scroll.<span class="hljs-title function_">refresh</span>();<span class="hljs-comment">//当滚动区域的dom结构有变化时，需要执行这个操作    </span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">scrollHandler</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>&gt;<span class="hljs-number">50</span>) $(<span class="hljs-string">&#x27;.refresh&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;松手开始加载&quot;</span>);
    <span class="hljs-keyword">else</span> $(<span class="hljs-string">&#x27;.refresh&#x27;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;下拉刷新&quot;</span>);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getlist</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">//返回的数据</span>
    <span class="hljs-keyword">let</span> result=....;
    dataList=dataList.<span class="hljs-title function_">concat</span>(result);
    <span class="hljs-comment">//判断是否已加载完</span>
    <span class="hljs-keyword">if</span>(result.<span class="hljs-property">length</span>&lt;pageSize) isMore=<span class="hljs-literal">false</span>;
    <span class="hljs-comment">//将dataList渲染到html内容中</span>
}    
</code></pre><p>注意点：</p>
<p>使用 <code>better-scroll</code> 实现下拉刷新、上拉加载时要注意以下几点：</p>
<ul>
<li><code>wrapper</code> 里必须只有一个子元素</li>
<li>子元素的高度要比 <code>wrapper</code> 要高</li>
<li>使用的时候，要确定 <code>DOM</code> 元素是否已经生成，必须要等到 <code>DOM</code> 渲染完成后，再 <code>new BScroll()</code></li>
<li>滚动区域的 <code>DOM</code> 元素结构有变化后，需要执行刷新 <code>refresh()</code></li>
<li>上拉或者下拉，结束后，需要执行 <code>finishPullUp()</code> 或者 <code>finishPullDown()</code>，否则将不会执行下次操作</li>
<li><code>better-scroll</code>，默认会阻止浏览器的原生 <code>click</code> 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 <code>click:true</code></li>
</ul>
</details>

</div></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-21T10:35:00.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DdwsHJDi\",\"ing.md\":\"BpWiIgfU\",\"readme.md\":\"ebzd1Aw-\",\"src_guide_getting-started.md\":\"BxhEd4nu\",\"src_guide_why.md\":\"rLr7oeDE\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"xRF4fGgN\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"D1s2dL6m\",\"src_questions_computer-base_1_计算机硬件.md\":\"DHc17cHQ\",\"src_questions_computer-base_2_计算机软件.md\":\"IyK4xJQn\",\"src_questions_computer-base_3_计算机网络.md\":\"DtILA4xG\",\"src_questions_computer-base_4_计算机编程.md\":\"CBbMSrL2\",\"src_questions_computer-base_5_计算机科学.md\":\"COu_6nUj\",\"src_questions_computer-base_6_软件工程.md\":\"Dad6u5LS\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"3NFdegLM\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"XUbaEKUx\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CkZgNzUs\",\"src_questions_front-architect_1_前端架构.md\":\"BORQJy-k\",\"src_questions_front-base_1_html.md\":\"BMQdcFc7\",\"src_questions_front-base_2_css.md\":\"Dr0rQRxC\",\"src_questions_front-base_3_javascript.md\":\"Dtt7u7Aq\",\"src_questions_front-base_4_typescript.md\":\"hw7c5vl-\",\"src_questions_front-component_1_ui组件库.md\":\"BN_3tn2z\",\"src_questions_front-component_2_业务组件库.md\":\"CtS4pqwK\",\"src_questions_front-engineering_1_前端标准化.md\":\"DB4u9a8G\",\"src_questions_front-engineering_2_前端自动化.md\":\"BzRxR-YQ\",\"src_questions_front-engineering_3_webpack.md\":\"BvDii2YX\",\"src_questions_front-engineering_4_vite.md\":\"DPXSHSz9\",\"src_questions_front-engineering_5_rollup.md\":\"DNf-uKqw\",\"src_questions_front-frame_1_react.md\":\"CpvoO5nG\",\"src_questions_front-frame_2_vue.md\":\"DWLcxrgp\",\"src_questions_front-frame_3_next.md\":\"BZZ8xfql\",\"src_questions_front-frame_4_nuxt.md\":\"BSw9licx\",\"src_questions_front-frame_5_qiankun.md\":\"C7YRZDNP\",\"src_questions_front-newest_1_前端最前沿.md\":\"Di_lIpMx\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"q_BgXaOn\",\"src_questions_front-runtime_1_浏览器.md\":\"Cfu44P3X\",\"src_questions_front-runtime_2_nodejs.md\":\"CpbpSssB\",\"src_questions_front-safety_1_前端安全.md\":\"BWF4orFI\",\"src_questions_server_1_nest.md\":\"CtZ9fhhC\",\"src_questions_server_2_mongodb.md\":\"8gOHIdai\",\"src_questions_server_3_mysql.md\":\"CdpQ4D_s\",\"src_questions_server_4_nginx.md\":\"KVyn0GQ1\",\"src_questions_server_5_docker.md\":\"BY8jNRqc\",\"src_questions_server_6_kubernets.md\":\"D1cDY2vY\",\"src_questions_server_7_nacos.md\":\"DNqyt0yy\",\"src_questions_server_8_redis.md\":\"DtJjX1Mj\",\"src_training_training-architecture_index.md\":\"CR2bZMsP\",\"src_training_training-experts_index.md\":\"D5qI8mct\",\"src_training_training-intermediate_index.md\":\"B7hC9kBs\",\"src_training_training-primary_index.md\":\"DQo3ko9S\",\"src_training_training-senior_index.md\":\"Dl6B2VJu\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>