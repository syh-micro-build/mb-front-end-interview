<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.Dqb6yj2l.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.DjnnLVgv.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.dJbyYXqx.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.C3Wt8LlC.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. 什么是 React？它的主要特点是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：</p>
</li>
<li><p>组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。</p>
</li>
<li><p>虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。</p>
</li>
<li><p>声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。</p>
</li>
<li><p>JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。</p>
</li>
<li><p>生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>0：</strong> 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。</li>
<li><strong>1：</strong> 添加 SSR 相关依赖：安装<code>@vue/server-renderer</code>和<code>express</code>等依赖，<code>@vue/server-renderer</code>用于服务器端渲染，<code>express</code>作为服务器框架。命令
为<code>npm install @vue/server-renderer express</code>。</li>
<li><strong>1：</strong> 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使
用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。</li>
<li><strong>1：</strong> 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如<code>entry-server.js</code>，在该文件中，创建 Vue 应用实例，并导出。同时，可能
需要调整一些组件的逻辑，以适应服务器端渲染的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. HTML、XML、XHTML 的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；</p>
</li>
<li><p>XML：可扩展标记语言，是语法较为严格、严格的标记语言；</p>
</li>
<li><p>XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. HTML元素如何体现其嵌套关系</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>块级元素可以包含行内元素；</p>
<p>块级元素不一定能包含块级元素；</p>
<p>行内元素一般不能包含块级元素（a元素例外）</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 如何动态更新对象或数组的值？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 解释一下Node.js的Express框架及其主要组件?</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：</p>
</li>
<li><p>Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。</p>
</li>
<li><p>Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。</p>
</li>
<li><p>View engine：视图引擎，用于渲染HTML模板。</p>
</li>
<li><p>Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。</p>
</li>
<li><p>Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。</p>
</li>
<li><p>Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。</p>
</li>
<li><p>Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">HTTP2相对于HTTP1.x有什么优势和特点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。</li>
<li>HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。</li>
<li>HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。</li>
<li>HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。</li>
<li>HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 对 SPA 单页面的理解，它的优缺点分别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. class和function的区别?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>相同点：1. 函数作为构造函数</p>
</li>
<li><p>不同点：</p>
</li>
<li><p>class构造函数必须使用new操作符。</p>
</li>
<li><p>class声明不可以提升。</p>
</li>
<li><p>class不可以用call、apply、bind改变this指向。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. SPA及其优缺点是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>shallowRef：只对 .value 进行响应式处理。</p>
<p>shallowReactive：只对对象的第一层属性进行响应式处理。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { shallowRef, shallowReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">shallowRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 基本类型</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">info</span>: { <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> } }); <span class="hljs-comment">// 对象类型</span>

    <span class="hljs-keyword">return</span> { count, state };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 说一下 HTML5 drag API</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</p>
<p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</p>
<p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>
<p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</p>
<p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</p>
<p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</p>
<p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 如何实现一个类型工具 `IsNever&lt;T&gt;`，用于判断一个类型 T 是否为 never 类型？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 使用 <code>[T]</code> extends <code>[never]</code> 来判断，因为直接 T extends never 会有特殊处理，而包装成元组可以正确判断。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 答案</span>
type <span class="hljs-title class_">IsNever</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [never]? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// 测试</span>
type <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">IsNever</span>&lt;never&gt;; <span class="hljs-comment">// true</span>
type <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">IsNever</span>&lt;string&gt;; <span class="hljs-comment">// false</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Node.js的优点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。</p>
</li>
<li><p>单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p>
</li>
<li><p>开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p>
</li>
<li><p>跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。</p>
</li>
<li><p>高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。</p>
</li>
<li><p>数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. CSS 居中</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：定位居中</strong></li>
</ul>
<p>①已知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            width:100px;
            height:100px;
            background-color: aqua;
            position:fixed;
            left:50%;
            top:50%;
            margin-left:-50px;
            margin-top:-50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>②未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-html">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .box{
            position:fixed;
            left:0;
            top:0;
            right:0;
            bottom:0;
            margin:auto;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ul>
<li><strong>1：子元素在父元素中居中</strong></li>
</ul>
<p>①已知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">    父元素{
        <span class="hljs-comment">/* 相对定位 */</span>
        <span class="hljs-attr">position</span>: relative;
    }
    子元素{
        <span class="hljs-attr">width</span>:100px;
        <span class="hljs-attr">height</span>:100px;
        <span class="hljs-comment">/* 绝对定位 */</span>
        <span class="hljs-attr">position</span>:absolute;
        <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
        <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
        margin-<span class="hljs-attr">left</span>:-50px;
        margin-<span class="hljs-attr">top</span>:-50px;
    }
</code></pre><p>②未知大小的子元素在父元素中居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-comment">/* 相对定位 */</span>
      <span class="hljs-attr">position</span>: relative;
  }
  子元素{
      <span class="hljs-comment">/* 绝对定位 */</span>
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">top</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">right</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">bottom</span>:<span class="hljs-number">0</span>;
      <span class="hljs-attr">margin</span>:auto;
  }
</code></pre><ul>
<li><strong>1：使用弹性布局</strong></li>
</ul>
<p>① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  html,body{
      <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>%;
  }
  <span class="hljs-comment">/* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */</span>
  body{
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
</code></pre><p>② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**</p>
<pre><code class="hljs language-css">  父元素 {
      <span class="hljs-attr">display</span>:flex;
      justify-<span class="hljs-attr">content</span>:center;
      align-<span class="hljs-attr">items</span>:center;
  }
    
</code></pre><ul>
<li><strong>1：使用css3变形来实现</strong></li>
</ul>
<p>① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中</p>
<pre><code class="hljs language-css">  元素{
      <span class="hljs-attr">position</span>:fixed;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(-<span class="hljs-number">50</span>%) <span class="hljs-title function_">translateY</span>(-<span class="hljs-number">50</span>%);
  }
</code></pre><p>② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中</p>
<pre><code class="hljs language-css">  父元素{
      <span class="hljs-attr">position</span>:relative;
  }
  子元素{
      <span class="hljs-attr">position</span>:absolute;
      <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">top</span>:<span class="hljs-number">50</span>%;
      <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translate</span>(-<span class="hljs-number">50</span>%,-<span class="hljs-number">50</span>%);
  }
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. 请解释 TypeScript 中类型断言和类型守卫的区别，并分别举例说明</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> 类型断言：类型断言是一种告诉 TypeScript 编译器某个变量具有特定类型的方式，它不会进行运行时检查，只是在编译阶段影响类型系统。开发者需要确保断言的正
确性，否则可能导致运行时错误。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 定义一个变量，类型为 unknown</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: unknown = <span class="hljs-string">&#x27;hello&#x27;</span>;

<span class="hljs-comment">// 使用类型断言将 unknown 类型断言为 string 类型</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (value <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strLength); <span class="hljs-comment">// 输出: 5</span>
</code></pre><ul>
<li><strong>1：</strong> 类型守卫：类型守卫是在运行时检查某个变量是否符合特定类型的条件，根据检查结果缩小变量的类型范围，使得在特定代码块内可以安全地使用该类型的属性和方法。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 定义一个类型守卫函数，检查值是否为字符串</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value: unknown</span>): value is string {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: unknown = <span class="hljs-string">&#x27;hello&#x27;</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isString</span>(value)) {
    <span class="hljs-comment">// 在这个代码块内，TypeScript 知道 value 是 string 类型</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = value.<span class="hljs-property">length</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strLength); <span class="hljs-comment">// 输出: 5</span>
}
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. node.js的同步和异步编程是什么意思？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。</p>
</li>
<li><p>而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。</p>
</li>
<li><p>Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. bind、call、apply 区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同</li>
<li><strong>1：</strong> 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a = { <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> }
<span class="hljs-keyword">function</span>
  <span class="hljs-title function_">getValue</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)
}
getValue.<span class="hljs-title function_">call</span>(a, <span class="hljs-string">&#x27;yck&#x27;</span>,<span class="hljs-string">&#x27;24&#x27;</span>)
getValue.<span class="hljs-title function_">apply</span>(a,[<span class="hljs-string">&#x27;yck&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>])
</code></pre><ul>
<li><strong>1：</strong> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 说一下 Vue 的 computed 的实现原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。</p>
<p>它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。</p>
<p>收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty</p>
<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>
<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。</p>
<p>如果 dirty 为 false，则直接返回 watcher 的 value</p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher</p>
<p>当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算</p>
<p>而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 为什么要初始化 CSS 样式</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 什么是事件冒泡和事件捕获？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 事件冒泡：事件从目标元素开始，向上冒泡到 document;</li>
<li><strong>1：</strong> 事件捕获：事件从 document 开始，向下捕获到目标元素;</li>
<li><strong>1：</strong> 事件流顺序: 1.捕获 -&gt; 2.目标 -&gt; 3.冒泡;</li>
<li><strong>2：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么情况会阻塞渲染</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。</p>
</li>
<li><p><strong>4：</strong></p>
<ul>
<li>当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。</li>
<li>如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</li>
<li>script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。</li>
<li>对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. 迭代查询与递归查询</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</p>
</li>
<li><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</p>
</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. Nodejs的内存泄漏排查方法有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js的内存泄漏排查方法有以下几种：</p>
<ul>
<li><p>使用Node.js自带的内存分析工具，如<code>process.memoryUsage()</code>和<code>heapdump</code>模块。</p>
</li>
<li><p>使用第三方内存分析工具，如Chrome DevTools、VisualVM等。</p>
</li>
<li><p>使用内存泄漏检测工具，如<code>leak</code>、<code>memwatch</code>等。</p>
</li>
<li><p>使用代码审查和静态分析工具，如ESLint、JSHint等。</p>
</li>
<li><p>使用单元测试和集成测试，确保代码的正确性和稳定性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 如何判断一个变量是不是数组？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>instanceof Array</p>
</li>
<li><p>Array.isArray();</p>
</li>
<li><p>Object.prototype.toString.call();</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. typeof NaN 的结果是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 为什么有时候⽤translate来改变位置⽽不是定位？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 简述 NonNullable 类型工具的作用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> <code>NonNullable&lt;T&gt;</code> 用于从类型 T 中排除 null 和 undefined 类型。示例：</li>
</ul>
<pre><code class="hljs language-ts">type <span class="hljs-title class_">MaybeString</span> = string | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>;
type <span class="hljs-title class_">DefiniteString</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-title class_">MaybeString</span>&gt;; 
<span class="hljs-comment">// DefiniteString 类型为 string</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. Vue 3 生命周期钩子有什么变化？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. HTML5 中的WebSocket是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>基于TCP的全双工通信协议</li>
<li>服务器可以主动推送数据</li>
<li>建立在HTTP协议之上</li>
<li>使用ws://或wss://作为协议前缀</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>持久连接</li>
<li>全双工通信</li>
<li>数据格式轻量</li>
<li>更好的实时性</li>
</ul>
</li>
<li><p><strong>1：</strong> 与HTTP的区别：</p>
<ul>
<li>不需要频繁建立连接</li>
<li>服务器可以主动推送</li>
<li>更低的通信开销</li>
<li>无同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 应用场景：</p>
<ul>
<li>实时聊天</li>
<li>游戏通信</li>
<li>实时数据展示</li>
<li>协同编辑</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. 如何减少页面回流和重绘？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流</li>
<li><strong>1：</strong> 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流</li>
<li><strong>1：</strong> 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式</li>
<li><strong>1：</strong> 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。</li>
<li><strong>1：</strong> 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Rollup 的preserveModules选项有什么作用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> preserveModules选项会保留原始的模块结构，输出的文件中每个模块会单独成为一个文件，并且保持目录结构。这在需要保持模块结构清晰，或者需要对每个模块进行单独处理时很有用。例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;input.js&#x27;</span>,
    <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,
        <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;es&#x27;</span>,
        <span class="hljs-attr">preserveModules</span>: <span class="hljs-literal">true</span>
    }
};
<span class="hljs-comment">//这样会在dist目录下按照原始模块结构生成多个文件。</span>
<span class="hljs-comment">//如果你对这些面试题的答案还有更深入的问题，或者还想补充一些特定的知识点考察，欢迎随时告诉我。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">前端如何防止点击劫持？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. HTML5的离线储存怎么使用，它的工作原理是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p>**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.</p>
<p>使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<pre><code class="hljs language-html">
  &lt;html lang=<span class="hljs-string">&quot;en&quot;</span> manifest=<span class="hljs-string">&quot;index.manifest&quot;</span>&gt;
</code></pre><p>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p>
<pre><code class="hljs language-html">
  <span class="hljs-variable constant_">CACHE</span> <span class="hljs-variable constant_">MANIFEST</span>
    #v0<span class="hljs-number">.11</span>
    <span class="hljs-attr">CACHE</span>:
    js/app.<span class="hljs-property">js</span>
    css/style.<span class="hljs-property">css</span>
    <span class="hljs-attr">NETWORK</span>:
    resourse/logo.<span class="hljs-property">png</span>
    <span class="hljs-attr">FALLBACK</span>:
    <span class="hljs-regexp">/ /</span>offline.<span class="hljs-property">html</span>
</code></pre><p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</p>
<p>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</p>
<p>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</p>
<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. keep-alive的常用属性有哪些及实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<p>常用的两个属性include/exclude，允许组件有条件的进行缓存。</p>
<p>两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。</p>
<p>keep-alive的中还运用了LRU(Least Recently Used)算法。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 HTTP 中响应体的 Connection 字段指定为 keep-alive</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. JS 数据类型有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；</li>
<li><strong>1：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">iframe 风险</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。</li>
<li><strong>1：</strong>  <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：主要用于移动端开发，设置视口的属性，<code>width=device-width</code> 表示视口
宽度等于设备的屏幕宽度，<code>initial-scale=1.0</code> 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;description&quot; content=&quot;这是一个关于 HTML 面试题的页面描述&quot;&gt;</code>：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜
索排名和用户点击行为，因此应该简洁且准确地描述页面内容。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, 面试题, 网页开发&quot;&gt;</code>：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为
搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. HTTP 常用的请求方式，区别和用途？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>http/1.1 规定如下请求方法：</p>
<ul>
<li><p>GET：通用获取数据</p>
</li>
<li><p>HEAD：获取资源的元信息</p>
</li>
<li><p>POST：提交数据</p>
</li>
<li><p>PUT：修改数据</p>
</li>
<li><p>DELETE：删除数据</p>
</li>
<li><p>CONNECT：建立连接隧道，用于代理服务器</p>
</li>
<li><p>OPTIONS：列出可对资源实行的请求方法，常用于跨域</p>
</li>
<li><p>TRACE：追踪请求-响应的传输路径</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 如何在 TypeScript 中定义一个只读属性的接口？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用 readonly 关键字。例如：</li>
</ul>
<pre><code class="hljs language-ts">interface <span class="hljs-title class_">Person</span> {
  readonly <span class="hljs-attr">name</span>: string;
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
<span class="hljs-comment">// p.name = &quot;Doe&quot;;  // 错误，不能修改只读属性</span>
</code></pre></details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-14T06:27:01.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DR-CRcVW\",\"ing.md\":\"5u8N9YHE\",\"readme.md\":\"BO7L1nGd\",\"src_guide_getting-started.md\":\"BL_q6Ue2\",\"src_guide_why.md\":\"D9J8LAG8\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DcQeWWsV\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"DwhFqmEd\",\"src_questions_computer-base_1_计算机硬件.md\":\"BEuR0vGs\",\"src_questions_computer-base_2_计算机软件.md\":\"BjIdeU2K\",\"src_questions_computer-base_3_计算机网络.md\":\"D0cgmLEE\",\"src_questions_computer-base_4_计算机编程.md\":\"CMYadLtf\",\"src_questions_computer-base_5_计算机科学.md\":\"B4axBKUR\",\"src_questions_computer-base_6_软件工程.md\":\"Draq3Zd6\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"DJqPu91Q\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"glBfufB5\",\"src_questions_data-structures-algorithms_1_算法.md\":\"B3MBj-pW\",\"src_questions_front-architect_1_前端架构.md\":\"DEiliwZN\",\"src_questions_front-base_1_html.md\":\"7eQWgNwI\",\"src_questions_front-base_2_css.md\":\"B9SAoPEq\",\"src_questions_front-base_3_javascript.md\":\"DGSj343P\",\"src_questions_front-base_4_typescript.md\":\"CFBsX3A4\",\"src_questions_front-component_1_ui组件库.md\":\"DV463euX\",\"src_questions_front-component_2_业务组件库.md\":\"In8RE9n3\",\"src_questions_front-engineering_1_前端标准化.md\":\"HOR6L34l\",\"src_questions_front-engineering_2_前端自动化.md\":\"4eN3C8u2\",\"src_questions_front-engineering_3_webpack.md\":\"C5tOso6L\",\"src_questions_front-engineering_4_vite.md\":\"Bop_fEoV\",\"src_questions_front-engineering_5_rollup.md\":\"zPKOYs4K\",\"src_questions_front-frame_1_react.md\":\"BUAn8I8g\",\"src_questions_front-frame_2_vue.md\":\"CQ4vRVvZ\",\"src_questions_front-frame_3_next.md\":\"C1mviGo9\",\"src_questions_front-frame_4_nuxt.md\":\"Bmm06HKq\",\"src_questions_front-frame_5_qiankun.md\":\"a35X8AbZ\",\"src_questions_front-newest_1_前端最前沿.md\":\"Bs3MACdv\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DuqkDZEw\",\"src_questions_front-runtime_1_浏览器.md\":\"B_ikF5EJ\",\"src_questions_front-runtime_2_nodejs.md\":\"Cy_garHb\",\"src_questions_front-safety_1_前端安全.md\":\"BDsXyF_-\",\"src_questions_server_1_nest.md\":\"Bs698SMq\",\"src_questions_server_2_mongodb.md\":\"CeTKWpP9\",\"src_questions_server_3_mysql.md\":\"DQMVdoJZ\",\"src_questions_server_4_nginx.md\":\"Du-5ryhs\",\"src_questions_server_5_docker.md\":\"Im4aj6DF\",\"src_questions_server_6_kubernets.md\":\"Bwso7S1m\",\"src_questions_server_7_nacos.md\":\"BJsq7EXT\",\"src_questions_server_8_redis.md\":\"DDhlAmtA\",\"src_training_training-architecture_index.md\":\"BOePXhi9\",\"src_training_training-experts_index.md\":\"B53GKTpD\",\"src_training_training-intermediate_index.md\":\"Dh43bU4g\",\"src_training_training-primary_index.md\":\"C3Wt8LlC\",\"src_training_training-senior_index.md\":\"dVTv3L9z\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>