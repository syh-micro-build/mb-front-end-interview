<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfdlugHt.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.UPCtyyuv.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CjDcszOu.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.5WXdMwYP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.Bx7u4ngQ.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.CXaiaEIx.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. 对 CSSSprites 的理解</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p>优点：</p>
<ul>
<li><p>减少HTTP请求数，极大地提高页面加载速度</p>
</li>
<li><p>增加图片信息重复度，提高压缩比，减少图片大小</p>
</li>
<li><p>减少图片的总大小</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>图片合并麻烦</p>
</li>
<li><p>维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. 说一下 Vue complier 的实现原理是什么样的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode</p>
<p>complier 主要分为 3 大块：</p>
<ul>
<li><p>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</p>
</li>
<li><p>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</p>
</li>
<li><p>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. 请阐述 HTML5 中 `&lt;template&gt;` 元素的特点和优势</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  特点：<code>&lt;template&gt;</code> 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片
段，包括标签、文本、样式等。</li>
<li><strong>1：</strong>  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP 三次握手与四次挥手</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>TCP 三次握手</li>
<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>
<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服
务器同意建立连接。</li>
<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成
功。此时，双方都确认连接已建立，可以开始数据传输。</li>
<li>TCP 四次挥手</li>
<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>
<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据
未发送完，所以先不关闭连接。</li>
<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>
<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段
时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 什么是静态网页？什么是动态网页？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });
<span class="hljs-comment">//Proxy 能对对象的所有操作进行拦截，包括属性的读取、设置、删除等，从而实现更精准的响应式追踪。</span>
</code></pre><ul>
<li><strong>1：</strong> 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。</li>
<li><strong>1：</strong> 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() =&gt; console.log(&#39;Delayed&#39;), 1000);，1 秒后会执行一次回调打印Delayed。
setInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() =&gt; console.log(&#39;Repeating&#39;), 1000);，每隔 1 秒就会执行一次回调打印Repeating。</li>
<li><strong>1：</strong> 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() =&gt; console.log(&#39;Timeout&#39;), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。
    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">77. v-if和v-for为什么不能连用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。</p>
<p>如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。</p>
<p>要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">iframe 风险</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件
的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。</li>
<li><strong>1：</strong> 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，
让这些组件都通过这个 HOC 来获得权限验证功能。</li>
<li><strong>1：</strong> 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专
注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Node.js的优点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。</p>
</li>
<li><p>单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p>
</li>
<li><p>开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p>
</li>
<li><p>跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。</p>
</li>
<li><p>高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。</p>
</li>
<li><p>数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. link和@import的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li><p>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p>
</li>
<li><p>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p>
</li>
<li><p>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p>
</li>
<li><p>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. CSS 有哪些选择器？权重是如何计算的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong><ul>
<li>基本选择器：ID 选择器 &gt; 类选择器/伪类选择器/属性选择器 &gt; 元素选择器/伪元素选择器 &gt; 通配符选择器</li>
<li>关系选择器：后代选择器、父子选择器、兄弟选择器</li>
</ul>
</li>
<li><strong>1：</strong> ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. 什么是执行上下文和执行栈？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。</p>
</li>
<li><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. CommonJS和ES6模块的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>CommonJS模块是同步加载的，ES6模块是异步加载的。</p>
</li>
<li><p>CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。</p>
</li>
<li><p>CommonJS模块的导入是动态的，ES6模块的导入是静态的。</p>
</li>
<li><p>CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。</p>
</li>
<li><p>CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。</p>
</li>
<li><p>CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. return，break，continue的区别是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用</p>
</li>
<li><p>break 跳出循环，剩余的循环不再执行</p>
</li>
<li><p>continue  跳出本次循环，剩余的循环继续执行</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是服务器端渲染（SSR）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 解释 Set 和 Map 的使用及区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Set：是一个集合，用于存储不重复的值，按照插入顺序排列。</li>
<li><strong>1：</strong> Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// Set</span>
<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 会被忽略</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set { 1, 2 }</span>

<span class="hljs-comment">// Map</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">25</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// Alice</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. bind、call、apply 区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同</li>
<li><strong>1：</strong> 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a = { <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> }
<span class="hljs-keyword">function</span>
  <span class="hljs-title function_">getValue</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)
}
getValue.<span class="hljs-title function_">call</span>(a, <span class="hljs-string">&#x27;yck&#x27;</span>,<span class="hljs-string">&#x27;24&#x27;</span>)
getValue.<span class="hljs-title function_">apply</span>(a,[<span class="hljs-string">&#x27;yck&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>])
</code></pre><ul>
<li><strong>1：</strong> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是多核处理器（Multi-Core Processor）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 什么是事件冒泡和事件捕获？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 事件冒泡：事件从目标元素开始，向上冒泡到 document;</li>
<li><strong>1：</strong> 事件捕获：事件从 document 开始，向下捕获到目标元素;</li>
<li><strong>1：</strong> 事件流顺序: 1.捕获 -&gt; 2.目标 -&gt; 3.冒泡;</li>
<li><strong>2：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 介绍一下Promise</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。</p>
<p>Promise 对象有三种状态：</p>
<ul>
<li><p>Pending（进行中）：初始状态，既不是成功，也不是失败状态。</p>
</li>
<li><p>Fulfilled（已成功）：意味着操作成功完成。</p>
</li>
<li><p>Rejected（已失败）：意味着操作失败。</p>
</li>
</ul>
<p>Promise 对象使用 <code>then</code> 方法来处理成功和失败的情况。<code>then</code> 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {


})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>
<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. CSS哪些属性可以继承</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> 不可继承的</p>
<ul>
<li><p>display
指定元素的显示方式，常见的值包括：
block：块级元素，占据整行
inline：行内元素，只占据必要的宽度，不换行
inline-block：结合了 inline 和 block 的特性
none：隐藏元素</p>
</li>
<li><p>margin
设置元素外部的空白区域，即元素与其他元素之间的距离</p>
</li>
<li><p>border
设置元素的边框可以指定边框的宽度、样式和颜色</p>
</li>
<li><p>padding
设置元素内容与边框之间的内边距，控制元素内部的空白区域</p>
</li>
<li><p>background
设置元素的背景，包括背景颜色、背景图像等</p>
</li>
<li><p>height
指定元素的高度</p>
</li>
<li><p>min-height
设置元素的最小高度，元素的高度不能小于此值</p>
</li>
<li><p>max-height
设置元素的最大高度，元素的高度不能超过此值</p>
</li>
<li><p>width
指定元素的宽度</p>
</li>
<li><p>min-width
设置元素的最小宽度，元素的宽度不能小于此值</p>
</li>
<li><p>max-width
设置元素的最大宽度，元素的宽度不能超过此值</p>
</li>
<li><p>overflow
控制当内容溢出元素的边界时如何显示常见的值：
  visible：内容溢出时可见
  hidden：内容溢出时隐藏
  scroll：出现滚动条
  auto：根据需要自动显示滚动条</p>
</li>
<li><p>position
设置元素的定位方式常见的值：
  static：默认值，元素按文档流排列
  relative：相对定位，元素相对于其原始位置偏移
  absolute：绝对定位，元素相对于最近的已定位祖先元素定位
  fixed：固定定位，元素相对于浏览器窗口定位
  sticky：粘性定位，元素在滚动到特定位置时变为固定定位</p>
</li>
<li><p>top, bottom, left, right
当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量</p>
</li>
<li><p>z-index
控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效</p>
</li>
<li><p>float
指定元素是否浮动（通常用于让文本环绕图片等）常见的值：
  left：元素向左浮动
  right：元素向右浮动
  none：取消浮动</p>
</li>
<li><p>clear
控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：
  left：禁止元素左侧有浮动元素
  right：禁止元素右侧有浮动元素
  both：禁止元素两侧有浮动元素
  none：允许两侧都有浮动元素</p>
</li>
<li><p>table-layout
控制表格布局的算法常见的值：
  auto：浏览器根据内容调整列宽（默认）
  fixed：浏览器根据表格的宽度固定列宽</p>
</li>
<li><p>vertical-align
控制元素在垂直方向上的对齐方式常见的值：
  top：元素顶部对齐
  middle：元素垂直居中对齐
  bottom：元素底部对齐</p>
</li>
<li><p>page-break-after
控制分页符的位置常见的值：
  auto：默认，自动决定分页
  always：强制分页
  avoid：避免分页</p>
</li>
<li><p>page-break-before
与 page-break-after 类似，控制元素前面的分页符</p>
</li>
<li><p>unicode-bidi
控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：
  normal：正常的双向文本布局
  embed：强制嵌入的文本遵循本地的方向性
  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值</p>
</li>
</ul>
</li>
<li><p><strong>1：</strong> 所有元素可继承的</p>
<ul>
<li><p>visibility
visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；
常见值包括：
  visible（默认值）：元素是可见的
  hidden：元素不可见，但仍然占据空间
  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 <code>&lt;tr&gt;、&lt;th&gt;、&lt;td&gt;</code> 等表格元素）</p>
</li>
<li><p>cursor
cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；
常见值包括：
  auto：默认指针，浏览器根据上下文决定指针样式
  pointer：显示手形指针，通常用于可点击的链接或按钮
  default：默认的光标样式
  none：隐藏鼠标指针
  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行
  move：显示一个四向箭头，表示可以移动元素
  text：显示文本光标，通常用于文本输入区域
  not-allowed：显示禁用的指针，通常表示该操作不可用
  help：显示问号光标，通常表示需要帮助的地方</p>
</li>
</ul>
</li>
<li><p><strong>1：</strong> 终极块级元素可继承的</p>
<ul>
<li><p>text-indent
text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 <code>&lt;p&gt;、&lt;div&gt;</code> 等，控制块内文本的缩进量；常见值：
  length：指定缩进的距离，例如 20px 或 2em
  %：表示缩进的百分比，基于元素的宽度
  initial：将属性恢复为默认值</p>
</li>
<li><p>text-align
text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：
  left：将文本对齐到左边
  right：将文本对齐到右边
  center：将文本居中
  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器
  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式</p>
</li>
</ul>
</li>
<li><p><strong>1：</strong> 内联元素可继承的</p>
<ul>
<li><p>letter-spacing
letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：
  normal：默认的字符间距，通常为 0
  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em</p>
</li>
<li><p>word-spacing
word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。
常见值：
  normal：默认的单词间距。
  length：指定单词间距，可以使用 px、em、rem 等单位。</p>
</li>
<li><p>white-space
white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：
  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行
  nowrap：文本不会换行，所有空白字符会被合并为一个空格
  pre：保留空格和换行符，类似于 <code>&lt;pre&gt;</code> 标签的效果
  pre-wrap：保留空格和换行符，文本会自动换行
  pre-line：合并多个空白字符，但保留换行符</p>
</li>
<li><p>line-height
line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：
  normal：默认的行高，通常为字体大小的 1.2 倍。
  number：指定行高为字体大小的倍数。
  length：指定固定的行高值，如 20px、1.5em。
  percentage：指定行高为字体大小的百分比。</p>
</li>
<li><p>color
color 用于设置文本的颜色，常见值：
  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。</p>
</li>
<li><p>font</p>
<p>font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：
  font-style、font-variant、font-weight、font-size、line-height、font-family</p>
</li>
<li><p>font-size
font-size 用于设置文本的大小；常见值：
  length：如 12px、1em、0.75rem。
  percentage：相对于父元素的字体大小，如 150%。
  medium：默认字体大小。
  larger / smaller：相对于父元素字体大小的大小调整。</p>
</li>
<li><p>font-style
font-style 用于设置文本的样式，通常用于斜体文本；常见值：
  normal：正常样式
  italic：斜体
  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形</p>
</li>
<li><p>font-variant
font-variant 用于控制文本是否使用变体字体；常见值：
  normal：正常字体。
  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。</p>
</li>
<li><p>font-weight
font-weight 用于设置文本的粗细；常见值：
  normal：正常的字体粗细
  bold：加粗字体
  bolder：比父元素更粗
  lighter：比父元素更细
  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗</p>
</li>
<li><p>text-decoration
text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：
  none：无装饰
  underline：下划线
  overline：上划线
  line-through：删除线
  blink：闪烁的文本（大多数浏览器已不支持）</p>
</li>
<li><p>text-transform
text-transform 用于控制文本的大小写转换；常见值：
  none：不转换大小写
  capitalize：将每个单词的首字母转换为大写
  uppercase：将所有字母转换为大写
  lowercase：将所有字母转换为小写</p>
</li>
<li><p>direction
direction 用于设置文本的书写方向；常见值：
  ltr：从左到右（默认）
  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言</p>
</li>
</ul>
</li>
<li><p><strong>1：</strong> 列表元素可继承的属性</p>
<ul>
<li><p>list-style
list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：
  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。
  list-style-position：标记的位置，inside 或 outside。
  list-style-image：指定列表项标记为图片。</p>
</li>
<li><p>list-style-type
list-style-type 用于设置列表项的标记类型；常见值：
  disc：实心圆点（默认）
  circle：空心圆点
  square：方块
  decimal：数字列表（如 1, 2, 3）
  none：没有标记</p>
</li>
<li><p>list-style-position
list-style-position 用于设置列表标记的位置；常见值：
  outside：标记在列表项外部（默认）
  inside：标记在列表项内部</p>
</li>
<li><p>list-style-image
list-style-image 用于设置列表项标记为自定义图像；常见值：<code>url(&lt;image-url&gt;)：指定图像的 URL，如 url(&#39;bullet.png&#39;)</code></p>
</li>
</ul>
</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. ?.、??、!、!.、_、** 等符号的含义？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行</li>
<li><strong>1：</strong> ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</li>
<li><strong>1：</strong> ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined</li>
<li><strong>1：</strong> !. 在变量名后添加，可以断言排除undefined和null类型</li>
<li><strong>1：</strong> _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324</li>
<li><strong>1：</strong> ** 求幂</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. CSS Grid 布局的基本概念和使用方法是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> Grid布局的基本概念：</p>
<ul>
<li>Grid Container：设置 display: grid 的元素</li>
<li>Grid Item：Grid Container 的直接子元素</li>
<li>Grid Line：构成网格结构的分界线</li>
<li>Grid Track：两条相邻网格线之间的空间</li>
<li>Grid Cell：网格中的单元格</li>
<li>Grid Area：任意数量的网格单元格组成的区域</li>
</ul>
</li>
<li><p><strong>2：</strong> 基本使用示例：</p>
</li>
</ul>
<pre><code class="hljs language-css">.<span class="hljs-property">container</span> {
    <span class="hljs-attr">display</span>: grid;
    <span class="hljs-comment">/* 定义列的大小和数量 */</span>
    grid-template-<span class="hljs-attr">columns</span>: 100px 100px 100px;
    <span class="hljs-comment">/* 定义行的大小和数量 */</span>
    grid-template-<span class="hljs-attr">rows</span>: 100px 100px;
    <span class="hljs-comment">/* 设置间距 */</span>
    <span class="hljs-attr">gap</span>: 10px;
}

.<span class="hljs-property">item</span> {
    <span class="hljs-comment">/* 指定元素位置 */</span>
    grid-<span class="hljs-attr">column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">/* 从第1条网格线到第3条网格线 */</span>
    grid-<span class="hljs-attr">row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* 从第1条网格线到第2条网格线 */</span>
}
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 如何实现一个类型工具 `IsNever&lt;T&gt;`，用于判断一个类型 T 是否为 never 类型？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 使用 <code>[T]</code> extends <code>[never]</code> 来判断，因为直接 T extends never 会有特殊处理，而包装成元组可以正确判断。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 答案</span>
type <span class="hljs-title class_">IsNever</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [never]? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// 测试</span>
type <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">IsNever</span>&lt;never&gt;; <span class="hljs-comment">// true</span>
type <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">IsNever</span>&lt;string&gt;; <span class="hljs-comment">// false</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 解释 TypeScript 中的类型断言（Type Assertion）及其作用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 类型断言是一种告诉编译器某个值的类型的方式，它允许开发者手动指定一个值的类型，而不是让编译器自动推断。有两种语法形式：as语法和尖括号语法。例如：</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// as语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (someValue <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;

<span class="hljs-comment">// 尖括号语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="hljs-property">length</span>;
</code></pre><ul>
<li><strong>1：</strong> 类型断言的作用主要是在某些情况下，当编译器无法准确推断类型或者开发者确定某个值的类型时，通过类型断言来告诉编译器，以便进行更准确的类型检查和代码提示，避免类型错误。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. ES5、ES6 如何实现继承?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承</p>
</li>
<li><p>ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. Vue 如何清除浏览器缓存？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；</p>
</li>
<li><p>在 html 文件中加入 meta 标签，content 属性设置为no-cache;</p>
</li>
<li><p>在后端服务器中进行禁止缓存设置。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Mac 安装 Nginx</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<pre><code class="hljs language-shell"># 基于 brew 安装 <span class="hljs-title class_">Nginx</span>

# 安装 <span class="hljs-title class_">Nginx</span>
brew install nginx
</code></pre><p><img src="/public/images/4_Nginx_20241231111116.png" alt=""></p>
<p><a href="https://juejin.cn/post/6883018403641032712">常用指令</a></p>
<pre><code class="hljs language-shell">
# 查看配置信息
brew info nginx

# 查看 <span class="hljs-title class_">Nginx</span> 配置文件内容
cat /opt/homebrew/etc/nginx/nginx.<span class="hljs-property">conf</span>

# 查看 <span class="hljs-title class_">Nginx</span> 进程
ps -ef | grep nginx

# 查看 <span class="hljs-title class_">Nginx</span> 进程数
ps -ef | grep nginx | wc -l

# 查看 <span class="hljs-title class_">Nginx</span> 进程 <span class="hljs-variable constant_">ID</span>
ps -ef | grep nginx | awk <span class="hljs-string">&#x27;{print $2}&#x27;</span>

# 查看 <span class="hljs-title class_">Nginx</span> 进程 <span class="hljs-variable constant_">ID</span> 的个数
ps -ef | grep nginx | awk <span class="hljs-string">&#x27;{print $2}&#x27;</span> | wc -l
</code></pre><p><img src="/public/images/4_Nginx_20241231113535.png" alt=""></p>
<pre><code class="hljs language-shell"># 启动 <span class="hljs-title class_">Nginx</span>
brew services start nginx

# 打开界面时，记得查看端口是否被占用
# 重启 <span class="hljs-title class_">Nginx</span>
brew services restart nginx

# 停止 <span class="hljs-title class_">Nginx</span>
brew services stop nginx

# 取消进程
sudo kill 进程 <span class="hljs-variable constant_">ID</span>
</code></pre></details></div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. 说一下 ref 的作用是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：</p>
<ul>
<li><p>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素</p>
</li>
<li><p>基本用法，本页面获取 DOM 元素</p>
</li>
<li><p>获取子组件中的 data</p>
</li>
<li><p>调用子组件中的方法</p>
</li>
<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. React 中如何处理事件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);
  };

  <span class="hljs-keyword">return</span> &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
}
</code></pre><ul>
<li><strong>1：</strong> React 会自动绑定事件处理函数。</li>
<li><strong>1：</strong> 事件对象会被 React 规范化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何在 Nuxt.js 中配置和使用环境变量？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定
义变量，如<code>API_URL=&lt;http://localhost:3000/api（开发环境下的&gt; API 地址）</code>。</li>
<li><strong>1：</strong> 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-attr">modules</span>: [
  <span class="hljs-string">&#x27;@nuxtjs/dotenv&#x27;</span>
]
</code></pre><ul>
<li><strong>1：</strong> 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在
不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. table的作用以及其优缺点</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>作用</p>
<ul>
<li><p>可用于布局（已过时）；</p>
</li>
<li><p>用于显示批量数据；</p>
</li>
</ul>
<p>优点</p>
<p>在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；</p>
<p>缺点</p>
<p>Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；</p>
<p>Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；</p>
<p>灵活性差，比如要通多td才能设置tr的border属性；</p>
<p>代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；</p>
<p>混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；</p>
<p>深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；</p>
<p>不够语义。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器的渲染过程</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li><strong>1：</strong> 然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li><strong>1：</strong> 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li><strong>1：</strong> 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li><strong>1：</strong> 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
</li>
<li><p>toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。</p>
</li>
</ul>
<pre><code class="hljs language-js">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器 Eventloop</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题</p>
</li>
<li><p><strong>1：</strong> JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为</p>
</li>
<li><p><strong>1：</strong> 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 <code>不得⼩于 4 毫秒</code>，不⾜会⾃动增加。所以 setTimeout 还是会在 script end
 之后打印</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);
},<span class="hljs-number">0</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);
</code></pre><ul>
<li><strong>1：</strong> 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)
    <span class="hljs-title function_">resolve</span>()
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);

<span class="hljs-comment">// 结果</span>
<span class="hljs-comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTime</span>
</code></pre><ul>
<li><p><strong>1：</strong> 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver</p>
</li>
<li><p><strong>1：</strong> 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin</p>
</li>
</ul>
<p>注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务</p>
<ul>
<li><p><strong>1：</strong> 正确的⼀次 Event loop 顺序是这样的：</p>
<p>  执⾏同步代码，这属于宏任务</p>
<p>  执⾏栈为空，查询是否有微任务需要执⾏</p>
<p>  执⾏所有微任务</p>
<p>  必要的话渲染 UI</p>
<p>  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码</p>
</li>
</ul>
<p>注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中</p>
</details>

</div></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-23T06:58:03.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"BVdWOOGE\",\"ing.md\":\"C2RMowPG\",\"readme.md\":\"BZv3p58O\",\"src_guide_getting-started.md\":\"Dv7vU2cL\",\"src_guide_why.md\":\"Bgh3KYO5\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"CXYy7gyd\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"B18pheR7\",\"src_questions_computer-base_1_计算机硬件.md\":\"GOqZzQi3\",\"src_questions_computer-base_2_计算机软件.md\":\"dnAUYSYr\",\"src_questions_computer-base_3_计算机网络.md\":\"CKpKDBRT\",\"src_questions_computer-base_4_计算机编程.md\":\"Cy9WRY0u\",\"src_questions_computer-base_5_计算机科学.md\":\"CIEJOHPe\",\"src_questions_computer-base_6_软件工程.md\":\"yNN4fdgV\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BVfkNten\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"BegF1Mp_\",\"src_questions_data-structures-algorithms_1_算法.md\":\"LxfL5D1T\",\"src_questions_front-architect_1_前端架构.md\":\"7w_45Gqw\",\"src_questions_front-base_1_html.md\":\"CYAJCe5u\",\"src_questions_front-base_2_css.md\":\"Duh42jXN\",\"src_questions_front-base_3_javascript.md\":\"lzpztEdc\",\"src_questions_front-base_4_typescript.md\":\"CQ42UGdn\",\"src_questions_front-component_1_ui组件库.md\":\"_EcP5sAb\",\"src_questions_front-component_2_业务组件库.md\":\"DWyXS_8t\",\"src_questions_front-engineering_1_前端标准化.md\":\"DtShkZ71\",\"src_questions_front-engineering_2_前端自动化.md\":\"DD-F8Ovu\",\"src_questions_front-engineering_3_webpack.md\":\"CpAj-XNg\",\"src_questions_front-engineering_4_vite.md\":\"DEQ1gx6A\",\"src_questions_front-engineering_5_rollup.md\":\"BcdGBbyC\",\"src_questions_front-frame_1_react.md\":\"BVVmzf06\",\"src_questions_front-frame_2_vue.md\":\"Cvs4WoPj\",\"src_questions_front-frame_3_next.md\":\"DsqCtipk\",\"src_questions_front-frame_4_nuxt.md\":\"Ww_fX4tj\",\"src_questions_front-frame_5_qiankun.md\":\"D-_gopMa\",\"src_questions_front-newest_1_前端最前沿.md\":\"CWdZqRcD\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"BYpozV5n\",\"src_questions_front-runtime_1_浏览器.md\":\"CaBbkQ-9\",\"src_questions_front-runtime_2_nodejs.md\":\"iO69GskE\",\"src_questions_front-safety_1_前端安全.md\":\"CbskK0Lh\",\"src_questions_server_1_nest.md\":\"F6UZ3RkE\",\"src_questions_server_2_mongodb.md\":\"BbrDp5R6\",\"src_questions_server_3_mysql.md\":\"BmD1qt4C\",\"src_questions_server_4_nginx.md\":\"DOOLlHQq\",\"src_questions_server_5_docker.md\":\"CdaWD3OI\",\"src_questions_server_6_kubernets.md\":\"d1UUiiQf\",\"src_questions_server_7_nacos.md\":\"Cdxji0Cr\",\"src_questions_server_8_redis.md\":\"D5yT7vpk\",\"src_training_training-architecture_index.md\":\"BxPl1uct\",\"src_training_training-experts_index.md\":\"B53GvStw\",\"src_training_training-intermediate_index.md\":\"kno1TfdN\",\"src_training_training-primary_index.md\":\"CXaiaEIx\",\"src_training_training-senior_index.md\":\"DmYXkMep\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>