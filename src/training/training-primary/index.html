<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.D_2ikLVm.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.6r0Fk3dT.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.BofWP1Zn.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.sKlbmfkT.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. src 与 href 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. DOM操作的常用API</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>创建：createElement</p>
</li>
<li><p>插入：appendChild</p>
</li>
<li><p>删除：removeChild</p>
</li>
<li><p>获取子节点：childNodes</p>
</li>
<li><p>获取子节点：parentNodes</p>
</li>
<li><p>获取兄弟节点：nextSibling</p>
</li>
<li><p>获取兄弟节点：previousSibling</p>
</li>
<li><p>获取属性：getAttribute</p>
</li>
<li><p>设置属性：setAttribute</p>
</li>
<li><p>获取元素样式：style</p>
</li>
<li><p>获取元素属性：getAttribute</p>
</li>
<li><p>设置元素属性：setAttribute</p>
</li>
<li><p>获取元素类名：className</p>
</li>
<li><p>设置元素类名：className</p>
</li>
<li><p>获取元素内容：innerHTML</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. 请解释 CSS 中 display: none 和 visibility: hidden 的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> display: none 会使元素完全从文档流中移除，该元素及其子元素所占空间消失，在页面布局中就好像这个元素不存在一样，而且元素也不会响应任何用户交互，比如点击事件等。</li>
<li><strong>1：</strong> visibility: hidden 只是让元素不可见，但元素依然占据原来在文档流中的空间，并且仍然可以响应一些用户交互，例如鼠标悬停事件（虽然看不见，但鼠标移到该位置时，事件依然会触发）。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 对 SPA 单页面的理解，它的优缺点分别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22.讲一下EventEmitter？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。</p>
</li>
<li><p>使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。</p>
</li>
<li><p>举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。</p>
</li>
<li><p>这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to read file: <span class="hljs-subst">${err}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`File content: <span class="hljs-subst">${data}</span>`</span>);
  }
});
</code></pre><ul>
<li>这是使用EventEmitter的文件读取：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> stream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>);

stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">${chunk.length}</span> bytes of data.`</span>);
});

stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Finished reading file.&#x27;</span>);
});
</code></pre><ul>
<li>很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
</li>
<li><p>toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。</p>
</li>
</ul>
<pre><code class="hljs language-js">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. Vue 3 中的Teleport功能有什么作用，如何使用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 <code>&lt;teleport&gt;</code> 标签包裹需要瞬移的元素，并
指定to属性为目标 DOM 元素的选择器或id。例如:</li>
</ul>
<pre><code class="hljs language-js">&lt;teleport to=<span class="hljs-string">&quot;#app-root&quot;</span>&gt;...&lt;/teleport&gt;
<span class="hljs-comment">//会将包裹的元素移动到id为app-root的元素内部。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 简述 Vuex 的核心概念和工作流程</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 核心概念:<br/>
&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>
&emsp;Mutations：用于同步修改 State 中的数据。
是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>
&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>
&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>
<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，
Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化
和组件的更新。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 几种Doctype文档类型</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<p>HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；</p>
<p>XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；</p>
<p>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；</p>
<p>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">热插拔（Hot Swap）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. CSS 动画和过渡的区别是什么？如何使用它们？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> 过渡（Transition）：<ul>
<li>从一个状态到另一个状态的平滑过渡</li>
<li>需要触发条件（如hover）</li>
<li>只能定义开始和结束状态</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">.<span class="hljs-property">element</span> {
    <span class="hljs-attr">width</span>: 100px;
    <span class="hljs-attr">transition</span>: width <span class="hljs-number">0.</span>3s ease;
}

.<span class="hljs-property">element</span>:hover {
    <span class="hljs-attr">width</span>: 200px;
}
</code></pre><ul>
<li><strong>2：</strong> 动画（Animation）：<ul>
<li>可以定义多个状态的变化</li>
<li>可以循环播放</li>
<li>可以自动播放，无需触发条件</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">@keyframes slide {
    <span class="hljs-number">0</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-number">50</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(100px);
    }
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
}

.<span class="hljs-property">element</span> {
    <span class="hljs-attr">animation</span>: slide 2s ease infinite;
}
</code></pre><ul>
<li><strong>2：</strong> 主要区别：<ul>
<li>触发方式：过渡需要触发条件，动画可以自动播放</li>
<li>状态数量：过渡只有开始和结束两个状态，动画可以有多个状态</li>
<li>循环播放：动画可以循环播放，过渡不能</li>
<li>控制能力：动画的控制能力更强，可以精确控制中间状态</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 深浅拷贝的区别？如何实现一个深拷贝？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>深浅拷贝通常只针对引用类型</p>
</li>
<li><p>浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针</p>
</li>
<li><p>深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
          newObj[key]=obj[key]
        }
      }
      <span class="hljs-keyword">return</span>  newObj
} 
<span class="hljs-comment">// 咱们会浅拷贝当然还要深拷贝呀  开始</span>
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
        <span class="hljs-keyword">if</span>  ( <span class="hljs-title function_">typeof</span>(obj[key])!==obj||obj[key]===<span class="hljs-literal">null</span>){
           newObj[key]=obj[key]
        }<span class="hljs-keyword">else</span>{
           newObj[key]=<span class="hljs-title function_">shallowCopy</span>(obj[key])
        }  
        }
      }
      <span class="hljs-keyword">return</span>  newObj
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21.请解释一下Node.js的集群化工作模式？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。
在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。</p>
</li>
<li><p>此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。</p>
</li>
<li><p>总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. position:fixed; 在 android 下无效怎么处理 ？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-html">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">https是怎么保证安全的，为什么比http安全？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。</li>
<li>HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。</li>
<li>在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSRF 攻击</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>
<li><strong>:4</strong> 防御：</li>
</ul>
<blockquote>
<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>
<blockquote>
<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>
</blockquote>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 怎么理解Vue的单向数据流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>
<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 作用域链的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。</p>
<details>

<ul>
<li><strong>1：</strong> 数据类型</li>
</ul>
<pre><code class="hljs language-mermaid">graph <span class="hljs-variable constant_">TD</span>;

    A[作用域链] --&gt; B[作用域];
    A --&gt; C[词法作用域];
    A --&gt; D[作用域链];
</code></pre><ul>
<li><strong>1：</strong> 作用域</li>
</ul>
<p>作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。
例如：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-title function_">greet</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<span class="hljs-comment">// Uncaught ReferenceError: greeting is not defined</span>
</code></pre><ul>
<li><strong>1：</strong> 全局作用域</li>
</ul>
<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 全局变量</span>
<span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
</code></pre><ul>
<li><strong>1：</strong> 函数作用域</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 块级作用域</li>
</ul>
<p>ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</p>
<pre><code class="hljs language-js">{
  <span class="hljs-comment">// 块级作用域中的变量</span>
  <span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-keyword">var</span> lang = <span class="hljs-string">&#x27;English&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// Prints &#x27;Hello World!&#x27;</span>
}
<span class="hljs-comment">// 变量 &#x27;English&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lang);
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 词法作用域</li>
</ul>
<p>词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">foo</span>();
}
<span class="hljs-title function_">bar</span>();
</code></pre><ul>
<li><strong>1：</strong> 作用域链</li>
</ul>
<p>在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>
<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> sex = <span class="hljs-string">&#x27;男&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">student</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 张三</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sex); <span class="hljs-comment">// 男</span>
    }
    <span class="hljs-title function_">student</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span>
}
<span class="hljs-title function_">person</span>();

<span class="hljs-comment">/*
student 函数内部：
当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。
当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。

person 函数内部：
当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。

*/</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在前端如何安全地处理用户密码？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=&quot;password&quot;来隐藏用户输入。</li>
<li><strong>1：</strong> 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。</li>
<li><strong>1：</strong> 避免本地缓存：设置表单元素的autocomplete=&quot;off&quot;，防止浏览器缓存密码。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">XSS 攻击</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】</li>
<li><strong>:2</strong> 防御：</li>
</ul>
<blockquote>
<p>1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。<br>2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. ts 如何定义对象结构体</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。</li>
</ul>
<pre><code class="hljs language-typescript">interface <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">age</span>: number;
}
</code></pre><ul>
<li><strong>1：</strong> type 也可以用于定义类型</li>
</ul>
<pre><code class="hljs language-typescript">type <span class="hljs-title class_">Person</span> = {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">age</span>: number;
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. Vue 3 中的 toRef 和 toRefs 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>toRef：将对象的某个属性转换为 ref。</p>
<p>toRefs：将整个响应式对象的所有属性转换为 ref。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { reactive, toRef, toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> });
    <span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 单个属性</span>
    <span class="hljs-keyword">const</span> stateRefs = <span class="hljs-title function_">toRefs</span>(state); <span class="hljs-comment">// 所有属性</span>

    <span class="hljs-keyword">return</span> { nameRef, stateRefs };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Vue 组件的 data 为什么必须是函数？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">66. 如果new一个箭头函数的会怎么样?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
</li>
<li><p>new操作符的实现步骤如下：</p>
</li>
<li><p>1.创建一个对象</p>
</li>
<li><p>2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</p>
</li>
<li><p>3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</p>
</li>
<li><p>4.返回新的对象</p>
</li>
<li><p>由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>3：</strong> Nuxt 插件的作用<br/>
&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引
入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>
&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在
每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>
&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地
适配不同的环境和满足特定的需求。</li>
<li><strong>2：</strong> 编写一个自定义插件<br/>
&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>
&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">context, inject</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">myLogger</span> = (<span class="hljs-params">message</span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[MyLogger] <span class="hljs-subst">${message}</span>`</span>);
  };
  <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;myLogger&#x27;</span>, myLogger);
}
</code></pre></details></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. 什么是事件冒泡？什么是事件代理？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>事件冒泡和事件代理都是JavaScript中处理事件的机制。</p>
</li>
<li><p>事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。</p>
</li>
<li><p>事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 解释一下TypeScript中的字面量类型和联合类型的区别</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> 定义与概念<ul>
<li>字面量类型：是指由具体的字面量值所构成的类型，比如1、&#39;hello&#39;、true等，每个具体的值就是一个字面量类型。它表示变量只能取特定的单一值。</li>
<li>联合类型：是由多个不同类型通过|运算符组合而成的类型，它表示变量可以是这些类型中的任意一种。</li>
</ul>
</li>
<li><strong>2：</strong> 作用与用途<ul>
<li>字面量类型：主要用于精确地限定变量的取值范围，当我们希望变量只能取某个特定的值时，就可以使用字面量类型。例如，在表示一周中的某一天时，可以定
义<code>type Day = &#39;Monday&#39; | &#39;Tuesday&#39; | &#39;Wednesday&#39; | &#39;Thursday&#39; | &#39;Friday&#39; | &#39;Saturday&#39; | &#39;Sunday&#39;</code>，这里的每个星期几就是一个字面量类型，通过这
种方式可以确保变量只能被赋值为这些特定的字符串值。</li>
<li>联合类型：用于在变量可能有多种不同类型的情况下，为其指定多种可能的类型。比如，一个函数的参数可能接受字符串或者数字，就可以定义为
<code>function foo(arg: string | number) {}</code>，这样参数arg就可以接受字符串类型的值或者数字类型的值。</li>
</ul>
</li>
<li><strong>2：</strong> 类型检查行为<ul>
<li>字面量类型：在类型检查时，变量必须严格等于字面量的值才能通过类型检查。例如，定义const num: 5 = 5是正确的，但const num: 5 = 6就会报错，因为6不等于字面量类型5所允许的值。</li>
<li>联合类型：类型检查时，只要变量的值符合联合类型中的某一种类型，就可以通过类型检查。例如，对于<code>let value: string | number，value = &#39;hello&#39;</code>或者<code>value = 123</code>都是
可以通过类型检查的，因为它们分别符合联合类型中的string和number类型。</li>
</ul>
</li>
<li><strong>2：</strong> 可扩展性<ul>
<li>字面量类型：通常比较固定和单一，如果需要增加新的取值，就需要重新定义字面量类型。例如，在上述Day类型中，如果要增加一个新的休息日，就需要修改定义，添加新的字面量。</li>
<li>联合类型：具有较好的扩展性，当需要增加新的可能类型时，直接使用|运算符添加到联合类型中即可。比如，对于<code>function foo(arg: string | number)</code>，如果还需要支持布尔类型，只
需要修改为<code>function foo(arg: string | number | boolean)</code>。</li>
</ul>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">如何在 Nuxt.js 中配置和使用环境变量？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定
义变量，如<code>API_URL=&lt;http://localhost:3000/api（开发环境下的&gt; API 地址）</code>。</li>
<li><strong>1：</strong> 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-attr">modules</span>: [
  <span class="hljs-string">&#x27;@nuxtjs/dotenv&#x27;</span>
]
</code></pre><ul>
<li><strong>1：</strong> 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在
不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器会直接使用离线存储的资源。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Vue 3 中的 Suspense 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Suspense 用于处理异步组件的加载状态。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;AsyncComponent /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 什么是 JSX？它有什么优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.</p>
</li>
<li><p>可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。</p>
</li>
<li><p>类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。</p>
</li>
<li><p>表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。</p>
</li>
<li><p>工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. 什么是 TypeScript 中的模块（Module）？如何在模块中导出和导入成员？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> 模块定义：模块是 TypeScript 中用于组织和封装代码的一种方式，它可以将相关的代码、类型定义、函数等组合在一起，形成一个独立的单元，提高代码的可维护性和可复用性。</li>
<li><strong>1：</strong> 导出成员：使用export关键字来导出模块中的成员，如变量、函数、类、接口等。可以在定义成员时直接使用export导出，也可以在模块末尾统一使用export导出。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 方式一：直接导出</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Tom&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
}
<span class="hljs-comment">// 方式二：统一导出</span>
<span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Doing something&#x27;</span>);
}
<span class="hljs-keyword">export</span> { age, doSomething };
</code></pre><ul>
<li><strong>1：</strong> 导入成员：使用import关键字来导入模块中的成员，可以按需导入特定成员，也可以整体导入模块并通过别名访问成员。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 按需导入</span>
<span class="hljs-keyword">import</span> { name, sayHello } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span>;
<span class="hljs-comment">// 整体导入并使用别名</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module&#x27;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myModule.<span class="hljs-property">name</span>);
myModule.<span class="hljs-title function_">sayHello</span>();
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">post请求为什么会多发送一次option请求？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。<br>预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Node.js的优点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。</p>
</li>
<li><p>单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p>
</li>
<li><p>开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p>
</li>
<li><p>跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。</p>
</li>
<li><p>高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。</p>
</li>
<li><p>数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. TCP的流量控制机制</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>TCP的流量控制机制主要是通过滑动窗口来实现的。发送方和接收方都会维护一个窗口，发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。当接收方收到数据后，会发送一个ACK确认报文，其中包含接收方窗口的大小，发送方根据这个信息来调整发送窗口的大小。</p>
<ul>
<li><p>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</p>
</li>
<li><p>当数据到达时，接收方将数据放入缓冲区，并告诉发送方缓冲区中还可以容纳多少数据。</p>
</li>
<li><p>当接收方应用程序读取数据时，接收方将窗口向前滑动，并告诉发送方窗口的大小。</p>
</li>
<li><p>发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 网络协议是什么</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-08T08:19:08.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"B67Vkczo\",\"ing.md\":\"ppl6W11u\",\"readme.md\":\"DWJz_5j3\",\"src_guide_getting-started.md\":\"CpM9Yo95\",\"src_guide_why.md\":\"C0oeijep\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"Cfr6_Eoz\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"D4Qoq_T8\",\"src_questions_computer-base_1_计算机硬件.md\":\"13SsxRxA\",\"src_questions_computer-base_2_计算机软件.md\":\"CKqmY1dK\",\"src_questions_computer-base_3_计算机网络.md\":\"3uz9aJxR\",\"src_questions_computer-base_4_计算机编程.md\":\"CrUdsACY\",\"src_questions_computer-base_5_计算机科学.md\":\"_yFI1R5Q\",\"src_questions_computer-base_6_软件工程.md\":\"BXYQQeqH\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BQxVu0PG\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"Gfu3_sP0\",\"src_questions_data-structures-algorithms_1_算法.md\":\"vPAniCk3\",\"src_questions_front-architect_1_前端架构.md\":\"Bdmg5vGk\",\"src_questions_front-base_1_html.md\":\"BaThqo-b\",\"src_questions_front-base_2_css.md\":\"DRQjP4hN\",\"src_questions_front-base_3_javascript.md\":\"k9Ooup1d\",\"src_questions_front-base_4_typescript.md\":\"f_MD4-KS\",\"src_questions_front-component_1_ui组件库.md\":\"B6JvC2Vt\",\"src_questions_front-component_2_业务组件库.md\":\"DoCdo59X\",\"src_questions_front-engineering_1_前端标准化.md\":\"CFWMwec8\",\"src_questions_front-engineering_2_前端自动化.md\":\"Dk_JKYMi\",\"src_questions_front-engineering_3_webpack.md\":\"C7fNEZ_z\",\"src_questions_front-engineering_4_vite.md\":\"DKIKrQKG\",\"src_questions_front-engineering_5_rollup.md\":\"C-F_ozc9\",\"src_questions_front-frame_1_react.md\":\"C3JxmoYQ\",\"src_questions_front-frame_2_vue.md\":\"D0cggqjW\",\"src_questions_front-frame_3_next.md\":\"aVe3KGry\",\"src_questions_front-frame_4_nuxt.md\":\"GbOWqNlo\",\"src_questions_front-frame_5_qiankun.md\":\"CS-cYVci\",\"src_questions_front-newest_1_前端最前沿.md\":\"bMLI0xjp\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"B_C-OuXL\",\"src_questions_front-runtime_1_浏览器.md\":\"Debk5m2r\",\"src_questions_front-runtime_2_nodejs.md\":\"Dz9RDgon\",\"src_questions_front-safety_1_前端安全.md\":\"Da0z-kPV\",\"src_questions_server_1_nest.md\":\"BhPY9llS\",\"src_questions_server_2_mongodb.md\":\"BtVvvnfZ\",\"src_questions_server_3_mysql.md\":\"D9xJF5vI\",\"src_questions_server_4_nginx.md\":\"Jx--UsC3\",\"src_questions_server_5_docker.md\":\"JhGclHJj\",\"src_questions_server_6_kubernets.md\":\"B5wWDFxC\",\"src_questions_server_7_nacos.md\":\"Cq8z1Ciu\",\"src_questions_server_8_redis.md\":\"5SVj9rzu\",\"src_training_training-architecture_index.md\":\"kxz1uF9x\",\"src_training_training-experts_index.md\":\"DTfJzJKD\",\"src_training_training-intermediate_index.md\":\"Cgny5K3v\",\"src_training_training-primary_index.md\":\"sKlbmfkT\",\"src_training_training-senior_index.md\":\"BOzOiAWn\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>