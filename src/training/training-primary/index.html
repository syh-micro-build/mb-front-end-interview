<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.Bs1qLOmp.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.4a5KvWbr.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.CbqoL1Og.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.BYipliXv.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. 对 rest 参数的理解</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> args) {
    result *= val;
  }
  <span class="hljs-keyword">return</span> result;
}
<span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span>
</code></pre><ul>
<li>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)
}
<span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span>
</code></pre><ul>
<li>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. TypeScript中的装饰器是什么？如何使用？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>
</li>
<li><p><strong>4：</strong> 常见的装饰器类型：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 类装饰器</span>
<span class="hljs-keyword">function</span> classDecorator&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>:any[]):{}}&gt;(<span class="hljs-attr">constructor</span>:T) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> constructor {
        newProperty = <span class="hljs-string">&quot;new property&quot;</span>;
        hello = <span class="hljs-string">&quot;override&quot;</span>;
    }
}

<span class="hljs-comment">// 方法装饰器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">methodDecorator</span>(<span class="hljs-params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) {
    <span class="hljs-comment">// 保存原始方法</span>
    <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;
    
    <span class="hljs-comment">// 修改方法的行为</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: any[]</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before method execution&#x27;</span>);
        <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After method execution&#x27;</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-comment">// 使用装饰器</span>
@classDecorator
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {
    @methodDecorator
    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);
    }
}

<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();
e.<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// Before method execution</span>
<span class="hljs-comment">// Hello!</span>
<span class="hljs-comment">// After method execution</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">https 存在的风险</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。</li>
<li><strong>:2</strong> 过程:</li>
</ul>
<blockquote>
<p>1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；<br>2、随后浏览器向服务器发起 http 通信;<br>3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  </p>
</blockquote>
<ul>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。
 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. delete和Vue.delete删除数组的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</p>
</li>
<li><p>Vue.delete 直接删除了数组 改变了数组的键值。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. $route 和$router 的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p>
<p>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. 如何动态更新对象或数组的值？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. node.js的同步和异步编程是什么意思？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。</p>
</li>
<li><p>而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。</p>
</li>
<li><p>Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. ES5、ES6 如何实现继承?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承</p>
</li>
<li><p>ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 如何使用 calc() 函数？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算。例如：</li>
</ul>
<pre><code class="hljs language-css">  <span class="hljs-attr">width</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% - 20px);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. Node.js采用哪种编程模式？它的优势是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。</p>
</li>
<li><p>此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。</p>
</li>
<li><p>总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. Nodejs的事件循环和浏览器有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：</p>
<ul>
<li><p>timers阶段：处理setTimeout()和setInterval()等定时器事件。</p>
</li>
<li><p>I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。</p>
</li>
<li><p>idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。</p>
</li>
<li><p>poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。</p>
</li>
<li><p>check阶段：执行setImmediate()的回调函数。</p>
</li>
<li><p>close callbacks阶段：执行关闭事件的回调函数，例如socket.on(&#39;close&#39;)。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. Canvas 和 SVG 有何区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。</p>
<p>SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">https是怎么保证安全的，为什么比http安全？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。</li>
<li>HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。</li>
<li>在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. vue-router怎么动态添加、删除路由？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>添加路由</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { useRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title function_">addRoute</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> newRoute = {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HelloWorld.vue&#x27;</span>), <span class="hljs-comment">// 动态加载组件</span>
  };
  router.<span class="hljs-title function_">addRoute</span>(newRoute);
};
</code></pre><p>添加路由</p>
<pre><code class="hljs language-js">
router.<span class="hljs-title function_">removeRoute</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 伪元素和伪类的区别和作用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
<p>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. 什么是 mixin？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. forEach和map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>这方法都是用来遍历数组的，两者区别如下：</p>
</li>
<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p>
</li>
<li><p>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">第三方依赖包带来的问题</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>:1</strong> 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。
比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。</p>
</li>
<li><p><strong>:1</strong> 防御：</p>
</li>
</ul>
<blockquote>
<p>使用 NSP(Node Security Platform)、Snyk 等等这类工具。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">nuxt2常用的组件有哪些</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> <code>&lt;Nuxt&gt;</code>Nuxt 框架中的核心组件;</p>
</li>
<li><p><code>&lt;NuxtLink&gt;</code>用于在 Nuxt 应用内部进行页面导航;</p>
</li>
<li><p><code>&lt;ClientOnly&gt;</code>只在客户端被渲染和执行;</p>
</li>
<li><p><code>&lt;NoSSR&gt;</code>用来处理不适合在服务端渲染的内容;</p>
</li>
<li><p><code>&lt;Transition&gt;</code>用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。</p>
</li>
<li><p><strong>1：</strong> <code>&lt;NuxtChild&gt;</code>主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;</p>
</li>
<li><p><code>&lt;KeepAlive&gt;</code>保留组件的状态，让它在切换后依然保持之前的状态;</p>
</li>
<li><p><code>&lt;slot&gt;</code>用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">71. Vue 3 中的 Fragment 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Fragment 允许组件返回多个根元素。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;div&gt;Hello&lt;/div&gt;
  &lt;div&gt;Vue 3&lt;/div&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. Vue中怎么做全局错误监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Vue 3 中的 Suspense 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Suspense 用于处理异步组件的加载状态。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;AsyncComponent /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. Vue 3 生命周期钩子有什么变化？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">进程与线程的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。</li>
<li><strong>1：</strong> 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。</li>
<li><strong>1：</strong> 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。</li>
<li><strong>1：</strong> 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的
场景，如 Web 服务器中处理多个并发请求。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20.你如何在Node.js中处理HTTP请求和响应？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.</p>
</li>
<li><p>监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。</p>
</li>
<li><p>处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。</p>
</li>
<li><p>发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。</p>
</li>
<li><p>通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。
需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 说一下 watch 与 computed 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>都是观察数据变化的（相同）</p>
</li>
<li><p>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化</p>
</li>
<li><p>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</p>
</li>
<li><p>watch 支持异步，computed 不支持；</p>
</li>
<li><p>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</p>
</li>
<li><p>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</p>
</li>
<li><p>omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 什么是 React 的生命周期方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 类组件声明周期方法:</li>
<li><strong>1：</strong> 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。</li>
<li><strong>1：</strong> 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。</li>
<li><strong>1：</strong> 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。</li>
<li><strong>1：</strong> 函数组件生命周期（Hooks）:</li>
<li><strong>1：</strong> useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件挂载时执行的操作</span>
<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件卸载时清理资源</span>
};
}, [dependencies]);  <span class="hljs-comment">// 依赖数组</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Ajax Fetch Axios的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise</p>
</li>
<li><p>Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现</p>
</li>
<li><p>Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 怎么理解Vue的单向数据流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>
<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. Nodejs适用于哪些场景？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>T后端开发，Nodejs的异步I/O天生适合做Web高并发。</p>
</li>
<li><p>BFF开发，比如SSR中间层或者GraphQL中间层。</p>
</li>
<li><p>前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. Object.defineProperty 的使用</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><p><strong>1：</strong> Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。</p>
</li>
<li><p><strong>1：</strong> 访问属性描述符包括：configurable、enumerable、writable、value</p>
</li>
<li><p><strong>1：</strong> 访问属性描述符的方法：Object.getOwnPropertyDescriptor()</p>
</li>
<li><p><strong>1：</strong> 缺点</p>
<p>  ① 一次监听太多的时候，不是很友好</p>
<p>  ② 新增、删除的时候，他是无能为力的</p>
<p>  ③ 会修改原对象中的属性</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;里斯&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>
};

<span class="hljs-comment">/**
 * 监听某个属性
 */</span>
<span class="hljs-comment">/*
Object.defineProperty(obj, &quot;name&quot;, {
    set(v) {
        console.log(v);
        console.log(&quot;监听到 set&quot;);
    },
    get() {
        console.log(&quot;监听到 get&quot;);
    }
});
*/</span>

<span class="hljs-comment">/**
 * 监听所有的属性
 */</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);
    <span class="hljs-keyword">let</span> value = obj[key];
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
        <span class="hljs-title function_">set</span>(<span class="hljs-params">v</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到属性 <span class="hljs-subst">${key}</span>，被 set 为 <span class="hljs-subst">${v}</span>`</span>);
            value = v;
        },
        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`监听到属性 <span class="hljs-subst">${key}</span> get`</span>);
            <span class="hljs-keyword">return</span> value;
        }
    });
});


obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;哈哈哈&quot;</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是重绘和回流及怎么减少重绘和回流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。</p>
</li>
<li><p>回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. typeof NaN 的结果是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 为什么有时候⽤translate来改变位置⽽不是定位？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. == 和 ===区别，什么情况⽤ ==</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. nextTick 的作用是什么？他的实现原理是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li><p>Promise</p>
</li>
<li><p>MutationObserver</p>
</li>
<li><p>setImmediate</p>
</li>
<li><p>setTimeout</p>
</li>
</ul>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. vue响应式原理是什么？vue3的响应式有何不同?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p>
</li>
<li><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. margin 和 padding 的使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</p>
</li>
<li><p>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 什么是HTML5以及和HTML的区别是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。</p>
<p>HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。</p>
<p>从文档声明类型上看：</p>
<ul>
<li>HTML是很长的一段代码，很难记住。如下代码：</li>
</ul>
<pre><code class="hljs language-html">
&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;


- HTML5却只有简简单单的声明，方便记忆。如下：

```html

&lt;!DOCTYPE html&gt;
</code></pre><p>从语法规则上看：</p>
<ul>
<li><p>HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；</p>
</li>
<li><p>HTML5允许省略标签，比如<code>&lt;img&gt;</code>标签的<code>&lt;img&gt;</code>、<code>&lt;br&gt;</code>标签的<code>&lt;br&gt;</code>、<code>&lt;input&gt;</code>标签的<code>&lt;input&gt;</code>等，这种情况下，标签的结束标志不是必需的；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是虚拟 DOM？它是如何工作的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>
</li>
<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>
</li>
<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>
</li>
<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">77. v-if和v-for为什么不能连用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。</p>
<p>如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。</p>
<p>要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. attribute和property（都是属性）的区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>两者都有可能引起DOM重新渲染</p>
</li>
<li><p>property : 修改对象属性，不会体现到html结构中</p>
</li>
<li><p>attribute : 修改html属性，会改变html结构</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. 什么是ORM？Nodejs的ORM框架有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。</p>
</li>
<li><p>这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。</p>
</li>
<li><p>Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。</p>
</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-24T06:17:18.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"cUgFDYJ8\",\"ing.md\":\"C7K-JIv9\",\"readme.md\":\"FXViB3LL\",\"src_guide_getting-started.md\":\"DxCfpS6C\",\"src_guide_why.md\":\"CwM69Rm0\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"C7x41sBI\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"BebAqh4h\",\"src_questions_computer-base_1_计算机硬件.md\":\"pnpVTiz-\",\"src_questions_computer-base_2_计算机软件.md\":\"rlE1JiIp\",\"src_questions_computer-base_3_计算机网络.md\":\"DeVLkpqI\",\"src_questions_computer-base_4_计算机编程.md\":\"FA7cygv4\",\"src_questions_computer-base_5_计算机科学.md\":\"u93s6aX6\",\"src_questions_computer-base_6_软件工程.md\":\"BdPuCYVm\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BT7BuCDi\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"B86w_kaG\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CXfSrH-H\",\"src_questions_front-architect_1_前端架构.md\":\"DACSalpM\",\"src_questions_front-base_1_html.md\":\"BS15v9KI\",\"src_questions_front-base_2_css.md\":\"Ci-9A8T6\",\"src_questions_front-base_3_javascript.md\":\"DQJ3wN9Q\",\"src_questions_front-base_4_typescript.md\":\"BNYuClW1\",\"src_questions_front-component_1_ui组件库.md\":\"Cq8f9QIv\",\"src_questions_front-component_2_业务组件库.md\":\"H_htzyR1\",\"src_questions_front-engineering_1_前端标准化.md\":\"DkmG1g-r\",\"src_questions_front-engineering_2_前端自动化.md\":\"DXK0T28h\",\"src_questions_front-engineering_3_webpack.md\":\"CWH_Xgrv\",\"src_questions_front-engineering_4_vite.md\":\"Dfpf3Gr9\",\"src_questions_front-engineering_5_rollup.md\":\"DyYDu8wF\",\"src_questions_front-frame_1_react.md\":\"D5Yp02nh\",\"src_questions_front-frame_2_vue.md\":\"Dnu3-Opi\",\"src_questions_front-frame_3_next.md\":\"ByAawdEG\",\"src_questions_front-frame_4_nuxt.md\":\"C2J7eTS-\",\"src_questions_front-frame_5_qiankun.md\":\"CofEjfEy\",\"src_questions_front-newest_1_前端最前沿.md\":\"DKM0xvh5\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"_JfjBIsX\",\"src_questions_front-runtime_1_浏览器.md\":\"nr97r-3-\",\"src_questions_front-runtime_2_nodejs.md\":\"Dcrb6pY3\",\"src_questions_front-safety_1_前端安全.md\":\"CVSxxaGW\",\"src_questions_server_1_nest.md\":\"DhwC3DUs\",\"src_questions_server_2_mongodb.md\":\"ByGgHN0g\",\"src_questions_server_3_mysql.md\":\"5mf69SMB\",\"src_questions_server_4_nginx.md\":\"CmDbQjql\",\"src_questions_server_5_docker.md\":\"DSAPifO_\",\"src_questions_server_6_kubernets.md\":\"taWwC6jl\",\"src_questions_server_7_nacos.md\":\"CNZSchh2\",\"src_questions_server_8_redis.md\":\"DdjsyJlS\",\"src_training_training-architecture_index.md\":\"CSlA1hX4\",\"src_training_training-experts_index.md\":\"Duz6DXmi\",\"src_training_training-intermediate_index.md\":\"DfoPGPpy\",\"src_training_training-primary_index.md\":\"BYipliXv\",\"src_training_training-senior_index.md\":\"CfdVGd5G\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>