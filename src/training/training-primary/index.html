<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.BugVFdDY.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.DjS0JqvM.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.Dn8fXuHs.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.Yf3z8opX.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.JG7NU-vm.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</li>
<li><strong>1：</strong>（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</li>
<li><strong>1：</strong>（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">nuxt2和nuxt3的区别</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 性能方面：<br/>
&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，
在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>
&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。
Nuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，
生成的代码包可能会包含一些冗余代码，影响最终的性能。</li>
<li><strong>1：</strong> 目录结构和文件约定：<br/>
&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。
例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，
允许更好地定制页面布局。<br/>
&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。
例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。</li>
<li><strong>1：</strong> TypeScript 支持：<br/>
&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。
例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，
开发体验更加友好。<br/>
&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安
装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。</li>
<li><strong>1：</strong> Composition API 和 Options API：<br/>
&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可
复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中
的mounted等生命周期钩子来实现相同的功能。<br/>
&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。
例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。</li>
<li><strong>2：</strong> Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>
&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能
够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>
&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要
更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 什么是 React 的生命周期方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 类组件声明周期方法:</li>
<li><strong>1：</strong> 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。</li>
<li><strong>1：</strong> 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。</li>
<li><strong>1：</strong> 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。</li>
<li><strong>1：</strong> 函数组件生命周期（Hooks）:</li>
<li><strong>1：</strong> useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件挂载时执行的操作</span>
<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
<span class="hljs-comment">// 组件卸载时清理资源</span>
};
}, [dependencies]);  <span class="hljs-comment">// 依赖数组</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">75. Vue 项目中如何实现多环境配置？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：</p>
<p>env：默认的环境配置（用于开发环境或没有明确环境时）。</p>
<p>.env.development：开发环境配置。</p>
<p>.env.production：生产环境配置。</p>
<p>.env.test：测试环境配置。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">63.  || 和 &amp;&amp; 操作符的返回值？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
</li>
<li><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p>
</li>
<li><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p>
</li>
<li><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 解释 TypeScript 中的类型断言（Type Assertion）及其作用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 类型断言是一种告诉编译器某个值的类型的方式，它允许开发者手动指定一个值的类型，而不是让编译器自动推断。有两种语法形式：as语法和尖括号语法。例如：</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// as语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (someValue <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;

<span class="hljs-comment">// 尖括号语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="hljs-property">length</span>;
</code></pre><ul>
<li><strong>1：</strong> 类型断言的作用主要是在某些情况下，当编译器无法准确推断类型或者开发者确定某个值的类型时，通过类型断言来告诉编译器，以便进行更准确的类型检查和代码提示，避免类型错误。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在前端如何安全地处理用户密码？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=&quot;password&quot;来隐藏用户输入。</li>
<li><strong>1：</strong> 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。</li>
<li><strong>1：</strong> 避免本地缓存：设置表单元素的autocomplete=&quot;off&quot;，防止浏览器缓存密码。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. CSS 动画和过渡的区别是什么？如何使用它们？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>2：</strong> 过渡（Transition）：<ul>
<li>从一个状态到另一个状态的平滑过渡</li>
<li>需要触发条件（如hover）</li>
<li>只能定义开始和结束状态</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">.<span class="hljs-property">element</span> {
    <span class="hljs-attr">width</span>: 100px;
    <span class="hljs-attr">transition</span>: width <span class="hljs-number">0.</span>3s ease;
}

.<span class="hljs-property">element</span>:hover {
    <span class="hljs-attr">width</span>: 200px;
}
</code></pre><ul>
<li><strong>2：</strong> 动画（Animation）：<ul>
<li>可以定义多个状态的变化</li>
<li>可以循环播放</li>
<li>可以自动播放，无需触发条件</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css">@keyframes slide {
    <span class="hljs-number">0</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
    <span class="hljs-number">50</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(100px);
    }
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(<span class="hljs-number">0</span>);
    }
}

.<span class="hljs-property">element</span> {
    <span class="hljs-attr">animation</span>: slide 2s ease infinite;
}
</code></pre><ul>
<li><strong>2：</strong> 主要区别：<ul>
<li>触发方式：过渡需要触发条件，动画可以自动播放</li>
<li>状态数量：过渡只有开始和结束两个状态，动画可以有多个状态</li>
<li>循环播放：动画可以循环播放，过渡不能</li>
<li>控制能力：动画的控制能力更强，可以精确控制中间状态</li>
</ul>
</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. 什么是执行上下文和执行栈？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。</p>
</li>
<li><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. Vue中怎么做全局错误监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. Vue 3 中的 provide 和 inject 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>provide 和 inject 用于跨层级组件通信。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { provide, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>);
    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;message&#x27;</span>, message); <span class="hljs-comment">// 提供数据</span>
  }
};

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;message&#x27;</span>); <span class="hljs-comment">// 注入数据</span>
    <span class="hljs-keyword">return</span> { message };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 Rollup？它与 Webpack 有何不同？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>6：</strong> Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。</p>
</li>
<li><p>模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。</p>
</li>
<li><p>性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。</p>
</li>
<li><p>输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。</p>
</li>
<li><p>插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。</p>
</li>
<li><p>在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化</p>
</li>
<li><p>Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. React中的Context是什么？如何使用？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Context的创建和提供：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;light&#x27;</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;ThemedButton /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}
</code></pre><ul>
<li><strong>1：</strong> 在类组件中使用Context：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThemedButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">ThemeContext</span>;
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> &lt;Button theme={this.context} /&gt;;
  }
}
</code></pre><ul>
<li><strong>1：</strong> 在函数组件中使用useContext：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemedButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);
  <span class="hljs-keyword">return</span> &lt;Button theme={theme} /&gt;;
}
</code></pre><ul>
<li><strong>1：</strong> Context的注意事项：<ul>
<li>避免过度使用Context</li>
<li>Context值变化会导致所有消费组件重新渲染</li>
<li>适合共享全局数据，如主题、用户信息等</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. v-model 双向绑定的原理是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 说一下 Vue SSR 的实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>
</li>
<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。</li>
<li><strong>1：</strong>  <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：主要用于移动端开发，设置视口的属性，<code>width=device-width</code> 表示视口
宽度等于设备的屏幕宽度，<code>initial-scale=1.0</code> 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;description&quot; content=&quot;这是一个关于 HTML 面试题的页面描述&quot;&gt;</code>：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜
索排名和用户点击行为，因此应该简洁且准确地描述页面内容。</li>
<li><strong>1：</strong>  <code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, 面试题, 网页开发&quot;&gt;</code>：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为
搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 什么是HTML5以及和HTML的区别是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。</p>
<p>HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。</p>
<p>从文档声明类型上看：</p>
<ul>
<li>HTML是很长的一段代码，很难记住。如下代码：</li>
</ul>
<pre><code class="hljs language-html">
&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html <span class="hljs-variable constant_">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;
http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;


- HTML5却只有简简单单的声明，方便记忆。如下：

```html

&lt;!DOCTYPE html&gt;
</code></pre><p>从语法规则上看：</p>
<ul>
<li><p>HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；</p>
</li>
<li><p>HTML5允许省略标签，比如<code>&lt;img&gt;</code>标签的<code>&lt;img&gt;</code>、<code>&lt;br&gt;</code>标签的<code>&lt;br&gt;</code>、<code>&lt;input&gt;</code>标签的<code>&lt;input&gt;</code>等，这种情况下，标签的结束标志不是必需的；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. 什么是泛型,有什么作用？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><ul>
<li><strong>1：</strong> 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。</li>
</ul>
<details>

<pre><code class="hljs language-typescript">
interface <span class="hljs-title class_">IResponseData</span>&lt;T&gt;{
    <span class="hljs-attr">code</span>: number;
    message?: string;
    <span class="hljs-attr">data</span>: T;
}


interface <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">email</span>: string;
}

<span class="hljs-comment">// 使用时传入User类型</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">response</span>: <span class="hljs-title class_">IResponseData</span>&lt;<span class="hljs-title class_">User</span>&gt; = {
  <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Success&quot;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,
    <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;xxx@qq.com&quot;</span>
  }
};
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. vue3和vue2的区别</h4><div class="head-re"><span class="head-score">11 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 源码组织方式变化：使用 TS 重写</li>
<li><strong>1：</strong> 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>
<li><strong>1：</strong> 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>
<li><strong>1：</strong> 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>
<li><strong>1：</strong> 打包体积优化：移除了一些不常用的api（inline-template、filter）</li>
<li><strong>1：</strong> 生命周期的变化：使用setup代替了之前的beforeCreate和created</li>
<li><strong>1：</strong> Vue3 的 template 模板支持多个根标签</li>
<li><strong>1：</strong> Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>
<li><strong>1：</strong> Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>
<li><strong>1：</strong> Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li><strong>1：</strong> 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 如何使用 calc() 函数？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算。例如：</li>
</ul>
<pre><code class="hljs language-css">  <span class="hljs-attr">width</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% - 20px);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">网络协议是什么</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. 为什么不建议用index作为key?</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. React 中的 Hook 是什么？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> useState()：用于在函数组件中添加状态。</li>
<li><strong>1：</strong> useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。</li>
<li><strong>1：</strong> useContext()：用于在函数组件中访问上下文（Context）。</li>
<li><strong>1：</strong> useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。</li>
<li><strong>1：</strong> useRef()：用于访问组件中的 DOM 节点或保存可变的值。</li>
<li><strong>1：</strong> useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. watch 和 watchEffect 的区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> watch ：既要指明监视的数据源，也要指明监视的回调。</li>
<li><strong>1：</strong> watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</li>
<li><strong>1：</strong> watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 柯里化</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<p>给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：</p>
<p><img src="/public/images/3_JavaScript_20241224170424.png" alt=""></p>
<p>也就是 拆分函数的参数，这样的就可以叫 柯里化。</p>
<ul>
<li><strong>1：</strong> 使用函数柯里化的好处？</li>
</ul>
<p>在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。</p>
<ul>
<li><strong>1：</strong> 例子</li>
</ul>
<p>实现一个给第一个参数加2，给第二个参数乘2的例子</p>
<p><img src="/public/images/3_JavaScript_20241224170632.png" alt=""></p>
<ul>
<li><strong>2：</strong> 柯里化函数的实现</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 多参函数 转 柯里化函数
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">currying</span>(<span class="hljs-params">fn</span>) { <span class="hljs-comment">// 接受一个函数,返回一个函数</span>
    <span class="hljs-comment">// 这里是接受剩余参数</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">receivedParameters</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-comment">// 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致</span>
        <span class="hljs-comment">// console.log(fn.length);</span>
        <span class="hljs-comment">// console.log(args.length);</span>
        <span class="hljs-comment">// 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数</span>
        <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) {
            <span class="hljs-comment">// 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱</span>
            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...smallArgs</span>) {
                <span class="hljs-comment">// 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)</span>
                <span class="hljs-keyword">return</span> receivedParameters.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [...args, ...smallArgs])
            }
        }
    }
    <span class="hljs-keyword">return</span> receivedParameters
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">n, m, b</span>) { <span class="hljs-comment">// fun的参数个数,是可以 通过 fun.length 拿到的</span>
    <span class="hljs-keyword">return</span> n + m + b
}

<span class="hljs-keyword">const</span> test = <span class="hljs-title function_">currying</span>(fun);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>));
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. Node.js采用哪种编程模式？它的优势是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。</p>
</li>
<li><p>此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。</p>
</li>
<li><p>总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. EventBus 与 mitt 区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。</p>
<p>如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：</p>
<p>非常小，压缩后仅有 200 bytes。</p>
<p>完整 TS 支持，源码由 TS 编码。</p>
<p>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</p>
<p>使用简单，仅有 on、emit、off 等少量实用API。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 说说Ajax的原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。</p>
</li>
<li><p>创建XHR实例对象</p>
</li>
<li><p>调用实例对象中的open方法与服务器建立连接</p>
</li>
<li><p>调用实例对象中的send方法发送请求</p>
</li>
<li><p>监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据</p>
</li>
<li><p>将数据更新到html页面</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 什么是margin重叠问题？如何解决？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。</p>
<p>解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠</p>
<ul>
<li><p>底部元素变为行内盒子：display: inline-block</p>
</li>
<li><p>底部元素设置浮动：float</p>
</li>
<li><p>底部元素的position的值为absolute/fixed</p>
</li>
</ul>
<p>父子之间重叠</p>
<ul>
<li><p>父元素加入：overflow: hidden</p>
</li>
<li><p>父元素添加透明边框：border:1px solid transparent</p>
</li>
<li><p>子元素变为行内盒子：display: inline-block</p>
</li>
<li><p>子元素加入浮动属性或定位</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. == 和 ===区别，什么情况⽤ ==</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Ajax Fetch Axios的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise</p>
</li>
<li><p>Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现</p>
</li>
<li><p>Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 什么是函数组件和类组件？它们有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>函数组件：</p>
</li>
<li><p>定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。</p>
</li>
<li><p>优点：代码更简洁，性能更好（因为没有类的开销）。</p>
</li>
<li><p>限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。</p>
</li>
<li><p>类组件：</p>
</li>
<li><p>定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。</p>
</li>
<li><p>优点：支持生命周期方法和状态管理，功能更强大。</p>
</li>
<li><p>缺点：代码相对复杂，性能略逊于函数组件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">进程和线程的区别?</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>. 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p>. 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。</p>
</li>
<li><p>进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。</p>
</li>
<li><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是BFF？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。</p>
</li>
<li><p>最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。</p>
</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-23T07:13:33.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"B0kI6ZAn\",\"ing.md\":\"D1nWfXw6\",\"readme.md\":\"V-2xb-2G\",\"src_guide_getting-started.md\":\"BQLWWlLl\",\"src_guide_why.md\":\"OU7461E3\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BLPjwUje\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"DR1Y899G\",\"src_questions_computer-base_1_计算机硬件.md\":\"CNJX_Gmh\",\"src_questions_computer-base_2_计算机软件.md\":\"3AHM_dFp\",\"src_questions_computer-base_3_计算机网络.md\":\"Cz3_phQD\",\"src_questions_computer-base_4_计算机编程.md\":\"iz2hcs7Z\",\"src_questions_computer-base_5_计算机科学.md\":\"Dduwy4Fn\",\"src_questions_computer-base_6_软件工程.md\":\"BgskRMZQ\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"Bw7y5gdE\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"Duz1RZHm\",\"src_questions_data-structures-algorithms_1_算法.md\":\"B4RUqUcP\",\"src_questions_front-architect_1_前端架构.md\":\"DBCmoyXJ\",\"src_questions_front-base_1_html.md\":\"CY8M36wG\",\"src_questions_front-base_2_css.md\":\"CdCz3wtD\",\"src_questions_front-base_3_javascript.md\":\"DCO6-lRG\",\"src_questions_front-base_4_typescript.md\":\"sb_DU04C\",\"src_questions_front-component_1_ui组件库.md\":\"BkHcZQOo\",\"src_questions_front-component_2_业务组件库.md\":\"BXDe725T\",\"src_questions_front-engineering_1_前端标准化.md\":\"DK5EbIOS\",\"src_questions_front-engineering_2_前端自动化.md\":\"DmGicU7r\",\"src_questions_front-engineering_3_webpack.md\":\"DK1-MjFB\",\"src_questions_front-engineering_4_vite.md\":\"C8tjvJlu\",\"src_questions_front-engineering_5_rollup.md\":\"DQgOmzHl\",\"src_questions_front-frame_1_react.md\":\"7ggdYYic\",\"src_questions_front-frame_2_vue.md\":\"BnMYsCpX\",\"src_questions_front-frame_3_next.md\":\"DPpVj7o7\",\"src_questions_front-frame_4_nuxt.md\":\"Cz6Sjgu6\",\"src_questions_front-frame_5_qiankun.md\":\"BRXOg93l\",\"src_questions_front-newest_1_前端最前沿.md\":\"DGQCpAd6\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DTbYUNGk\",\"src_questions_front-runtime_1_浏览器.md\":\"CJZzU5_Q\",\"src_questions_front-runtime_2_nodejs.md\":\"CJTviEm7\",\"src_questions_front-safety_1_前端安全.md\":\"B5qgd_Zy\",\"src_questions_server_1_nest.md\":\"CpWxXPyz\",\"src_questions_server_2_mongodb.md\":\"DmHp7BE2\",\"src_questions_server_3_mysql.md\":\"BNbkwvdx\",\"src_questions_server_4_nginx.md\":\"CxL3C3Ah\",\"src_questions_server_5_docker.md\":\"BAENpARb\",\"src_questions_server_6_kubernets.md\":\"Dr1NgPRO\",\"src_questions_server_7_nacos.md\":\"CRIXxMHr\",\"src_questions_server_8_redis.md\":\"qwm-KtdX\",\"src_training_training-architecture_index.md\":\"5JIvloGv\",\"src_training_training-experts_index.md\":\"q9-YtNN3\",\"src_training_training-intermediate_index.md\":\"ScbRqrwV\",\"src_training_training-primary_index.md\":\"JG7NU-vm\",\"src_training_training-senior_index.md\":\"CV2bcnFQ\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>