<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.BLIBqwzP.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.Bnz-PKZN.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.C63GCDmY.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.BWh1m_7a.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 说一下 web worker</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>如何创建 web worker：</p>
<p>检测浏览器对于 web worker 的支持性</p>
<p>创建 web worker 文件（js，回传函数等）</p>
<p>创建 web worker 对象</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. any、never、unknown、null &amp; undefined 和 void 有什么区别？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> any: 动态的变量类型（失去了类型检查的作用）</li>
<li><strong>1：</strong> never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</li>
<li><strong>1：</strong> unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型</li>
<li><strong>1：</strong> null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自</li>
<li><strong>1：</strong> void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. 如何在TypeScript中实现函数重载？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 重载签名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>): number;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: string, b: string</span>): string;

<span class="hljs-comment">// 实现签名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number | string, b: number | string</span>): number | string {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) {
        <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">concat</span>(b);
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Parameters must be numbers or strings&#x27;</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));          <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)); <span class="hljs-comment">// &quot;Hello World&quot;</span>
</code></pre><ul>
<li><strong>2：</strong> 在类中使用函数重载：</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: number, <span class="hljs-attr">b</span>: number): number;
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: string, <span class="hljs-attr">b</span>: string): string;
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: any, <span class="hljs-attr">b</span>: any): any {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;number&#x27;</span>) {
            <span class="hljs-keyword">return</span> a + b;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) {
            <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">concat</span>(b);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Parameters must be numbers or strings&#x27;</span>);
    }
}
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. typeof NaN 的结果是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>0：</strong> 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。</li>
<li><strong>1：</strong> 添加 SSR 相关依赖：安装<code>@vue/server-renderer</code>和<code>express</code>等依赖，<code>@vue/server-renderer</code>用于服务器端渲染，<code>express</code>作为服务器框架。命令
为<code>npm install @vue/server-renderer express</code>。</li>
<li><strong>1：</strong> 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使
用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。</li>
<li><strong>1：</strong> 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如<code>entry-server.js</code>，在该文件中，创建 Vue 应用实例，并导出。同时，可能
需要调整一些组件的逻辑，以适应服务器端渲染的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. js 中const真的不能修改吗？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">https 存在的风险</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。</li>
<li><strong>:2</strong> 过程:</li>
</ul>
<blockquote>
<p>1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；<br>2、随后浏览器向服务器发起 http 通信;<br>3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  </p>
</blockquote>
<ul>
<li><strong>:1</strong> 防御：</li>
</ul>
<blockquote>
<p>使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。
 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 如何在组件中批量使用Vuex的getter属性</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>如何在组件中批量使用Vuex的getter属性</p>
<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {mapGetters} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">computed</span>:{
        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])
    }
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. Nodejs的文件系统有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js的文件系统有以下几种方法：</p>
<ul>
<li><p><code>fs.readFile</code>：读取文件内容。</p>
</li>
<li><p><code>fs.writeFile</code>：写入文件内容。</p>
</li>
<li><p><code>fs.appendFile</code>：追加文件内容。</p>
</li>
<li><p><code>fs.unlink</code>：删除文件。</p>
</li>
<li><p><code>fs.rename</code>：重命名文件。</p>
</li>
<li><p><code>fs.stat</code>：获取文件信息。</p>
</li>
<li><p><code>fs.readdir</code>：读取目录内容。</p>
</li>
<li><p><code>fs.mkdir</code>：创建目录。</p>
</li>
<li><p><code>fs.rmdir</code>：删除目录。</p>
</li>
<li><p><code>fs.watch</code>：监听文件或目录的变化。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. 怎么监听子组件内的错误？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error&quot;</span>);

<span class="hljs-comment">//父组件</span>
<span class="hljs-keyword">import</span> { onErrorCaptured } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// 监听到子组件错误，执行回调</span>
<span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 如何判断一个变量是不是数组？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>instanceof Array</p>
</li>
<li><p>Array.isArray();</p>
</li>
<li><p>Object.prototype.toString.call();</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">常见的浏览器内核有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>
<li><strong>1：</strong>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
<li><strong>1：</strong>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>
<li><strong>1：</strong>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">73. Vue 3 中的 watch 如何监听多个数据？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>通过数组传入多个监听源。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue 3&#x27;</span>);

    <span class="hljs-title function_">watch</span>([count, name], <span class="hljs-function">(<span class="hljs-params">[newCount, newName], [oldCount, oldName]</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count 或 name 变化了&#x27;</span>);
    });

    <span class="hljs-keyword">return</span> { count, name };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 什么是Stream流，有哪些应用场景？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。</p>
</li>
<li><p>比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">37. watch怎么停止监听？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> soptWatch = <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span>, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal)
})
<span class="hljs-title function_">soptWatch</span>()
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是虚拟 DOM？它是如何工作的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>
</li>
<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>
</li>
<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>
</li>
<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. mixin和mixis区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。</p>
<p>mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. 对 SPA 单页面的理解，它的优缺点分别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>
</li>
<li><p>基于上面一点，SPA 相对对服务器压力小；</p>
</li>
<li><p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p>
</li>
<li><p>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p>
</li>
<li><p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. 什么是 React？它的主要特点是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：</p>
</li>
<li><p>组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。</p>
</li>
<li><p>虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。</p>
</li>
<li><p>声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。</p>
</li>
<li><p>JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。</p>
</li>
<li><p>生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>当一个元素的 <strong>visibility</strong> 属性被设置成 <strong>collapse</strong> 值后，对于一般的元素，它的表现跟 <strong>hidden</strong> 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 <strong>display: none</strong> 一样，也就是说，它们占用的空间也会释放。</p>
<p>在谷歌浏览器里，使用 <strong>collapse</strong> 值和使用 <strong>hidden</strong> 值没有什么区别。</p>
<p>在火狐浏览器、Opera和IE11里，使用 <strong>collapse</strong> 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">GET和POST有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>
<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>
<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>
<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>
<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>
<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 什么是函数组件和类组件？它们有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>函数组件：</p>
</li>
<li><p>定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。</p>
</li>
<li><p>优点：代码更简洁，性能更好（因为没有类的开销）。</p>
</li>
<li><p>限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。</p>
</li>
<li><p>类组件：</p>
</li>
<li><p>定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。</p>
</li>
<li><p>优点：支持生命周期方法和状态管理，功能更强大。</p>
</li>
<li><p>缺点：代码相对复杂，性能略逊于函数组件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 说一下 watch 与 computed 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>都是观察数据变化的（相同）</p>
</li>
<li><p>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化</p>
</li>
<li><p>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</p>
</li>
<li><p>watch 支持异步，computed 不支持；</p>
</li>
<li><p>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</p>
</li>
<li><p>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</p>
</li>
<li><p>omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. 什么是 mixin？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. `&lt;form&gt;`标签的method属性有get和post两种取值，它们之间有什么区别？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  数据传输方式：get方式将表单数据附加在 URL 后面，以?分隔 URL 和参数，参数之间用&amp;连接；post方式将表单数据放在 HTTP 请求体中。</li>
<li><strong>1：</strong>  数据可见性：由于get方式数据在 URL 中，所以数据是可见的，不安全，不适合传输敏感信息；post方式数据在请求体中，相对更安全。</li>
<li><strong>1：</strong>  数据长度限制：get方式受限于 URL 长度，不同浏览器对 URL 长度限制不同，一般较短；post方式理论上对数据长度没有限制。</li>
<li><strong>1：</strong>  缓存：get请求会被浏览器缓存，因为其参数在 URL 中，可被收藏；post请求不会被缓存。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">27. HTML5的离线储存怎么使用，它的工作原理是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p>**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.</p>
<p>使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<pre><code class="hljs language-html">
  &lt;html lang=<span class="hljs-string">&quot;en&quot;</span> manifest=<span class="hljs-string">&quot;index.manifest&quot;</span>&gt;
</code></pre><p>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p>
<pre><code class="hljs language-html">
  <span class="hljs-variable constant_">CACHE</span> <span class="hljs-variable constant_">MANIFEST</span>
    #v0<span class="hljs-number">.11</span>
    <span class="hljs-attr">CACHE</span>:
    js/app.<span class="hljs-property">js</span>
    css/style.<span class="hljs-property">css</span>
    <span class="hljs-attr">NETWORK</span>:
    resourse/logo.<span class="hljs-property">png</span>
    <span class="hljs-attr">FALLBACK</span>:
    <span class="hljs-regexp">/ /</span>offline.<span class="hljs-property">html</span>
</code></pre><p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</p>
<p>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</p>
<p>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</p>
<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。
枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>
</li>
<li><p>接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 常用工具类型？</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> Partial：满足部分属性(一个都没满足也可)即可</li>
<li><strong>1：</strong> Required：所有属性都需要</li>
<li><strong>1：</strong> Readonly: 包装后的所有属性只读</li>
<li><strong>1：</strong> Pick: 选取部分属性</li>
<li><strong>1：</strong> Omit: 去除部分属性</li>
<li><strong>1：</strong> Extract: 交集</li>
<li><strong>1：</strong> Exclude: 差集</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. JS 什么是防抖和节流？它们的应用场景有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。</li>
<li><strong>2：</strong> 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Nuxt.js的SEO优化方案有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> Meta标签管理：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>,
    <span class="hljs-attr">meta</span>: [
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> },
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">keywords</span> }
    ]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 服务端渲染(SSR)：</p>
<ul>
<li>预渲染完整HTML</li>
<li>更好的首屏加载</li>
<li>搜索引擎可直接爬取内容</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>
}
</code></pre></li>
<li><p><strong>1：</strong> 静态站点生成(SSG)：</p>
<ul>
<li>构建时生成静态HTML</li>
<li>适合内容不常更新的站点</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>,
  <span class="hljs-attr">generate</span>: {
    <span class="hljs-attr">routes</span>: [<span class="hljs-string">&#x27;/posts/1&#x27;</span>, <span class="hljs-string">&#x27;/posts/2&#x27;</span>]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 结构化数据：</p>
<ul>
<li>实现JSON-LD</li>
<li>添加Schema.org标记</li>
<li>提供更丰富的搜索结果</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">script</span>: [{
      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/ld+json&#x27;</span>,
      <span class="hljs-attr">json</span>: {
        <span class="hljs-string">&quot;@context&quot;</span>: <span class="hljs-string">&quot;https://schema.org&quot;</span>,
        <span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;Article&quot;</span>,
        <span class="hljs-string">&quot;headline&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>
      }
    }]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 性能优化：</p>
<ul>
<li>图片懒加载</li>
<li>资源预加载</li>
<li>代码分割</li>
<li>缓存策略</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">render</span>: {
    <span class="hljs-attr">http2</span>: {
      <span class="hljs-attr">push</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">static</span>: {
      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>
    }
  }
}
</code></pre></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. TCP的流量控制机制</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>TCP的流量控制机制主要是通过滑动窗口来实现的。发送方和接收方都会维护一个窗口，发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。当接收方收到数据后，会发送一个ACK确认报文，其中包含接收方窗口的大小，发送方根据这个信息来调整发送窗口的大小。</p>
<ul>
<li><p>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</p>
</li>
<li><p>当数据到达时，接收方将数据放入缓冲区，并告诉发送方缓冲区中还可以容纳多少数据。</p>
</li>
<li><p>当接收方应用程序读取数据时，接收方将窗口向前滑动，并告诉发送方窗口的大小。</p>
</li>
<li><p>发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 什么是TypeScript？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. DNS 协议是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>简单来说，diff算法有以下过程</p>
<ul>
<li><p>同级比较，再比较子节点</p>
</li>
<li><p>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</p>
</li>
<li><p>比较都有子节点的情况(核心diff)</p>
</li>
<li><p>递归比较子节点</p>
</li>
</ul>
<p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>
<p>Vue3.x借鉴了 ivi算法和 inferno算法</p>
<p>在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染
后 useEffect 都会执行，可能导致不必要的副作用反复运行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. 说一下 Vue complier 的实现原理是什么样的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode</p>
<p>complier 主要分为 3 大块：</p>
<ul>
<li><p>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</p>
</li>
<li><p>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</p>
</li>
<li><p>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. 组件中写 name 选项有哪些好处？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</p>
</li>
<li><p>可以通过 name 属性实现缓存功能（keep-alive）</p>
</li>
<li><p>可以通过 name 来识别组件（跨级组件通信时非常重要）</p>
</li>
<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. margin 和 padding 的使用场景</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong><ul>
<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-10T03:39:39.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"Bug4xKfu\",\"ing.md\":\"BEfu_B2x\",\"readme.md\":\"BFxdRj6L\",\"src_guide_getting-started.md\":\"DvjdHOD8\",\"src_guide_why.md\":\"DKodEw9g\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DTgwrId1\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"UtWwkcEY\",\"src_questions_computer-base_1_计算机硬件.md\":\"D7FrlEB3\",\"src_questions_computer-base_2_计算机软件.md\":\"CUM7EPK3\",\"src_questions_computer-base_3_计算机网络.md\":\"GcUAEZjl\",\"src_questions_computer-base_4_计算机编程.md\":\"80ptEm6K\",\"src_questions_computer-base_5_计算机科学.md\":\"CZZKbEtj\",\"src_questions_computer-base_6_软件工程.md\":\"fH3-1W5K\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"D37RaliO\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"DCvfpR_G\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CNnEamST\",\"src_questions_front-architect_1_前端架构.md\":\"D3KPStTe\",\"src_questions_front-base_1_html.md\":\"B0_fP5tb\",\"src_questions_front-base_2_css.md\":\"gkW8PMLq\",\"src_questions_front-base_3_javascript.md\":\"BfmbZV9N\",\"src_questions_front-base_4_typescript.md\":\"C5C8Y6rw\",\"src_questions_front-component_1_ui组件库.md\":\"CvZx8wbj\",\"src_questions_front-component_2_业务组件库.md\":\"DshSeEGh\",\"src_questions_front-engineering_1_前端标准化.md\":\"DP5Rcpnj\",\"src_questions_front-engineering_2_前端自动化.md\":\"XIhJPOF-\",\"src_questions_front-engineering_3_webpack.md\":\"nnKRlCxe\",\"src_questions_front-engineering_4_vite.md\":\"xU-2pd4T\",\"src_questions_front-engineering_5_rollup.md\":\"D42Un-jp\",\"src_questions_front-frame_1_react.md\":\"BArCzvuG\",\"src_questions_front-frame_2_vue.md\":\"Cs90GizK\",\"src_questions_front-frame_3_next.md\":\"BLomThq6\",\"src_questions_front-frame_4_nuxt.md\":\"m6uYEa9F\",\"src_questions_front-frame_5_qiankun.md\":\"Dwhiy0g7\",\"src_questions_front-newest_1_前端最前沿.md\":\"Bqk7wXtT\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"CHWOHStp\",\"src_questions_front-runtime_1_浏览器.md\":\"DDnfYWxn\",\"src_questions_front-runtime_2_nodejs.md\":\"589wpn91\",\"src_questions_front-safety_1_前端安全.md\":\"O76fZLMW\",\"src_questions_server_1_nest.md\":\"BkVkPjtn\",\"src_questions_server_2_mongodb.md\":\"sz-qFopu\",\"src_questions_server_3_mysql.md\":\"DlqHewOE\",\"src_questions_server_4_nginx.md\":\"clL8xsN8\",\"src_questions_server_5_docker.md\":\"CxR-eeKJ\",\"src_questions_server_6_kubernets.md\":\"By-749PO\",\"src_questions_server_7_nacos.md\":\"30UzhGmD\",\"src_questions_server_8_redis.md\":\"DvcJ8Hha\",\"src_training_training-architecture_index.md\":\"BKbfJfFW\",\"src_training_training-experts_index.md\":\"ByMQKu2K\",\"src_training_training-intermediate_index.md\":\"Ce3fpnP9\",\"src_training_training-primary_index.md\":\"BWh1m_7a\",\"src_training_training-senior_index.md\":\"7GE5UJfj\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>