<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.BugVFdDY.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.DYZywAJi.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.q38nOD6H.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.C22IKpcs.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.BLScaYNZ.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. Proxy 的使用</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>4：</strong> 部分 API</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<ul>
<li><strong>1：</strong> 函数调用的监听</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>);
}

<span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fun, {
    <span class="hljs-comment">/**
     * 拦截对函数的调用的捕获器
     * <span class="hljs-doctag">@param</span> target target new Proxy 所代理的 obj（监听的对象）
     * <span class="hljs-doctag">@param</span> thisArg 调用函数时绑定的 this 值
     * <span class="hljs-doctag">@param</span> argArray 调用函数时传递的参数列表
     */</span>
    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argArray</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对 fun 函数进行了 apply 的调用。&quot;</span>);
        <span class="hljs-comment">// 调用原始函数，并在其结果前后添加一些内容</span>
        target.<span class="hljs-title function_">apply</span>(thisArg, argArray)
    },
    <span class="hljs-comment">/**
     * 监听 class 时的捕获器
     * <span class="hljs-doctag">@param</span> target target new Proxy 所代理的 obj（监听的对象）
     * <span class="hljs-doctag">@param</span> argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)
     * <span class="hljs-doctag">@param</span> newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理
     */</span>
    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argArray, newTarget</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对 fun 函数进行了 construct 的调用。&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">target</span>(...argArray)
    }
});

objProxy.<span class="hljs-title function_">apply</span>();
<span class="hljs-keyword">new</span> <span class="hljs-title function_">objProxy</span>();
</code></pre><ul>
<li><strong>1：</strong> new Proxy 中 receiver 参数的作用</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;里斯&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>,
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
    },
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = newValue;
    }
};

<span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {
    <span class="hljs-comment">/**
     * receiver 就是 objProxy 这个代理对象
     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）
     *
     */</span>
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver);
        <span class="hljs-comment">/**
         * 传入 receiver 后，他被访问了两次
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) {
        <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);
    }
});

objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;哈哈哈&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">进程与线程的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。</li>
<li><strong>1：</strong> 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。</li>
<li><strong>1：</strong> 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。</li>
<li><strong>1：</strong> 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的
场景，如 Web 服务器中处理多个并发请求。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器的渲染过程</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li><strong>1：</strong> 然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li><strong>1：</strong> 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li><strong>1：</strong> 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li><strong>1：</strong> 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. ES5、ES6 如何实现继承?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承</p>
</li>
<li><p>ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">48. box-sizing属性？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>用来控制元素的盒子模型的解析模式，默认为content-box</p>
<p>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽</p>
<p>**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. forEach和map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>这方法都是用来遍历数组的，两者区别如下：</p>
</li>
<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p>
</li>
<li><p>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. margin 和 padding 的使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</p>
</li>
<li><p>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. var 、let 、 const 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;
        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;</li>
<li><strong>1：</strong> let、 const 作用域: 级作用域（只在其所在的代码块内有效）;
    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;</li>
<li><strong>1：</strong> 区别:
      const： 需要在声明时初始化，且之后不能被修改;
      let：可以修改其值;
      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 对 SPA 单页面的理解，它的优缺点分别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 如何实现一个类型工具 `IsNever&lt;T&gt;`，用于判断一个类型 T 是否为 never 类型？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 使用 <code>[T]</code> extends <code>[never]</code> 来判断，因为直接 T extends never 会有特殊处理，而包装成元组可以正确判断。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// 答案</span>
type <span class="hljs-title class_">IsNever</span>&lt;T&gt; = [T] <span class="hljs-keyword">extends</span> [never]? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// 测试</span>
type <span class="hljs-title class_">Result1</span> = <span class="hljs-title class_">IsNever</span>&lt;never&gt;; <span class="hljs-comment">// true</span>
type <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">IsNever</span>&lt;string&gt;; <span class="hljs-comment">// false</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. 说一下 web worker</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>如何创建 web worker：</p>
<p>检测浏览器对于 web worker 的支持性</p>
<p>创建 web worker 文件（js，回传函数等）</p>
<p>创建 web worker 对象</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器会直接使用离线存储的资源。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 什么是微服务？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。</p>
</li>
<li><p>微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. 有使用过v-memo么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。</p>
<p>一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新</p>
<p>v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">前端如何防止点击劫持？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. Set、Map的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
</li>
<li><p>Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。</p>
</li>
<li><p>Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. useState 连续调用，页面不更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [age,  setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">42</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
}

<span class="hljs-comment">// 点击一次后，age 将只会变为 43 而不是 45！</span>
</code></pre><ul>
<li><strong>1：</strong> 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。</li>
<li><strong>1：</strong> 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 =&gt; 43)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(43 =&gt; 44)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(44 =&gt; 45)</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Vuex和单纯的全局对象有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. 如何对网站的文件和资源进行优化</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>文件合并（目的是减少http请求）；</p>
<p>文件压缩 （目的是直接减少文件下载的体积）；</p>
<p>使用缓存；</p>
<p>使用cdn托管资源；</p>
<p>gizp压缩需要的js和css文件；</p>
<p>反向链接，网站外链接优化；</p>
<p>meta标签优化（title, description, keywords）,heading标签的优化,alt优化；</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. nextTick 的作用是什么？他的实现原理是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li><p>Promise</p>
</li>
<li><p>MutationObserver</p>
</li>
<li><p>setImmediate</p>
</li>
<li><p>setTimeout</p>
</li>
</ul>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP 三次握手与四次挥手</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>TCP 三次握手</li>
<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>
<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服
务器同意建立连接。</li>
<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成
功。此时，双方都确认连接已建立，可以开始数据传输。</li>
<li>TCP 四次挥手</li>
<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>
<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据
未发送完，所以先不关闭连接。</li>
<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>
<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段
时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Mac 安装 Nginx</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<pre><code class="hljs language-shell"># 基于 brew 安装 <span class="hljs-title class_">Nginx</span>

# 安装 <span class="hljs-title class_">Nginx</span>
brew install nginx
</code></pre><p><img src="/public/images/4_Nginx_20241231111116.png" alt=""></p>
<p><a href="https://juejin.cn/post/6883018403641032712">常用指令</a></p>
<pre><code class="hljs language-shell">
# 查看配置信息
brew info nginx

# 查看 <span class="hljs-title class_">Nginx</span> 配置文件内容
cat /opt/homebrew/etc/nginx/nginx.<span class="hljs-property">conf</span>

# 查看 <span class="hljs-title class_">Nginx</span> 进程
ps -ef | grep nginx

# 查看 <span class="hljs-title class_">Nginx</span> 进程数
ps -ef | grep nginx | wc -l

# 查看 <span class="hljs-title class_">Nginx</span> 进程 <span class="hljs-variable constant_">ID</span>
ps -ef | grep nginx | awk <span class="hljs-string">&#x27;{print $2}&#x27;</span>

# 查看 <span class="hljs-title class_">Nginx</span> 进程 <span class="hljs-variable constant_">ID</span> 的个数
ps -ef | grep nginx | awk <span class="hljs-string">&#x27;{print $2}&#x27;</span> | wc -l
</code></pre><p><img src="/public/images/4_Nginx_20241231113535.png" alt=""></p>
<pre><code class="hljs language-shell"># 启动 <span class="hljs-title class_">Nginx</span>
brew services start nginx

# 打开界面时，记得查看端口是否被占用
# 重启 <span class="hljs-title class_">Nginx</span>
brew services restart nginx

# 停止 <span class="hljs-title class_">Nginx</span>
brew services stop nginx

# 取消进程
sudo kill 进程 <span class="hljs-variable constant_">ID</span>
</code></pre></details></div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. ref与reactive的区别？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li>
<li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li>
<li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li>
<li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li>
<li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li>
<li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 对媒体查询的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<pre><code class="hljs language-html">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; 
&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;style&gt; 
@media (max-width: 600px) { 
  .facet_sidebar { 
    display: none; 
  } 
}
&lt;/style&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. Node.js采用哪种编程模式？它的优势是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。</p>
</li>
<li><p>此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。</p>
</li>
<li><p>总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. head 标签有什么作用，其中什么标签必不可少？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：base, link 等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. 什么是虚拟 DOM？它是如何工作的？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>
</li>
<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>
</li>
<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>
</li>
<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSRF 攻击</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>
<li><strong>:4</strong> 防御：</li>
</ul>
<blockquote>
<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>
<blockquote>
<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>
</blockquote>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. Nodejs的进程管理有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js的进程管理有以下几种方法：</p>
<ul>
<li><p>使用<code>child_process</code>模块创建子进程，并使用<code>process</code>模块进行进程间通信。</p>
</li>
<li><p>使用<code>cluster</code>模块创建集群，利用多核CPU资源。</p>
</li>
<li><p>使用<code>pm2</code>等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。</p>
</li>
<li><p>使用<code>forever</code>等第三方工具，如自动重启、日志管理等功能。</p>
</li>
<li><p>使用<code>node-mac</code>等第三方工具，如自动重启、日志管理等功能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释数据库事务的 ACID 特性</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>
<li><strong>1：</strong> 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改
时，事务要确保这个一致性始终成立。</li>
<li><strong>1：</strong> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之
间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。</li>
<li><strong>1：</strong> 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订
单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 伪元素和伪类的区别和作用？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>
<p>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">19. 如何在TypeScript中实现函数重载？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 重载签名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>): number;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: string, b: string</span>): string;

<span class="hljs-comment">// 实现签名</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number | string, b: number | string</span>): number | string {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) {
        <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">concat</span>(b);
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Parameters must be numbers or strings&#x27;</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));          <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)); <span class="hljs-comment">// &quot;Hello World&quot;</span>
</code></pre><ul>
<li><strong>2：</strong> 在类中使用函数重载：</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: number, <span class="hljs-attr">b</span>: number): number;
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: string, <span class="hljs-attr">b</span>: string): string;
    <span class="hljs-title function_">add</span>(<span class="hljs-attr">a</span>: any, <span class="hljs-attr">b</span>: any): any {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;number&#x27;</span>) {
            <span class="hljs-keyword">return</span> a + b;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&#x27;string&#x27;</span>) {
            <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">concat</span>(b);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Parameters must be numbers or strings&#x27;</span>);
    }
}
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Nuxt.js的SEO优化方案有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> Meta标签管理：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>,
    <span class="hljs-attr">meta</span>: [
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> },
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">keywords</span> }
    ]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 服务端渲染(SSR)：</p>
<ul>
<li>预渲染完整HTML</li>
<li>更好的首屏加载</li>
<li>搜索引擎可直接爬取内容</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>
}
</code></pre></li>
<li><p><strong>1：</strong> 静态站点生成(SSG)：</p>
<ul>
<li>构建时生成静态HTML</li>
<li>适合内容不常更新的站点</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>,
  <span class="hljs-attr">generate</span>: {
    <span class="hljs-attr">routes</span>: [<span class="hljs-string">&#x27;/posts/1&#x27;</span>, <span class="hljs-string">&#x27;/posts/2&#x27;</span>]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 结构化数据：</p>
<ul>
<li>实现JSON-LD</li>
<li>添加Schema.org标记</li>
<li>提供更丰富的搜索结果</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">script</span>: [{
      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/ld+json&#x27;</span>,
      <span class="hljs-attr">json</span>: {
        <span class="hljs-string">&quot;@context&quot;</span>: <span class="hljs-string">&quot;https://schema.org&quot;</span>,
        <span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;Article&quot;</span>,
        <span class="hljs-string">&quot;headline&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>
      }
    }]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 性能优化：</p>
<ul>
<li>图片懒加载</li>
<li>资源预加载</li>
<li>代码分割</li>
<li>缓存策略</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">render</span>: {
    <span class="hljs-attr">http2</span>: {
      <span class="hljs-attr">push</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">static</span>: {
      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>
    }
  }
}
</code></pre></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. CSS Grid 布局的基本概念和使用方法是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> Grid布局的基本概念：</p>
<ul>
<li>Grid Container：设置 display: grid 的元素</li>
<li>Grid Item：Grid Container 的直接子元素</li>
<li>Grid Line：构成网格结构的分界线</li>
<li>Grid Track：两条相邻网格线之间的空间</li>
<li>Grid Cell：网格中的单元格</li>
<li>Grid Area：任意数量的网格单元格组成的区域</li>
</ul>
</li>
<li><p><strong>2：</strong> 基本使用示例：</p>
</li>
</ul>
<pre><code class="hljs language-css">.<span class="hljs-property">container</span> {
    <span class="hljs-attr">display</span>: grid;
    <span class="hljs-comment">/* 定义列的大小和数量 */</span>
    grid-template-<span class="hljs-attr">columns</span>: 100px 100px 100px;
    <span class="hljs-comment">/* 定义行的大小和数量 */</span>
    grid-template-<span class="hljs-attr">rows</span>: 100px 100px;
    <span class="hljs-comment">/* 设置间距 */</span>
    <span class="hljs-attr">gap</span>: 10px;
}

.<span class="hljs-property">item</span> {
    <span class="hljs-comment">/* 指定元素位置 */</span>
    grid-<span class="hljs-attr">column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">/* 从第1条网格线到第3条网格线 */</span>
    grid-<span class="hljs-attr">row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* 从第1条网格线到第2条网格线 */</span>
}
</code></pre></details>

</div></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-23T09:24:00.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"BP_TxIHV\",\"ing.md\":\"BTlz652q\",\"readme.md\":\"CdlIUM7x\",\"src_guide_getting-started.md\":\"DsIuXUmz\",\"src_guide_why.md\":\"DICU16--\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"mhKAlk1x\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Cds9atPm\",\"src_questions_computer-base_1_计算机硬件.md\":\"BNQ0oi4i\",\"src_questions_computer-base_2_计算机软件.md\":\"B-O2yYhP\",\"src_questions_computer-base_3_计算机网络.md\":\"BGXTQytO\",\"src_questions_computer-base_4_计算机编程.md\":\"DZl-gJMP\",\"src_questions_computer-base_5_计算机科学.md\":\"pxlEgk5w\",\"src_questions_computer-base_6_软件工程.md\":\"D9h9vIc_\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"DAP_-gcv\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"BY2kYmi9\",\"src_questions_data-structures-algorithms_1_算法.md\":\"DQAB3ZI8\",\"src_questions_front-architect_1_前端架构.md\":\"DxC4B600\",\"src_questions_front-base_1_html.md\":\"BZGhlZmN\",\"src_questions_front-base_2_css.md\":\"DyrZnojH\",\"src_questions_front-base_3_javascript.md\":\"BpT-JlYq\",\"src_questions_front-base_4_typescript.md\":\"CvIlqq_Q\",\"src_questions_front-component_1_ui组件库.md\":\"DK5uy_1O\",\"src_questions_front-component_2_业务组件库.md\":\"CYAj83vP\",\"src_questions_front-engineering_1_前端标准化.md\":\"DLdgtD32\",\"src_questions_front-engineering_2_前端自动化.md\":\"DDRmb11U\",\"src_questions_front-engineering_3_webpack.md\":\"DFS2rCSX\",\"src_questions_front-engineering_4_vite.md\":\"CgZSza5l\",\"src_questions_front-engineering_5_rollup.md\":\"BKUdBkr4\",\"src_questions_front-frame_1_react.md\":\"y7s-Q_Mf\",\"src_questions_front-frame_2_vue.md\":\"B9EuzilL\",\"src_questions_front-frame_3_next.md\":\"BAN9nN-I\",\"src_questions_front-frame_4_nuxt.md\":\"p8cuMmzf\",\"src_questions_front-frame_5_qiankun.md\":\"BhOhJHVF\",\"src_questions_front-newest_1_前端最前沿.md\":\"wqgPqed2\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DkHV1hXw\",\"src_questions_front-runtime_1_浏览器.md\":\"CxBGSIZK\",\"src_questions_front-runtime_2_nodejs.md\":\"CShCETBq\",\"src_questions_front-safety_1_前端安全.md\":\"B_0PvkJ-\",\"src_questions_server_1_nest.md\":\"BnEM9Svy\",\"src_questions_server_2_mongodb.md\":\"Dp3noJWv\",\"src_questions_server_3_mysql.md\":\"BTxDhMeo\",\"src_questions_server_4_nginx.md\":\"BKMbFl3q\",\"src_questions_server_5_docker.md\":\"CTFM9gyn\",\"src_questions_server_6_kubernets.md\":\"C_52BOQs\",\"src_questions_server_7_nacos.md\":\"CnOJvaYn\",\"src_questions_server_8_redis.md\":\"c_c8QzQI\",\"src_training_training-architecture_index.md\":\"CiiOByY3\",\"src_training_training-experts_index.md\":\"Bz3t2kbY\",\"src_training_training-intermediate_index.md\":\"JuMH5FRI\",\"src_training_training-primary_index.md\":\"BLScaYNZ\",\"src_training_training-senior_index.md\":\"CeCfNjBn\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>