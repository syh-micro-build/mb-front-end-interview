<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfdlugHt.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.UPCtyyuv.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CjDcszOu.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.5WXdMwYP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.DaqghNJ-.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.DQo3ko9S.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 浏览器是怎样解析CSS选择器的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。
而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 请解释一下 TypeScript 中的基本数据类型有哪些？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>
TypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">GET和POST有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>
<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>
<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>
<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>
<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>
<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 默认插槽、具名插槽、作用域插槽</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 在 Vue2.x 中如何检测数组的变化？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. typeof与instanceof的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</p>
</li>
<li><p>判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. Vue 3 中的 provide 和 inject 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>provide 和 inject 用于跨层级组件通信。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { provide, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>);
    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;message&#x27;</span>, message); <span class="hljs-comment">// 提供数据</span>
  }
};

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;message&#x27;</span>); <span class="hljs-comment">// 注入数据</span>
    <span class="hljs-keyword">return</span> { message };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 对媒体查询的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<pre><code class="hljs language-html">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; 
&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;style&gt; 
@media (max-width: 600px) { 
  .facet_sidebar { 
    display: none; 
  } 
}
&lt;/style&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. position:fixed; 在 android 下无效怎么处理 ？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-html">&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. HTML5 为什么只需要写 docType</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. 解释一下Event Loop的工作原理？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。</p>
</li>
<li><p>当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。</p>
</li>
<li><p>当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. ES6 和 CommonJS 的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const</li>
<li><strong>2：</strong> import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错</li>
</ul>
<p>注：S6 Module和CommonJS模块的共同点：</p>
<p>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变</p>
<p><a href="https://juejin.cn/post/7331931937357496354">docs</a></p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的
 data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { 
 <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncData</span>(<span class="hljs-params">ctx</span>) { 
   <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> ctx.<span class="hljs-property">$axios</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>); 
   <span class="hljs-keyword">return</span> { 
     <span class="hljs-attr">fetchedData</span>: data 
   }; 
 } 
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. src 与 href 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 匿名函数的典型应用场景是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。</li>
</ul>
<pre><code class="hljs language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 一些代码。</span>
})();
</code></pre><ul>
<li>匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
}, <span class="hljs-number">1000</span>);
</code></pre><ul>
<li>匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> double = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) {
  <span class="hljs-keyword">return</span> el * <span class="hljs-number">2</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(double); <span class="hljs-comment">// [2, 4, 6]</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. v-on 如何绑定多个事件？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js">&lt;!--单事件绑定--&gt;
&lt;input type=&quot;text&quot; @click=&quot;onClick&quot;&gt;
&lt;!--多事件绑定--&gt;
&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur }&quot;&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">29. 说一下 Vue 的 computed 的实现原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。</p>
<p>它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖</p>
<p>但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。</p>
<p>收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty</p>
<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>
<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>
<p>当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。</p>
<p>如果 dirty 为 false，则直接返回 watcher 的 value</p>
<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher</p>
<p>当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p>
<p>由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算</p>
<p>而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. 对 rest 参数的理解</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val <span class="hljs-keyword">of</span> args) {
    result *= val;
  }
  <span class="hljs-keyword">return</span> result;
}
<span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span>
</code></pre><ul>
<li>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)
}
<span class="hljs-title function_">mutiple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span>
</code></pre><ul>
<li>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 如何使用 calc() 函数？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算。例如：</li>
</ul>
<pre><code class="hljs language-css">  <span class="hljs-attr">width</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% - 20px);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. 谈谈你对 HTML 语义化的理解</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> What：通过语义化标签对网站进行结构化；</li>
<li><strong>1：</strong> Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；</li>
<li><strong>1：</strong> How：<code>header</code>-文档头、<code>nav</code>-导航区、<code>section</code>-文档块、<code>article</code>-内容、<code>aside</code>-侧边栏-广告栏、<code>footer</code>-文档脚注；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. Vue 初始化页面闪动问题如何解决？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。</p>
<p>解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：</p>
<pre><code class="hljs language-html">[v-cloak] { <span class="hljs-attr">display</span>: none; }

&lt;div v-cloak&gt;
  {{ message }}
&lt;/div&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. TypeScript中的映射类型是什么？请举例说明</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>
</li>
<li><p><strong>2：</strong> 示例：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 原始接口</span>
interface <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">age</span>: number;
    <span class="hljs-attr">address</span>: string;
}

<span class="hljs-comment">// 将所有属性变为可选</span>
type <span class="hljs-title class_">PartialPerson</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name?: string;</span>
<span class="hljs-comment">//    age?: number;</span>
<span class="hljs-comment">//    address?: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 将所有属性变为只读</span>
type <span class="hljs-title class_">ReadonlyPerson</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    readonly name: string;</span>
<span class="hljs-comment">//    readonly age: number;</span>
<span class="hljs-comment">//    readonly address: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 自定义映射类型</span>
type <span class="hljs-title class_">Nullable</span>&lt;T&gt; = {
    [P <span class="hljs-keyword">in</span> keyof T]: T[P] | <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">// 使用自定义映射类型</span>
type <span class="hljs-title class_">NullablePerson</span> = <span class="hljs-title class_">Nullable</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name: string | null;</span>
<span class="hljs-comment">//    age: number | null;</span>
<span class="hljs-comment">//    address: string | null;</span>
<span class="hljs-comment">// }</span>
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">79. Vue 3的插槽（Slots）和Vue 2有何不同？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. CSS 中的 BEM 命名规范是什么？为什么要使用它？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>2：</strong> BEM 命名规范：<ul>
<li>Block（块）：独立的组件，如 <code>.button</code></li>
<li>Element（元素）：属于块的一部分，用 <code>__</code> 连接，如 <code>.button__text</code></li>
<li>Modifier（修饰符）：改变块或元素的外观或行为，用 <code>--</code> 连接，如 <code>.button--large</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs language-css"><span class="hljs-comment">/* Block */</span>
.<span class="hljs-property">card</span> {
    <span class="hljs-attr">padding</span>: 20px;
}

<span class="hljs-comment">/* Element */</span>
.<span class="hljs-property">card__title</span> {
    font-<span class="hljs-attr">size</span>: 18px;
}

<span class="hljs-comment">/* Element */</span>
.<span class="hljs-property">card__content</span> {
    margin-<span class="hljs-attr">top</span>: 10px;
}

<span class="hljs-comment">/* Modifier */</span>
.<span class="hljs-property">card</span>--featured {
    <span class="hljs-attr">background</span>: #f0f0f0;
}
</code></pre><ul>
<li><strong>2：</strong> 使用BEM的好处：<ul>
<li>提高代码的可读性和可维护性</li>
<li>避免CSS选择器嵌套过深</li>
<li>减少命名冲突</li>
<li>明确表达组件结构和关系</li>
<li>方便团队协作和代码复用</li>
</ul>
</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 数组的原生方法有哪些？</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li><strong>1：</strong> 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li><strong>1：</strong> 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li><strong>1：</strong> 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li><strong>1：</strong> 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li><strong>1：</strong> 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li><strong>1：</strong> 数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">第三方依赖包带来的问题</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>:1</strong> 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。
比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。</p>
</li>
<li><p><strong>:1</strong> 防御：</p>
</li>
</ul>
<blockquote>
<p>使用 NSP(Node Security Platform)、Snyk 等等这类工具。</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">SSR 的原理是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 当用户请求一个页面时，服务器会执行以下步骤：<ul>
<li>获取页面数据和模板。</li>
<li>使用数据和模板生成完整的 HTML 页面。</li>
<li>将 HTML 页面发送给浏览器。</li>
<li>浏览器解析和显示 HTML 页面。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>
flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：
display: flex：将容器设置为弹性容器。
flex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。
justify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。
align-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。
枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>
</li>
<li><p>接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. Pinia与 Vuex 有哪些不同？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>更符合 Composition API 思维模式</p>
<p>更好的 TypeScript 类型支持</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. SPA及其优缺点是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 如何在 TypeScript 中定义一个只读属性的接口？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 使用 readonly 关键字。例如：</li>
</ul>
<pre><code class="hljs language-ts">interface <span class="hljs-title class_">Person</span> {
  readonly <span class="hljs-attr">name</span>: string;
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
<span class="hljs-comment">// p.name = &quot;Doe&quot;;  // 错误，不能修改只读属性</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. display的block、inline和inline-block的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. 什么是 JSX？它有什么优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.</p>
</li>
<li><p>可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。</p>
</li>
<li><p>类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。</p>
</li>
<li><p>表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。</p>
</li>
<li><p>工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是代码的时间复杂度和空间复杂度</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 时间复杂度和空间复杂度是衡量算法效率的两个重要指标</li>
<li><strong>1：</strong> 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。</li>
<li><strong>1：</strong> 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">get_element</span>(arr, index):
    <span class="hljs-keyword">return</span> arr[index]
</code></pre><ul>
<li><strong>1：</strong> 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">sum_array</span>(arr):
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-attr">arr</span>:
        total += num
    <span class="hljs-keyword">return</span> total
</code></pre><ul>
<li><strong>1：</strong> 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的
数组，总的比较次数为 n*(n - 1)/2。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">bubble_sort</span>(arr):
    n = <span class="hljs-title function_">len</span>(arr)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>, n - i - <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j + <span class="hljs-number">1</span>]:
                arr[j], arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>], arr[j]
    <span class="hljs-keyword">return</span> arr
</code></pre><ul>
<li><strong>1：</strong> 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。</li>
<li><strong>1：</strong> 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">add_numbers</span>(a, b):
    <span class="hljs-keyword">return</span> a + b
</code></pre><ul>
<li><strong>1：</strong> 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">create_array</span>(n):
    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>] * n
</code></pre><ul>
<li><strong>1：</strong> 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。</li>
</ul>
<pre><code class="hljs language-python">def <span class="hljs-title function_">create_2d_array</span>(n):
    <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n)]
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">21. Canvas 和 SVG 有何区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。</p>
<p>SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. 页面刷新了之后vuex中的数据消失怎么解决</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage</p>
</li>
<li><p>tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作</p>
</li>
</ul>
<pre><code class="hljs language-js">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title function_">store</span>({
   <span class="hljs-attr">state</span>: {
       <span class="hljs-attr">user</span>: localStorge.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>)  <span class="hljs-comment">// 初始化时读取 本地存储</span>
   },
   <span class="hljs-attr">mutations</span>: {
       <span class="hljs-title function_">updateUser</span> (state, payload) {
           state.<span class="hljs-property">user</span> = payload.<span class="hljs-property">user</span>
           localStoregae.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>,payload.<span class="hljs-property">user</span>) <span class="hljs-comment">// 数据更新时 设置本地存储</span>
       }
   }
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">46. 什么是margin重叠问题？如何解决？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。</p>
<p>解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠</p>
<ul>
<li><p>底部元素变为行内盒子：display: inline-block</p>
</li>
<li><p>底部元素设置浮动：float</p>
</li>
<li><p>底部元素的position的值为absolute/fixed</p>
</li>
</ul>
<p>父子之间重叠</p>
<ul>
<li><p>父元素加入：overflow: hidden</p>
</li>
<li><p>父元素添加透明边框：border:1px solid transparent</p>
</li>
<li><p>子元素变为行内盒子：display: inline-block</p>
</li>
<li><p>子元素加入浮动属性或定位</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. 全屏滚动的原理是什么？用到了CSS的哪些属性？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现
overflow：hidden；transition：all 1000ms ease；</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释一下什么是处理器架构（CPU Architecture）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Nuxt.js的生命周期有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 服务器端生命周期：</p>
<ul>
<li>nuxtServerInit：在服务端初始化数据</li>
<li>middleware：中间件执行</li>
<li>validate()：验证动态路由参数</li>
<li>asyncData()：异步数据加载</li>
<li>fetch()：服务端数据获取</li>
</ul>
</li>
<li><p><strong>1：</strong> Vue生命周期（服务端）：</p>
<ul>
<li>beforeCreate：组件实例化之前</li>
<li>created：组件创建完成</li>
</ul>
</li>
<li><p><strong>1：</strong> Vue生命周期（客户端）：</p>
<ul>
<li>beforeMount：DOM挂载之前</li>
<li>mounted：DOM挂载完成</li>
<li>beforeUpdate：数据更新前</li>
<li>updated：数据更新后</li>
</ul>
</li>
<li><p><strong>1：</strong> 页面特定钩子：</p>
<ul>
<li>transition：页面过渡效果</li>
<li>head：设置页面元信息</li>
</ul>
</li>
<li><p><strong>1：</strong> 注意事项：</p>
<ul>
<li>服务端只能访问beforeCreate和created</li>
<li>window/document只能在mounted中使用</li>
<li>asyncData/fetch在每次路由变化时都会调用</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 作用域链的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><p>注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。</p>
<details>

<ul>
<li><strong>1：</strong> 数据类型</li>
</ul>
<pre><code class="hljs language-mermaid">graph <span class="hljs-variable constant_">TD</span>;

    A[作用域链] --&gt; B[作用域];
    A --&gt; C[词法作用域];
    A --&gt; D[作用域链];
</code></pre><ul>
<li><strong>1：</strong> 作用域</li>
</ul>
<p>作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。
例如：</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-title function_">greet</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<span class="hljs-comment">// Uncaught ReferenceError: greeting is not defined</span>
</code></pre><ul>
<li><strong>1：</strong> 全局作用域</li>
</ul>
<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 全局变量</span>
<span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
</code></pre><ul>
<li><strong>1：</strong> 函数作用域</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
}
<span class="hljs-comment">// 打印 &#x27;Hello World!&#x27;</span>
<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 块级作用域</li>
</ul>
<p>ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</p>
<pre><code class="hljs language-js">{
  <span class="hljs-comment">// 块级作用域中的变量</span>
  <span class="hljs-keyword">let</span> greeting = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;
  <span class="hljs-keyword">var</span> lang = <span class="hljs-string">&#x27;English&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// Prints &#x27;Hello World!&#x27;</span>
}
<span class="hljs-comment">// 变量 &#x27;English&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lang);
<span class="hljs-comment">// 报错: Uncaught ReferenceError: greeting is not defined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);
</code></pre><ul>
<li><strong>1：</strong> 词法作用域</li>
</ul>
<p>词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">foo</span>();
}
<span class="hljs-title function_">bar</span>();
</code></pre><ul>
<li><strong>1：</strong> 作用域链</li>
</ul>
<p>在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>
<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">var</span> sex = <span class="hljs-string">&#x27;男&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">student</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 张三</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sex); <span class="hljs-comment">// 男</span>
    }
    <span class="hljs-title function_">student</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// Uncaught ReferenceError: age is not defined</span>
}
<span class="hljs-title function_">person</span>();

<span class="hljs-comment">/*
student 函数内部：
当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。
当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。

person 函数内部：
当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。

*/</span>
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. node.js的同步和异步编程是什么意思？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。</p>
</li>
<li><p>而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。</p>
</li>
<li><p>Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。</p>
</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-21T10:35:00.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"DdwsHJDi\",\"ing.md\":\"BpWiIgfU\",\"readme.md\":\"ebzd1Aw-\",\"src_guide_getting-started.md\":\"BxhEd4nu\",\"src_guide_why.md\":\"rLr7oeDE\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"xRF4fGgN\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"D1s2dL6m\",\"src_questions_computer-base_1_计算机硬件.md\":\"DHc17cHQ\",\"src_questions_computer-base_2_计算机软件.md\":\"IyK4xJQn\",\"src_questions_computer-base_3_计算机网络.md\":\"DtILA4xG\",\"src_questions_computer-base_4_计算机编程.md\":\"CBbMSrL2\",\"src_questions_computer-base_5_计算机科学.md\":\"COu_6nUj\",\"src_questions_computer-base_6_软件工程.md\":\"Dad6u5LS\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"3NFdegLM\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"XUbaEKUx\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CkZgNzUs\",\"src_questions_front-architect_1_前端架构.md\":\"BORQJy-k\",\"src_questions_front-base_1_html.md\":\"BMQdcFc7\",\"src_questions_front-base_2_css.md\":\"Dr0rQRxC\",\"src_questions_front-base_3_javascript.md\":\"Dtt7u7Aq\",\"src_questions_front-base_4_typescript.md\":\"hw7c5vl-\",\"src_questions_front-component_1_ui组件库.md\":\"BN_3tn2z\",\"src_questions_front-component_2_业务组件库.md\":\"CtS4pqwK\",\"src_questions_front-engineering_1_前端标准化.md\":\"DB4u9a8G\",\"src_questions_front-engineering_2_前端自动化.md\":\"BzRxR-YQ\",\"src_questions_front-engineering_3_webpack.md\":\"BvDii2YX\",\"src_questions_front-engineering_4_vite.md\":\"DPXSHSz9\",\"src_questions_front-engineering_5_rollup.md\":\"DNf-uKqw\",\"src_questions_front-frame_1_react.md\":\"CpvoO5nG\",\"src_questions_front-frame_2_vue.md\":\"DWLcxrgp\",\"src_questions_front-frame_3_next.md\":\"BZZ8xfql\",\"src_questions_front-frame_4_nuxt.md\":\"BSw9licx\",\"src_questions_front-frame_5_qiankun.md\":\"C7YRZDNP\",\"src_questions_front-newest_1_前端最前沿.md\":\"Di_lIpMx\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"q_BgXaOn\",\"src_questions_front-runtime_1_浏览器.md\":\"Cfu44P3X\",\"src_questions_front-runtime_2_nodejs.md\":\"CpbpSssB\",\"src_questions_front-safety_1_前端安全.md\":\"BWF4orFI\",\"src_questions_server_1_nest.md\":\"CtZ9fhhC\",\"src_questions_server_2_mongodb.md\":\"8gOHIdai\",\"src_questions_server_3_mysql.md\":\"CdpQ4D_s\",\"src_questions_server_4_nginx.md\":\"KVyn0GQ1\",\"src_questions_server_5_docker.md\":\"BY8jNRqc\",\"src_questions_server_6_kubernets.md\":\"D1cDY2vY\",\"src_questions_server_7_nacos.md\":\"DNqyt0yy\",\"src_questions_server_8_redis.md\":\"DtJjX1Mj\",\"src_training_training-architecture_index.md\":\"CR2bZMsP\",\"src_training_training-experts_index.md\":\"D5qI8mct\",\"src_training_training-intermediate_index.md\":\"B7hC9kBs\",\"src_training_training-primary_index.md\":\"DQo3ko9S\",\"src_training_training-senior_index.md\":\"Dl6B2VJu\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>