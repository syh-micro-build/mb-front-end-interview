<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DV7oKBPG.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.JHhhBAiM.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.BB7Zvbmn.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.CXauwka1.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.CRJU82XK.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. vue 组件通信方式有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>父子组件通信</p>
<p>父-&gt;子props，子-&gt;父 $on、$emit</p>
<p>获取父子组件实例 $parent、$children</p>
<p>Ref 获取实例的方式调用组件的属性或者方法</p>
<p>Provide、inject 官方不推荐使用，但是写组件库时很常用</p>
<p>兄弟组件通信</p>
<p>Event Bus 实现跨组件通信，代码繁琐，不推荐</p>
<p>Vuex 官方推荐使用，功能强大，vue-devtools有插件支持</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. 迭代查询与递归查询</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</p>
</li>
<li><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</p>
</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 说说Ajax的原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。</p>
</li>
<li><p>创建XHR实例对象</p>
</li>
<li><p>调用实例对象中的open方法与服务器建立连接</p>
</li>
<li><p>调用实例对象中的send方法发送请求</p>
</li>
<li><p>监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据</p>
</li>
<li><p>将数据更新到html页面</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 宏任务有哪些？微任务有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。</p>
</li>
<li><p>常见的宏任务有：</p>
</li>
<li><p>setTimeout 和 setInterval 的回调函数</p>
</li>
<li><p>DOM 事件</p>
</li>
<li><p>XMLHttpRequest 中的readystatechange事件</p>
</li>
<li><p>requestAnimationFrame 中的回调函数</p>
</li>
<li><p>I/O 操作和网络请求的回调函数</p>
</li>
<li><p>Node.js 中的文件读写操作的回调函数</p>
</li>
<li><p>Node.js 中的进程事件</p>
</li>
<li><p>常见的微任务有：</p>
</li>
<li><p>Promise.then 和 Promise.catch 的回调函数</p>
</li>
<li><p>MutationObserver 的回调函数</p>
</li>
<li><p>process.nextTick 函数</p>
</li>
<li><p>Object.observe 的回调函数</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. Vue 3 中的 toRef 和 toRefs 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>toRef：将对象的某个属性转换为 ref。</p>
<p>toRefs：将整个响应式对象的所有属性转换为 ref。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { reactive, toRef, toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> });
    <span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// 单个属性</span>
    <span class="hljs-keyword">const</span> stateRefs = <span class="hljs-title function_">toRefs</span>(state); <span class="hljs-comment">// 所有属性</span>

    <span class="hljs-keyword">return</span> { nameRef, stateRefs };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. var 、let 、 const 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`</div><details class="inner-content"><ul>
<li><strong>1：</strong> var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;
        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;</li>
<li><strong>1：</strong> let、 const 作用域: 级作用域（只在其所在的代码块内有效）;
    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;</li>
<li><strong>1：</strong> 区别:
      const： 需要在声明时初始化，且之后不能被修改;
      let：可以修改其值;
      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. TypeScript中的装饰器是什么？如何使用？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>
</li>
<li><p><strong>4：</strong> 常见的装饰器类型：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 类装饰器</span>
<span class="hljs-keyword">function</span> classDecorator&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>:any[]):{}}&gt;(<span class="hljs-attr">constructor</span>:T) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> constructor {
        newProperty = <span class="hljs-string">&quot;new property&quot;</span>;
        hello = <span class="hljs-string">&quot;override&quot;</span>;
    }
}

<span class="hljs-comment">// 方法装饰器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">methodDecorator</span>(<span class="hljs-params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) {
    <span class="hljs-comment">// 保存原始方法</span>
    <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;
    
    <span class="hljs-comment">// 修改方法的行为</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: any[]</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before method execution&#x27;</span>);
        <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After method execution&#x27;</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-comment">// 使用装饰器</span>
@classDecorator
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {
    @methodDecorator
    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);
    }
}

<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();
e.<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// Before method execution</span>
<span class="hljs-comment">// Hello!</span>
<span class="hljs-comment">// After method execution</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Suspense是在vue3中新提供的，用来处理异步组件的加载状态。</li>
<li><strong>1：</strong> Suspense 组件允许你指定一个加载中的状态<code>（fallback）</code>和一个加载失败的状态<code>（fallback slot）</code>，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中
的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong>
flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：
display: flex：将容器设置为弹性容器。
flex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。
justify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。
align-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. absolute与fixed共同点与不同点</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>共同点：</p>
<ul>
<li><p>改变行内元素的呈现方式，将display置为inline-block  </p>
</li>
<li><p>使元素脱离普通文档流，不占据空间</p>
</li>
<li><p>覆盖非定位文档元素</p>
</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</p>
</li>
<li><p>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. 什么是TCP/IP和UDP</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">71. Vue 3 中的 Fragment 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Fragment 允许组件返回多个根元素。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;div&gt;Hello&lt;/div&gt;
  &lt;div&gt;Vue 3&lt;/div&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">42. Vue 如何清除浏览器缓存？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；</p>
</li>
<li><p>在 html 文件中加入 meta 标签，content 属性设置为no-cache;</p>
</li>
<li><p>在后端服务器中进行禁止缓存设置。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 简述 Vuex 的核心概念和工作流程</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 核心概念:<br/>
&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>
&emsp;Mutations：用于同步修改 State 中的数据。
是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>
&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>
&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>
<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，
Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化
和组件的更新。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. Nodejs的模块化有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Node.js的模块化有以下几种方法：</p>
<ul>
<li><p>CommonJS模块化：使用<code>require</code>和<code>module.exports</code>进行模块导入和导出。</p>
</li>
<li><p>ES6模块化：使用<code>import</code>和<code>export</code>进行模块导入和导出。</p>
</li>
<li><p>AMD模块化：使用<code>define</code>和<code>require</code>进行模块导入和导出。</p>
</li>
<li><p>UMD模块化：兼容CommonJS和AMD模块化。</p>
</li>
<li><p>全局变量：将变量挂载到<code>global</code>对象上，方便全局访问。</p>
</li>
<li><p>命名空间：将变量挂载到命名空间对象上，避免全局变量污染。</p>
</li>
<li><p>模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 如何清除浮动?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong>
.clearfix{
  clear:both;
  content:&#39;&#39;;
  display:block;
  width: 0;
  height: 0;
  visibility:hidden;
}</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>
<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. isNaN 和 Number.isNaN 函数的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p>
</li>
<li><p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. React如何做路由监听</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><pre><code class="hljs language-react">
<span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){ <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">router</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>)=&gt;</span>{ <span class="hljs-keyword">if</span>(route.<span class="hljs-property">pathname</span>===<span class="hljs-string">&#x27;/xxx&#x27;</span>){ <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); } }); } 
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. React18中引入了新的startTransition API，说说它的作用以及如何使用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。</p>
</li>
<li><p>这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。</p>
</li>
<li><p>通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”</p>
</li>
<li><p>这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. React如何进行代码拆分？拆分的原则是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>
</li>
<li><p>在我们的react项目中：</p>
</li>
<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>
</li>
<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>
</li>
<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>
</li>
<li><p>静态类型的资源单独放置</p>
</li>
<li><p>公共组件、高阶组件、插件单独放置</p>
</li>
<li><p>工具类文件单独放置</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. Redux 有哪些优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>
</li>
<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>
</li>
<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>
</li>
<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>
</li>
<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>
</li>
<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. 如何用 React构建（ build）生产模式？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. 如何跟踪功能组件中对象字段的变化？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Changed!&#x27;</span>)
}, [obj.<span class="hljs-property">someField</span>])
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行</p>
<p>componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。</p>
<p>componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。</p>
<p>访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：</p>
<p>使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">PWA有那些优点？</h4><div class="head-re"><span class="head-score">9 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>
<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>
<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>
<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>
<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>
<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>
<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>
<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>
<li><strong>1：</strong> 绕过应用商店</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. React.Component 和 React.PureComponent 的区别</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>区别：</p>
<p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：</p>
<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>
<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>
<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">67. 说说React的Context API及其使用场景</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>
</li>
<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>
</li>
<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 使用 Mobx 的特点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. proxy是工作原理？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>({<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
}));
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 WebAssembly？其主要用途是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>
<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>
<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>
<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。</p>
</li>
<li><p><strong>1：</strong> Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。</p>
</li>
<li><p><strong>1：</strong> 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. transition和animation的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p>
<p>animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是多核处理器（Multi-Core Processor）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 对媒体查询的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<pre><code class="hljs language-html">&lt;!-- link元素中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; 
&lt;!-- 样式表中的<span class="hljs-variable constant_">CSS</span>媒体查询 --&gt; 
&lt;style&gt; 
@media (max-width: 600px) { 
  .facet_sidebar { 
    display: none; 
  } 
}
&lt;/style&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. 全屏滚动的原理是什么？用到了CSS的哪些属性？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现
overflow：hidden；transition：all 1000ms ease；</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">src 与 href 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Vue 3 中的 Suspense 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>Suspense 用于处理异步组件的加载状态。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;AsyncComponent /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
</code></pre></details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-25T02:37:45.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CdRx0EWC\",\"ing.md\":\"C4KskrqH\",\"readme.md\":\"BJAUy-oU\",\"src_guide_getting-started.md\":\"B67E5foD\",\"src_guide_why.md\":\"D5uSQAYp\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"BuAPywA4\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"CIMTA1da\",\"src_questions_computer-base_1_计算机硬件.md\":\"B0QJLjZk\",\"src_questions_computer-base_2_计算机软件.md\":\"BIQNd-dr\",\"src_questions_computer-base_3_计算机网络.md\":\"CLBkP-oo\",\"src_questions_computer-base_4_计算机编程.md\":\"B67fFYr4\",\"src_questions_computer-base_5_计算机科学.md\":\"Am6SiERC\",\"src_questions_computer-base_6_软件工程.md\":\"DHTkMmfz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BeoM2cLL\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"Cm7EEYLV\",\"src_questions_data-structures-algorithms_1_算法.md\":\"C36XHruA\",\"src_questions_front-architect_1_前端架构.md\":\"Dn5REoYo\",\"src_questions_front-base_1_html.md\":\"7rp5WzQA\",\"src_questions_front-base_2_css.md\":\"ej_lSZpa\",\"src_questions_front-base_3_javascript.md\":\"BrbVzDu0\",\"src_questions_front-base_4_typescript.md\":\"C_8sV-Uu\",\"src_questions_front-component_1_ui组件库.md\":\"BUsuUtfN\",\"src_questions_front-component_2_业务组件库.md\":\"Cj8aMQXA\",\"src_questions_front-engineering_1_前端标准化.md\":\"CO9AvNec\",\"src_questions_front-engineering_2_前端自动化.md\":\"BD6Nrd2Z\",\"src_questions_front-engineering_3_webpack.md\":\"BFh-dMzP\",\"src_questions_front-engineering_4_vite.md\":\"BZ_CfkBT\",\"src_questions_front-engineering_5_rollup.md\":\"DLZWgLW7\",\"src_questions_front-frame_1_react.md\":\"EWaBAfHZ\",\"src_questions_front-frame_2_vue.md\":\"uJAKFK5R\",\"src_questions_front-frame_3_next.md\":\"CF65gB-q\",\"src_questions_front-frame_4_nuxt.md\":\"CxB_CpX1\",\"src_questions_front-frame_5_qiankun.md\":\"OEjnB5ZT\",\"src_questions_front-newest_1_前端最前沿.md\":\"WPYcZ4Na\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DFHvsn2Y\",\"src_questions_front-runtime_1_浏览器.md\":\"D1E5yw3M\",\"src_questions_front-runtime_2_nodejs.md\":\"DKz7cJ09\",\"src_questions_front-safety_1_前端安全.md\":\"CqkE8BB4\",\"src_questions_server_1_nest.md\":\"DUuQlIPe\",\"src_questions_server_2_mongodb.md\":\"C8uvoIbU\",\"src_questions_server_3_mysql.md\":\"2-9BwMsY\",\"src_questions_server_4_nginx.md\":\"r9j2e8Tl\",\"src_questions_server_5_docker.md\":\"Bp1ijTFM\",\"src_questions_server_6_kubernets.md\":\"C0jgLa_V\",\"src_questions_server_7_nacos.md\":\"DzFOSoaR\",\"src_questions_server_8_redis.md\":\"xynWRlvo\",\"src_training_training-architecture_index.md\":\"nBXaS7jn\",\"src_training_training-experts_index.md\":\"C3-C1tP9\",\"src_training_training-intermediate_index.md\":\"CVSVsAVW\",\"src_training_training-primary_index.md\":\"CRJU82XK\",\"src_training_training-senior_index.md\":\"Chh9CF7-\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>