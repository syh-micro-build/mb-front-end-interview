<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DEQL0GKN.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.CSA9e9Ah.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.y5MckFiJ.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.KAQz_zsC.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.BrcGar2Z.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>shallowRef：只对 .value 进行响应式处理。</p>
<p>shallowReactive：只对对象的第一层属性进行响应式处理。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { shallowRef, shallowReactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">shallowRef</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 基本类型</span>
    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">shallowReactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue 3&#x27;</span>, <span class="hljs-attr">info</span>: { <span class="hljs-attr">age</span>: <span class="hljs-number">3</span> } }); <span class="hljs-comment">// 对象类型</span>

    <span class="hljs-keyword">return</span> { count, state };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 谈一谈对 MVVM 的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. Promise 的常用方法</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。</li>
<li><strong>1：</strong> Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。</li>
<li><strong>1：</strong> Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。</li>
<li><strong>1：</strong> Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。</li>
<li><strong>1：</strong> Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。</li>
<li><strong>1：</strong> Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。</li>
<li><strong>1：</strong> Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 如何在组件中批量使用Vuex的getter属性</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>如何在组件中批量使用Vuex的getter属性</p>
<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {mapGetters} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">computed</span>:{
        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])
    }
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. iframe 有哪些特点（优缺点）？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 优点：<ul>
<li>内容独立：iframe 中的元素、变量、样式是独立的；</li>
<li>并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；</li>
<li>灵活性强：可以引入各类网站，即使跨域；</li>
</ul>
</li>
<li><strong>2：</strong> 缺点：<ul>
<li>不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；</li>
<li>性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；</li>
<li>通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP 三次握手与四次挥手</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>TCP 三次握手</li>
<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>
<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服
务器同意建立连接。</li>
<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成
功。此时，双方都确认连接已建立，可以开始数据传输。</li>
<li>TCP 四次挥手</li>
<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>
<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据
未发送完，所以先不关闭连接。</li>
<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>
<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段
时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. class和function的区别?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>相同点：1. 函数作为构造函数</p>
</li>
<li><p>不同点：</p>
</li>
<li><p>class构造函数必须使用new操作符。</p>
</li>
<li><p>class声明不可以提升。</p>
</li>
<li><p>class不可以用call、apply、bind改变this指向。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">虚拟化（Virtualization）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是同源策略，它如何影响前端安全？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。</li>
<li><strong>1：</strong> 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 简述 Vuex 的核心概念和工作流程</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 核心概念:<br/>
&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>
&emsp;Mutations：用于同步修改 State 中的数据。
是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>
&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>
&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>
<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，
Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化
和组件的更新。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 说一下 Vue SSR 的实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>
</li>
<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 全局注册在 main.js 中使用 app.directive(&#39;指令名&#39;, 指令对象)；局部注册在组件内，通过 directives: { &#39;指令名&#39;: 指令对象 }，指令对象包含
 mounted、updated 等生命周期钩子函数用于定义指令行为。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 怎么理解Vue的单向数据流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>
<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在前端如何安全地处理用户密码？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=&quot;password&quot;来隐藏用户输入。</li>
<li><strong>1：</strong> 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。</li>
<li><strong>1：</strong> 避免本地缓存：设置表单元素的autocomplete=&quot;off&quot;，防止浏览器缓存密码。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. JS严格模式有什么特点？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>全局变量必须声明</p>
</li>
<li><p>禁止this指向windows</p>
</li>
<li><p>函数参数名称不能重复</p>
</li>
<li><p>禁止使用with语句</p>
</li>
<li><p>创建eval作用域（单独作用域）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">热插拔（Hot Swap）是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Vuex的严格模式是什么,有什么作用，如何开启？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p>在Vuex.Store 构造器选项中开启,如下</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
  <span class="hljs-attr">strict</span>: <span class="hljs-literal">true</span>
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">49. 宏任务有哪些？微任务有哪些？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。</p>
</li>
<li><p>常见的宏任务有：</p>
</li>
<li><p>setTimeout 和 setInterval 的回调函数</p>
</li>
<li><p>DOM 事件</p>
</li>
<li><p>XMLHttpRequest 中的readystatechange事件</p>
</li>
<li><p>requestAnimationFrame 中的回调函数</p>
</li>
<li><p>I/O 操作和网络请求的回调函数</p>
</li>
<li><p>Node.js 中的文件读写操作的回调函数</p>
</li>
<li><p>Node.js 中的进程事件</p>
</li>
<li><p>常见的微任务有：</p>
</li>
<li><p>Promise.then 和 Promise.catch 的回调函数</p>
</li>
<li><p>MutationObserver 的回调函数</p>
</li>
<li><p>process.nextTick 函数</p>
</li>
<li><p>Object.observe 的回调函数</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. Nodejs适用于哪些场景？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>T后端开发，Nodejs的异步I/O天生适合做Web高并发。</p>
</li>
<li><p>BFF开发，比如SSR中间层或者GraphQL中间层。</p>
</li>
<li><p>前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. HTML5 为什么只需要写 docType</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. TypeScript中的装饰器是什么？如何使用？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>
</li>
<li><p><strong>4：</strong> 常见的装饰器类型：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 类装饰器</span>
<span class="hljs-keyword">function</span> classDecorator&lt;T <span class="hljs-keyword">extends</span> {<span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>:any[]):{}}&gt;(<span class="hljs-attr">constructor</span>:T) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> constructor {
        newProperty = <span class="hljs-string">&quot;new property&quot;</span>;
        hello = <span class="hljs-string">&quot;override&quot;</span>;
    }
}

<span class="hljs-comment">// 方法装饰器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">methodDecorator</span>(<span class="hljs-params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) {
    <span class="hljs-comment">// 保存原始方法</span>
    <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>;
    
    <span class="hljs-comment">// 修改方法的行为</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args: any[]</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Before method execution&#x27;</span>);
        <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;After method execution&#x27;</span>);
        <span class="hljs-keyword">return</span> result;
    }
}

<span class="hljs-comment">// 使用装饰器</span>
@classDecorator
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {
    @methodDecorator
    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);
    }
}

<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();
e.<span class="hljs-title function_">greet</span>();
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// Before method execution</span>
<span class="hljs-comment">// Hello!</span>
<span class="hljs-comment">// After method execution</span>
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">哪些操作会造成内存泄漏？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>1：</strong> 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>1：</strong> 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>1：</strong> 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. JS 什么是防抖和节流？它们的应用场景有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。</li>
<li><strong>2：</strong> 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. 如何阻止事件冒泡，事件的默认行为？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>阻止事件冒泡：</p>
</li>
<li><p>event.stopPropagation();</p>
</li>
<li><p>IE：evnet.cancelBuddle = true;</p>
</li>
<li><p>阻止事件默认行为：</p>
</li>
<li><p>event.preventDefault();</p>
</li>
<li><p>IE： e.return Value = false;</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSRF 攻击</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>
<li><strong>:4</strong> 防御：</li>
</ul>
<blockquote>
<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>
<blockquote>
<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>
</blockquote>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. 解释一下Node.js的Express框架及其主要组件?</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：</p>
</li>
<li><p>Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。</p>
</li>
<li><p>Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。</p>
</li>
<li><p>View engine：视图引擎，用于渲染HTML模板。</p>
</li>
<li><p>Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。</p>
</li>
<li><p>Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。</p>
</li>
<li><p>Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。</p>
</li>
<li><p>Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. CSS 中的三种常用布局方式？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> float 布局：通过浮动和清除浮动来实现布局</li>
<li><strong>1：</strong> flex 布局：更加现代和灵活，适用于一维布局</li>
<li><strong>1：</strong> grid 布局：二维布局，支持更复杂的布局</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Suspense是在vue3中新提供的，用来处理异步组件的加载状态。</li>
<li><strong>1：</strong> Suspense 组件允许你指定一个加载中的状态<code>（fallback）</code>和一个加载失败的状态<code>（fallback slot）</code>，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中
的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. 解释 Set 和 Map 的使用及区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Set：是一个集合，用于存储不重复的值，按照插入顺序排列。</li>
<li><strong>1：</strong> Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// Set</span>
<span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);
set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 会被忽略</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set { 1, 2 }</span>

<span class="hljs-comment">// Map</span>
<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);
map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">25</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// Alice</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. 谈谈你对锚点的理解</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> What &amp; Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；</li>
<li><strong>1：</strong> How：<code>&lt;h2 id=&quot;know&quot;&gt;谈谈你对锚点的理解 &lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/h2&gt;</code>、<code>&lt;div&gt;&lt;a name=&quot;know&quot;&gt;​&lt;/a&gt;&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/div&gt;</code>、``；</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>两者都是浅拷贝。</p>
</li>
<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>
</li>
<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么情况会阻塞渲染</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。</p>
</li>
<li><p><strong>4：</strong></p>
<ul>
<li>当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。</li>
<li>如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</li>
<li>script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。</li>
<li>对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() =&gt; console.log(&#39;Delayed&#39;), 1000);，1 秒后会执行一次回调打印Delayed。
setInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() =&gt; console.log(&#39;Repeating&#39;), 1000);，每隔 1 秒就会执行一次回调打印Repeating。</li>
<li><strong>1：</strong> 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() =&gt; console.log(&#39;Timeout&#39;), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。
    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">70. Unicode、UTF-8、UTF-16、UTF-32的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。</p>
</li>
<li><p>UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。</p>
</li>
<li><p>UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>
</li>
<li><p>UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>
</li>
<li><p>UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 请介绍一下require的模块加载机制？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>先计算模块路径</p>
</li>
<li><p>如果模块在缓存里面，取出缓存</p>
</li>
<li><p>如果是内置模块，取出内置模块</p>
</li>
<li><p>加载模块</p>
</li>
<li><p>输出模块的exports属性即可</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. useState 连续调用，页面不更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [age,  setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">42</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
}

<span class="hljs-comment">// 点击一次后，age 将只会变为 43 而不是 45！</span>
</code></pre><ul>
<li><strong>1：</strong> 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。</li>
<li><strong>1：</strong> 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 =&gt; 43)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(43 =&gt; 44)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(44 =&gt; 45)</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20. CommonJS和ES6模块的区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> Iterator 描述</li>
</ul>
<p>迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</p>
<p>注：迭代器可以帮助我们去遍历某个数据结构。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8">文档</a></p>
<ul>
<li><strong>2：</strong> 实现一个简单的迭代器</li>
</ul>
<p>迭代器是一个对象，但是需要符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">文档</a>
注：在使用的过程中，根据需求，进行修改。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">/**
 * 下面就是一个迭代器
 * 但是他是毫无作用的
 */</span>
<span class="hljs-comment">/*
const iterator = {
    next: function () {
        return {done: true, value: &quot;test&quot;};
    }
};
*/</span>

<span class="hljs-comment">/**
 * 创建一个迭代器，去访问一个数组
 * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）
 *
 * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createArrayIterator</span>(<span class="hljs-params">arr</span>) {
    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> arrIterator = {
        <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-comment">// return {done: false, value: &quot;你好&quot;};</span>
            <span class="hljs-comment">// return {done: false, value: &quot;哈哈&quot;};</span>
            <span class="hljs-comment">// return {done: false, value: &quot;啊啊&quot;};</span>
            <span class="hljs-comment">// return {done: true, value: undefined};</span>
            <span class="hljs-keyword">if</span> (index &lt; arr.<span class="hljs-property">length</span>) {
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: arr[index++]};
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> {<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>};
            }
        }
    };
    <span class="hljs-keyword">return</span> arrIterator;
}

<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-string">&quot;哈哈&quot;</span>, <span class="hljs-string">&quot;啊啊&quot;</span>];
<span class="hljs-keyword">const</span> arr1Iterator = <span class="hljs-title function_">createArrayIterator</span>(arr1);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-comment">// 前面的都能访问到，后面的就无法访问了</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1Iterator.<span class="hljs-title function_">next</span>());

<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> arr2Iterator = <span class="hljs-title function_">createArrayIterator</span>(arr2);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2Iterator.<span class="hljs-title function_">next</span>());
</code></pre><p> <img src="https://not-have.github.io/file/images/image-20240202230330197.png" alt="image-20240202230330197"></p>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. src 与 href 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-07T10:22:06.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"67oPUNm0\",\"ing.md\":\"B1bdgE1J\",\"readme.md\":\"Byfv3CVo\",\"src_guide_getting-started.md\":\"zW1zakJi\",\"src_guide_why.md\":\"D2x4ud5w\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"CNJOJ2_8\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Dt66jo8r\",\"src_questions_computer-base_1_计算机硬件.md\":\"C4Oz8Lb9\",\"src_questions_computer-base_2_计算机软件.md\":\"CF1aUnc6\",\"src_questions_computer-base_3_计算机网络.md\":\"DBideFga\",\"src_questions_computer-base_4_计算机编程.md\":\"BVJgAmGm\",\"src_questions_computer-base_5_计算机科学.md\":\"DWeV7UIw\",\"src_questions_computer-base_6_软件工程.md\":\"DNQN1yEz\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"BY6WVDnG\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"B_0bvJA3\",\"src_questions_data-structures-algorithms_1_算法.md\":\"D8SrYBaL\",\"src_questions_front-architect_1_前端架构.md\":\"Dbgj-82H\",\"src_questions_front-base_1_html.md\":\"DMB_hQ8I\",\"src_questions_front-base_2_css.md\":\"wvegWmTo\",\"src_questions_front-base_3_javascript.md\":\"BJN_QHKI\",\"src_questions_front-base_4_typescript.md\":\"C2tEm5ek\",\"src_questions_front-component_1_ui组件库.md\":\"DdkXqeGF\",\"src_questions_front-component_2_业务组件库.md\":\"nlmFiq-7\",\"src_questions_front-engineering_1_前端标准化.md\":\"CcVdD_4-\",\"src_questions_front-engineering_2_前端自动化.md\":\"C_ObcZUk\",\"src_questions_front-engineering_3_webpack.md\":\"C_UQqPoj\",\"src_questions_front-engineering_4_vite.md\":\"JeGPZMNA\",\"src_questions_front-engineering_5_rollup.md\":\"C2M1uYps\",\"src_questions_front-frame_1_react.md\":\"BnVer4CL\",\"src_questions_front-frame_2_vue.md\":\"uIqyO-Oo\",\"src_questions_front-frame_3_next.md\":\"DtEaYuR9\",\"src_questions_front-frame_4_nuxt.md\":\"C1WrCg8L\",\"src_questions_front-frame_5_qiankun.md\":\"BwZ10FDj\",\"src_questions_front-newest_1_前端最前沿.md\":\"CkOPJbom\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"Y1YYN3Ud\",\"src_questions_front-runtime_1_浏览器.md\":\"CaS6fm6h\",\"src_questions_front-runtime_2_nodejs.md\":\"C6XqsZ1A\",\"src_questions_front-safety_1_前端安全.md\":\"C6DLHJ43\",\"src_questions_server_1_nest.md\":\"BOMSNSSC\",\"src_questions_server_2_mongodb.md\":\"NWpo9pl3\",\"src_questions_server_3_mysql.md\":\"DpJwRIli\",\"src_questions_server_4_nginx.md\":\"qNFFGs-P\",\"src_questions_server_5_docker.md\":\"BOgiSHaM\",\"src_questions_server_6_kubernets.md\":\"doe--BqB\",\"src_questions_server_7_nacos.md\":\"C4GksE-T\",\"src_questions_server_8_redis.md\":\"BuBc2S9c\",\"src_training_training-architecture_index.md\":\"RvkubvPc\",\"src_training_training-experts_index.md\":\"C3Bg7WJV\",\"src_training_training-intermediate_index.md\":\"DrMfWgHU\",\"src_training_training-primary_index.md\":\"BrcGar2Z\",\"src_training_training-senior_index.md\":\"DmVOE8P3\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>