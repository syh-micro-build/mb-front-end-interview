import{_ as a,c as o,a0 as t,o as r}from"./chunks/framework.Canm8p3M.js";const W=JSON.parse('{"title":"Next","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/front-frame/3_Next.md","filePath":"src/questions/front-frame/3_Next.md","lastUpdated":1735184713000}'),d={name:"src/questions/front-frame/3_Next.md"};function c(l,e,i,s,n,h){return r(),o("div",null,e[0]||(e[0]=[t('<h1 id="next" tabindex="-1">Next <a class="header-anchor" href="#next" aria-label="Permalink to &quot;Next&quot;">​</a></h1><h2 id="next-js-与-react-技术选型的区别在哪里" tabindex="-1">Next.js 与 React 技术选型的区别在哪里？ <a class="header-anchor" href="#next-js-与-react-技术选型的区别在哪里" aria-label="Permalink to &quot;Next.js 与 React 技术选型的区别在哪里？&quot;">​</a></h2><h4 id="类型-基础" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。</p></li><li><p><strong>1：</strong> Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。</p></li></ul><h2 id="什么是服务器端渲染-ssr" tabindex="-1">什么是服务器端渲染（SSR）？ <a class="header-anchor" href="#什么是服务器端渲染-ssr" aria-label="Permalink to &quot;什么是服务器端渲染（SSR）？&quot;">​</a></h2><h4 id="类型-基础-1" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-1" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。</li></ul><h2 id="ssr-的原理是什么" tabindex="-1">SSR 的原理是什么？ <a class="header-anchor" href="#ssr-的原理是什么" aria-label="Permalink to &quot;SSR 的原理是什么？&quot;">​</a></h2><h4 id="类型-基础-2" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-2" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分-1" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分-1" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>2：</strong> 当用户请求一个页面时，服务器会执行以下步骤： <ul><li>获取页面数据和模板。</li><li>使用数据和模板生成完整的 HTML 页面。</li><li>将 HTML 页面发送给浏览器。</li><li>浏览器解析和显示 HTML 页面。</li></ul></li></ul>',16)]))}const w=a(d,[["render",c]]);export{W as __pageData,w as default};
