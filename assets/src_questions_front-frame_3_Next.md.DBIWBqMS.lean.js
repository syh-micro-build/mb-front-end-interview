import{_ as a,c as t,a2 as s,o as i}from"./chunks/framework.Dvg3AjVP.js";const p=JSON.parse('{"title":"Next","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/front-frame/3_Next.md","filePath":"src/questions/front-frame/3_Next.md","lastUpdated":1739954034000}'),o={name:"src/questions/front-frame/3_Next.md"};function l(r,e,d,n,h,c){return i(),t("div",null,e[0]||(e[0]=[s('<h1 id="next" tabindex="-1">Next <a class="header-anchor" href="#next" aria-label="Permalink to &quot;Next&quot;">​</a></h1><h2 id="next-js-与-react-技术选型的区别在哪里" tabindex="-1">Next.js 与 React 技术选型的区别在哪里？ <a class="header-anchor" href="#next-js-与-react-技术选型的区别在哪里" aria-label="Permalink to &quot;Next.js 与 React 技术选型的区别在哪里？&quot;">​</a></h2><h4 id="类型-基础" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。</p></li><li><p><strong>1：</strong> Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。</p></li></ul><h2 id="什么是服务器端渲染-ssr" tabindex="-1">什么是服务器端渲染（SSR）？ <a class="header-anchor" href="#什么是服务器端渲染-ssr" aria-label="Permalink to &quot;什么是服务器端渲染（SSR）？&quot;">​</a></h2><h4 id="类型-基础-1" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-1" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。</li></ul><h2 id="ssr-的原理是什么" tabindex="-1">SSR 的原理是什么？ <a class="header-anchor" href="#ssr-的原理是什么" aria-label="Permalink to &quot;SSR 的原理是什么？&quot;">​</a></h2><h4 id="类型-基础-2" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-2" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分-1" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分-1" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>2：</strong> 当用户请求一个页面时，服务器会执行以下步骤： <ul><li>获取页面数据和模板。</li><li>使用数据和模板生成完整的 HTML 页面。</li><li>将 HTML 页面发送给浏览器。</li><li>浏览器解析和显示 HTML 页面。</li></ul></li></ul><h2 id="next-js-中getstaticprops函数的用途是什么-getserversideprops和getstaticprops函数有什么区别" tabindex="-1">Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？ <a class="header-anchor" href="#next-js-中getstaticprops函数的用途是什么-getserversideprops和getstaticprops函数有什么区别" aria-label="Permalink to &quot;Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？&quot;">​</a></h2><h4 id="类型-基础-3" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-3" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-3" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-3" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分-2" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分-2" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>1：</strong> getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件</li><li><strong>1：</strong> getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点</li></ul><h2 id="如何在-next-js-应用程序中配置动态路由" tabindex="-1">如何在 Next.js 应用程序中配置动态路由？ <a class="header-anchor" href="#如何在-next-js-应用程序中配置动态路由" aria-label="Permalink to &quot;如何在 Next.js 应用程序中配置动态路由？&quot;">​</a></h2><h4 id="类型-基础-4" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-4" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-4" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-4" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分-1" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分-1" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件</li></ul><h2 id="react-中-useeffect-与-next-js-用途是什么-有什么关系" tabindex="-1">React 中 useEffect 与 Next.js 用途是什么?有什么关系？ <a class="header-anchor" href="#react-中-useeffect-与-next-js-用途是什么-有什么关系" aria-label="Permalink to &quot;React 中 useEffect 与 Next.js 用途是什么?有什么关系？&quot;">​</a></h2><h4 id="类型-基础-5" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-5" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-5" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-5" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分-3" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分-3" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li><li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li></ul><h2 id="如何在-next-js-中优化图像" tabindex="-1">如何在 Next.js 中优化图像？ <a class="header-anchor" href="#如何在-next-js-中优化图像" aria-label="Permalink to &quot;如何在 Next.js 中优化图像？&quot;">​</a></h2><h4 id="类型-基础-6" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-6" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>Next.js 提供了内置的 <code>&lt;Image&gt;</code> 组件来优化图像，主要通过以下几种方式：</p><ul><li><strong>1：</strong> 自动调整大小：<code>&lt;Image&gt;</code> 组件会根据指定的宽度和高度自动调整图像大小，避免不必要的大尺寸图像加载。</li><li><strong>1：</strong> 压缩图像：Next.js 会在构建时自动压缩图像，减少图像文件大小。</li><li><strong>1：</strong> 懒加载：图像默认采用懒加载方式，只有当图像进入浏览器视口时才会加载，提高页面加载速度。</li></ul><h2 id="如何在-next-js-中处理-404-页面" tabindex="-1">如何在 Next.js 中处理 404 页面？ <a class="header-anchor" href="#如何在-next-js-中处理-404-页面" aria-label="Permalink to &quot;如何在 Next.js 中处理 404 页面？&quot;">​</a></h2><h4 id="类型-基础-7" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-7" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-7" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-7" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分-2" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分-2" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 在 Next.js 中，可以通过在 pages 目录下创建 404.js 文件来定义自定义 404 页面。示例代码如下：</li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Custom404</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;404 - 页面未找到&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;你访问的页面不存在。&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Custom404;</span></span></code></pre></div><h2 id="next-js中如何进行状态管理" tabindex="-1">Next.js中如何进行状态管理？ <a class="header-anchor" href="#next-js中如何进行状态管理" aria-label="Permalink to &quot;Next.js中如何进行状态管理？&quot;">​</a></h2><h4 id="类型-基础-8" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-8" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-8" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-8" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-9-分" tabindex="-1">解答（9 分） <a class="header-anchor" href="#解答-9-分" aria-label="Permalink to &quot;解答（9 分）&quot;">​</a></h4><ul><li><strong>2：</strong> 局部状态管理 <ul><li>useState：借助 React 的useState钩子可以管理组件内的简单状态。例如管理按钮的点击次数、输入框的值等。代码简洁，适合处理单一组件内独立的状态变化;</li><li>useReducer：当状态逻辑较为复杂，有多个子值或者下一个状态依赖于之前的状态时，使用useReducer更合适。它能把状态更新逻辑集中处理，让代码更易维护;</li></ul></li><li><strong>1：</strong> 全局状态管理（Context API）：React 自带的 Context API 可以在组件树中共享数据，避免了通过 props 层层传递数据的繁琐。在创建 Context 对象后，使用Provider包裹组件树，子组件通过useContext获取数据。不过在大型应用中，它的性能和可维护性可能会受到挑战。</li><li><strong>3：</strong> 第三方库 <ul><li>Redux：是一个可预测的状态容器，适合管理大型应用的复杂状态。它采用单向数据流，所有状态集中存储在 store 中，通过 action 触发 reducer 来更新状态。结合react-redux库可以方便地在 React 组件中使用 Redux。</li><li>MobX：基于响应式编程的思想，使用observable定义可观察的状态，action修改状态，组件可以自动响应状态的变化。它的代码简洁，学习成本相对较低。</li><li>Zustand：轻量级的状态管理库，使用简单，没有复杂的样板代码。它通过创建 store 函数来定义状态和更新逻辑，组件可以直接订阅 store 的变化。</li></ul></li><li><strong>3：</strong> 服务器状态管理 <ul><li>React Query：专注于处理服务器状态，如数据的获取、缓存、同步和更新等。它能自动处理加载状态、错误处理和数据的缓存，减少重复请求，提高应用性能。</li><li>SWR：也是用于数据获取的库，具有自动重新验证、聚焦重新验证、间隔重新验证等特性，能确保数据的实时性。</li></ul></li></ul>',48)]))}const k=a(o,[["render",l]]);export{p as __pageData,k as default};
