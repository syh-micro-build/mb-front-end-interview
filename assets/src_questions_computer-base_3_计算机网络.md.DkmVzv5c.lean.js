import{_ as i,c as e,a2 as s,o as l}from"./chunks/framework.Dvg3AjVP.js";const k=JSON.parse('{"title":"计算机网络","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/computer-base/3_计算机网络.md","filePath":"src/questions/computer-base/3_计算机网络.md","lastUpdated":1739954034000}'),h={name:"src/questions/computer-base/3_计算机网络.md"};function o(t,a,d,n,r,c){return l(),e("div",null,a[0]||(a[0]=[s('<h1 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h1><h2 id="_1-网络协议是什么" tabindex="-1">1. 网络协议是什么 <a class="header-anchor" href="#_1-网络协议是什么" aria-label="Permalink to &quot;1. 网络协议是什么&quot;">​</a></h2><h4 id="类型-基础" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li></ul><h2 id="_2-什么是tcp-ip和udp" tabindex="-1">2. 什么是TCP/IP和UDP <a class="header-anchor" href="#_2-什么是tcp-ip和udp" aria-label="Permalink to &quot;2. 什么是TCP/IP和UDP&quot;">​</a></h2><h4 id="类型-基础-1" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-1" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>1：</strong> TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li><li><strong>1：</strong> UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的</li></ul><h2 id="_3-tcp与udp区别是什么" tabindex="-1">3. TCP与UDP区别是什么 <a class="header-anchor" href="#_3-tcp与udp区别是什么" aria-label="Permalink to &quot;3. TCP与UDP区别是什么&quot;">​</a></h2><h4 id="类型-编程" tabindex="-1">类型：<code>编程</code> <a class="header-anchor" href="#类型-编程" aria-label="Permalink to &quot;类型：`编程`&quot;">​</a></h4><h4 id="级别-w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-8-分" tabindex="-1">解答（8 分） <a class="header-anchor" href="#解答-8-分" aria-label="Permalink to &quot;解答（8 分）&quot;">​</a></h4><ul><li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li><li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li><li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li><li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li><li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li><li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li><li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li><li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li></ul><h2 id="_4-http和https的区别是什么" tabindex="-1">4. HTTP和HTTPS的区别是什么？ <a class="header-anchor" href="#_4-http和https的区别是什么" aria-label="Permalink to &quot;4. HTTP和HTTPS的区别是什么？&quot;">​</a></h2><h4 id="类型-基础-2" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-2" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-5-分" tabindex="-1">解答（5 分） <a class="header-anchor" href="#解答-5-分" aria-label="Permalink to &quot;解答（5 分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> 安全性：</p><ul><li>HTTP是明文传输，数据可能被窃听和篡改</li><li>HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护</li></ul></li><li><p><strong>1：</strong> 端口：</p><ul><li>HTTP默认使用80端口</li><li>HTTPS默认使用443端口</li></ul></li><li><p><strong>1：</strong> 证书：</p><ul><li>HTTP不需要证书</li><li>HTTPS需要CA机构颁发的SSL证书</li></ul></li><li><p><strong>1：</strong> 性能：</p><ul><li>HTTP性能更好，因为没有加密解密过程</li><li>HTTPS因为需要加密解密，性能会有所损耗</li></ul></li><li><p><strong>1：</strong> 使用场景：</p><ul><li>HTTP适用于对安全要求不高的场景</li><li>HTTPS适用于需要保护用户隐私和数据安全的场景</li></ul></li></ul><h2 id="_5-什么是跨域-如何解决跨域问题" tabindex="-1">5. 什么是跨域？如何解决跨域问题？ <a class="header-anchor" href="#_5-什么是跨域-如何解决跨域问题" aria-label="Permalink to &quot;5. 什么是跨域？如何解决跨域问题？&quot;">​</a></h2><h4 id="类型-基础-3" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-3" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-3" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-3" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-6-分" tabindex="-1">解答（6 分） <a class="header-anchor" href="#解答-6-分" aria-label="Permalink to &quot;解答（6 分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> 什么是跨域：</p><ul><li>浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求</li><li>同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据</li></ul></li><li><p><strong>1：</strong> CORS（跨域资源共享）：</p><ul><li>使用场景：现代浏览器的首选跨域解决方案，适用于REST API</li><li>优点：支持所有类型的HTTP请求，配置灵活</li><li>缺点：需要服务器配合，老版本浏览器可能不支持</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务器端设置</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Methods&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;GET,PUT,POST,DELETE&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Headers&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li><strong>1：</strong> JSONP： <ul><li>使用场景：兼容老版本浏览器，只需要GET请求的场景</li><li>优点：兼容性好，实现简单</li><li>缺点：只支持GET请求，可能存在安全问题</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jsonp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}?callback=${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">callback</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>1：</strong> 代理服务器： <ul><li>使用场景：需要隐藏跨域细节，适合生产环境</li><li>优点：可以集中处理跨域问题，对前端透明</li><li>缺点：需要额外的服务器配置和维护</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// nginx配置示例</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">api {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  proxy_pass </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//backend-server;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  proxy_set_header Host $host;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  proxy_set_header </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $remote_addr;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>1：</strong> postMessage： <ul><li>使用场景：iframe跨域通信，不同标签页通信</li><li>优点：可以实现跨窗口通信，安全性好</li><li>缺点：使用相对复杂，需要双方页面都进行相应处理</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送消息</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;http://receiver.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收消息</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.origin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;http://sender.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li><strong>1：</strong> WebSocket： <ul><li>使用场景：需要实时双向通信的场景</li><li>优点：支持全双工通信，没有跨域限制</li><li>缺点：需要专门的服务器支持，协议和HTTP不同</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://example.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_6-osi七层模型是什么" tabindex="-1">6. OSI七层模型是什么？ <a class="header-anchor" href="#_6-osi七层模型是什么" aria-label="Permalink to &quot;6. OSI七层模型是什么？&quot;">​</a></h2><h4 id="类型-基础-4" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-4" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-4" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-4" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-7-分" tabindex="-1">解答（7 分） <a class="header-anchor" href="#解答-7-分" aria-label="Permalink to &quot;解答（7 分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> 应用层（第7层）：</p><ul><li>为应用程序提供网络服务</li><li>协议：HTTP、FTP、SMTP等</li><li>数据单位：消息</li></ul></li><li><p><strong>1：</strong> 表示层（第6层）：</p><ul><li>数据格式转换、加密解密</li><li>确保数据可以被接收方理解</li><li>数据单位：消息</li></ul></li><li><p><strong>1：</strong> 会话层（第5层）：</p><ul><li>建立、管理和终止会话</li><li>提供对话控制</li><li>数据单位：消息</li></ul></li><li><p><strong>1：</strong> 传输层（第4层）：</p><ul><li>端到端的可靠数据传输</li><li>协议：TCP、UDP</li><li>数据单位：段（TCP）、数据报（UDP）</li></ul></li><li><p><strong>1：</strong> 网络层（第3层）：</p><ul><li>负责数据包的路由和转发</li><li>协议：IP、ICMP</li><li>数据单位：数据包</li></ul></li><li><p><strong>1：</strong> 数据链路层（第2层）：</p><ul><li>相邻节点之间的数据传输</li><li>差错检测和纠正</li><li>数据单位：帧</li></ul></li><li><p><strong>1：</strong> 物理层（第1层）：</p><ul><li>比特流的传输</li><li>定义物理媒介、接口和电气特性</li><li>数据单位：比特</li></ul></li></ul><h2 id="_7-tcp和udp的使用场景" tabindex="-1">7. TCP和UDP的使用场景？ <a class="header-anchor" href="#_7-tcp和udp的使用场景" aria-label="Permalink to &quot;7. TCP和UDP的使用场景？&quot;">​</a></h2><h4 id="类型-基础-5" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-5" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-5" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-5" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p><p>UDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</p><h2 id="_8-udp协议为什么不可靠" tabindex="-1">8. UDP协议为什么不可靠？ <a class="header-anchor" href="#_8-udp协议为什么不可靠" aria-label="Permalink to &quot;8. UDP协议为什么不可靠？&quot;">​</a></h2><h4 id="类型-基础-6" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-6" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-1" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-1" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li><p>不保证消息交付：不确认，不重传，无超时</p></li><li><p>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</p></li><li><p>不跟踪连接状态：不必建立连接或重启状态机</p></li><li><p>不进行拥塞控制：不内置客户端或网络反馈机制</p></li></ul><h2 id="_9-tcp的重传机制" tabindex="-1">9. TCP的重传机制 <a class="header-anchor" href="#_9-tcp的重传机制" aria-label="Permalink to &quot;9. TCP的重传机制&quot;">​</a></h2><h4 id="类型-基础-7" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-7" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-7" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-7" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-2" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-2" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。</p><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h2 id="_10-tcp的拥塞控制机制" tabindex="-1">10. TCP的拥塞控制机制 <a class="header-anchor" href="#_10-tcp的拥塞控制机制" aria-label="Permalink to &quot;10. TCP的拥塞控制机制&quot;">​</a></h2><h4 id="类型-基础-8" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-8" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-8" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-8" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-3" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-3" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li><p>慢启动：TCP连接建立后，会经历一个慢启动的过程，即逐渐增加发送窗口的大小，以避免一开始就发送大量数据导致网络拥塞。</p></li><li><p>拥塞避免：当TCP检测到网络拥塞时，会进入拥塞避免阶段，此时发送窗口的大小会按照一定的速率增加，以避免快速增加导致网络拥塞。</p></li><li><p>快速重传：当TCP接收到三个重复的ACK时，会立即重传丢失的数据包，而不需要等待超时。</p></li><li><p>快速恢复：当TCP检测到网络拥塞时，会进入快速恢复阶段，此时发送窗口的大小会立即减半，然后进入拥塞避免阶段。</p></li></ul><h2 id="_11-tcp的流量控制机制" tabindex="-1">11. TCP的流量控制机制 <a class="header-anchor" href="#_11-tcp的流量控制机制" aria-label="Permalink to &quot;11. TCP的流量控制机制&quot;">​</a></h2><h4 id="类型-基础-9" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-9" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-9" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-9" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-4" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-4" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>TCP的流量控制机制主要是通过滑动窗口来实现的。发送方和接收方都会维护一个窗口，发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。当接收方收到数据后，会发送一个ACK确认报文，其中包含接收方窗口的大小，发送方根据这个信息来调整发送窗口的大小。</p><ul><li><p>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</p></li><li><p>当数据到达时，接收方将数据放入缓冲区，并告诉发送方缓冲区中还可以容纳多少数据。</p></li><li><p>当接收方应用程序读取数据时，接收方将窗口向前滑动，并告诉发送方窗口的大小。</p></li><li><p>发送方根据接收方窗口的大小来控制发送数据的速率，以避免发送方发送的数据过多导致接收方处理不过来。</p></li></ul><h2 id="_12-tcp的粘包和拆包问题" tabindex="-1">12. TCP的粘包和拆包问题 <a class="header-anchor" href="#_12-tcp的粘包和拆包问题" aria-label="Permalink to &quot;12. TCP的粘包和拆包问题&quot;">​</a></h2><h4 id="类型-基础-10" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-10" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-10" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-10" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-5" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-5" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>TCP的粘包和拆包问题是指TCP协议在传输数据时，由于数据包的大小和发送速率等因素，可能会导致数据包的粘连和拆分。例如，发送方发送了两个数据包，接收方可能会将这两个数据包粘连在一起，或者将一个数据包拆分成多个部分来接收。</p><p>TCP的粘包和拆包问题可以通过以下几种方式来解决：</p><ul><li><p>在数据包中添加分隔符：在数据包中添加分隔符，接收方可以根据分隔符来区分不同的数据包。例如，可以使用换行符作为分隔符。</p></li><li><p>在数据包中添加长度字段：在数据包中添加长度字段，接收方可以根据长度字段来区分不同的数据包。例如，可以使用长度字段来表示数据包的长度。</p></li><li><p>使用专门的协议：使用专门的协议来处理TCP的粘包和拆包问题，例如HTTP协议。</p></li></ul><h2 id="_13-tcp的可靠传输机制" tabindex="-1">13. TCP的可靠传输机制 <a class="header-anchor" href="#_13-tcp的可靠传输机制" aria-label="Permalink to &quot;13. TCP的可靠传输机制&quot;">​</a></h2><h4 id="类型-基础-11" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-11" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-11" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-11" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-6" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-6" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。</p><p>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。</p><p>当发送方收到接收方的三个冗余的确认应答后，这是一种指示，说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h2 id="_14-为什么udp不会粘包" tabindex="-1">14. 为什么udp不会粘包？ <a class="header-anchor" href="#_14-为什么udp不会粘包" aria-label="Permalink to &quot;14. 为什么udp不会粘包？&quot;">​</a></h2><h4 id="类型-基础-12" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-12" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-12" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-12" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-7" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-7" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><ul><li><p>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</p></li><li><p>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</p></li></ul><h2 id="_15-数字证书是什么" tabindex="-1">15. 数字证书是什么？ <a class="header-anchor" href="#_15-数字证书是什么" aria-label="Permalink to &quot;15. 数字证书是什么？&quot;">​</a></h2><h4 id="类型-基础-13" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-13" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-13" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-13" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-8" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-8" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p><p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p><p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p><h2 id="_16-https通信-握手-过程" tabindex="-1">16. HTTPS通信（握手）过程 <a class="header-anchor" href="#_16-https通信-握手-过程" aria-label="Permalink to &quot;16. HTTPS通信（握手）过程&quot;">​</a></h2><h4 id="类型-基础-14" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-14" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-14" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-14" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-9" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-9" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>HTTPS的通信过程如下：</p><ul><li><p>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p></li><li><p>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p></li><li><p>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p></li><li><p>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p></li><li><p>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</p></li></ul><h2 id="_17-dns-协议是什么" tabindex="-1">17. DNS 协议是什么 <a class="header-anchor" href="#_17-dns-协议是什么" aria-label="Permalink to &quot;17. DNS 协议是什么&quot;">​</a></h2><h4 id="类型-基础-15" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-15" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-15" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-15" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-10" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-10" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p><h2 id="_18-dns同时使用tcp和udp协议" tabindex="-1">18. DNS同时使用TCP和UDP协议？ <a class="header-anchor" href="#_18-dns同时使用tcp和udp协议" aria-label="Permalink to &quot;18. DNS同时使用TCP和UDP协议？&quot;">​</a></h2><h4 id="类型-基础-16" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-16" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-16" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-16" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-11" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-11" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>DNS占用53号端口，同时使用TCP和UDP协议</p><ul><li>在区域传输的时候使用TCP协议</li></ul><p>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p><p>TCP是一种可靠连接，保证了数据的准确性。</p><ul><li>在域名解析的时候使用UDP协议</li></ul><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h2 id="_19-dns同时使用tcp和udp协议" tabindex="-1">19. DNS同时使用TCP和UDP协议？ <a class="header-anchor" href="#_19-dns同时使用tcp和udp协议" aria-label="Permalink to &quot;19. DNS同时使用TCP和UDP协议？&quot;">​</a></h2><h4 id="类型-基础-17" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-17" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-17" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-17" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-12" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-12" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>DNS完整的查询过程</p><p>DNS服务器解析域名的过程：</p><ul><li><p>首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</p></li><li><p>浏览器会向DNS服务器发起一个查询请求，DNS服务器首先会查看自身的缓存，看是否有这个域名的映射关系，如果有直接返回结果，如果没有则继续下一步</p></li><li><p>DNS服务器向根域名服务器发起一个查询请求，根域名服务器返回顶级域名的地址（如.com），DNS服务器向顶级域名服务器发起一个查询请求，返回次级域名服务器的地址（如.baidu.com），DNS服务器向次级域名服务器发起一个查询请求，得到最终的IP地址</p></li><li><p>DNS服务器将得到的IP地址返回给客户端，客户端和目标建立连接</p></li><li><p>浏览器会缓存查询结果，以备下次使用</p></li></ul><h2 id="_20-迭代查询与递归查询" tabindex="-1">20. 迭代查询与递归查询 <a class="header-anchor" href="#_20-迭代查询与递归查询" aria-label="Permalink to &quot;20. 迭代查询与递归查询&quot;">​</a></h2><h4 id="类型-基础-18" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-18" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-18" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-18" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-13" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-13" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</p></li><li><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</p></li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h2 id="_21-http-常用的状态码及使用场景" tabindex="-1">21. HTTP 常用的状态码及使用场景？ <a class="header-anchor" href="#_21-http-常用的状态码及使用场景" aria-label="Permalink to &quot;21. HTTP 常用的状态码及使用场景？&quot;">​</a></h2><h4 id="类型-基础-19" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-19" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-19" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-19" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-14" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-14" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><ul><li><p>1xx：表示目前是协议的中间状态，还需要后续请求</p></li><li><p>2xx：表示请求成功</p></li><li><p>3xx：表示重定向状态，需要重新请求</p></li><li><p>4xx：表示请求报文错误</p></li><li><p>5xx：服务器端错误</p></li></ul><h2 id="_22-你知道-302-状态码是什么嘛-你平时浏览网页的过程中遇到过哪些-302-的场景" tabindex="-1">22. 你知道 302 状态码是什么嘛？你平时浏览网页的过程中遇到过哪些 302 的场景？ <a class="header-anchor" href="#_22-你知道-302-状态码是什么嘛-你平时浏览网页的过程中遇到过哪些-302-的场景" aria-label="Permalink to &quot;22. 你知道 302 状态码是什么嘛？你平时浏览网页的过程中遇到过哪些 302 的场景？&quot;">​</a></h2><h4 id="类型-基础-20" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-20" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-20" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-20" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-15" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-15" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>而 302 表示临时重定向，这个资源只是暂时不能被访问了，但是之后过一段时间还是可以继续访问，一般是访问某个网站的资源需要权限时，会需要用户去登录，跳转到登录页面之后登录之后，还可以继续访问。</p><p>301 类似，都会跳转到一个新的网站，但是 301 代表访问的地址的资源被永久移除了，以后都不应该访问这个地址，搜索引擎抓取的时候也会用新的地址替换这个老的。可以在返回的响应的 location 首部去获取到返回的地址。301 的场景如下：</p><ul><li><p>比如从 baidu.com，跳转到 baidu.com</p></li><li><p>域名换了</p></li></ul><h2 id="_23-http-常用的请求方式-区别和用途" tabindex="-1">23. HTTP 常用的请求方式，区别和用途？ <a class="header-anchor" href="#_23-http-常用的请求方式-区别和用途" aria-label="Permalink to &quot;23. HTTP 常用的请求方式，区别和用途？&quot;">​</a></h2><h4 id="类型-基础-21" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-21" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-21" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-21" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-16" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-16" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>http/1.1 规定如下请求方法：</p><ul><li><p>GET：通用获取数据</p></li><li><p>HEAD：获取资源的元信息</p></li><li><p>POST：提交数据</p></li><li><p>PUT：修改数据</p></li><li><p>DELETE：删除数据</p></li><li><p>CONNECT：建立连接隧道，用于代理服务器</p></li><li><p>OPTIONS：列出可对资源实行的请求方法，常用于跨域</p></li><li><p>TRACE：追踪请求-响应的传输路径</p></li></ul><h2 id="_24-https-是什么-具体流程" tabindex="-1">24. HTTPS 是什么？具体流程 <a class="header-anchor" href="#_24-https-是什么-具体流程" aria-label="Permalink to &quot;24. HTTPS 是什么？具体流程&quot;">​</a></h2><h4 id="类型-基础-22" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-22" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-22" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-22" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-17" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-17" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给 TCP，相应的 TCP 必须将数据包解密，才能传给上面的 HTTP。</p><p>浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和 pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个secret作为秘钥来进行数据的加解密。</p><h2 id="_25-在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" tabindex="-1">25. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？ <a class="header-anchor" href="#_25-在交互过程中如果数据传送完了-还不想断开连接怎么办-怎么维持" aria-label="Permalink to &quot;25. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？&quot;">​</a></h2><h4 id="类型-基础-23" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-23" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-23" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-23" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-18" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-18" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>在 HTTP 中响应体的 Connection 字段指定为 keep-alive</p><h2 id="_26-你对-tcp-滑动窗口有了解嘛" tabindex="-1">26. 你对 TCP 滑动窗口有了解嘛？ <a class="header-anchor" href="#_26-你对-tcp-滑动窗口有了解嘛" aria-label="Permalink to &quot;26. 你对 TCP 滑动窗口有了解嘛？&quot;">​</a></h2><h4 id="类型-基础-24" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-24" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-24" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-24" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-19" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-19" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。</p><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。</p><h2 id="_26-http-如何实现长连接-在什么时候会超时" tabindex="-1">26. HTTP 如何实现长连接？在什么时候会超时？ <a class="header-anchor" href="#_26-http-如何实现长连接-在什么时候会超时" aria-label="Permalink to &quot;26. HTTP 如何实现长连接？在什么时候会超时？&quot;">​</a></h2><h4 id="类型-基础-25" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-25" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-25" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-25" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-20" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-20" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><p>通过在头部（请求和响应头）设置 Connection: keep-alive，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长连接</p><ul><li><p>HTTP 一般会有 httpd 守护进程，里面可以设置 keep-alive timeout，当 tcp 链接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</p></li><li><p>TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当 TCP 链接之后，闲置了 tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 tcp_keepalive_probes，就会丢弃该链接。</p></li></ul><p>tcp_keepalive_intvl = 15</p><p>tcp_keepalive_probes = 5</p><p>tcp_keepalive_time = 1800</p><p>实际上 HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等</p>',181)]))}const u=i(h,[["render",o]]);export{k as __pageData,u as default};
