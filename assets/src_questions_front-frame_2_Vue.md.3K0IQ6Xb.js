import{_ as s,c as i,a0 as e,o as t}from"./chunks/framework.Canm8p3M.js";const p=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/front-frame/2_Vue.md","filePath":"src/questions/front-frame/2_Vue.md","lastUpdated":1735005210000}'),n={name:"src/questions/front-frame/2_Vue.md"};function l(h,a,o,r,d,c){return t(),i("div",null,a[0]||(a[0]=[e('<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="vue3和vue2的区别" tabindex="-1">vue3和vue2的区别 <a class="header-anchor" href="#vue3和vue2的区别" aria-label="Permalink to &quot;vue3和vue2的区别&quot;">​</a></h2><h4 id="类型-基础" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-11-分" tabindex="-1">解答（11 分） <a class="header-anchor" href="#解答-11-分" aria-label="Permalink to &quot;解答（11 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 源码组织方式变化：使用 TS 重写</li><li><strong>1：</strong> 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li><li><strong>1：</strong> 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li><li><strong>1：</strong> 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li><li><strong>1：</strong> 打包体积优化：移除了一些不常用的api（inline-template、filter）</li><li><strong>1：</strong> 生命周期的变化：使用setup代替了之前的beforeCreate和created</li><li><strong>1：</strong> Vue3 的 template 模板支持多个根标签</li><li><strong>1：</strong> Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li><li><strong>1：</strong> Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li><li><strong>1：</strong> Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li><li><strong>1：</strong> 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li></ul><h2 id="watch-和-watcheffect-的区别" tabindex="-1">watch 和 watchEffect 的区别？ <a class="header-anchor" href="#watch-和-watcheffect-的区别" aria-label="Permalink to &quot;watch 和 watchEffect 的区别？&quot;">​</a></h2><h4 id="类型-基础-1" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-1" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3分" tabindex="-1">解答（3分） <a class="header-anchor" href="#解答-3分" aria-label="Permalink to &quot;解答（3分）&quot;">​</a></h4><ul><li><p><strong>1：</strong> watch ：既要指明监视的数据源，也要指明监视的回调。</p></li><li><p><strong>1：</strong> watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</p></li><li><p><strong>1：</strong> watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</p></li></ul><h2 id="在-vue2-x-中如何检测数组的变化" tabindex="-1">在 Vue2.x 中如何检测数组的变化？ <a class="header-anchor" href="#在-vue2-x-中如何检测数组的变化" aria-label="Permalink to &quot;在 Vue2.x 中如何检测数组的变化？&quot;">​</a></h2><h4 id="类型-基础-2" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-2" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul><h2 id="在-v-if-与-v-show-的区别" tabindex="-1">在 v-if 与 v-show 的区别？ <a class="header-anchor" href="#在-v-if-与-v-show-的区别" aria-label="Permalink to &quot;在 v-if 与 v-show 的区别？&quot;">​</a></h2><h4 id="类型-基础-3" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-3" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-3" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-3" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分-1" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分-1" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li></ul><h2 id="如何实现-vue-组件的插槽-slot-有哪些类型的插槽" tabindex="-1">如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？ <a class="header-anchor" href="#如何实现-vue-组件的插槽-slot-有哪些类型的插槽" aria-label="Permalink to &quot;如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？&quot;">​</a></h2><h4 id="类型-基础-4" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-4" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-4" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-4" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1分-2" tabindex="-1">解答（1分） <a class="header-anchor" href="#解答-1分-2" aria-label="Permalink to &quot;解答（1分）&quot;">​</a></h4><ul><li><strong>1：</strong> 默认插槽、具名插槽、作用域插槽</li></ul><h2 id="简述-vuex-的核心概念和工作流程" tabindex="-1">简述 Vuex 的核心概念和工作流程 <a class="header-anchor" href="#简述-vuex-的核心概念和工作流程" aria-label="Permalink to &quot;简述 Vuex 的核心概念和工作流程&quot;">​</a></h2><h4 id="类型-基础-5" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-5" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-5" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-5" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2分" tabindex="-1">解答（2分） <a class="header-anchor" href="#解答-2分" aria-label="Permalink to &quot;解答（2分）&quot;">​</a></h4><ul><li><strong>1：</strong> 核心概念:<br>  State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br>  Mutations：用于同步修改 State 中的数据。 是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>  Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br>  Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li><li><strong>1：</strong> 工作流程：<br>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations， Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化 和组件的更新。</li></ul><h2 id="vue项目中如何进行性能优化" tabindex="-1">Vue项目中如何进行性能优化？ <a class="header-anchor" href="#vue项目中如何进行性能优化" aria-label="Permalink to &quot;Vue项目中如何进行性能优化？&quot;">​</a></h2><h4 id="类型-基础-6" tabindex="-1">类型：<code>基础</code> <a class="header-anchor" href="#类型-基础-6" aria-label="Permalink to &quot;类型：`基础`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-10分" tabindex="-1">解答（10分） <a class="header-anchor" href="#解答-10分" aria-label="Permalink to &quot;解答（10分）&quot;">​</a></h4><details><ul><li><strong>1：</strong> 合理使用v-show和v-if：<br>  原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。 而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br>  应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。 对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br></li><li><strong>1：</strong> 优化组件的props和events传递：<br>  原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组 件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br>  应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应 用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。 对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。</li><li><strong>1：</strong> 使用keep-alive缓存组件:<br>  原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和 初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br>  应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹 表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。</li><li><strong>1：</strong> 列表渲染优化: 为v-for列表添加key属性<br>  原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要 更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br>  应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key</li><li><strong>2：</strong> 数据响应式优化: 避免过度的响应式数据<br>  原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据， 并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br>  应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将 这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只 对对象的第一层数据进行响应式处理，减少性能消耗。</li><li><strong>2：</strong> 路由层面优化: 路由懒加载<br>  原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加 快首屏加载速度。<br>  应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒 加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () =&gt; import(&#39;./views/ProductDetail.vue&#39;)，在 路由配置中{ path: &#39;/product - detail&#39;, component: ProductDetail }。</li><li><strong>1：</strong> 代码压缩和混淆（Webpack 相关）<br>  原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注 释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br></li><li><strong>1：</strong> 合理设置chunk大小和数量（Webpack 相关）<br>  原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过 大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br>  应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块 的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimization: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    splitChunks: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      chunks: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;all&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxAsyncRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxInitialRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      automaticNamePrefix: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;chunk - &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      cacheGroups: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        vendors: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">node_modules</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          reuseExistingChunk: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></details>',36)]))}const u=s(n,[["render",l]]);export{p as __pageData,u as default};
