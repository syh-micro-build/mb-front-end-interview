import{_ as e,c as o,a0 as n,o as r}from"./chunks/framework.Canm8p3M.js";const w=JSON.parse('{"title":"Qiankun","description":"","frontmatter":{},"headers":[],"relativePath":"src/questions/front-frame/5_Qiankun.md","filePath":"src/questions/front-frame/5_Qiankun.md","lastUpdated":1737341819000}'),i={name:"src/questions/front-frame/5_Qiankun.md"};function t(d,a,l,c,h,s){return r(),o("div",null,a[0]||(a[0]=[n('<h1 id="qiankun" tabindex="-1">Qiankun <a class="header-anchor" href="#qiankun" aria-label="Permalink to &quot;Qiankun&quot;">​</a></h1><h2 id="当前主流的微前端方案大概有哪些" tabindex="-1">当前主流的微前端方案大概有哪些？ <a class="header-anchor" href="#当前主流的微前端方案大概有哪些" aria-label="Permalink to &quot;当前主流的微前端方案大概有哪些？&quot;">​</a></h2><h4 id="类型-拓展" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w4、w5、w6" tabindex="-1">级别：<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w4、w5、w6" aria-label="Permalink to &quot;级别：`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-6-分" tabindex="-1">解答（6 分） <a class="header-anchor" href="#解答-6-分" aria-label="Permalink to &quot;解答（6 分）&quot;">​</a></h4><ul><li><strong>1：</strong> iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。</li><li><strong>1：</strong> single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。</li><li><strong>1：</strong> qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。</li><li><strong>1：</strong> micro-app：基于 Webcomponent 的微前端方案，由京东出品。</li><li><strong>1：</strong> EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。</li><li><strong>1：</strong> 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生</li></ul><h2 id="qiankun-有哪些优点" tabindex="-1">Qiankun 有哪些优点？ <a class="header-anchor" href="#qiankun-有哪些优点" aria-label="Permalink to &quot;Qiankun 有哪些优点？&quot;">​</a></h2><h4 id="类型-拓展-1" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-1" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-4-分" tabindex="-1">解答（4 分） <a class="header-anchor" href="#解答-4-分" aria-label="Permalink to &quot;解答（4 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。</li><li><strong>1：</strong> 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。</li><li><strong>1：</strong> 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。</li><li><strong>1：</strong> 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。</li></ul><h2 id="qiankun-如何实现子应用的加载" tabindex="-1">Qiankun 如何实现子应用的加载？ <a class="header-anchor" href="#qiankun-如何实现子应用的加载" aria-label="Permalink to &quot;Qiankun 如何实现子应用的加载？&quot;">​</a></h2><h4 id="类型-拓展-2" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-2" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-1" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-1" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加 载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li></ul><h2 id="qiankun-如何处理子应用之间的公共依赖" tabindex="-1">Qiankun 如何处理子应用之间的公共依赖？ <a class="header-anchor" href="#qiankun-如何处理子应用之间的公共依赖" aria-label="Permalink to &quot;Qiankun 如何处理子应用之间的公共依赖？&quot;">​</a></h2><h4 id="类型-拓展-3" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-3" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-2" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-2" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-1-分" tabindex="-1">解答（1 分） <a class="header-anchor" href="#解答-1-分" aria-label="Permalink to &quot;解答（1 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配 置 props 等方式将主应用中的公共依赖传递给子应用使用。</li></ul><h2 id="简述-qiankun-主应用和微应用的加载流程" tabindex="-1">简述 qiankun 主应用和微应用的加载流程？ <a class="header-anchor" href="#简述-qiankun-主应用和微应用的加载流程" aria-label="Permalink to &quot;简述 qiankun 主应用和微应用的加载流程？&quot;">​</a></h2><h4 id="类型-拓展-4" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-4" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-3" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-3" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-2-分-1" tabindex="-1">解答（2 分） <a class="header-anchor" href="#解答-2-分-1" aria-label="Permalink to &quot;解答（2 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 主应用：主应用首先需要通过registerMicroApps方法注册微应用，配置微应用的相关信息，如入口地址、名称、激活规则等。然后调用start方法启动 qiankun。在启动过程 中，主应用会监听路由变化，根据激活规则判断哪些微应用需要加载。</li><li><strong>1：</strong> 微应用：当主应用判断某个微应用需要加载时，会根据微应用的入口地址去请求微应用的资源。微应用需要在自身代码中通过qiankun提供的生命周期钩子函 数（如bootstrap、mount、unmount）来进行初始化、挂载和卸载等操作。例如，在bootstrap中可以进行一些全局变量的初始化，在mount中可以将微应用的 DOM 元素挂载到主应用的指定容器中。</li></ul><h2 id="qiankun-中微应用如何与主应用进行通信" tabindex="-1">qiankun 中微应用如何与主应用进行通信？ <a class="header-anchor" href="#qiankun-中微应用如何与主应用进行通信" aria-label="Permalink to &quot;qiankun 中微应用如何与主应用进行通信？&quot;">​</a></h2><h4 id="类型-拓展-5" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-5" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-4" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-4" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 使用props：主应用在注册微应用时，可以通过props属性传递数据给微应用。微应用在mount生命周期钩子函数中通过props参数接收数据。</li><li><strong>1：</strong> 自定义事件：可以使用window.dispatchEvent和window.addEventListener来自定义事件实现通信。主应用和微应用都可以监听和触发这些自定义事件，从而实现数据传递和交互。</li><li><strong>1：</strong> 使用全局状态管理工具：如 Redux、Vuex 等。主应用和微应用可以共享同一个状态管理仓库，通过修改和读取仓库中的状态来进行通信。但需要注意在微应用卸载时，避免状态污染等问题。</li></ul><h2 id="在-qiankun-中-微应用的样式如何进行隔离" tabindex="-1">在 qiankun 中，微应用的样式如何进行隔离？ <a class="header-anchor" href="#在-qiankun-中-微应用的样式如何进行隔离" aria-label="Permalink to &quot;在 qiankun 中，微应用的样式如何进行隔离？&quot;">​</a></h2><h4 id="类型-拓展-6" tabindex="-1">类型：<code>拓展</code> <a class="header-anchor" href="#类型-拓展-6" aria-label="Permalink to &quot;类型：`拓展`&quot;">​</a></h4><h4 id="级别-w1、w2、w3、w4、w5、w6-5" tabindex="-1">级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code> <a class="header-anchor" href="#级别-w1、w2、w3、w4、w5、w6-5" aria-label="Permalink to &quot;级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`&quot;">​</a></h4><h4 id="解答-3-分-1" tabindex="-1">解答（3 分） <a class="header-anchor" href="#解答-3-分-1" aria-label="Permalink to &quot;解答（3 分）&quot;">​</a></h4><ul><li><strong>1：</strong> 使用 CSS Modules：微应用内部可以采用 CSS Modules 的方式编写样式。CSS Modules 会将每个样式文件中的类名进行哈希处理，生成唯一的类名，从而避免与其他微应用或主应 用的样式冲突。</li><li><strong>1：</strong> Shadow DOM：一些现代浏览器支持 Shadow DOM 技术，微应用可以使用 Shadow DOM 来创建一个独立的 DOM 树和样式作用域。在 Shadow DOM 内部的样式不会影响到外 部，反之亦然，实现了样式的彻底隔离。</li><li><strong>1：</strong> 约定命名空间：在微应用中约定统一的样式类名命名空间，例如所有样式类名都以特定的前缀开头。这样可以在一定程度上避免样式冲突，并且在维护和排查问题时也更加方便。</li></ul>',36)]))}const q=e(i,[["render",t]]);export{w as __pageData,q as default};
